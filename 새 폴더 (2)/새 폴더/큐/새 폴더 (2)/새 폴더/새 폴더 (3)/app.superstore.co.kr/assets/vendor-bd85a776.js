var ote = Object.defineProperty;
var ate = (t, e, n) => e in t ? ote(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var Ct = (t, e, n) => (ate(t, typeof e != "symbol" ? e + "" : e, n), n);

function lte(t, e) {
    for (var n = 0; n < e.length; n++) {
        const r = e[n];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const i in r)
                if (i !== "default" && !(i in t)) {
                    const s = Object.getOwnPropertyDescriptor(r, i);
                    s && Object.defineProperty(t, i, s.get ? s : {
                        enumerable: !0,
                        get: () => r[i]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }))
}
var _n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function la(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function qa(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(t).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(n, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), n
}
var R$ = {
        exports: {}
    },
    O2 = {},
    O$ = {
        exports: {}
    },
    Sn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q0 = Symbol.for("react.element"),
    ute = Symbol.for("react.portal"),
    cte = Symbol.for("react.fragment"),
    fte = Symbol.for("react.strict_mode"),
    dte = Symbol.for("react.profiler"),
    pte = Symbol.for("react.provider"),
    hte = Symbol.for("react.context"),
    mte = Symbol.for("react.forward_ref"),
    gte = Symbol.for("react.suspense"),
    yte = Symbol.for("react.memo"),
    vte = Symbol.for("react.lazy"),
    l5 = Symbol.iterator;

function bte(t) {
    return t === null || typeof t != "object" ? null : (t = l5 && t[l5] || t["@@iterator"], typeof t == "function" ? t : null)
}
var D$ = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    L$ = Object.assign,
    k$ = {};

function fg(t, e, n) {
    this.props = t, this.context = e, this.refs = k$, this.updater = n || D$
}
fg.prototype.isReactComponent = {};
fg.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
};
fg.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
};

function B$() {}
B$.prototype = fg.prototype;

function zO(t, e, n) {
    this.props = t, this.context = e, this.refs = k$, this.updater = n || D$
}
var HO = zO.prototype = new B$;
HO.constructor = zO;
L$(HO, fg.prototype);
HO.isPureReactComponent = !0;
var u5 = Array.isArray,
    F$ = Object.prototype.hasOwnProperty,
    UO = {
        current: null
    },
    N$ = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function z$(t, e, n) {
    var r, i = {},
        s = null,
        o = null;
    if (e != null)
        for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) F$.call(e, r) && !N$.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1) i.children = n;
    else if (1 < a) {
        for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
        i.children = l
    }
    if (t && t.defaultProps)
        for (r in a = t.defaultProps, a) i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: Q0,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: UO.current
    }
}

function xte(t, e) {
    return {
        $$typeof: Q0,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}

function $O(t) {
    return typeof t == "object" && t !== null && t.$$typeof === Q0
}

function _te(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
        return e[n]
    })
}
var c5 = /\/+/g;

function XC(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? _te("" + t.key) : e.toString(36)
}

function sS(t, e, n, r, i) {
    var s = typeof t;
    (s === "undefined" || s === "boolean") && (t = null);
    var o = !1;
    if (t === null) o = !0;
    else switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
                case Q0:
                case ute:
                    o = !0
            }
    }
    if (o) return o = t, i = i(o), t = r === "" ? "." + XC(o, 0) : r, u5(i) ? (n = "", t != null && (n = t.replace(c5, "$&/") + "/"), sS(i, e, n, "", function(u) {
        return u
    })) : i != null && ($O(i) && (i = xte(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(c5, "$&/") + "/") + t)), e.push(i)), 1;
    if (o = 0, r = r === "" ? "." : r + ":", u5(t))
        for (var a = 0; a < t.length; a++) {
            s = t[a];
            var l = r + XC(s, a);
            o += sS(s, e, n, l, i)
        } else if (l = bte(t), typeof l == "function")
            for (t = l.call(t), a = 0; !(s = t.next()).done;) s = s.value, l = r + XC(s, a++), o += sS(s, e, n, l, i);
        else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}

function Kb(t, e, n) {
    if (t == null) return t;
    var r = [],
        i = 0;
    return sS(t, r, "", "", function(s) {
        return e.call(n, s, i++)
    }), r
}

function Ste(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(), e.then(function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n)
        }, function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n)
        }), t._status === -1 && (t._status = 0, t._result = e)
    }
    if (t._status === 1) return t._result.default;
    throw t._result
}
var ws = {
        current: null
    },
    oS = {
        transition: null
    },
    wte = {
        ReactCurrentDispatcher: ws,
        ReactCurrentBatchConfig: oS,
        ReactCurrentOwner: UO
    };
Sn.Children = {
    map: Kb,
    forEach: function(t, e, n) {
        Kb(t, function() {
            e.apply(this, arguments)
        }, n)
    },
    count: function(t) {
        var e = 0;
        return Kb(t, function() {
            e++
        }), e
    },
    toArray: function(t) {
        return Kb(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!$O(t)) throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Sn.Component = fg;
Sn.Fragment = cte;
Sn.Profiler = dte;
Sn.PureComponent = zO;
Sn.StrictMode = fte;
Sn.Suspense = gte;
Sn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = wte;
Sn.cloneElement = function(t, e, n) {
    if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = L$({}, t.props),
        i = t.key,
        s = t.ref,
        o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref, o = UO.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps;
        for (l in e) F$.call(e, l) && !N$.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1) r.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
        r.children = a
    }
    return {
        $$typeof: Q0,
        type: t.type,
        key: i,
        ref: s,
        props: r,
        _owner: o
    }
};
Sn.createContext = function(t) {
    return t = {
        $$typeof: hte,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, t.Provider = {
        $$typeof: pte,
        _context: t
    }, t.Consumer = t
};
Sn.createElement = z$;
Sn.createFactory = function(t) {
    var e = z$.bind(null, t);
    return e.type = t, e
};
Sn.createRef = function() {
    return {
        current: null
    }
};
Sn.forwardRef = function(t) {
    return {
        $$typeof: mte,
        render: t
    }
};
Sn.isValidElement = $O;
Sn.lazy = function(t) {
    return {
        $$typeof: vte,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: Ste
    }
};
Sn.memo = function(t, e) {
    return {
        $$typeof: yte,
        type: t,
        compare: e === void 0 ? null : e
    }
};
Sn.startTransition = function(t) {
    var e = oS.transition;
    oS.transition = {};
    try {
        t()
    } finally {
        oS.transition = e
    }
};
Sn.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
};
Sn.useCallback = function(t, e) {
    return ws.current.useCallback(t, e)
};
Sn.useContext = function(t) {
    return ws.current.useContext(t)
};
Sn.useDebugValue = function() {};
Sn.useDeferredValue = function(t) {
    return ws.current.useDeferredValue(t)
};
Sn.useEffect = function(t, e) {
    return ws.current.useEffect(t, e)
};
Sn.useId = function() {
    return ws.current.useId()
};
Sn.useImperativeHandle = function(t, e, n) {
    return ws.current.useImperativeHandle(t, e, n)
};
Sn.useInsertionEffect = function(t, e) {
    return ws.current.useInsertionEffect(t, e)
};
Sn.useLayoutEffect = function(t, e) {
    return ws.current.useLayoutEffect(t, e)
};
Sn.useMemo = function(t, e) {
    return ws.current.useMemo(t, e)
};
Sn.useReducer = function(t, e, n) {
    return ws.current.useReducer(t, e, n)
};
Sn.useRef = function(t) {
    return ws.current.useRef(t)
};
Sn.useState = function(t) {
    return ws.current.useState(t)
};
Sn.useSyncExternalStore = function(t, e, n) {
    return ws.current.useSyncExternalStore(t, e, n)
};
Sn.useTransition = function() {
    return ws.current.useTransition()
};
Sn.version = "18.2.0";
O$.exports = Sn;
var P = O$.exports;
const Bt = la(P),
    Am = lte({
        __proto__: null,
        default: Bt
    }, [P]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ete = P,
    Ate = Symbol.for("react.element"),
    Cte = Symbol.for("react.fragment"),
    Mte = Object.prototype.hasOwnProperty,
    Tte = Ete.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    Pte = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function H$(t, e, n) {
    var r, i = {},
        s = null,
        o = null;
    n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
    for (r in e) Mte.call(e, r) && !Pte.hasOwnProperty(r) && (i[r] = e[r]);
    if (t && t.defaultProps)
        for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]);
    return {
        $$typeof: Ate,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: Tte.current
    }
}
O2.Fragment = Cte;
O2.jsx = H$;
O2.jsxs = H$;
R$.exports = O2;
var GO = R$.exports;
const Ite = GO.Fragment,
    gt = GO.jsx,
    Zo = GO.jsxs,
    Rte = Object.freeze(Object.defineProperty({
        __proto__: null,
        Fragment: Ite,
        jsx: gt,
        jsxs: Zo
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var U$ = {
        exports: {}
    },
    go = {},
    $$ = {
        exports: {}
    },
    G$ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(F, G) {
        var W = F.length;
        F.push(G);
        e: for (; 0 < W;) {
            var se = W - 1 >>> 1,
                ee = F[se];
            if (0 < i(ee, G)) F[se] = G, F[W] = ee, W = se;
            else break e
        }
    }

    function n(F) {
        return F.length === 0 ? null : F[0]
    }

    function r(F) {
        if (F.length === 0) return null;
        var G = F[0],
            W = F.pop();
        if (W !== G) {
            F[0] = W;
            e: for (var se = 0, ee = F.length, ae = ee >>> 1; se < ae;) {
                var de = 2 * (se + 1) - 1,
                    re = F[de],
                    _e = de + 1,
                    fe = F[_e];
                if (0 > i(re, W)) _e < ee && 0 > i(fe, re) ? (F[se] = fe, F[_e] = W, se = _e) : (F[se] = re, F[de] = W, se = de);
                else if (_e < ee && 0 > i(fe, W)) F[se] = fe, F[_e] = W, se = _e;
                else break e
            }
        }
        return G
    }

    function i(F, G) {
        var W = F.sortIndex - G.sortIndex;
        return W !== 0 ? W : F.id - G.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        u = [],
        c = 1,
        f = null,
        d = 3,
        p = !1,
        m = !1,
        y = !1,
        v = typeof setTimeout == "function" ? setTimeout : null,
        b = typeof clearTimeout == "function" ? clearTimeout : null,
        _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function x(F) {
        for (var G = n(u); G !== null;) {
            if (G.callback === null) r(u);
            else if (G.startTime <= F) r(u), G.sortIndex = G.expirationTime, e(l, G);
            else break;
            G = n(u)
        }
    }

    function S(F) {
        if (y = !1, x(F), !m)
            if (n(l) !== null) m = !0, q(E);
            else {
                var G = n(u);
                G !== null && Q(S, G.startTime - F)
            }
    }

    function E(F, G) {
        m = !1, y && (y = !1, b(M), M = -1), p = !0;
        var W = d;
        try {
            for (x(G), f = n(l); f !== null && (!(f.expirationTime > G) || F && !k());) {
                var se = f.callback;
                if (typeof se == "function") {
                    f.callback = null, d = f.priorityLevel;
                    var ee = se(f.expirationTime <= G);
                    G = t.unstable_now(), typeof ee == "function" ? f.callback = ee : f === n(l) && r(l), x(G)
                } else r(l);
                f = n(l)
            }
            if (f !== null) var ae = !0;
            else {
                var de = n(u);
                de !== null && Q(S, de.startTime - G), ae = !1
            }
            return ae
        } finally {
            f = null, d = W, p = !1
        }
    }
    var A = !1,
        T = null,
        M = -1,
        I = 5,
        O = -1;

    function k() {
        return !(t.unstable_now() - O < I)
    }

    function H() {
        if (T !== null) {
            var F = t.unstable_now();
            O = F;
            var G = !0;
            try {
                G = T(!0, F)
            } finally {
                G ? N() : (A = !1, T = null)
            }
        } else A = !1
    }
    var N;
    if (typeof _ == "function") N = function() {
        _(H)
    };
    else if (typeof MessageChannel < "u") {
        var B = new MessageChannel,
            U = B.port2;
        B.port1.onmessage = H, N = function() {
            U.postMessage(null)
        }
    } else N = function() {
        v(H, 0)
    };

    function q(F) {
        T = F, A || (A = !0, N())
    }

    function Q(F, G) {
        M = v(function() {
            F(t.unstable_now())
        }, G)
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(F) {
        F.callback = null
    }, t.unstable_continueExecution = function() {
        m || p || (m = !0, q(E))
    }, t.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < F ? Math.floor(1e3 / F) : 5
    }, t.unstable_getCurrentPriorityLevel = function() {
        return d
    }, t.unstable_getFirstCallbackNode = function() {
        return n(l)
    }, t.unstable_next = function(F) {
        switch (d) {
            case 1:
            case 2:
            case 3:
                var G = 3;
                break;
            default:
                G = d
        }
        var W = d;
        d = G;
        try {
            return F()
        } finally {
            d = W
        }
    }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(F, G) {
        switch (F) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                F = 3
        }
        var W = d;
        d = F;
        try {
            return G()
        } finally {
            d = W
        }
    }, t.unstable_scheduleCallback = function(F, G, W) {
        var se = t.unstable_now();
        switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? se + W : se) : W = se, F) {
            case 1:
                var ee = -1;
                break;
            case 2:
                ee = 250;
                break;
            case 5:
                ee = 1073741823;
                break;
            case 4:
                ee = 1e4;
                break;
            default:
                ee = 5e3
        }
        return ee = W + ee, F = {
            id: c++,
            callback: G,
            priorityLevel: F,
            startTime: W,
            expirationTime: ee,
            sortIndex: -1
        }, W > se ? (F.sortIndex = W, e(u, F), n(l) === null && F === n(u) && (y ? (b(M), M = -1) : y = !0, Q(S, W - se))) : (F.sortIndex = ee, e(l, F), m || p || (m = !0, q(E))), F
    }, t.unstable_shouldYield = k, t.unstable_wrapCallback = function(F) {
        var G = d;
        return function() {
            var W = d;
            d = G;
            try {
                return F.apply(this, arguments)
            } finally {
                d = W
            }
        }
    }
})(G$);
$$.exports = G$;
var Ote = $$.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V$ = P,
    fo = Ote;

function We(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var j$ = new Set,
    zv = {};

function gp(t, e) {
    Cm(t, e), Cm(t + "Capture", e)
}

function Cm(t, e) {
    for (zv[t] = e, t = 0; t < e.length; t++) j$.add(e[t])
}
var Tu = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    zP = Object.prototype.hasOwnProperty,
    Dte = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    f5 = {},
    d5 = {};

function Lte(t) {
    return zP.call(d5, t) ? !0 : zP.call(f5, t) ? !1 : Dte.test(t) ? d5[t] = !0 : (f5[t] = !0, !1)
}

function kte(t, e, n, r) {
    if (n !== null && n.type === 0) return !1;
    switch (typeof e) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
        default:
            return !1
    }
}

function Bte(t, e, n, r) {
    if (e === null || typeof e > "u" || kte(t, e, n, r)) return !0;
    if (r) return !1;
    if (n !== null) switch (n.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
    }
    return !1
}

function Es(t, e, n, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o
}
var Gi = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    Gi[t] = new Es(t, 0, !1, t, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(t) {
    var e = t[0];
    Gi[e] = new Es(e, 1, !1, t[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    Gi[t] = new Es(t, 2, !1, t.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    Gi[t] = new Es(t, 2, !1, t, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    Gi[t] = new Es(t, 3, !1, t.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    Gi[t] = new Es(t, 3, !0, t, null, !1, !1)
});
["capture", "download"].forEach(function(t) {
    Gi[t] = new Es(t, 4, !1, t, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    Gi[t] = new Es(t, 6, !1, t, null, !1, !1)
});
["rowSpan", "start"].forEach(function(t) {
    Gi[t] = new Es(t, 5, !1, t.toLowerCase(), null, !1, !1)
});
var VO = /[\-:]([a-z])/g;

function jO(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(VO, jO);
    Gi[e] = new Es(e, 1, !1, t, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(VO, jO);
    Gi[e] = new Es(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(VO, jO);
    Gi[e] = new Es(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    Gi[t] = new Es(t, 1, !1, t.toLowerCase(), null, !1, !1)
});
Gi.xlinkHref = new Es("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(t) {
    Gi[t] = new Es(t, 1, !1, t.toLowerCase(), null, !0, !0)
});

function WO(t, e, n, r) {
    var i = Gi.hasOwnProperty(e) ? Gi[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (Bte(e, n, i, r) && (n = null), r || i === null ? Lte(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
}
var Gu = V$.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    qb = Symbol.for("react.element"),
    wh = Symbol.for("react.portal"),
    Eh = Symbol.for("react.fragment"),
    KO = Symbol.for("react.strict_mode"),
    HP = Symbol.for("react.profiler"),
    W$ = Symbol.for("react.provider"),
    K$ = Symbol.for("react.context"),
    qO = Symbol.for("react.forward_ref"),
    UP = Symbol.for("react.suspense"),
    $P = Symbol.for("react.suspense_list"),
    XO = Symbol.for("react.memo"),
    _c = Symbol.for("react.lazy"),
    q$ = Symbol.for("react.offscreen"),
    p5 = Symbol.iterator;

function oy(t) {
    return t === null || typeof t != "object" ? null : (t = p5 && t[p5] || t["@@iterator"], typeof t == "function" ? t : null)
}
var Pr = Object.assign,
    JC;

function Vy(t) {
    if (JC === void 0) try {
        throw Error()
    } catch (n) {
        var e = n.stack.trim().match(/\n( *(at )?)/);
        JC = e && e[1] || ""
    }
    return `
` + JC + t
}
var YC = !1;

function QC(t, e) {
    if (!t || YC) return "";
    YC = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                    throw Error()
                }, Object.defineProperty(e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (u) {
                    var r = u
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (u) {
                    r = u
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (u) {
                r = u
            }
            t()
        }
    } catch (u) {
        if (u && r && typeof u.stack == "string") {
            for (var i = u.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--, a--, 0 > a || i[o] !== s[a]) {
                                var l = `
` + i[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
                            }
                    while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        YC = !1, Error.prepareStackTrace = n
    }
    return (t = t ? t.displayName || t.name : "") ? Vy(t) : ""
}

function Fte(t) {
    switch (t.tag) {
        case 5:
            return Vy(t.type);
        case 16:
            return Vy("Lazy");
        case 13:
            return Vy("Suspense");
        case 19:
            return Vy("SuspenseList");
        case 0:
        case 2:
        case 15:
            return t = QC(t.type, !1), t;
        case 11:
            return t = QC(t.type.render, !1), t;
        case 1:
            return t = QC(t.type, !0), t;
        default:
            return ""
    }
}

function GP(t) {
    if (t == null) return null;
    if (typeof t == "function") return t.displayName || t.name || null;
    if (typeof t == "string") return t;
    switch (t) {
        case Eh:
            return "Fragment";
        case wh:
            return "Portal";
        case HP:
            return "Profiler";
        case KO:
            return "StrictMode";
        case UP:
            return "Suspense";
        case $P:
            return "SuspenseList"
    }
    if (typeof t == "object") switch (t.$$typeof) {
        case K$:
            return (t.displayName || "Context") + ".Consumer";
        case W$:
            return (t._context.displayName || "Context") + ".Provider";
        case qO:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case XO:
            return e = t.displayName || null, e !== null ? e : GP(t.type) || "Memo";
        case _c:
            e = t._payload, t = t._init;
            try {
                return GP(t(e))
            } catch {}
    }
    return null
}

function Nte(t) {
    var e = t.type;
    switch (t.tag) {
        case 24:
            return "Cache";
        case 9:
            return (e.displayName || "Context") + ".Consumer";
        case 10:
            return (e._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return e;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return GP(e);
        case 8:
            return e === KO ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof e == "function") return e.displayName || e.name || null;
            if (typeof e == "string") return e
    }
    return null
}

function rf(t) {
    switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return t;
        case "object":
            return t;
        default:
            return ""
    }
}

function X$(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function zte(t) {
    var e = X$(t) ? "checked" : "value",
        n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
        r = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get,
            s = n.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                r = "" + o, s.call(this, o)
            }
        }), Object.defineProperty(t, e, {
            enumerable: n.enumerable
        }), {
            getValue: function() {
                return r
            },
            setValue: function(o) {
                r = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null, delete t[e]
            }
        }
    }
}

function Xb(t) {
    t._valueTracker || (t._valueTracker = zte(t))
}

function J$(t) {
    if (!t) return !1;
    var e = t._valueTracker;
    if (!e) return !0;
    var n = e.getValue(),
        r = "";
    return t && (r = X$(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1
}

function qS(t) {
    if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}

function VP(t, e) {
    var n = e.checked;
    return Pr({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ? ? t._wrapperState.initialChecked
    })
}

function h5(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue,
        r = e.checked != null ? e.checked : e.defaultChecked;
    n = rf(e.value != null ? e.value : n), t._wrapperState = {
        initialChecked: r,
        initialValue: n,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}

function Y$(t, e) {
    e = e.checked, e != null && WO(t, "checked", e, !1)
}

function jP(t, e) {
    Y$(t, e);
    var n = rf(e.value),
        r = e.type;
    if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (r === "submit" || r === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? WP(t, e.type, n) : e.hasOwnProperty("defaultValue") && WP(t, e.type, rf(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}

function m5(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var r = e.type;
        if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return;
        e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e
    }
    n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n)
}

function WP(t, e, n) {
    (e !== "number" || qS(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
}
var jy = Array.isArray;

function Zh(t, e, n, r) {
    if (t = t.options, e) {
        e = {};
        for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
        for (n = 0; n < t.length; n++) i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0)
    } else {
        for (n = "" + rf(n), e = null, i = 0; i < t.length; i++) {
            if (t[i].value === n) {
                t[i].selected = !0, r && (t[i].defaultSelected = !0);
                return
            }
            e !== null || t[i].disabled || (e = t[i])
        }
        e !== null && (e.selected = !0)
    }
}

function KP(t, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(We(91));
    return Pr({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}

function g5(t, e) {
    var n = e.value;
    if (n == null) {
        if (n = e.children, e = e.defaultValue, n != null) {
            if (e != null) throw Error(We(92));
            if (jy(n)) {
                if (1 < n.length) throw Error(We(93));
                n = n[0]
            }
            e = n
        }
        e == null && (e = ""), n = e
    }
    t._wrapperState = {
        initialValue: rf(n)
    }
}

function Q$(t, e) {
    var n = rf(e.value),
        r = rf(e.defaultValue);
    n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r)
}

function y5(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}

function Z$(t) {
    switch (t) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function qP(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? Z$(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Jb, e7 = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, n, r, i)
        })
    } : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
    else {
        for (Jb = Jb || document.createElement("div"), Jb.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Jb.firstChild; t.firstChild;) t.removeChild(t.firstChild);
        for (; e.firstChild;) t.appendChild(e.firstChild)
    }
});

function Hv(t, e) {
    if (e) {
        var n = t.firstChild;
        if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var rv = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    Hte = ["Webkit", "ms", "Moz", "O"];
Object.keys(rv).forEach(function(t) {
    Hte.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1), rv[e] = rv[t]
    })
});

function t7(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || rv.hasOwnProperty(t) && rv[t] ? ("" + e).trim() : e + "px"
}

function n7(t, e) {
    t = t.style;
    for (var n in e)
        if (e.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0,
                i = t7(n, e[n], r);
            n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i
        }
}
var Ute = Pr({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function XP(t, e) {
    if (e) {
        if (Ute[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(We(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(We(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(We(61))
        }
        if (e.style != null && typeof e.style != "object") throw Error(We(62))
    }
}

function JP(t, e) {
    if (t.indexOf("-") === -1) return typeof e.is == "string";
    switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var YP = null;

function JO(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
}
var QP = null,
    em = null,
    tm = null;

function v5(t) {
    if (t = t1(t)) {
        if (typeof QP != "function") throw Error(We(280));
        var e = t.stateNode;
        e && (e = F2(e), QP(t.stateNode, t.type, e))
    }
}

function r7(t) {
    em ? tm ? tm.push(t) : tm = [t] : em = t
}

function i7() {
    if (em) {
        var t = em,
            e = tm;
        if (tm = em = null, v5(t), e)
            for (t = 0; t < e.length; t++) v5(e[t])
    }
}

function s7(t, e) {
    return t(e)
}

function o7() {}
var ZC = !1;

function a7(t, e, n) {
    if (ZC) return t(e, n);
    ZC = !0;
    try {
        return s7(t, e, n)
    } finally {
        ZC = !1, (em !== null || tm !== null) && (o7(), i7())
    }
}

function Uv(t, e) {
    var n = t.stateNode;
    if (n === null) return null;
    var r = F2(n);
    if (r === null) return null;
    n = r[e];
    e: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
            break e;
        default:
            t = !1
    }
    if (t) return null;
    if (n && typeof n != "function") throw Error(We(231, e, typeof n));
    return n
}
var ZP = !1;
if (Tu) try {
    var ay = {};
    Object.defineProperty(ay, "passive", {
        get: function() {
            ZP = !0
        }
    }), window.addEventListener("test", ay, ay), window.removeEventListener("test", ay, ay)
} catch {
    ZP = !1
}

function $te(t, e, n, r, i, s, o, a, l) {
    var u = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(n, u)
    } catch (c) {
        this.onError(c)
    }
}
var iv = !1,
    XS = null,
    JS = !1,
    eI = null,
    Gte = {
        onError: function(t) {
            iv = !0, XS = t
        }
    };

function Vte(t, e, n, r, i, s, o, a, l) {
    iv = !1, XS = null, $te.apply(Gte, arguments)
}

function jte(t, e, n, r, i, s, o, a, l) {
    if (Vte.apply(this, arguments), iv) {
        if (iv) {
            var u = XS;
            iv = !1, XS = null
        } else throw Error(We(198));
        JS || (JS = !0, eI = u)
    }
}

function yp(t) {
    var e = t,
        n = t;
    if (t.alternate)
        for (; e.return;) e = e.return;
    else {
        t = e;
        do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t)
    }
    return e.tag === 3 ? n : null
}

function l7(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
    }
    return null
}

function b5(t) {
    if (yp(t) !== t) throw Error(We(188))
}

function Wte(t) {
    var e = t.alternate;
    if (!e) {
        if (e = yp(t), e === null) throw Error(We(188));
        return e !== t ? null : t
    }
    for (var n = t, r = e;;) {
        var i = n.return;
        if (i === null) break;
        var s = i.alternate;
        if (s === null) {
            if (r = i.return, r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s;) {
                if (s === n) return b5(i), t;
                if (s === r) return b5(i), e;
                s = s.sibling
            }
            throw Error(We(188))
        }
        if (n.return !== r.return) n = i, r = s;
        else {
            for (var o = !1, a = i.child; a;) {
                if (a === n) {
                    o = !0, n = i, r = s;
                    break
                }
                if (a === r) {
                    o = !0, r = i, n = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a;) {
                    if (a === n) {
                        o = !0, n = s, r = i;
                        break
                    }
                    if (a === r) {
                        o = !0, r = s, n = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o) throw Error(We(189))
            }
        }
        if (n.alternate !== r) throw Error(We(190))
    }
    if (n.tag !== 3) throw Error(We(188));
    return n.stateNode.current === n ? t : e
}

function u7(t) {
    return t = Wte(t), t !== null ? c7(t) : null
}

function c7(t) {
    if (t.tag === 5 || t.tag === 6) return t;
    for (t = t.child; t !== null;) {
        var e = c7(t);
        if (e !== null) return e;
        t = t.sibling
    }
    return null
}
var f7 = fo.unstable_scheduleCallback,
    x5 = fo.unstable_cancelCallback,
    Kte = fo.unstable_shouldYield,
    qte = fo.unstable_requestPaint,
    qr = fo.unstable_now,
    Xte = fo.unstable_getCurrentPriorityLevel,
    YO = fo.unstable_ImmediatePriority,
    d7 = fo.unstable_UserBlockingPriority,
    YS = fo.unstable_NormalPriority,
    Jte = fo.unstable_LowPriority,
    p7 = fo.unstable_IdlePriority,
    D2 = null,
    El = null;

function Yte(t) {
    if (El && typeof El.onCommitFiberRoot == "function") try {
        El.onCommitFiberRoot(D2, t, void 0, (t.current.flags & 128) === 128)
    } catch {}
}
var Ba = Math.clz32 ? Math.clz32 : ene,
    Qte = Math.log,
    Zte = Math.LN2;

function ene(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (Qte(t) / Zte | 0) | 0
}
var Yb = 64,
    Qb = 4194304;

function Wy(t) {
    switch (t & -t) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return t & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return t
    }
}

function QS(t, e) {
    var n = t.pendingLanes;
    if (n === 0) return 0;
    var r = 0,
        i = t.suspendedLanes,
        s = t.pingedLanes,
        o = n & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? r = Wy(a) : (s &= o, s !== 0 && (r = Wy(s)))
    } else o = n & ~i, o !== 0 ? r = Wy(o) : s !== 0 && (r = Wy(s));
    if (r === 0) return 0;
    if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e;
    if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0)
        for (t = t.entanglements, e &= r; 0 < e;) n = 31 - Ba(e), i = 1 << n, r |= t[n], e &= ~i;
    return r
}

function tne(t, e) {
    switch (t) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function nne(t, e) {
    for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
        var o = 31 - Ba(s),
            a = 1 << o,
            l = i[o];
        l === -1 ? (!(a & n) || a & r) && (i[o] = tne(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a
    }
}

function tI(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}

function h7() {
    var t = Yb;
    return Yb <<= 1, !(Yb & 4194240) && (Yb = 64), t
}

function eM(t) {
    for (var e = [], n = 0; 31 > n; n++) e.push(t);
    return e
}

function Z0(t, e, n) {
    t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Ba(e), t[e] = n
}

function rne(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < n;) {
        var i = 31 - Ba(n),
            s = 1 << i;
        e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s
    }
}

function QO(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n;) {
        var r = 31 - Ba(n),
            i = 1 << r;
        i & e | t[r] & e && (t[r] |= e), n &= ~i
    }
}
var Vn = 0;

function m7(t) {
    return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var g7, ZO, y7, v7, b7, nI = !1,
    Zb = [],
    $c = null,
    Gc = null,
    Vc = null,
    $v = new Map,
    Gv = new Map,
    Ac = [],
    ine = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function _5(t, e) {
    switch (t) {
        case "focusin":
        case "focusout":
            $c = null;
            break;
        case "dragenter":
        case "dragleave":
            Gc = null;
            break;
        case "mouseover":
        case "mouseout":
            Vc = null;
            break;
        case "pointerover":
        case "pointerout":
            $v.delete(e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Gv.delete(e.pointerId)
    }
}

function ly(t, e, n, r, i, s) {
    return t === null || t.nativeEvent !== s ? (t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i]
    }, e !== null && (e = t1(e), e !== null && ZO(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t)
}

function sne(t, e, n, r, i) {
    switch (e) {
        case "focusin":
            return $c = ly($c, t, e, n, r, i), !0;
        case "dragenter":
            return Gc = ly(Gc, t, e, n, r, i), !0;
        case "mouseover":
            return Vc = ly(Vc, t, e, n, r, i), !0;
        case "pointerover":
            var s = i.pointerId;
            return $v.set(s, ly($v.get(s) || null, t, e, n, r, i)), !0;
        case "gotpointercapture":
            return s = i.pointerId, Gv.set(s, ly(Gv.get(s) || null, t, e, n, r, i)), !0
    }
    return !1
}

function x7(t) {
    var e = pd(t.target);
    if (e !== null) {
        var n = yp(e);
        if (n !== null) {
            if (e = n.tag, e === 13) {
                if (e = l7(n), e !== null) {
                    t.blockedOn = e, b7(t.priority, function() {
                        y7(n)
                    });
                    return
                }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}

function aS(t) {
    if (t.blockedOn !== null) return !1;
    for (var e = t.targetContainers; 0 < e.length;) {
        var n = rI(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (n === null) {
            n = t.nativeEvent;
            var r = new n.constructor(n.type, n);
            YP = r, n.target.dispatchEvent(r), YP = null
        } else return e = t1(n), e !== null && ZO(e), t.blockedOn = n, !1;
        e.shift()
    }
    return !0
}

function S5(t, e, n) {
    aS(t) && n.delete(e)
}

function one() {
    nI = !1, $c !== null && aS($c) && ($c = null), Gc !== null && aS(Gc) && (Gc = null), Vc !== null && aS(Vc) && (Vc = null), $v.forEach(S5), Gv.forEach(S5)
}

function uy(t, e) {
    t.blockedOn === e && (t.blockedOn = null, nI || (nI = !0, fo.unstable_scheduleCallback(fo.unstable_NormalPriority, one)))
}

function Vv(t) {
    function e(i) {
        return uy(i, t)
    }
    if (0 < Zb.length) {
        uy(Zb[0], t);
        for (var n = 1; n < Zb.length; n++) {
            var r = Zb[n];
            r.blockedOn === t && (r.blockedOn = null)
        }
    }
    for ($c !== null && uy($c, t), Gc !== null && uy(Gc, t), Vc !== null && uy(Vc, t), $v.forEach(e), Gv.forEach(e), n = 0; n < Ac.length; n++) r = Ac[n], r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < Ac.length && (n = Ac[0], n.blockedOn === null);) x7(n), n.blockedOn === null && Ac.shift()
}
var nm = Gu.ReactCurrentBatchConfig,
    ZS = !0;

function ane(t, e, n, r) {
    var i = Vn,
        s = nm.transition;
    nm.transition = null;
    try {
        Vn = 1, eD(t, e, n, r)
    } finally {
        Vn = i, nm.transition = s
    }
}

function lne(t, e, n, r) {
    var i = Vn,
        s = nm.transition;
    nm.transition = null;
    try {
        Vn = 4, eD(t, e, n, r)
    } finally {
        Vn = i, nm.transition = s
    }
}

function eD(t, e, n, r) {
    if (ZS) {
        var i = rI(t, e, n, r);
        if (i === null) cM(t, e, r, ew, n), _5(t, r);
        else if (sne(i, t, e, n, r)) r.stopPropagation();
        else if (_5(t, r), e & 4 && -1 < ine.indexOf(t)) {
            for (; i !== null;) {
                var s = t1(i);
                if (s !== null && g7(s), s = rI(t, e, n, r), s === null && cM(t, e, r, ew, n), s === i) break;
                i = s
            }
            i !== null && r.stopPropagation()
        } else cM(t, e, r, null, n)
    }
}
var ew = null;

function rI(t, e, n, r) {
    if (ew = null, t = JO(r), t = pd(t), t !== null)
        if (e = yp(t), e === null) t = null;
        else if (n = e.tag, n === 13) {
        if (t = l7(e), t !== null) return t;
        t = null
    } else if (n === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
        t = null
    } else e !== t && (t = null);
    return ew = t, null
}

function _7(t) {
    switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (Xte()) {
                case YO:
                    return 1;
                case d7:
                    return 4;
                case YS:
                case Jte:
                    return 16;
                case p7:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var Pc = null,
    tD = null,
    lS = null;

function S7() {
    if (lS) return lS;
    var t, e = tD,
        n = e.length,
        r, i = "value" in Pc ? Pc.value : Pc.textContent,
        s = i.length;
    for (t = 0; t < n && e[t] === i[t]; t++);
    var o = n - t;
    for (r = 1; r <= o && e[n - r] === i[s - r]; r++);
    return lS = i.slice(t, 1 < r ? 1 - r : void 0)
}

function uS(t) {
    var e = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
}

function ex() {
    return !0
}

function w5() {
    return !1
}

function yo(t) {
    function e(n, r, i, s, o) {
        this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null;
        for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ex : w5, this.isPropagationStopped = w5, this
    }
    return Pr(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ex)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ex)
        },
        persist: function() {},
        isPersistent: ex
    }), e
}
var dg = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
            return t.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    nD = yo(dg),
    e1 = Pr({}, dg, {
        view: 0,
        detail: 0
    }),
    une = yo(e1),
    tM, nM, cy, L2 = Pr({}, e1, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: rD,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
            return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
        },
        movementX: function(t) {
            return "movementX" in t ? t.movementX : (t !== cy && (cy && t.type === "mousemove" ? (tM = t.screenX - cy.screenX, nM = t.screenY - cy.screenY) : nM = tM = 0, cy = t), tM)
        },
        movementY: function(t) {
            return "movementY" in t ? t.movementY : nM
        }
    }),
    E5 = yo(L2),
    cne = Pr({}, L2, {
        dataTransfer: 0
    }),
    fne = yo(cne),
    dne = Pr({}, e1, {
        relatedTarget: 0
    }),
    rM = yo(dne),
    pne = Pr({}, dg, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    hne = yo(pne),
    mne = Pr({}, dg, {
        clipboardData: function(t) {
            return "clipboardData" in t ? t.clipboardData : window.clipboardData
        }
    }),
    gne = yo(mne),
    yne = Pr({}, dg, {
        data: 0
    }),
    A5 = yo(yne),
    vne = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    bne = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    xne = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function _ne(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = xne[t]) ? !!e[t] : !1
}

function rD() {
    return _ne
}
var Sne = Pr({}, e1, {
        key: function(t) {
            if (t.key) {
                var e = vne[t.key] || t.key;
                if (e !== "Unidentified") return e
            }
            return t.type === "keypress" ? (t = uS(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? bne[t.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: rD,
        charCode: function(t) {
            return t.type === "keypress" ? uS(t) : 0
        },
        keyCode: function(t) {
            return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        },
        which: function(t) {
            return t.type === "keypress" ? uS(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        }
    }),
    wne = yo(Sne),
    Ene = Pr({}, L2, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    C5 = yo(Ene),
    Ane = Pr({}, e1, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: rD
    }),
    Cne = yo(Ane),
    Mne = Pr({}, dg, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    Tne = yo(Mne),
    Pne = Pr({}, L2, {
        deltaX: function(t) {
            return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
        },
        deltaY: function(t) {
            return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    Ine = yo(Pne),
    Rne = [9, 13, 27, 32],
    iD = Tu && "CompositionEvent" in window,
    sv = null;
Tu && "documentMode" in document && (sv = document.documentMode);
var One = Tu && "TextEvent" in window && !sv,
    w7 = Tu && (!iD || sv && 8 < sv && 11 >= sv),
    M5 = String.fromCharCode(32),
    T5 = !1;

function E7(t, e) {
    switch (t) {
        case "keyup":
            return Rne.indexOf(e.keyCode) !== -1;
        case "keydown":
            return e.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function A7(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
}
var Ah = !1;

function Dne(t, e) {
    switch (t) {
        case "compositionend":
            return A7(e);
        case "keypress":
            return e.which !== 32 ? null : (T5 = !0, M5);
        case "textInput":
            return t = e.data, t === M5 && T5 ? null : t;
        default:
            return null
    }
}

function Lne(t, e) {
    if (Ah) return t === "compositionend" || !iD && E7(t, e) ? (t = S7(), lS = tD = Pc = null, Ah = !1, t) : null;
    switch (t) {
        case "paste":
            return null;
        case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                if (e.char && 1 < e.char.length) return e.char;
                if (e.which) return String.fromCharCode(e.which)
            }
            return null;
        case "compositionend":
            return w7 && e.locale !== "ko" ? null : e.data;
        default:
            return null
    }
}
var kne = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function P5(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!kne[t.type] : e === "textarea"
}

function C7(t, e, n, r) {
    r7(r), e = tw(e, "onChange"), 0 < e.length && (n = new nD("onChange", "change", null, n, r), t.push({
        event: n,
        listeners: e
    }))
}
var ov = null,
    jv = null;

function Bne(t) {
    F7(t, 0)
}

function k2(t) {
    var e = Th(t);
    if (J$(e)) return t
}

function Fne(t, e) {
    if (t === "change") return e
}
var M7 = !1;
if (Tu) {
    var iM;
    if (Tu) {
        var sM = "oninput" in document;
        if (!sM) {
            var I5 = document.createElement("div");
            I5.setAttribute("oninput", "return;"), sM = typeof I5.oninput == "function"
        }
        iM = sM
    } else iM = !1;
    M7 = iM && (!document.documentMode || 9 < document.documentMode)
}

function R5() {
    ov && (ov.detachEvent("onpropertychange", T7), jv = ov = null)
}

function T7(t) {
    if (t.propertyName === "value" && k2(jv)) {
        var e = [];
        C7(e, jv, t, JO(t)), a7(Bne, e)
    }
}

function Nne(t, e, n) {
    t === "focusin" ? (R5(), ov = e, jv = n, ov.attachEvent("onpropertychange", T7)) : t === "focusout" && R5()
}

function zne(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown") return k2(jv)
}

function Hne(t, e) {
    if (t === "click") return k2(e)
}

function Une(t, e) {
    if (t === "input" || t === "change") return k2(e)
}

function $ne(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var ja = typeof Object.is == "function" ? Object.is : $ne;

function Wv(t, e) {
    if (ja(t, e)) return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
    var n = Object.keys(t),
        r = Object.keys(e);
    if (n.length !== r.length) return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!zP.call(e, i) || !ja(t[i], e[i])) return !1
    }
    return !0
}

function O5(t) {
    for (; t && t.firstChild;) t = t.firstChild;
    return t
}

function D5(t, e) {
    var n = O5(t);
    t = 0;
    for (var r; n;) {
        if (n.nodeType === 3) {
            if (r = t + n.textContent.length, t <= e && r >= e) return {
                node: n,
                offset: e - t
            };
            t = r
        }
        e: {
            for (; n;) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = O5(n)
    }
}

function P7(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? P7(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}

function I7() {
    for (var t = window, e = qS(); e instanceof t.HTMLIFrameElement;) {
        try {
            var n = typeof e.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n) t = e.contentWindow;
        else break;
        e = qS(t.document)
    }
    return e
}

function sD(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}

function Gne(t) {
    var e = I7(),
        n = t.focusedElem,
        r = t.selectionRange;
    if (e !== n && n && n.ownerDocument && P7(n.ownerDocument.documentElement, n)) {
        if (r !== null && sD(n)) {
            if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
                t = t.getSelection();
                var i = n.textContent.length,
                    s = Math.min(r.start, i);
                r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = D5(n, s);
                var o = D5(n, r);
                i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e)))
            }
        }
        for (e = [], t = n; t = t.parentNode;) t.nodeType === 1 && e.push({
            element: t,
            left: t.scrollLeft,
            top: t.scrollTop
        });
        for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++) t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top
    }
}
var Vne = Tu && "documentMode" in document && 11 >= document.documentMode,
    Ch = null,
    iI = null,
    av = null,
    sI = !1;

function L5(t, e, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    sI || Ch == null || Ch !== qS(r) || (r = Ch, "selectionStart" in r && sD(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }), av && Wv(av, r) || (av = r, r = tw(iI, "onSelect"), 0 < r.length && (e = new nD("onSelect", "select", null, e, n), t.push({
        event: e,
        listeners: r
    }), e.target = Ch)))
}

function tx(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n
}
var Mh = {
        animationend: tx("Animation", "AnimationEnd"),
        animationiteration: tx("Animation", "AnimationIteration"),
        animationstart: tx("Animation", "AnimationStart"),
        transitionend: tx("Transition", "TransitionEnd")
    },
    oM = {},
    R7 = {};
Tu && (R7 = document.createElement("div").style, "AnimationEvent" in window || (delete Mh.animationend.animation, delete Mh.animationiteration.animation, delete Mh.animationstart.animation), "TransitionEvent" in window || delete Mh.transitionend.transition);

function B2(t) {
    if (oM[t]) return oM[t];
    if (!Mh[t]) return t;
    var e = Mh[t],
        n;
    for (n in e)
        if (e.hasOwnProperty(n) && n in R7) return oM[t] = e[n];
    return t
}
var O7 = B2("animationend"),
    D7 = B2("animationiteration"),
    L7 = B2("animationstart"),
    k7 = B2("transitionend"),
    B7 = new Map,
    k5 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function yf(t, e) {
    B7.set(t, e), gp(e, [t])
}
for (var aM = 0; aM < k5.length; aM++) {
    var lM = k5[aM],
        jne = lM.toLowerCase(),
        Wne = lM[0].toUpperCase() + lM.slice(1);
    yf(jne, "on" + Wne)
}
yf(O7, "onAnimationEnd");
yf(D7, "onAnimationIteration");
yf(L7, "onAnimationStart");
yf("dblclick", "onDoubleClick");
yf("focusin", "onFocus");
yf("focusout", "onBlur");
yf(k7, "onTransitionEnd");
Cm("onMouseEnter", ["mouseout", "mouseover"]);
Cm("onMouseLeave", ["mouseout", "mouseover"]);
Cm("onPointerEnter", ["pointerout", "pointerover"]);
Cm("onPointerLeave", ["pointerout", "pointerover"]);
gp("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
gp("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
gp("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
gp("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
gp("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
gp("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Ky = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    Kne = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ky));

function B5(t, e, n) {
    var r = t.type || "unknown-event";
    t.currentTarget = n, jte(r, e, void 0, t), t.currentTarget = null
}

function F7(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
        var r = t[n],
            i = r.event;
        r = r.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = r.length - 1; 0 <= o; o--) {
                    var a = r[o],
                        l = a.instance,
                        u = a.currentTarget;
                    if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
                    B5(i, a, u), s = l
                } else
                    for (o = 0; o < r.length; o++) {
                        if (a = r[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
                        B5(i, a, u), s = l
                    }
        }
    }
    if (JS) throw t = eI, JS = !1, eI = null, t
}

function lr(t, e) {
    var n = e[cI];
    n === void 0 && (n = e[cI] = new Set);
    var r = t + "__bubble";
    n.has(r) || (N7(e, t, 2, !1), n.add(r))
}

function uM(t, e, n) {
    var r = 0;
    e && (r |= 4), N7(n, t, r, e)
}
var nx = "_reactListening" + Math.random().toString(36).slice(2);

function Kv(t) {
    if (!t[nx]) {
        t[nx] = !0, j$.forEach(function(n) {
            n !== "selectionchange" && (Kne.has(n) || uM(n, !1, t), uM(n, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[nx] || (e[nx] = !0, uM("selectionchange", !1, e))
    }
}

function N7(t, e, n, r) {
    switch (_7(e)) {
        case 1:
            var i = ane;
            break;
        case 4:
            i = lne;
            break;
        default:
            i = eD
    }
    n = i.bind(null, e, n, t), i = void 0, !ZP || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, {
        capture: !0,
        passive: i
    }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, {
        passive: i
    }) : t.addEventListener(e, n, !1)
}

function cM(t, e, n, r, i) {
    var s = r;
    if (!(e & 1) && !(e & 2) && r !== null) e: for (;;) {
        if (r === null) return;
        var o = r.tag;
        if (o === 3 || o === 4) {
            var a = r.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i) break;
            if (o === 4)
                for (o = r.return; o !== null;) {
                    var l = o.tag;
                    if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return;
                    o = o.return
                }
            for (; a !== null;) {
                if (o = pd(a), o === null) return;
                if (l = o.tag, l === 5 || l === 6) {
                    r = s = o;
                    continue e
                }
                a = a.parentNode
            }
        }
        r = r.return
    }
    a7(function() {
        var u = s,
            c = JO(n),
            f = [];
        e: {
            var d = B7.get(t);
            if (d !== void 0) {
                var p = nD,
                    m = t;
                switch (t) {
                    case "keypress":
                        if (uS(n) === 0) break e;
                    case "keydown":
                    case "keyup":
                        p = wne;
                        break;
                    case "focusin":
                        m = "focus", p = rM;
                        break;
                    case "focusout":
                        m = "blur", p = rM;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        p = rM;
                        break;
                    case "click":
                        if (n.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        p = E5;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        p = fne;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        p = Cne;
                        break;
                    case O7:
                    case D7:
                    case L7:
                        p = hne;
                        break;
                    case k7:
                        p = Tne;
                        break;
                    case "scroll":
                        p = une;
                        break;
                    case "wheel":
                        p = Ine;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        p = gne;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        p = C5
                }
                var y = (e & 4) !== 0,
                    v = !y && t === "scroll",
                    b = y ? d !== null ? d + "Capture" : null : d;
                y = [];
                for (var _ = u, x; _ !== null;) {
                    x = _;
                    var S = x.stateNode;
                    if (x.tag === 5 && S !== null && (x = S, b !== null && (S = Uv(_, b), S != null && y.push(qv(_, S, x)))), v) break;
                    _ = _.return
                }
                0 < y.length && (d = new p(d, m, null, n, c), f.push({
                    event: d,
                    listeners: y
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (d = t === "mouseover" || t === "pointerover", p = t === "mouseout" || t === "pointerout", d && n !== YP && (m = n.relatedTarget || n.fromElement) && (pd(m) || m[Pu])) break e;
                if ((p || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, p ? (m = n.relatedTarget || n.toElement, p = u, m = m ? pd(m) : null, m !== null && (v = yp(m), m !== v || m.tag !== 5 && m.tag !== 6) && (m = null)) : (p = null, m = u), p !== m)) {
                    if (y = E5, S = "onMouseLeave", b = "onMouseEnter", _ = "mouse", (t === "pointerout" || t === "pointerover") && (y = C5, S = "onPointerLeave", b = "onPointerEnter", _ = "pointer"), v = p == null ? d : Th(p), x = m == null ? d : Th(m), d = new y(S, _ + "leave", p, n, c), d.target = v, d.relatedTarget = x, S = null, pd(c) === u && (y = new y(b, _ + "enter", m, n, c), y.target = x, y.relatedTarget = v, S = y), v = S, p && m) t: {
                        for (y = p, b = m, _ = 0, x = y; x; x = kp(x)) _++;
                        for (x = 0, S = b; S; S = kp(S)) x++;
                        for (; 0 < _ - x;) y = kp(y),
                        _--;
                        for (; 0 < x - _;) b = kp(b),
                        x--;
                        for (; _--;) {
                            if (y === b || b !== null && y === b.alternate) break t;
                            y = kp(y), b = kp(b)
                        }
                        y = null
                    }
                    else y = null;
                    p !== null && F5(f, d, p, y, !1), m !== null && v !== null && F5(f, v, m, y, !0)
                }
            }
            e: {
                if (d = u ? Th(u) : window, p = d.nodeName && d.nodeName.toLowerCase(), p === "select" || p === "input" && d.type === "file") var E = Fne;
                else if (P5(d))
                    if (M7) E = Une;
                    else {
                        E = zne;
                        var A = Nne
                    }
                else(p = d.nodeName) && p.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (E = Hne);
                if (E && (E = E(t, u))) {
                    C7(f, E, n, c);
                    break e
                }
                A && A(t, d, u),
                t === "focusout" && (A = d._wrapperState) && A.controlled && d.type === "number" && WP(d, "number", d.value)
            }
            switch (A = u ? Th(u) : window, t) {
                case "focusin":
                    (P5(A) || A.contentEditable === "true") && (Ch = A, iI = u, av = null);
                    break;
                case "focusout":
                    av = iI = Ch = null;
                    break;
                case "mousedown":
                    sI = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    sI = !1, L5(f, n, c);
                    break;
                case "selectionchange":
                    if (Vne) break;
                case "keydown":
                case "keyup":
                    L5(f, n, c)
            }
            var T;
            if (iD) e: {
                switch (t) {
                    case "compositionstart":
                        var M = "onCompositionStart";
                        break e;
                    case "compositionend":
                        M = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        M = "onCompositionUpdate";
                        break e
                }
                M = void 0
            }
            else Ah ? E7(t, n) && (M = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (M = "onCompositionStart");M && (w7 && n.locale !== "ko" && (Ah || M !== "onCompositionStart" ? M === "onCompositionEnd" && Ah && (T = S7()) : (Pc = c, tD = "value" in Pc ? Pc.value : Pc.textContent, Ah = !0)), A = tw(u, M), 0 < A.length && (M = new A5(M, t, null, n, c), f.push({
                event: M,
                listeners: A
            }), T ? M.data = T : (T = A7(n), T !== null && (M.data = T)))),
            (T = One ? Dne(t, n) : Lne(t, n)) && (u = tw(u, "onBeforeInput"), 0 < u.length && (c = new A5("onBeforeInput", "beforeinput", null, n, c), f.push({
                event: c,
                listeners: u
            }), c.data = T))
        }
        F7(f, e)
    })
}

function qv(t, e, n) {
    return {
        instance: t,
        listener: e,
        currentTarget: n
    }
}

function tw(t, e) {
    for (var n = e + "Capture", r = []; t !== null;) {
        var i = t,
            s = i.stateNode;
        i.tag === 5 && s !== null && (i = s, s = Uv(t, n), s != null && r.unshift(qv(t, s, i)), s = Uv(t, e), s != null && r.push(qv(t, s, i))), t = t.return
    }
    return r
}

function kp(t) {
    if (t === null) return null;
    do t = t.return; while (t && t.tag !== 5);
    return t || null
}

function F5(t, e, n, r, i) {
    for (var s = e._reactName, o = []; n !== null && n !== r;) {
        var a = n,
            l = a.alternate,
            u = a.stateNode;
        if (l !== null && l === r) break;
        a.tag === 5 && u !== null && (a = u, i ? (l = Uv(n, s), l != null && o.unshift(qv(n, l, a))) : i || (l = Uv(n, s), l != null && o.push(qv(n, l, a)))), n = n.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var qne = /\r\n?/g,
    Xne = /\u0000|\uFFFD/g;

function N5(t) {
    return (typeof t == "string" ? t : "" + t).replace(qne, `
`).replace(Xne, "")
}

function rx(t, e, n) {
    if (e = N5(e), N5(t) !== e && n) throw Error(We(425))
}

function nw() {}
var oI = null,
    aI = null;

function lI(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var uI = typeof setTimeout == "function" ? setTimeout : void 0,
    Jne = typeof clearTimeout == "function" ? clearTimeout : void 0,
    z5 = typeof Promise == "function" ? Promise : void 0,
    Yne = typeof queueMicrotask == "function" ? queueMicrotask : typeof z5 < "u" ? function(t) {
        return z5.resolve(null).then(t).catch(Qne)
    } : uI;

function Qne(t) {
    setTimeout(function() {
        throw t
    })
}

function fM(t, e) {
    var n = e,
        r = 0;
    do {
        var i = n.nextSibling;
        if (t.removeChild(n), i && i.nodeType === 8)
            if (n = i.data, n === "/$") {
                if (r === 0) {
                    t.removeChild(i), Vv(e);
                    return
                }
                r--
            } else n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    Vv(e)
}

function jc(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
            if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
            if (e === "/$") return null
        }
    }
    return t
}

function H5(t) {
    t = t.previousSibling;
    for (var e = 0; t;) {
        if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (e === 0) return t;
                e--
            } else n === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var pg = Math.random().toString(36).slice(2),
    vl = "__reactFiber$" + pg,
    Xv = "__reactProps$" + pg,
    Pu = "__reactContainer$" + pg,
    cI = "__reactEvents$" + pg,
    Zne = "__reactListeners$" + pg,
    ere = "__reactHandles$" + pg;

function pd(t) {
    var e = t[vl];
    if (e) return e;
    for (var n = t.parentNode; n;) {
        if (e = n[Pu] || n[vl]) {
            if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
                for (t = H5(t); t !== null;) {
                    if (n = t[vl]) return n;
                    t = H5(t)
                }
            return e
        }
        t = n, n = t.parentNode
    }
    return null
}

function t1(t) {
    return t = t[vl] || t[Pu], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}

function Th(t) {
    if (t.tag === 5 || t.tag === 6) return t.stateNode;
    throw Error(We(33))
}

function F2(t) {
    return t[Xv] || null
}
var fI = [],
    Ph = -1;

function vf(t) {
    return {
        current: t
    }
}

function pr(t) {
    0 > Ph || (t.current = fI[Ph], fI[Ph] = null, Ph--)
}

function sr(t, e) {
    Ph++, fI[Ph] = t.current, t.current = e
}
var sf = {},
    as = vf(sf),
    Us = vf(!1),
    Wd = sf;

function Mm(t, e) {
    var n = t.type.contextTypes;
    if (!n) return sf;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
    var i = {},
        s;
    for (s in n) i[s] = e[s];
    return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i
}

function $s(t) {
    return t = t.childContextTypes, t != null
}

function rw() {
    pr(Us), pr(as)
}

function U5(t, e, n) {
    if (as.current !== sf) throw Error(We(168));
    sr(as, e), sr(Us, n)
}

function z7(t, e, n) {
    var r = t.stateNode;
    if (e = e.childContextTypes, typeof r.getChildContext != "function") return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in e)) throw Error(We(108, Nte(t) || "Unknown", i));
    return Pr({}, n, r)
}

function iw(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || sf, Wd = as.current, sr(as, t), sr(Us, Us.current), !0
}

function $5(t, e, n) {
    var r = t.stateNode;
    if (!r) throw Error(We(169));
    n ? (t = z7(t, e, Wd), r.__reactInternalMemoizedMergedChildContext = t, pr(Us), pr(as), sr(as, t)) : pr(Us), sr(Us, n)
}
var hu = null,
    N2 = !1,
    dM = !1;

function H7(t) {
    hu === null ? hu = [t] : hu.push(t)
}

function tre(t) {
    N2 = !0, H7(t)
}

function bf() {
    if (!dM && hu !== null) {
        dM = !0;
        var t = 0,
            e = Vn;
        try {
            var n = hu;
            for (Vn = 1; t < n.length; t++) {
                var r = n[t];
                do r = r(!0); while (r !== null)
            }
            hu = null, N2 = !1
        } catch (i) {
            throw hu !== null && (hu = hu.slice(t + 1)), f7(YO, bf), i
        } finally {
            Vn = e, dM = !1
        }
    }
    return null
}
var Ih = [],
    Rh = 0,
    sw = null,
    ow = 0,
    No = [],
    zo = 0,
    Kd = null,
    bu = 1,
    xu = "";

function Yf(t, e) {
    Ih[Rh++] = ow, Ih[Rh++] = sw, sw = t, ow = e
}

function U7(t, e, n) {
    No[zo++] = bu, No[zo++] = xu, No[zo++] = Kd, Kd = t;
    var r = bu;
    t = xu;
    var i = 32 - Ba(r) - 1;
    r &= ~(1 << i), n += 1;
    var s = 32 - Ba(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, bu = 1 << 32 - Ba(e) + i | n << i | r, xu = s + t
    } else bu = 1 << s | n << i | r, xu = t
}

function oD(t) {
    t.return !== null && (Yf(t, 1), U7(t, 1, 0))
}

function aD(t) {
    for (; t === sw;) sw = Ih[--Rh], Ih[Rh] = null, ow = Ih[--Rh], Ih[Rh] = null;
    for (; t === Kd;) Kd = No[--zo], No[zo] = null, xu = No[--zo], No[zo] = null, bu = No[--zo], No[zo] = null
}
var lo = null,
    so = null,
    xr = !1,
    Ca = null;

function $7(t, e) {
    var n = Wo(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n)
}

function G5(t, e) {
    switch (t.tag) {
        case 5:
            var n = t.type;
            return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, lo = t, so = jc(e.firstChild), !0) : !1;
        case 6:
            return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, lo = t, so = null, !0) : !1;
        case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Kd !== null ? {
                id: bu,
                overflow: xu
            } : null, t.memoizedState = {
                dehydrated: e,
                treeContext: n,
                retryLane: 1073741824
            }, n = Wo(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, lo = t, so = null, !0) : !1;
        default:
            return !1
    }
}

function dI(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}

function pI(t) {
    if (xr) {
        var e = so;
        if (e) {
            var n = e;
            if (!G5(t, e)) {
                if (dI(t)) throw Error(We(418));
                e = jc(n.nextSibling);
                var r = lo;
                e && G5(t, e) ? $7(r, n) : (t.flags = t.flags & -4097 | 2, xr = !1, lo = t)
            }
        } else {
            if (dI(t)) throw Error(We(418));
            t.flags = t.flags & -4097 | 2, xr = !1, lo = t
        }
    }
}

function V5(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
    lo = t
}

function ix(t) {
    if (t !== lo) return !1;
    if (!xr) return V5(t), xr = !0, !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !lI(t.type, t.memoizedProps)), e && (e = so)) {
        if (dI(t)) throw G7(), Error(We(418));
        for (; e;) $7(t, e), e = jc(e.nextSibling)
    }
    if (V5(t), t.tag === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(We(317));
        e: {
            for (t = t.nextSibling, e = 0; t;) {
                if (t.nodeType === 8) {
                    var n = t.data;
                    if (n === "/$") {
                        if (e === 0) {
                            so = jc(t.nextSibling);
                            break e
                        }
                        e--
                    } else n !== "$" && n !== "$!" && n !== "$?" || e++
                }
                t = t.nextSibling
            }
            so = null
        }
    } else so = lo ? jc(t.stateNode.nextSibling) : null;
    return !0
}

function G7() {
    for (var t = so; t;) t = jc(t.nextSibling)
}

function Tm() {
    so = lo = null, xr = !1
}

function lD(t) {
    Ca === null ? Ca = [t] : Ca.push(t)
}
var nre = Gu.ReactCurrentBatchConfig;

function Sa(t, e) {
    if (t && t.defaultProps) {
        e = Pr({}, e), t = t.defaultProps;
        for (var n in t) e[n] === void 0 && (e[n] = t[n]);
        return e
    }
    return e
}
var aw = vf(null),
    lw = null,
    Oh = null,
    uD = null;

function cD() {
    uD = Oh = lw = null
}

function fD(t) {
    var e = aw.current;
    pr(aw), t._currentValue = e
}

function hI(t, e, n) {
    for (; t !== null;) {
        var r = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break;
        t = t.return
    }
}

function rm(t, e) {
    lw = t, uD = Oh = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (zs = !0), t.firstContext = null)
}

function ea(t) {
    var e = t._currentValue;
    if (uD !== t)
        if (t = {
                context: t,
                memoizedValue: e,
                next: null
            }, Oh === null) {
            if (lw === null) throw Error(We(308));
            Oh = t, lw.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else Oh = Oh.next = t;
    return e
}
var hd = null;

function dD(t) {
    hd === null ? hd = [t] : hd.push(t)
}

function V7(t, e, n, r) {
    var i = e.interleaved;
    return i === null ? (n.next = n, dD(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Iu(t, r)
}

function Iu(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;) t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
    return n.tag === 3 ? n.stateNode : null
}
var Sc = !1;

function pD(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function j7(t, e) {
    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}

function Eu(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function Wc(t, e, n) {
    var r = t.updateQueue;
    if (r === null) return null;
    if (r = r.shared, Rn & 2) {
        var i = r.pending;
        return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Iu(t, n)
    }
    return i = r.interleaved, i === null ? (e.next = e, dD(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Iu(t, n)
}

function cS(t, e, n) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
        var r = e.lanes;
        r &= t.pendingLanes, n |= r, e.lanes = n, QO(t, n)
    }
}

function j5(t, e) {
    var n = t.updateQueue,
        r = t.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
        var i = null,
            s = null;
        if (n = n.firstBaseUpdate, n !== null) {
            do {
                var o = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o, n = n.next
            } while (n !== null);
            s === null ? i = s = e : s = s.next = e
        } else i = s = e;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
        }, t.updateQueue = n;
        return
    }
    t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e
}

function uw(t, e, n, r) {
    var i = t.updateQueue;
    Sc = !1;
    var s = i.firstBaseUpdate,
        o = i.lastBaseUpdate,
        a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a,
            u = l.next;
        l.next = null, o === null ? s = u : o.next = u, o = l;
        var c = t.alternate;
        c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l))
    }
    if (s !== null) {
        var f = i.baseState;
        o = 0, c = u = l = null, a = s;
        do {
            var d = a.lane,
                p = a.eventTime;
            if ((r & d) === d) {
                c !== null && (c = c.next = {
                    eventTime: p,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var m = t,
                        y = a;
                    switch (d = e, p = n, y.tag) {
                        case 1:
                            if (m = y.payload, typeof m == "function") {
                                f = m.call(p, f, d);
                                break e
                            }
                            f = m;
                            break e;
                        case 3:
                            m.flags = m.flags & -65537 | 128;
                        case 0:
                            if (m = y.payload, d = typeof m == "function" ? m.call(p, f, d) : m, d == null) break e;
                            f = Pr({}, f, d);
                            break e;
                        case 2:
                            Sc = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a))
            } else p = {
                eventTime: p,
                lane: d,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
            }, c === null ? (u = c = p, l = f) : c = c.next = p, o |= d;
            if (a = a.next, a === null) {
                if (a = i.shared.pending, a === null) break;
                d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null
            }
        } while (1);
        if (c === null && (l = f), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, e = i.shared.interleaved, e !== null) {
            i = e;
            do o |= i.lane, i = i.next; while (i !== e)
        } else s === null && (i.shared.lanes = 0);
        Xd |= o, t.lanes = o, t.memoizedState = f
    }
}

function W5(t, e, n) {
    if (t = e.effects, e.effects = null, t !== null)
        for (e = 0; e < t.length; e++) {
            var r = t[e],
                i = r.callback;
            if (i !== null) {
                if (r.callback = null, r = n, typeof i != "function") throw Error(We(191, i));
                i.call(r)
            }
        }
}
var W7 = new V$.Component().refs;

function mI(t, e, n, r) {
    e = t.memoizedState, n = n(r, e), n = n == null ? e : Pr({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n)
}
var z2 = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? yp(t) === t : !1
    },
    enqueueSetState: function(t, e, n) {
        t = t._reactInternals;
        var r = Ss(),
            i = qc(t),
            s = Eu(r, i);
        s.payload = e, n != null && (s.callback = n), e = Wc(t, s, i), e !== null && (Fa(e, t, i, r), cS(e, t, i))
    },
    enqueueReplaceState: function(t, e, n) {
        t = t._reactInternals;
        var r = Ss(),
            i = qc(t),
            s = Eu(r, i);
        s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Wc(t, s, i), e !== null && (Fa(e, t, i, r), cS(e, t, i))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var n = Ss(),
            r = qc(t),
            i = Eu(n, r);
        i.tag = 2, e != null && (i.callback = e), e = Wc(t, i, r), e !== null && (Fa(e, t, r, n), cS(e, t, r))
    }
};

function K5(t, e, n, r, i, s, o) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Wv(n, r) || !Wv(i, s) : !0
}

function K7(t, e, n) {
    var r = !1,
        i = sf,
        s = e.contextType;
    return typeof s == "object" && s !== null ? s = ea(s) : (i = $s(e) ? Wd : as.current, r = e.contextTypes, s = (r = r != null) ? Mm(t, i) : sf), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = z2, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e
}

function q5(t, e, n, r) {
    t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && z2.enqueueReplaceState(e, e.state, null)
}

function gI(t, e, n, r) {
    var i = t.stateNode;
    i.props = n, i.state = t.memoizedState, i.refs = W7, pD(t);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = ea(s) : (s = $s(e) ? Wd : as.current, i.context = Mm(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (mI(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && z2.enqueueReplaceState(i, i.state, null), uw(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308)
}

function fy(t, e, n) {
    if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
        if (n._owner) {
            if (n = n._owner, n) {
                if (n.tag !== 1) throw Error(We(309));
                var r = n.stateNode
            }
            if (!r) throw Error(We(147, t));
            var i = r,
                s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                a === W7 && (a = i.refs = {}), o === null ? delete a[s] : a[s] = o
            }, e._stringRef = s, e)
        }
        if (typeof t != "string") throw Error(We(284));
        if (!n._owner) throw Error(We(290, t))
    }
    return t
}

function sx(t, e) {
    throw t = Object.prototype.toString.call(e), Error(We(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}

function X5(t) {
    var e = t._init;
    return e(t._payload)
}

function q7(t) {
    function e(b, _) {
        if (t) {
            var x = b.deletions;
            x === null ? (b.deletions = [_], b.flags |= 16) : x.push(_)
        }
    }

    function n(b, _) {
        if (!t) return null;
        for (; _ !== null;) e(b, _), _ = _.sibling;
        return null
    }

    function r(b, _) {
        for (b = new Map; _ !== null;) _.key !== null ? b.set(_.key, _) : b.set(_.index, _), _ = _.sibling;
        return b
    }

    function i(b, _) {
        return b = Xc(b, _), b.index = 0, b.sibling = null, b
    }

    function s(b, _, x) {
        return b.index = x, t ? (x = b.alternate, x !== null ? (x = x.index, x < _ ? (b.flags |= 2, _) : x) : (b.flags |= 2, _)) : (b.flags |= 1048576, _)
    }

    function o(b) {
        return t && b.alternate === null && (b.flags |= 2), b
    }

    function a(b, _, x, S) {
        return _ === null || _.tag !== 6 ? (_ = bM(x, b.mode, S), _.return = b, _) : (_ = i(_, x), _.return = b, _)
    }

    function l(b, _, x, S) {
        var E = x.type;
        return E === Eh ? c(b, _, x.props.children, S, x.key) : _ !== null && (_.elementType === E || typeof E == "object" && E !== null && E.$$typeof === _c && X5(E) === _.type) ? (S = i(_, x.props), S.ref = fy(b, _, x), S.return = b, S) : (S = gS(x.type, x.key, x.props, null, b.mode, S), S.ref = fy(b, _, x), S.return = b, S)
    }

    function u(b, _, x, S) {
        return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== x.containerInfo || _.stateNode.implementation !== x.implementation ? (_ = xM(x, b.mode, S), _.return = b, _) : (_ = i(_, x.children || []), _.return = b, _)
    }

    function c(b, _, x, S, E) {
        return _ === null || _.tag !== 7 ? (_ = Rd(x, b.mode, S, E), _.return = b, _) : (_ = i(_, x), _.return = b, _)
    }

    function f(b, _, x) {
        if (typeof _ == "string" && _ !== "" || typeof _ == "number") return _ = bM("" + _, b.mode, x), _.return = b, _;
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
                case qb:
                    return x = gS(_.type, _.key, _.props, null, b.mode, x), x.ref = fy(b, null, _), x.return = b, x;
                case wh:
                    return _ = xM(_, b.mode, x), _.return = b, _;
                case _c:
                    var S = _._init;
                    return f(b, S(_._payload), x)
            }
            if (jy(_) || oy(_)) return _ = Rd(_, b.mode, x, null), _.return = b, _;
            sx(b, _)
        }
        return null
    }

    function d(b, _, x, S) {
        var E = _ !== null ? _.key : null;
        if (typeof x == "string" && x !== "" || typeof x == "number") return E !== null ? null : a(b, _, "" + x, S);
        if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
                case qb:
                    return x.key === E ? l(b, _, x, S) : null;
                case wh:
                    return x.key === E ? u(b, _, x, S) : null;
                case _c:
                    return E = x._init, d(b, _, E(x._payload), S)
            }
            if (jy(x) || oy(x)) return E !== null ? null : c(b, _, x, S, null);
            sx(b, x)
        }
        return null
    }

    function p(b, _, x, S, E) {
        if (typeof S == "string" && S !== "" || typeof S == "number") return b = b.get(x) || null, a(_, b, "" + S, E);
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
                case qb:
                    return b = b.get(S.key === null ? x : S.key) || null, l(_, b, S, E);
                case wh:
                    return b = b.get(S.key === null ? x : S.key) || null, u(_, b, S, E);
                case _c:
                    var A = S._init;
                    return p(b, _, x, A(S._payload), E)
            }
            if (jy(S) || oy(S)) return b = b.get(x) || null, c(_, b, S, E, null);
            sx(_, S)
        }
        return null
    }

    function m(b, _, x, S) {
        for (var E = null, A = null, T = _, M = _ = 0, I = null; T !== null && M < x.length; M++) {
            T.index > M ? (I = T, T = null) : I = T.sibling;
            var O = d(b, T, x[M], S);
            if (O === null) {
                T === null && (T = I);
                break
            }
            t && T && O.alternate === null && e(b, T), _ = s(O, _, M), A === null ? E = O : A.sibling = O, A = O, T = I
        }
        if (M === x.length) return n(b, T), xr && Yf(b, M), E;
        if (T === null) {
            for (; M < x.length; M++) T = f(b, x[M], S), T !== null && (_ = s(T, _, M), A === null ? E = T : A.sibling = T, A = T);
            return xr && Yf(b, M), E
        }
        for (T = r(b, T); M < x.length; M++) I = p(T, b, M, x[M], S), I !== null && (t && I.alternate !== null && T.delete(I.key === null ? M : I.key), _ = s(I, _, M), A === null ? E = I : A.sibling = I, A = I);
        return t && T.forEach(function(k) {
            return e(b, k)
        }), xr && Yf(b, M), E
    }

    function y(b, _, x, S) {
        var E = oy(x);
        if (typeof E != "function") throw Error(We(150));
        if (x = E.call(x), x == null) throw Error(We(151));
        for (var A = E = null, T = _, M = _ = 0, I = null, O = x.next(); T !== null && !O.done; M++, O = x.next()) {
            T.index > M ? (I = T, T = null) : I = T.sibling;
            var k = d(b, T, O.value, S);
            if (k === null) {
                T === null && (T = I);
                break
            }
            t && T && k.alternate === null && e(b, T), _ = s(k, _, M), A === null ? E = k : A.sibling = k, A = k, T = I
        }
        if (O.done) return n(b, T), xr && Yf(b, M), E;
        if (T === null) {
            for (; !O.done; M++, O = x.next()) O = f(b, O.value, S), O !== null && (_ = s(O, _, M), A === null ? E = O : A.sibling = O, A = O);
            return xr && Yf(b, M), E
        }
        for (T = r(b, T); !O.done; M++, O = x.next()) O = p(T, b, M, O.value, S), O !== null && (t && O.alternate !== null && T.delete(O.key === null ? M : O.key), _ = s(O, _, M), A === null ? E = O : A.sibling = O, A = O);
        return t && T.forEach(function(H) {
            return e(b, H)
        }), xr && Yf(b, M), E
    }

    function v(b, _, x, S) {
        if (typeof x == "object" && x !== null && x.type === Eh && x.key === null && (x = x.props.children), typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
                case qb:
                    e: {
                        for (var E = x.key, A = _; A !== null;) {
                            if (A.key === E) {
                                if (E = x.type, E === Eh) {
                                    if (A.tag === 7) {
                                        n(b, A.sibling), _ = i(A, x.props.children), _.return = b, b = _;
                                        break e
                                    }
                                } else if (A.elementType === E || typeof E == "object" && E !== null && E.$$typeof === _c && X5(E) === A.type) {
                                    n(b, A.sibling), _ = i(A, x.props), _.ref = fy(b, A, x), _.return = b, b = _;
                                    break e
                                }
                                n(b, A);
                                break
                            } else e(b, A);
                            A = A.sibling
                        }
                        x.type === Eh ? (_ = Rd(x.props.children, b.mode, S, x.key), _.return = b, b = _) : (S = gS(x.type, x.key, x.props, null, b.mode, S), S.ref = fy(b, _, x), S.return = b, b = S)
                    }
                    return o(b);
                case wh:
                    e: {
                        for (A = x.key; _ !== null;) {
                            if (_.key === A)
                                if (_.tag === 4 && _.stateNode.containerInfo === x.containerInfo && _.stateNode.implementation === x.implementation) {
                                    n(b, _.sibling), _ = i(_, x.children || []), _.return = b, b = _;
                                    break e
                                } else {
                                    n(b, _);
                                    break
                                }
                            else e(b, _);
                            _ = _.sibling
                        }
                        _ = xM(x, b.mode, S),
                        _.return = b,
                        b = _
                    }
                    return o(b);
                case _c:
                    return A = x._init, v(b, _, A(x._payload), S)
            }
            if (jy(x)) return m(b, _, x, S);
            if (oy(x)) return y(b, _, x, S);
            sx(b, x)
        }
        return typeof x == "string" && x !== "" || typeof x == "number" ? (x = "" + x, _ !== null && _.tag === 6 ? (n(b, _.sibling), _ = i(_, x), _.return = b, b = _) : (n(b, _), _ = bM(x, b.mode, S), _.return = b, b = _), o(b)) : n(b, _)
    }
    return v
}
var Pm = q7(!0),
    X7 = q7(!1),
    n1 = {},
    Al = vf(n1),
    Jv = vf(n1),
    Yv = vf(n1);

function md(t) {
    if (t === n1) throw Error(We(174));
    return t
}

function hD(t, e) {
    switch (sr(Yv, e), sr(Jv, t), sr(Al, n1), t = e.nodeType, t) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : qP(null, "");
            break;
        default:
            t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = qP(e, t)
    }
    pr(Al), sr(Al, e)
}

function Im() {
    pr(Al), pr(Jv), pr(Yv)
}

function J7(t) {
    md(Yv.current);
    var e = md(Al.current),
        n = qP(e, t.type);
    e !== n && (sr(Jv, t), sr(Al, n))
}

function mD(t) {
    Jv.current === t && (pr(Al), pr(Jv))
}
var Ar = vf(0);

function cw(t) {
    for (var e = t; e !== null;) {
        if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e
        } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue
        }
        if (e === t) break;
        for (; e.sibling === null;) {
            if (e.return === null || e.return === t) return null;
            e = e.return
        }
        e.sibling.return = e.return, e = e.sibling
    }
    return null
}
var pM = [];

function gD() {
    for (var t = 0; t < pM.length; t++) pM[t]._workInProgressVersionPrimary = null;
    pM.length = 0
}
var fS = Gu.ReactCurrentDispatcher,
    hM = Gu.ReactCurrentBatchConfig,
    qd = 0,
    Tr = null,
    pi = null,
    Ei = null,
    fw = !1,
    lv = !1,
    Qv = 0,
    rre = 0;

function Yi() {
    throw Error(We(321))
}

function yD(t, e) {
    if (e === null) return !1;
    for (var n = 0; n < e.length && n < t.length; n++)
        if (!ja(t[n], e[n])) return !1;
    return !0
}

function vD(t, e, n, r, i, s) {
    if (qd = s, Tr = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, fS.current = t === null || t.memoizedState === null ? are : lre, t = n(r, i), lv) {
        s = 0;
        do {
            if (lv = !1, Qv = 0, 25 <= s) throw Error(We(301));
            s += 1, Ei = pi = null, e.updateQueue = null, fS.current = ure, t = n(r, i)
        } while (lv)
    }
    if (fS.current = dw, e = pi !== null && pi.next !== null, qd = 0, Ei = pi = Tr = null, fw = !1, e) throw Error(We(300));
    return t
}

function bD() {
    var t = Qv !== 0;
    return Qv = 0, t
}

function ul() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ei === null ? Tr.memoizedState = Ei = t : Ei = Ei.next = t, Ei
}

function ta() {
    if (pi === null) {
        var t = Tr.alternate;
        t = t !== null ? t.memoizedState : null
    } else t = pi.next;
    var e = Ei === null ? Tr.memoizedState : Ei.next;
    if (e !== null) Ei = e, pi = t;
    else {
        if (t === null) throw Error(We(310));
        pi = t, t = {
            memoizedState: pi.memoizedState,
            baseState: pi.baseState,
            baseQueue: pi.baseQueue,
            queue: pi.queue,
            next: null
        }, Ei === null ? Tr.memoizedState = Ei = t : Ei = Ei.next = t
    }
    return Ei
}

function Zv(t, e) {
    return typeof e == "function" ? e(t) : e
}

function mM(t) {
    var e = ta(),
        n = e.queue;
    if (n === null) throw Error(We(311));
    n.lastRenderedReducer = t;
    var r = pi,
        i = r.baseQueue,
        s = n.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next, s.next = o
        }
        r.baseQueue = i = s, n.pending = null
    }
    if (i !== null) {
        s = i.next, r = r.baseState;
        var a = o = null,
            l = null,
            u = s;
        do {
            var c = u.lane;
            if ((qd & c) === c) l !== null && (l = l.next = {
                lane: 0,
                action: u.action,
                hasEagerState: u.hasEagerState,
                eagerState: u.eagerState,
                next: null
            }), r = u.hasEagerState ? u.eagerState : t(r, u.action);
            else {
                var f = {
                    lane: c,
                    action: u.action,
                    hasEagerState: u.hasEagerState,
                    eagerState: u.eagerState,
                    next: null
                };
                l === null ? (a = l = f, o = r) : l = l.next = f, Tr.lanes |= c, Xd |= c
            }
            u = u.next
        } while (u !== null && u !== s);
        l === null ? o = r : l.next = a, ja(r, e.memoizedState) || (zs = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, n.lastRenderedState = r
    }
    if (t = n.interleaved, t !== null) {
        i = t;
        do s = i.lane, Tr.lanes |= s, Xd |= s, i = i.next; while (i !== t)
    } else i === null && (n.lanes = 0);
    return [e.memoizedState, n.dispatch]
}

function gM(t) {
    var e = ta(),
        n = e.queue;
    if (n === null) throw Error(We(311));
    n.lastRenderedReducer = t;
    var r = n.dispatch,
        i = n.pending,
        s = e.memoizedState;
    if (i !== null) {
        n.pending = null;
        var o = i = i.next;
        do s = t(s, o.action), o = o.next; while (o !== i);
        ja(s, e.memoizedState) || (zs = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s
    }
    return [s, r]
}

function Y7() {}

function Q7(t, e) {
    var n = Tr,
        r = ta(),
        i = e(),
        s = !ja(r.memoizedState, i);
    if (s && (r.memoizedState = i, zs = !0), r = r.queue, xD(tG.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || Ei !== null && Ei.memoizedState.tag & 1) {
        if (n.flags |= 2048, e0(9, eG.bind(null, n, r, i, e), void 0, null), Mi === null) throw Error(We(349));
        qd & 30 || Z7(n, e, i)
    }
    return i
}

function Z7(t, e, n) {
    t.flags |= 16384, t = {
        getSnapshot: e,
        value: n
    }, e = Tr.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, Tr.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t))
}

function eG(t, e, n, r) {
    e.value = n, e.getSnapshot = r, nG(e) && rG(t)
}

function tG(t, e, n) {
    return n(function() {
        nG(e) && rG(t)
    })
}

function nG(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !ja(t, n)
    } catch {
        return !0
    }
}

function rG(t) {
    var e = Iu(t, 1);
    e !== null && Fa(e, t, 1, -1)
}

function J5(t) {
    var e = ul();
    return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zv,
        lastRenderedState: t
    }, e.queue = t, t = t.dispatch = ore.bind(null, Tr, t), [e.memoizedState, t]
}

function e0(t, e, n, r) {
    return t = {
        tag: t,
        create: e,
        destroy: n,
        deps: r,
        next: null
    }, e = Tr.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, Tr.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t
}

function iG() {
    return ta().memoizedState
}

function dS(t, e, n, r) {
    var i = ul();
    Tr.flags |= t, i.memoizedState = e0(1 | e, n, void 0, r === void 0 ? null : r)
}

function H2(t, e, n, r) {
    var i = ta();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (pi !== null) {
        var o = pi.memoizedState;
        if (s = o.destroy, r !== null && yD(r, o.deps)) {
            i.memoizedState = e0(e, n, s, r);
            return
        }
    }
    Tr.flags |= t, i.memoizedState = e0(1 | e, n, s, r)
}

function Y5(t, e) {
    return dS(8390656, 8, t, e)
}

function xD(t, e) {
    return H2(2048, 8, t, e)
}

function sG(t, e) {
    return H2(4, 2, t, e)
}

function oG(t, e) {
    return H2(4, 4, t, e)
}

function aG(t, e) {
    if (typeof e == "function") return t = t(), e(t),
        function() {
            e(null)
        };
    if (e != null) return t = t(), e.current = t,
        function() {
            e.current = null
        }
}

function lG(t, e, n) {
    return n = n != null ? n.concat([t]) : null, H2(4, 4, aG.bind(null, e, t), n)
}

function _D() {}

function uG(t, e) {
    var n = ta();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && yD(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t)
}

function cG(t, e) {
    var n = ta();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && yD(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t)
}

function fG(t, e, n) {
    return qd & 21 ? (ja(n, e) || (n = h7(), Tr.lanes |= n, Xd |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, zs = !0), t.memoizedState = n)
}

function ire(t, e) {
    var n = Vn;
    Vn = n !== 0 && 4 > n ? n : 4, t(!0);
    var r = hM.transition;
    hM.transition = {};
    try {
        t(!1), e()
    } finally {
        Vn = n, hM.transition = r
    }
}

function dG() {
    return ta().memoizedState
}

function sre(t, e, n) {
    var r = qc(t);
    if (n = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, pG(t)) hG(e, n);
    else if (n = V7(t, e, n, r), n !== null) {
        var i = Ss();
        Fa(n, t, r, i), mG(n, e, r)
    }
}

function ore(t, e, n) {
    var r = qc(t),
        i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (pG(t)) hG(e, i);
    else {
        var s = t.alternate;
        if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
            var o = e.lastRenderedState,
                a = s(o, n);
            if (i.hasEagerState = !0, i.eagerState = a, ja(a, o)) {
                var l = e.interleaved;
                l === null ? (i.next = i, dD(e)) : (i.next = l.next, l.next = i), e.interleaved = i;
                return
            }
        } catch {} finally {}
        n = V7(t, e, i, r), n !== null && (i = Ss(), Fa(n, t, r, i), mG(n, e, r))
    }
}

function pG(t) {
    var e = t.alternate;
    return t === Tr || e !== null && e === Tr
}

function hG(t, e) {
    lv = fw = !0;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e
}

function mG(t, e, n) {
    if (n & 4194240) {
        var r = e.lanes;
        r &= t.pendingLanes, n |= r, e.lanes = n, QO(t, n)
    }
}
var dw = {
        readContext: ea,
        useCallback: Yi,
        useContext: Yi,
        useEffect: Yi,
        useImperativeHandle: Yi,
        useInsertionEffect: Yi,
        useLayoutEffect: Yi,
        useMemo: Yi,
        useReducer: Yi,
        useRef: Yi,
        useState: Yi,
        useDebugValue: Yi,
        useDeferredValue: Yi,
        useTransition: Yi,
        useMutableSource: Yi,
        useSyncExternalStore: Yi,
        useId: Yi,
        unstable_isNewReconciler: !1
    },
    are = {
        readContext: ea,
        useCallback: function(t, e) {
            return ul().memoizedState = [t, e === void 0 ? null : e], t
        },
        useContext: ea,
        useEffect: Y5,
        useImperativeHandle: function(t, e, n) {
            return n = n != null ? n.concat([t]) : null, dS(4194308, 4, aG.bind(null, e, t), n)
        },
        useLayoutEffect: function(t, e) {
            return dS(4194308, 4, t, e)
        },
        useInsertionEffect: function(t, e) {
            return dS(4, 2, t, e)
        },
        useMemo: function(t, e) {
            var n = ul();
            return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t
        },
        useReducer: function(t, e, n) {
            var r = ul();
            return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: t,
                lastRenderedState: e
            }, r.queue = t, t = t.dispatch = sre.bind(null, Tr, t), [r.memoizedState, t]
        },
        useRef: function(t) {
            var e = ul();
            return t = {
                current: t
            }, e.memoizedState = t
        },
        useState: J5,
        useDebugValue: _D,
        useDeferredValue: function(t) {
            return ul().memoizedState = t
        },
        useTransition: function() {
            var t = J5(!1),
                e = t[0];
            return t = ire.bind(null, t[1]), ul().memoizedState = t, [e, t]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(t, e, n) {
            var r = Tr,
                i = ul();
            if (xr) {
                if (n === void 0) throw Error(We(407));
                n = n()
            } else {
                if (n = e(), Mi === null) throw Error(We(349));
                qd & 30 || Z7(r, e, n)
            }
            i.memoizedState = n;
            var s = {
                value: n,
                getSnapshot: e
            };
            return i.queue = s, Y5(tG.bind(null, r, s, t), [t]), r.flags |= 2048, e0(9, eG.bind(null, r, s, n, e), void 0, null), n
        },
        useId: function() {
            var t = ul(),
                e = Mi.identifierPrefix;
            if (xr) {
                var n = xu,
                    r = bu;
                n = (r & ~(1 << 32 - Ba(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Qv++, 0 < n && (e += "H" + n.toString(32)), e += ":"
            } else n = rre++, e = ":" + e + "r" + n.toString(32) + ":";
            return t.memoizedState = e
        },
        unstable_isNewReconciler: !1
    },
    lre = {
        readContext: ea,
        useCallback: uG,
        useContext: ea,
        useEffect: xD,
        useImperativeHandle: lG,
        useInsertionEffect: sG,
        useLayoutEffect: oG,
        useMemo: cG,
        useReducer: mM,
        useRef: iG,
        useState: function() {
            return mM(Zv)
        },
        useDebugValue: _D,
        useDeferredValue: function(t) {
            var e = ta();
            return fG(e, pi.memoizedState, t)
        },
        useTransition: function() {
            var t = mM(Zv)[0],
                e = ta().memoizedState;
            return [t, e]
        },
        useMutableSource: Y7,
        useSyncExternalStore: Q7,
        useId: dG,
        unstable_isNewReconciler: !1
    },
    ure = {
        readContext: ea,
        useCallback: uG,
        useContext: ea,
        useEffect: xD,
        useImperativeHandle: lG,
        useInsertionEffect: sG,
        useLayoutEffect: oG,
        useMemo: cG,
        useReducer: gM,
        useRef: iG,
        useState: function() {
            return gM(Zv)
        },
        useDebugValue: _D,
        useDeferredValue: function(t) {
            var e = ta();
            return pi === null ? e.memoizedState = t : fG(e, pi.memoizedState, t)
        },
        useTransition: function() {
            var t = gM(Zv)[0],
                e = ta().memoizedState;
            return [t, e]
        },
        useMutableSource: Y7,
        useSyncExternalStore: Q7,
        useId: dG,
        unstable_isNewReconciler: !1
    };

function Rm(t, e) {
    try {
        var n = "",
            r = e;
        do n += Fte(r), r = r.return; while (r);
        var i = n
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: t,
        source: e,
        stack: i,
        digest: null
    }
}

function yM(t, e, n) {
    return {
        value: t,
        source: null,
        stack: n ? ? null,
        digest: e ? ? null
    }
}

function yI(t, e) {
    try {
        console.error(e.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var cre = typeof WeakMap == "function" ? WeakMap : Map;

function gG(t, e, n) {
    n = Eu(-1, n), n.tag = 3, n.payload = {
        element: null
    };
    var r = e.value;
    return n.callback = function() {
        hw || (hw = !0, MI = r), yI(t, e)
    }, n
}

function yG(t, e, n) {
    n = Eu(-1, n), n.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = e.value;
        n.payload = function() {
            return r(i)
        }, n.callback = function() {
            yI(t, e)
        }
    }
    var s = t.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
        yI(t, e), typeof r != "function" && (Kc === null ? Kc = new Set([this]) : Kc.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }), n
}

function Q5(t, e, n) {
    var r = t.pingCache;
    if (r === null) {
        r = t.pingCache = new cre;
        var i = new Set;
        r.set(e, i)
    } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i));
    i.has(n) || (i.add(n), t = Ere.bind(null, t, e, n), e.then(t, t))
}

function Z5(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
        t = t.return
    } while (t !== null);
    return null
}

function eN(t, e, n, r, i) {
    return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Eu(-1, 1), e.tag = 2, Wc(n, e, 1))), n.lanes |= 1), t)
}
var fre = Gu.ReactCurrentOwner,
    zs = !1;

function xs(t, e, n, r) {
    e.child = t === null ? X7(e, null, n, r) : Pm(e, t.child, n, r)
}

function tN(t, e, n, r, i) {
    n = n.render;
    var s = e.ref;
    return rm(e, i), r = vD(t, e, n, r, s, i), n = bD(), t !== null && !zs ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Ru(t, e, i)) : (xr && n && oD(e), e.flags |= 1, xs(t, e, r, i), e.child)
}

function nN(t, e, n, r, i) {
    if (t === null) {
        var s = n.type;
        return typeof s == "function" && !PD(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, vG(t, e, s, r, i)) : (t = gS(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t)
    }
    if (s = t.child, !(t.lanes & i)) {
        var o = s.memoizedProps;
        if (n = n.compare, n = n !== null ? n : Wv, n(o, r) && t.ref === e.ref) return Ru(t, e, i)
    }
    return e.flags |= 1, t = Xc(s, r), t.ref = e.ref, t.return = e, e.child = t
}

function vG(t, e, n, r, i) {
    if (t !== null) {
        var s = t.memoizedProps;
        if (Wv(s, r) && t.ref === e.ref)
            if (zs = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (zs = !0);
            else return e.lanes = t.lanes, Ru(t, e, i)
    }
    return vI(t, e, n, r, i)
}

function bG(t, e, n) {
    var r = e.pendingProps,
        i = r.children,
        s = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden")
        if (!(e.mode & 1)) e.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, sr(Lh, no), no |= n;
        else {
            if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
                baseLanes: t,
                cachePool: null,
                transitions: null
            }, e.updateQueue = null, sr(Lh, no), no |= t, null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, r = s !== null ? s.baseLanes : n, sr(Lh, no), no |= r
        }
    else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, sr(Lh, no), no |= r;
    return xs(t, e, i, n), e.child
}

function xG(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152)
}

function vI(t, e, n, r, i) {
    var s = $s(n) ? Wd : as.current;
    return s = Mm(e, s), rm(e, i), n = vD(t, e, n, r, s, i), r = bD(), t !== null && !zs ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Ru(t, e, i)) : (xr && r && oD(e), e.flags |= 1, xs(t, e, n, i), e.child)
}

function rN(t, e, n, r, i) {
    if ($s(n)) {
        var s = !0;
        iw(e)
    } else s = !1;
    if (rm(e, i), e.stateNode === null) pS(t, e), K7(e, n, r), gI(e, n, r, i), r = !0;
    else if (t === null) {
        var o = e.stateNode,
            a = e.memoizedProps;
        o.props = a;
        var l = o.context,
            u = n.contextType;
        typeof u == "object" && u !== null ? u = ea(u) : (u = $s(n) ? Wd : as.current, u = Mm(e, u));
        var c = n.getDerivedStateFromProps,
            f = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== u) && q5(e, o, r, u), Sc = !1;
        var d = e.memoizedState;
        o.state = d, uw(e, r, o, i), l = e.memoizedState, a !== r || d !== l || Us.current || Sc ? (typeof c == "function" && (mI(e, n, c, r), l = e.memoizedState), (a = Sc || K5(e, n, a, r, d, l, u)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), o.props = r, o.state = l, o.context = u, r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1)
    } else {
        o = e.stateNode, j7(t, e), a = e.memoizedProps, u = e.type === e.elementType ? a : Sa(e.type, a), o.props = u, f = e.pendingProps, d = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = ea(l) : (l = $s(n) ? Wd : as.current, l = Mm(e, l));
        var p = n.getDerivedStateFromProps;
        (c = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || d !== l) && q5(e, o, r, l), Sc = !1, d = e.memoizedState, o.state = d, uw(e, r, o, i);
        var m = e.memoizedState;
        a !== f || d !== m || Us.current || Sc ? (typeof p == "function" && (mI(e, n, p, r), m = e.memoizedState), (u = Sc || K5(e, n, u, r, d, m, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, m, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, m, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = m), o.props = r, o.state = m, o.context = l, r = u) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 1024), r = !1)
    }
    return bI(t, e, n, r, s, i)
}

function bI(t, e, n, r, i, s) {
    xG(t, e);
    var o = (e.flags & 128) !== 0;
    if (!r && !o) return i && $5(e, n, !1), Ru(t, e, s);
    r = e.stateNode, fre.current = e;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1, t !== null && o ? (e.child = Pm(e, t.child, null, s), e.child = Pm(e, null, a, s)) : xs(t, e, a, s), e.memoizedState = r.state, i && $5(e, n, !0), e.child
}

function _G(t) {
    var e = t.stateNode;
    e.pendingContext ? U5(t, e.pendingContext, e.pendingContext !== e.context) : e.context && U5(t, e.context, !1), hD(t, e.containerInfo)
}

function iN(t, e, n, r, i) {
    return Tm(), lD(i), e.flags |= 256, xs(t, e, n, r), e.child
}
var xI = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function _I(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}

function SG(t, e, n) {
    var r = e.pendingProps,
        i = Ar.current,
        s = !1,
        o = (e.flags & 128) !== 0,
        a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), sr(Ar, i & 1), t === null) return pI(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = {
        mode: "hidden",
        children: o
    }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = G2(o, r, 0, null), t = Rd(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = _I(n), e.memoizedState = xI, t) : SD(e, o));
    if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return dre(t, e, o, r, a, i, n);
    if (s) {
        s = r.fallback, o = e.mode, i = t.child, a = i.sibling;
        var l = {
            mode: "hidden",
            children: r.children
        };
        return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = Xc(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = Xc(a, s) : (s = Rd(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? _I(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
        }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = xI, r
    }
    return s = t.child, t = s.sibling, r = Xc(s, {
        mode: "visible",
        children: r.children
    }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r
}

function SD(t, e) {
    return e = G2({
        mode: "visible",
        children: e
    }, t.mode, 0, null), e.return = t, t.child = e
}

function ox(t, e, n, r) {
    return r !== null && lD(r), Pm(e, t.child, null, n), t = SD(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t
}

function dre(t, e, n, r, i, s, o) {
    if (n) return e.flags & 256 ? (e.flags &= -257, r = yM(Error(We(422))), ox(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = G2({
        mode: "visible",
        children: r.children
    }, i, 0, null), s = Rd(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && Pm(e, t.child, null, o), e.child.memoizedState = _I(o), e.memoizedState = xI, s);
    if (!(e.mode & 1)) return ox(t, e, o, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst;
        return r = a, s = Error(We(419)), r = yM(s, r, void 0), ox(t, e, o, r)
    }
    if (a = (o & t.childLanes) !== 0, zs || a) {
        if (r = Mi, r !== null) {
            switch (o & -o) {
                case 4:
                    i = 2;
                    break;
                case 16:
                    i = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    i = 32;
                    break;
                case 536870912:
                    i = 268435456;
                    break;
                default:
                    i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, Iu(t, i), Fa(r, t, i, -1))
        }
        return TD(), r = yM(Error(We(421))), ox(t, e, o, r)
    }
    return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = Are.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, so = jc(i.nextSibling), lo = e, xr = !0, Ca = null, t !== null && (No[zo++] = bu, No[zo++] = xu, No[zo++] = Kd, bu = t.id, xu = t.overflow, Kd = e), e = SD(e, r.children), e.flags |= 4096, e)
}

function sN(t, e, n) {
    t.lanes |= e;
    var r = t.alternate;
    r !== null && (r.lanes |= e), hI(t.return, e, n)
}

function vM(t, e, n, r, i) {
    var s = t.memoizedState;
    s === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i)
}

function wG(t, e, n) {
    var r = e.pendingProps,
        i = r.revealOrder,
        s = r.tail;
    if (xs(t, e, r.children, n), r = Ar.current, r & 2) r = r & 1 | 2, e.flags |= 128;
    else {
        if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) {
            if (t.tag === 13) t.memoizedState !== null && sN(t, n, e);
            else if (t.tag === 19) sN(t, n, e);
            else if (t.child !== null) {
                t.child.return = t, t = t.child;
                continue
            }
            if (t === e) break e;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e) break e;
                t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
        }
        r &= 1
    }
    if (sr(Ar, r), !(e.mode & 1)) e.memoizedState = null;
    else switch (i) {
        case "forwards":
            for (n = e.child, i = null; n !== null;) t = n.alternate, t !== null && cw(t) === null && (i = n), n = n.sibling;
            n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), vM(e, !1, i, n, s);
            break;
        case "backwards":
            for (n = null, i = e.child, e.child = null; i !== null;) {
                if (t = i.alternate, t !== null && cw(t) === null) {
                    e.child = i;
                    break
                }
                t = i.sibling, i.sibling = n, n = i, i = t
            }
            vM(e, !0, n, null, s);
            break;
        case "together":
            vM(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
    }
    return e.child
}

function pS(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2)
}

function Ru(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies), Xd |= e.lanes, !(n & e.childLanes)) return null;
    if (t !== null && e.child !== t.child) throw Error(We(153));
    if (e.child !== null) {
        for (t = e.child, n = Xc(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;) t = t.sibling, n = n.sibling = Xc(t, t.pendingProps), n.return = e;
        n.sibling = null
    }
    return e.child
}

function pre(t, e, n) {
    switch (e.tag) {
        case 3:
            _G(e), Tm();
            break;
        case 5:
            J7(e);
            break;
        case 1:
            $s(e.type) && iw(e);
            break;
        case 4:
            hD(e, e.stateNode.containerInfo);
            break;
        case 10:
            var r = e.type._context,
                i = e.memoizedProps.value;
            sr(aw, r._currentValue), r._currentValue = i;
            break;
        case 13:
            if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (sr(Ar, Ar.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? SG(t, e, n) : (sr(Ar, Ar.current & 1), t = Ru(t, e, n), t !== null ? t.sibling : null);
            sr(Ar, Ar.current & 1);
            break;
        case 19:
            if (r = (n & e.childLanes) !== 0, t.flags & 128) {
                if (r) return wG(t, e, n);
                e.flags |= 128
            }
            if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), sr(Ar, Ar.current), r) break;
            return null;
        case 22:
        case 23:
            return e.lanes = 0, bG(t, e, n)
    }
    return Ru(t, e, n)
}
var EG, SI, AG, CG;
EG = function(t, e) {
    for (var n = e.child; n !== null;) {
        if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n, n = n.child;
            continue
        }
        if (n === e) break;
        for (; n.sibling === null;) {
            if (n.return === null || n.return === e) return;
            n = n.return
        }
        n.sibling.return = n.return, n = n.sibling
    }
};
SI = function() {};
AG = function(t, e, n, r) {
    var i = t.memoizedProps;
    if (i !== r) {
        t = e.stateNode, md(Al.current);
        var s = null;
        switch (n) {
            case "input":
                i = VP(t, i), r = VP(t, r), s = [];
                break;
            case "select":
                i = Pr({}, i, {
                    value: void 0
                }), r = Pr({}, r, {
                    value: void 0
                }), s = [];
                break;
            case "textarea":
                i = KP(t, i), r = KP(t, r), s = [];
                break;
            default:
                typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = nw)
        }
        XP(n, r);
        var o;
        n = null;
        for (u in i)
            if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
                if (u === "style") {
                    var a = i[u];
                    for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (zv.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null));
        for (u in r) {
            var l = r[u];
            if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null))
                if (u === "style")
                    if (a) {
                        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o])
                    } else n || (s || (s = []), s.push(u, n)), n = l;
            else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (zv.hasOwnProperty(u) ? (l != null && u === "onScroll" && lr("scroll", t), s || a === l || (s = [])) : (s = s || []).push(u, l))
        }
        n && (s = s || []).push("style", n);
        var u = s;
        (e.updateQueue = u) && (e.flags |= 4)
    }
};
CG = function(t, e, n, r) {
    n !== r && (e.flags |= 4)
};

function dy(t, e) {
    if (!xr) switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var n = null; e !== null;) e.alternate !== null && (n = e), e = e.sibling;
            n === null ? t.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = t.tail;
            for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
            r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null
    }
}

function Qi(t) {
    var e = t.alternate !== null && t.alternate.child === t.child,
        n = 0,
        r = 0;
    if (e)
        for (var i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
    else
        for (i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
    return t.subtreeFlags |= r, t.childLanes = n, e
}

function hre(t, e, n) {
    var r = e.pendingProps;
    switch (aD(e), e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Qi(e), null;
        case 1:
            return $s(e.type) && rw(), Qi(e), null;
        case 3:
            return r = e.stateNode, Im(), pr(Us), pr(as), gD(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (ix(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Ca !== null && (II(Ca), Ca = null))), SI(t, e), Qi(e), null;
        case 5:
            mD(e);
            var i = md(Yv.current);
            if (n = e.type, t !== null && e.stateNode != null) AG(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
                if (!r) {
                    if (e.stateNode === null) throw Error(We(166));
                    return Qi(e), null
                }
                if (t = md(Al.current), ix(e)) {
                    r = e.stateNode, n = e.type;
                    var s = e.memoizedProps;
                    switch (r[vl] = e, r[Xv] = s, t = (e.mode & 1) !== 0, n) {
                        case "dialog":
                            lr("cancel", r), lr("close", r);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            lr("load", r);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < Ky.length; i++) lr(Ky[i], r);
                            break;
                        case "source":
                            lr("error", r);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            lr("error", r), lr("load", r);
                            break;
                        case "details":
                            lr("toggle", r);
                            break;
                        case "input":
                            h5(r, s), lr("invalid", r);
                            break;
                        case "select":
                            r._wrapperState = {
                                wasMultiple: !!s.multiple
                            }, lr("invalid", r);
                            break;
                        case "textarea":
                            g5(r, s), lr("invalid", r)
                    }
                    XP(n, s), i = null;
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && rx(r.textContent, a, t), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && rx(r.textContent, a, t), i = ["children", "" + a]) : zv.hasOwnProperty(o) && a != null && o === "onScroll" && lr("scroll", r)
                        }
                    switch (n) {
                        case "input":
                            Xb(r), m5(r, s, !0);
                            break;
                        case "textarea":
                            Xb(r), y5(r);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof s.onClick == "function" && (r.onclick = nw)
                    }
                    r = i, e.updateQueue = r, r !== null && (e.flags |= 4)
                } else {
                    o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Z$(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, {
                        is: r.is
                    }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[vl] = e, t[Xv] = r, EG(t, e, !1, !1), e.stateNode = t;
                    e: {
                        switch (o = JP(n, r), n) {
                            case "dialog":
                                lr("cancel", t), lr("close", t), i = r;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                lr("load", t), i = r;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < Ky.length; i++) lr(Ky[i], t);
                                i = r;
                                break;
                            case "source":
                                lr("error", t), i = r;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                lr("error", t), lr("load", t), i = r;
                                break;
                            case "details":
                                lr("toggle", t), i = r;
                                break;
                            case "input":
                                h5(t, r), i = VP(t, r), lr("invalid", t);
                                break;
                            case "option":
                                i = r;
                                break;
                            case "select":
                                t._wrapperState = {
                                    wasMultiple: !!r.multiple
                                }, i = Pr({}, r, {
                                    value: void 0
                                }), lr("invalid", t);
                                break;
                            case "textarea":
                                g5(t, r), i = KP(t, r), lr("invalid", t);
                                break;
                            default:
                                i = r
                        }
                        XP(n, i),
                        a = i;
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var l = a[s];
                                s === "style" ? n7(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && e7(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Hv(t, l) : typeof l == "number" && Hv(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (zv.hasOwnProperty(s) ? l != null && s === "onScroll" && lr("scroll", t) : l != null && WO(t, s, l, o))
                            }
                        switch (n) {
                            case "input":
                                Xb(t), m5(t, r, !1);
                                break;
                            case "textarea":
                                Xb(t), y5(t);
                                break;
                            case "option":
                                r.value != null && t.setAttribute("value", "" + rf(r.value));
                                break;
                            case "select":
                                t.multiple = !!r.multiple, s = r.value, s != null ? Zh(t, !!r.multiple, s, !1) : r.defaultValue != null && Zh(t, !!r.multiple, r.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (t.onclick = nw)
                        }
                        switch (n) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                r = !!r.autoFocus;
                                break e;
                            case "img":
                                r = !0;
                                break e;
                            default:
                                r = !1
                        }
                    }
                    r && (e.flags |= 4)
                }
                e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
            }
            return Qi(e), null;
        case 6:
            if (t && e.stateNode != null) CG(t, e, t.memoizedProps, r);
            else {
                if (typeof r != "string" && e.stateNode === null) throw Error(We(166));
                if (n = md(Yv.current), md(Al.current), ix(e)) {
                    if (r = e.stateNode, n = e.memoizedProps, r[vl] = e, (s = r.nodeValue !== n) && (t = lo, t !== null)) switch (t.tag) {
                        case 3:
                            rx(r.nodeValue, n, (t.mode & 1) !== 0);
                            break;
                        case 5:
                            t.memoizedProps.suppressHydrationWarning !== !0 && rx(r.nodeValue, n, (t.mode & 1) !== 0)
                    }
                    s && (e.flags |= 4)
                } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[vl] = e, e.stateNode = r
            }
            return Qi(e), null;
        case 13:
            if (pr(Ar), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
                if (xr && so !== null && e.mode & 1 && !(e.flags & 128)) G7(), Tm(), e.flags |= 98560, s = !1;
                else if (s = ix(e), r !== null && r.dehydrated !== null) {
                    if (t === null) {
                        if (!s) throw Error(We(318));
                        if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(We(317));
                        s[vl] = e
                    } else Tm(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
                    Qi(e), s = !1
                } else Ca !== null && (II(Ca), Ca = null), s = !0;
                if (!s) return e.flags & 65536 ? e : null
            }
            return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || Ar.current & 1 ? hi === 0 && (hi = 3) : TD())), e.updateQueue !== null && (e.flags |= 4), Qi(e), null);
        case 4:
            return Im(), SI(t, e), t === null && Kv(e.stateNode.containerInfo), Qi(e), null;
        case 10:
            return fD(e.type._context), Qi(e), null;
        case 17:
            return $s(e.type) && rw(), Qi(e), null;
        case 19:
            if (pr(Ar), s = e.memoizedState, s === null) return Qi(e), null;
            if (r = (e.flags & 128) !== 0, o = s.rendering, o === null)
                if (r) dy(s, !1);
                else {
                    if (hi !== 0 || t !== null && t.flags & 128)
                        for (t = e.child; t !== null;) {
                            if (o = cw(t), o !== null) {
                                for (e.flags |= 128, dy(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;) s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }), n = n.sibling;
                                return sr(Ar, Ar.current & 1 | 2), e.child
                            }
                            t = t.sibling
                        }
                    s.tail !== null && qr() > Om && (e.flags |= 128, r = !0, dy(s, !1), e.lanes = 4194304)
                }
            else {
                if (!r)
                    if (t = cw(o), t !== null) {
                        if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), dy(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !xr) return Qi(e), null
                    } else 2 * qr() - s.renderingStartTime > Om && n !== 1073741824 && (e.flags |= 128, r = !0, dy(s, !1), e.lanes = 4194304);
                s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o)
            }
            return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = qr(), e.sibling = null, n = Ar.current, sr(Ar, r ? n & 1 | 2 : n & 1), e) : (Qi(e), null);
        case 22:
        case 23:
            return MD(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? no & 1073741824 && (Qi(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Qi(e), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(We(156, e.tag))
}

function mre(t, e) {
    switch (aD(e), e.tag) {
        case 1:
            return $s(e.type) && rw(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 3:
            return Im(), pr(Us), pr(as), gD(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null;
        case 5:
            return mD(e), null;
        case 13:
            if (pr(Ar), t = e.memoizedState, t !== null && t.dehydrated !== null) {
                if (e.alternate === null) throw Error(We(340));
                Tm()
            }
            return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 19:
            return pr(Ar), null;
        case 4:
            return Im(), null;
        case 10:
            return fD(e.type._context), null;
        case 22:
        case 23:
            return MD(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var ax = !1,
    ss = !1,
    gre = typeof WeakSet == "function" ? WeakSet : Set,
    Et = null;

function Dh(t, e) {
    var n = t.ref;
    if (n !== null)
        if (typeof n == "function") try {
            n(null)
        } catch (r) {
            kr(t, e, r)
        } else n.current = null
}

function wI(t, e, n) {
    try {
        n()
    } catch (r) {
        kr(t, e, r)
    }
}
var oN = !1;

function yre(t, e) {
    if (oI = ZS, t = I7(), sD(t)) {
        if ("selectionStart" in t) var n = {
            start: t.selectionStart,
            end: t.selectionEnd
        };
        else e: {
            n = (n = t.ownerDocument) && n.defaultView || window;
            var r = n.getSelection && n.getSelection();
            if (r && r.rangeCount !== 0) {
                n = r.anchorNode;
                var i = r.anchorOffset,
                    s = r.focusNode;
                r = r.focusOffset;
                try {
                    n.nodeType, s.nodeType
                } catch {
                    n = null;
                    break e
                }
                var o = 0,
                    a = -1,
                    l = -1,
                    u = 0,
                    c = 0,
                    f = t,
                    d = null;
                t: for (;;) {
                    for (var p; f !== n || i !== 0 && f.nodeType !== 3 || (a = o + i), f !== s || r !== 0 && f.nodeType !== 3 || (l = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (p = f.firstChild) !== null;) d = f, f = p;
                    for (;;) {
                        if (f === t) break t;
                        if (d === n && ++u === i && (a = o), d === s && ++c === r && (l = o), (p = f.nextSibling) !== null) break;
                        f = d, d = f.parentNode
                    }
                    f = p
                }
                n = a === -1 || l === -1 ? null : {
                    start: a,
                    end: l
                }
            } else n = null
        }
        n = n || {
            start: 0,
            end: 0
        }
    } else n = null;
    for (aI = {
            focusedElem: t,
            selectionRange: n
        }, ZS = !1, Et = e; Et !== null;)
        if (e = Et, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, Et = t;
        else
            for (; Et !== null;) {
                e = Et;
                try {
                    var m = e.alternate;
                    if (e.flags & 1024) switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (m !== null) {
                                var y = m.memoizedProps,
                                    v = m.memoizedState,
                                    b = e.stateNode,
                                    _ = b.getSnapshotBeforeUpdate(e.elementType === e.type ? y : Sa(e.type, y), v);
                                b.__reactInternalSnapshotBeforeUpdate = _
                            }
                            break;
                        case 3:
                            var x = e.stateNode.containerInfo;
                            x.nodeType === 1 ? x.textContent = "" : x.nodeType === 9 && x.documentElement && x.removeChild(x.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(We(163))
                    }
                } catch (S) {
                    kr(e, e.return, S)
                }
                if (t = e.sibling, t !== null) {
                    t.return = e.return, Et = t;
                    break
                }
                Et = e.return
            }
    return m = oN, oN = !1, m
}

function uv(t, e, n) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & t) === t) {
                var s = i.destroy;
                i.destroy = void 0, s !== void 0 && wI(e, n, s)
            }
            i = i.next
        } while (i !== r)
    }
}

function U2(t, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        var n = e = e.next;
        do {
            if ((n.tag & t) === t) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== e)
    }
}

function EI(t) {
    var e = t.ref;
    if (e !== null) {
        var n = t.stateNode;
        switch (t.tag) {
            case 5:
                t = n;
                break;
            default:
                t = n
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}

function MG(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null, MG(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[vl], delete e[Xv], delete e[cI], delete e[Zne], delete e[ere])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null
}

function TG(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}

function aN(t) {
    e: for (;;) {
        for (; t.sibling === null;) {
            if (t.return === null || TG(t.return)) return null;
            t = t.return
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
            if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
            t.child.return = t, t = t.child
        }
        if (!(t.flags & 2)) return t.stateNode
    }
}

function AI(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = nw));
    else if (r !== 4 && (t = t.child, t !== null))
        for (AI(t, e, n), t = t.sibling; t !== null;) AI(t, e, n), t = t.sibling
}

function CI(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (r !== 4 && (t = t.child, t !== null))
        for (CI(t, e, n), t = t.sibling; t !== null;) CI(t, e, n), t = t.sibling
}
var Bi = null,
    wa = !1;

function lc(t, e, n) {
    for (n = n.child; n !== null;) PG(t, e, n), n = n.sibling
}

function PG(t, e, n) {
    if (El && typeof El.onCommitFiberUnmount == "function") try {
        El.onCommitFiberUnmount(D2, n)
    } catch {}
    switch (n.tag) {
        case 5:
            ss || Dh(n, e);
        case 6:
            var r = Bi,
                i = wa;
            Bi = null, lc(t, e, n), Bi = r, wa = i, Bi !== null && (wa ? (t = Bi, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Bi.removeChild(n.stateNode));
            break;
        case 18:
            Bi !== null && (wa ? (t = Bi, n = n.stateNode, t.nodeType === 8 ? fM(t.parentNode, n) : t.nodeType === 1 && fM(t, n), Vv(t)) : fM(Bi, n.stateNode));
            break;
        case 4:
            r = Bi, i = wa, Bi = n.stateNode.containerInfo, wa = !0, lc(t, e, n), Bi = r, wa = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!ss && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
                i = r = r.next;
                do {
                    var s = i,
                        o = s.destroy;
                    s = s.tag, o !== void 0 && (s & 2 || s & 4) && wI(n, e, o), i = i.next
                } while (i !== r)
            }
            lc(t, e, n);
            break;
        case 1:
            if (!ss && (Dh(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
            } catch (a) {
                kr(n, e, a)
            }
            lc(t, e, n);
            break;
        case 21:
            lc(t, e, n);
            break;
        case 22:
            n.mode & 1 ? (ss = (r = ss) || n.memoizedState !== null, lc(t, e, n), ss = r) : lc(t, e, n);
            break;
        default:
            lc(t, e, n)
    }
}

function lN(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var n = t.stateNode;
        n === null && (n = t.stateNode = new gre), e.forEach(function(r) {
            var i = Cre.bind(null, t, r);
            n.has(r) || (n.add(r), r.then(i, i))
        })
    }
}

function ya(t, e) {
    var n = e.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var s = t,
                    o = e,
                    a = o;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            Bi = a.stateNode, wa = !1;
                            break e;
                        case 3:
                            Bi = a.stateNode.containerInfo, wa = !0;
                            break e;
                        case 4:
                            Bi = a.stateNode.containerInfo, wa = !0;
                            break e
                    }
                    a = a.return
                }
                if (Bi === null) throw Error(We(160));
                PG(s, o, i), Bi = null, wa = !1;
                var l = i.alternate;
                l !== null && (l.return = null), i.return = null
            } catch (u) {
                kr(i, e, u)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null;) IG(e, t), e = e.sibling
}

function IG(t, e) {
    var n = t.alternate,
        r = t.flags;
    switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (ya(e, t), il(t), r & 4) {
                try {
                    uv(3, t, t.return), U2(3, t)
                } catch (y) {
                    kr(t, t.return, y)
                }
                try {
                    uv(5, t, t.return)
                } catch (y) {
                    kr(t, t.return, y)
                }
            }
            break;
        case 1:
            ya(e, t), il(t), r & 512 && n !== null && Dh(n, n.return);
            break;
        case 5:
            if (ya(e, t), il(t), r & 512 && n !== null && Dh(n, n.return), t.flags & 32) {
                var i = t.stateNode;
                try {
                    Hv(i, "")
                } catch (y) {
                    kr(t, t.return, y)
                }
            }
            if (r & 4 && (i = t.stateNode, i != null)) {
                var s = t.memoizedProps,
                    o = n !== null ? n.memoizedProps : s,
                    a = t.type,
                    l = t.updateQueue;
                if (t.updateQueue = null, l !== null) try {
                    a === "input" && s.type === "radio" && s.name != null && Y$(i, s), JP(a, o);
                    var u = JP(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var c = l[o],
                            f = l[o + 1];
                        c === "style" ? n7(i, f) : c === "dangerouslySetInnerHTML" ? e7(i, f) : c === "children" ? Hv(i, f) : WO(i, c, f, u)
                    }
                    switch (a) {
                        case "input":
                            jP(i, s);
                            break;
                        case "textarea":
                            Q$(i, s);
                            break;
                        case "select":
                            var d = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!s.multiple;
                            var p = s.value;
                            p != null ? Zh(i, !!s.multiple, p, !1) : d !== !!s.multiple && (s.defaultValue != null ? Zh(i, !!s.multiple, s.defaultValue, !0) : Zh(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[Xv] = s
                } catch (y) {
                    kr(t, t.return, y)
                }
            }
            break;
        case 6:
            if (ya(e, t), il(t), r & 4) {
                if (t.stateNode === null) throw Error(We(162));
                i = t.stateNode, s = t.memoizedProps;
                try {
                    i.nodeValue = s
                } catch (y) {
                    kr(t, t.return, y)
                }
            }
            break;
        case 3:
            if (ya(e, t), il(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
                Vv(e.containerInfo)
            } catch (y) {
                kr(t, t.return, y)
            }
            break;
        case 4:
            ya(e, t), il(t);
            break;
        case 13:
            ya(e, t), il(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (AD = qr())), r & 4 && lN(t);
            break;
        case 22:
            if (c = n !== null && n.memoizedState !== null, t.mode & 1 ? (ss = (u = ss) || c, ya(e, t), ss = u) : ya(e, t), il(t), r & 8192) {
                if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !c && t.mode & 1)
                    for (Et = t, c = t.child; c !== null;) {
                        for (f = Et = c; Et !== null;) {
                            switch (d = Et, p = d.child, d.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    uv(4, d, d.return);
                                    break;
                                case 1:
                                    Dh(d, d.return);
                                    var m = d.stateNode;
                                    if (typeof m.componentWillUnmount == "function") {
                                        r = d, n = d.return;
                                        try {
                                            e = r, m.props = e.memoizedProps, m.state = e.memoizedState, m.componentWillUnmount()
                                        } catch (y) {
                                            kr(r, n, y)
                                        }
                                    }
                                    break;
                                case 5:
                                    Dh(d, d.return);
                                    break;
                                case 22:
                                    if (d.memoizedState !== null) {
                                        cN(f);
                                        continue
                                    }
                            }
                            p !== null ? (p.return = d, Et = p) : cN(f)
                        }
                        c = c.sibling
                    }
                e: for (c = null, f = t;;) {
                    if (f.tag === 5) {
                        if (c === null) {
                            c = f;
                            try {
                                i = f.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = t7("display", o))
                            } catch (y) {
                                kr(t, t.return, y)
                            }
                        }
                    } else if (f.tag === 6) {
                        if (c === null) try {
                            f.stateNode.nodeValue = u ? "" : f.memoizedProps
                        } catch (y) {
                            kr(t, t.return, y)
                        }
                    } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === t) && f.child !== null) {
                        f.child.return = f, f = f.child;
                        continue
                    }
                    if (f === t) break e;
                    for (; f.sibling === null;) {
                        if (f.return === null || f.return === t) break e;
                        c === f && (c = null), f = f.return
                    }
                    c === f && (c = null), f.sibling.return = f.return, f = f.sibling
                }
            }
            break;
        case 19:
            ya(e, t), il(t), r & 4 && lN(t);
            break;
        case 21:
            break;
        default:
            ya(e, t), il(t)
    }
}

function il(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var n = t.return; n !== null;) {
                    if (TG(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(We(160))
            }
            switch (r.tag) {
                case 5:
                    var i = r.stateNode;
                    r.flags & 32 && (Hv(i, ""), r.flags &= -33);
                    var s = aN(t);
                    CI(t, s, i);
                    break;
                case 3:
                case 4:
                    var o = r.stateNode.containerInfo,
                        a = aN(t);
                    AI(t, a, o);
                    break;
                default:
                    throw Error(We(161))
            }
        }
        catch (l) {
            kr(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}

function vre(t, e, n) {
    Et = t, RG(t)
}

function RG(t, e, n) {
    for (var r = (t.mode & 1) !== 0; Et !== null;) {
        var i = Et,
            s = i.child;
        if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || ax;
            if (!o) {
                var a = i.alternate,
                    l = a !== null && a.memoizedState !== null || ss;
                a = ax;
                var u = ss;
                if (ax = o, (ss = l) && !u)
                    for (Et = i; Et !== null;) o = Et, l = o.child, o.tag === 22 && o.memoizedState !== null ? fN(i) : l !== null ? (l.return = o, Et = l) : fN(i);
                for (; s !== null;) Et = s, RG(s), s = s.sibling;
                Et = i, ax = a, ss = u
            }
            uN(t)
        } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, Et = s) : uN(t)
    }
}

function uN(t) {
    for (; Et !== null;) {
        var e = Et;
        if (e.flags & 8772) {
            var n = e.alternate;
            try {
                if (e.flags & 8772) switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        ss || U2(5, e);
                        break;
                    case 1:
                        var r = e.stateNode;
                        if (e.flags & 4 && !ss)
                            if (n === null) r.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? n.memoizedProps : Sa(e.type, n.memoizedProps);
                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && W5(e, s, r);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (n = null, e.child !== null) switch (e.child.tag) {
                                case 5:
                                    n = e.child.stateNode;
                                    break;
                                case 1:
                                    n = e.child.stateNode
                            }
                            W5(e, o, n)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (n === null && e.flags & 4) {
                            n = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    l.autoFocus && n.focus();
                                    break;
                                case "img":
                                    l.src && (n.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var u = e.alternate;
                            if (u !== null) {
                                var c = u.memoizedState;
                                if (c !== null) {
                                    var f = c.dehydrated;
                                    f !== null && Vv(f)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(We(163))
                }
                ss || e.flags & 512 && EI(e)
            } catch (d) {
                kr(e, e.return, d)
            }
        }
        if (e === t) {
            Et = null;
            break
        }
        if (n = e.sibling, n !== null) {
            n.return = e.return, Et = n;
            break
        }
        Et = e.return
    }
}

function cN(t) {
    for (; Et !== null;) {
        var e = Et;
        if (e === t) {
            Et = null;
            break
        }
        var n = e.sibling;
        if (n !== null) {
            n.return = e.return, Et = n;
            break
        }
        Et = e.return
    }
}

function fN(t) {
    for (; Et !== null;) {
        var e = Et;
        try {
            switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var n = e.return;
                    try {
                        U2(4, e)
                    } catch (l) {
                        kr(e, n, l)
                    }
                    break;
                case 1:
                    var r = e.stateNode;
                    if (typeof r.componentDidMount == "function") {
                        var i = e.return;
                        try {
                            r.componentDidMount()
                        } catch (l) {
                            kr(e, i, l)
                        }
                    }
                    var s = e.return;
                    try {
                        EI(e)
                    } catch (l) {
                        kr(e, s, l)
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        EI(e)
                    } catch (l) {
                        kr(e, o, l)
                    }
            }
        } catch (l) {
            kr(e, e.return, l)
        }
        if (e === t) {
            Et = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return, Et = a;
            break
        }
        Et = e.return
    }
}
var bre = Math.ceil,
    pw = Gu.ReactCurrentDispatcher,
    wD = Gu.ReactCurrentOwner,
    Jo = Gu.ReactCurrentBatchConfig,
    Rn = 0,
    Mi = null,
    oi = null,
    Ui = 0,
    no = 0,
    Lh = vf(0),
    hi = 0,
    t0 = null,
    Xd = 0,
    $2 = 0,
    ED = 0,
    cv = null,
    Fs = null,
    AD = 0,
    Om = 1 / 0,
    uu = null,
    hw = !1,
    MI = null,
    Kc = null,
    lx = !1,
    Ic = null,
    mw = 0,
    fv = 0,
    TI = null,
    hS = -1,
    mS = 0;

function Ss() {
    return Rn & 6 ? qr() : hS !== -1 ? hS : hS = qr()
}

function qc(t) {
    return t.mode & 1 ? Rn & 2 && Ui !== 0 ? Ui & -Ui : nre.transition !== null ? (mS === 0 && (mS = h7()), mS) : (t = Vn, t !== 0 || (t = window.event, t = t === void 0 ? 16 : _7(t.type)), t) : 1
}

function Fa(t, e, n, r) {
    if (50 < fv) throw fv = 0, TI = null, Error(We(185));
    Z0(t, n, r), (!(Rn & 2) || t !== Mi) && (t === Mi && (!(Rn & 2) && ($2 |= n), hi === 4 && Cc(t, Ui)), Gs(t, r), n === 1 && Rn === 0 && !(e.mode & 1) && (Om = qr() + 500, N2 && bf()))
}

function Gs(t, e) {
    var n = t.callbackNode;
    nne(t, e);
    var r = QS(t, t === Mi ? Ui : 0);
    if (r === 0) n !== null && x5(n), t.callbackNode = null, t.callbackPriority = 0;
    else if (e = r & -r, t.callbackPriority !== e) {
        if (n != null && x5(n), e === 1) t.tag === 0 ? tre(dN.bind(null, t)) : H7(dN.bind(null, t)), Yne(function() {
            !(Rn & 6) && bf()
        }), n = null;
        else {
            switch (m7(r)) {
                case 1:
                    n = YO;
                    break;
                case 4:
                    n = d7;
                    break;
                case 16:
                    n = YS;
                    break;
                case 536870912:
                    n = p7;
                    break;
                default:
                    n = YS
            }
            n = zG(n, OG.bind(null, t))
        }
        t.callbackPriority = e, t.callbackNode = n
    }
}

function OG(t, e) {
    if (hS = -1, mS = 0, Rn & 6) throw Error(We(327));
    var n = t.callbackNode;
    if (im() && t.callbackNode !== n) return null;
    var r = QS(t, t === Mi ? Ui : 0);
    if (r === 0) return null;
    if (r & 30 || r & t.expiredLanes || e) e = gw(t, r);
    else {
        e = r;
        var i = Rn;
        Rn |= 2;
        var s = LG();
        (Mi !== t || Ui !== e) && (uu = null, Om = qr() + 500, Id(t, e));
        do try {
            Sre();
            break
        } catch (a) {
            DG(t, a)
        }
        while (1);
        cD(), pw.current = s, Rn = i, oi !== null ? e = 0 : (Mi = null, Ui = 0, e = hi)
    }
    if (e !== 0) {
        if (e === 2 && (i = tI(t), i !== 0 && (r = i, e = PI(t, i))), e === 1) throw n = t0, Id(t, 0), Cc(t, r), Gs(t, qr()), n;
        if (e === 6) Cc(t, r);
        else {
            if (i = t.current.alternate, !(r & 30) && !xre(i) && (e = gw(t, r), e === 2 && (s = tI(t), s !== 0 && (r = s, e = PI(t, s))), e === 1)) throw n = t0, Id(t, 0), Cc(t, r), Gs(t, qr()), n;
            switch (t.finishedWork = i, t.finishedLanes = r, e) {
                case 0:
                case 1:
                    throw Error(We(345));
                case 2:
                    Qf(t, Fs, uu);
                    break;
                case 3:
                    if (Cc(t, r), (r & 130023424) === r && (e = AD + 500 - qr(), 10 < e)) {
                        if (QS(t, 0) !== 0) break;
                        if (i = t.suspendedLanes, (i & r) !== r) {
                            Ss(), t.pingedLanes |= t.suspendedLanes & i;
                            break
                        }
                        t.timeoutHandle = uI(Qf.bind(null, t, Fs, uu), e);
                        break
                    }
                    Qf(t, Fs, uu);
                    break;
                case 4:
                    if (Cc(t, r), (r & 4194240) === r) break;
                    for (e = t.eventTimes, i = -1; 0 < r;) {
                        var o = 31 - Ba(r);
                        s = 1 << o, o = e[o], o > i && (i = o), r &= ~s
                    }
                    if (r = i, r = qr() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * bre(r / 1960)) - r, 10 < r) {
                        t.timeoutHandle = uI(Qf.bind(null, t, Fs, uu), r);
                        break
                    }
                    Qf(t, Fs, uu);
                    break;
                case 5:
                    Qf(t, Fs, uu);
                    break;
                default:
                    throw Error(We(329))
            }
        }
    }
    return Gs(t, qr()), t.callbackNode === n ? OG.bind(null, t) : null
}

function PI(t, e) {
    var n = cv;
    return t.current.memoizedState.isDehydrated && (Id(t, e).flags |= 256), t = gw(t, e), t !== 2 && (e = Fs, Fs = n, e !== null && II(e)), t
}

function II(t) {
    Fs === null ? Fs = t : Fs.push.apply(Fs, t)
}

function xre(t) {
    for (var e = t;;) {
        if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores, n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r],
                        s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!ja(s(), i)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n;
        else {
            if (e === t) break;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === t) return !0;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
    }
    return !0
}

function Cc(t, e) {
    for (e &= ~ED, e &= ~$2, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
        var n = 31 - Ba(e),
            r = 1 << n;
        t[n] = -1, e &= ~r
    }
}

function dN(t) {
    if (Rn & 6) throw Error(We(327));
    im();
    var e = QS(t, 0);
    if (!(e & 1)) return Gs(t, qr()), null;
    var n = gw(t, e);
    if (t.tag !== 0 && n === 2) {
        var r = tI(t);
        r !== 0 && (e = r, n = PI(t, r))
    }
    if (n === 1) throw n = t0, Id(t, 0), Cc(t, e), Gs(t, qr()), n;
    if (n === 6) throw Error(We(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = e, Qf(t, Fs, uu), Gs(t, qr()), null
}

function CD(t, e) {
    var n = Rn;
    Rn |= 1;
    try {
        return t(e)
    } finally {
        Rn = n, Rn === 0 && (Om = qr() + 500, N2 && bf())
    }
}

function Jd(t) {
    Ic !== null && Ic.tag === 0 && !(Rn & 6) && im();
    var e = Rn;
    Rn |= 1;
    var n = Jo.transition,
        r = Vn;
    try {
        if (Jo.transition = null, Vn = 1, t) return t()
    } finally {
        Vn = r, Jo.transition = n, Rn = e, !(Rn & 6) && bf()
    }
}

function MD() {
    no = Lh.current, pr(Lh)
}

function Id(t, e) {
    t.finishedWork = null, t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1, Jne(n)), oi !== null)
        for (n = oi.return; n !== null;) {
            var r = n;
            switch (aD(r), r.tag) {
                case 1:
                    r = r.type.childContextTypes, r != null && rw();
                    break;
                case 3:
                    Im(), pr(Us), pr(as), gD();
                    break;
                case 5:
                    mD(r);
                    break;
                case 4:
                    Im();
                    break;
                case 13:
                    pr(Ar);
                    break;
                case 19:
                    pr(Ar);
                    break;
                case 10:
                    fD(r.type._context);
                    break;
                case 22:
                case 23:
                    MD()
            }
            n = n.return
        }
    if (Mi = t, oi = t = Xc(t.current, null), Ui = no = e, hi = 0, t0 = null, ED = $2 = Xd = 0, Fs = cv = null, hd !== null) {
        for (e = 0; e < hd.length; e++)
            if (n = hd[e], r = n.interleaved, r !== null) {
                n.interleaved = null;
                var i = r.next,
                    s = n.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i, r.next = o
                }
                n.pending = r
            }
        hd = null
    }
    return t
}

function DG(t, e) {
    do {
        var n = oi;
        try {
            if (cD(), fS.current = dw, fw) {
                for (var r = Tr.memoizedState; r !== null;) {
                    var i = r.queue;
                    i !== null && (i.pending = null), r = r.next
                }
                fw = !1
            }
            if (qd = 0, Ei = pi = Tr = null, lv = !1, Qv = 0, wD.current = null, n === null || n.return === null) {
                hi = 1, t0 = e, oi = null;
                break
            }
            e: {
                var s = t,
                    o = n.return,
                    a = n,
                    l = e;
                if (e = Ui, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                    var u = l,
                        c = a,
                        f = c.tag;
                    if (!(c.mode & 1) && (f === 0 || f === 11 || f === 15)) {
                        var d = c.alternate;
                        d ? (c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.lanes = d.lanes) : (c.updateQueue = null, c.memoizedState = null)
                    }
                    var p = Z5(o);
                    if (p !== null) {
                        p.flags &= -257, eN(p, o, a, s, e), p.mode & 1 && Q5(s, u, e), e = p, l = u;
                        var m = e.updateQueue;
                        if (m === null) {
                            var y = new Set;
                            y.add(l), e.updateQueue = y
                        } else m.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            Q5(s, u, e), TD();
                            break e
                        }
                        l = Error(We(426))
                    }
                } else if (xr && a.mode & 1) {
                    var v = Z5(o);
                    if (v !== null) {
                        !(v.flags & 65536) && (v.flags |= 256), eN(v, o, a, s, e), lD(Rm(l, a));
                        break e
                    }
                }
                s = l = Rm(l, a),
                hi !== 4 && (hi = 2),
                cv === null ? cv = [s] : cv.push(s),
                s = o;do {
                    switch (s.tag) {
                        case 3:
                            s.flags |= 65536, e &= -e, s.lanes |= e;
                            var b = gG(s, l, e);
                            j5(s, b);
                            break e;
                        case 1:
                            a = l;
                            var _ = s.type,
                                x = s.stateNode;
                            if (!(s.flags & 128) && (typeof _.getDerivedStateFromError == "function" || x !== null && typeof x.componentDidCatch == "function" && (Kc === null || !Kc.has(x)))) {
                                s.flags |= 65536, e &= -e, s.lanes |= e;
                                var S = yG(s, a, e);
                                j5(s, S);
                                break e
                            }
                    }
                    s = s.return
                } while (s !== null)
            }
            BG(n)
        } catch (E) {
            e = E, oi === n && n !== null && (oi = n = n.return);
            continue
        }
        break
    } while (1)
}

function LG() {
    var t = pw.current;
    return pw.current = dw, t === null ? dw : t
}

function TD() {
    (hi === 0 || hi === 3 || hi === 2) && (hi = 4), Mi === null || !(Xd & 268435455) && !($2 & 268435455) || Cc(Mi, Ui)
}

function gw(t, e) {
    var n = Rn;
    Rn |= 2;
    var r = LG();
    (Mi !== t || Ui !== e) && (uu = null, Id(t, e));
    do try {
        _re();
        break
    } catch (i) {
        DG(t, i)
    }
    while (1);
    if (cD(), Rn = n, pw.current = r, oi !== null) throw Error(We(261));
    return Mi = null, Ui = 0, hi
}

function _re() {
    for (; oi !== null;) kG(oi)
}

function Sre() {
    for (; oi !== null && !Kte();) kG(oi)
}

function kG(t) {
    var e = NG(t.alternate, t, no);
    t.memoizedProps = t.pendingProps, e === null ? BG(t) : oi = e, wD.current = null
}

function BG(t) {
    var e = t;
    do {
        var n = e.alternate;
        if (t = e.return, e.flags & 32768) {
            if (n = mre(n, e), n !== null) {
                n.flags &= 32767, oi = n;
                return
            }
            if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
            else {
                hi = 6, oi = null;
                return
            }
        } else if (n = hre(n, e, no), n !== null) {
            oi = n;
            return
        }
        if (e = e.sibling, e !== null) {
            oi = e;
            return
        }
        oi = e = t
    } while (e !== null);
    hi === 0 && (hi = 5)
}

function Qf(t, e, n) {
    var r = Vn,
        i = Jo.transition;
    try {
        Jo.transition = null, Vn = 1, wre(t, e, n, r)
    } finally {
        Jo.transition = i, Vn = r
    }
    return null
}

function wre(t, e, n, r) {
    do im(); while (Ic !== null);
    if (Rn & 6) throw Error(We(327));
    n = t.finishedWork;
    var i = t.finishedLanes;
    if (n === null) return null;
    if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(We(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var s = n.lanes | n.childLanes;
    if (rne(t, s), t === Mi && (oi = Mi = null, Ui = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || lx || (lx = !0, zG(YS, function() {
            return im(), null
        })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) {
        s = Jo.transition, Jo.transition = null;
        var o = Vn;
        Vn = 1;
        var a = Rn;
        Rn |= 4, wD.current = null, yre(t, n), IG(n, t), Gne(aI), ZS = !!oI, aI = oI = null, t.current = n, vre(n), qte(), Rn = a, Vn = o, Jo.transition = s
    } else t.current = n;
    if (lx && (lx = !1, Ic = t, mw = i), s = t.pendingLanes, s === 0 && (Kc = null), Yte(n.stateNode), Gs(t, qr()), e !== null)
        for (r = t.onRecoverableError, n = 0; n < e.length; n++) i = e[n], r(i.value, {
            componentStack: i.stack,
            digest: i.digest
        });
    if (hw) throw hw = !1, t = MI, MI = null, t;
    return mw & 1 && t.tag !== 0 && im(), s = t.pendingLanes, s & 1 ? t === TI ? fv++ : (fv = 0, TI = t) : fv = 0, bf(), null
}

function im() {
    if (Ic !== null) {
        var t = m7(mw),
            e = Jo.transition,
            n = Vn;
        try {
            if (Jo.transition = null, Vn = 16 > t ? 16 : t, Ic === null) var r = !1;
            else {
                if (t = Ic, Ic = null, mw = 0, Rn & 6) throw Error(We(331));
                var i = Rn;
                for (Rn |= 4, Et = t.current; Et !== null;) {
                    var s = Et,
                        o = s.child;
                    if (Et.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var u = a[l];
                                for (Et = u; Et !== null;) {
                                    var c = Et;
                                    switch (c.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            uv(8, c, s)
                                    }
                                    var f = c.child;
                                    if (f !== null) f.return = c, Et = f;
                                    else
                                        for (; Et !== null;) {
                                            c = Et;
                                            var d = c.sibling,
                                                p = c.return;
                                            if (MG(c), c === u) {
                                                Et = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = p, Et = d;
                                                break
                                            }
                                            Et = p
                                        }
                                }
                            }
                            var m = s.alternate;
                            if (m !== null) {
                                var y = m.child;
                                if (y !== null) {
                                    m.child = null;
                                    do {
                                        var v = y.sibling;
                                        y.sibling = null, y = v
                                    } while (y !== null)
                                }
                            }
                            Et = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null) o.return = s, Et = o;
                    else e: for (; Et !== null;) {
                        if (s = Et, s.flags & 2048) switch (s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                uv(9, s, s.return)
                        }
                        var b = s.sibling;
                        if (b !== null) {
                            b.return = s.return, Et = b;
                            break e
                        }
                        Et = s.return
                    }
                }
                var _ = t.current;
                for (Et = _; Et !== null;) {
                    o = Et;
                    var x = o.child;
                    if (o.subtreeFlags & 2064 && x !== null) x.return = o, Et = x;
                    else e: for (o = _; Et !== null;) {
                        if (a = Et, a.flags & 2048) try {
                            switch (a.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    U2(9, a)
                            }
                        } catch (E) {
                            kr(a, a.return, E)
                        }
                        if (a === o) {
                            Et = null;
                            break e
                        }
                        var S = a.sibling;
                        if (S !== null) {
                            S.return = a.return, Et = S;
                            break e
                        }
                        Et = a.return
                    }
                }
                if (Rn = i, bf(), El && typeof El.onPostCommitFiberRoot == "function") try {
                    El.onPostCommitFiberRoot(D2, t)
                } catch {}
                r = !0
            }
            return r
        } finally {
            Vn = n, Jo.transition = e
        }
    }
    return !1
}

function pN(t, e, n) {
    e = Rm(n, e), e = gG(t, e, 1), t = Wc(t, e, 1), e = Ss(), t !== null && (Z0(t, 1, e), Gs(t, e))
}

function kr(t, e, n) {
    if (t.tag === 3) pN(t, t, n);
    else
        for (; e !== null;) {
            if (e.tag === 3) {
                pN(e, t, n);
                break
            } else if (e.tag === 1) {
                var r = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Kc === null || !Kc.has(r))) {
                    t = Rm(n, t), t = yG(e, t, 1), e = Wc(e, t, 1), t = Ss(), e !== null && (Z0(e, 1, t), Gs(e, t));
                    break
                }
            }
            e = e.return
        }
}

function Ere(t, e, n) {
    var r = t.pingCache;
    r !== null && r.delete(e), e = Ss(), t.pingedLanes |= t.suspendedLanes & n, Mi === t && (Ui & n) === n && (hi === 4 || hi === 3 && (Ui & 130023424) === Ui && 500 > qr() - AD ? Id(t, 0) : ED |= n), Gs(t, e)
}

function FG(t, e) {
    e === 0 && (t.mode & 1 ? (e = Qb, Qb <<= 1, !(Qb & 130023424) && (Qb = 4194304)) : e = 1);
    var n = Ss();
    t = Iu(t, e), t !== null && (Z0(t, e, n), Gs(t, n))
}

function Are(t) {
    var e = t.memoizedState,
        n = 0;
    e !== null && (n = e.retryLane), FG(t, n)
}

function Cre(t, e) {
    var n = 0;
    switch (t.tag) {
        case 13:
            var r = t.stateNode,
                i = t.memoizedState;
            i !== null && (n = i.retryLane);
            break;
        case 19:
            r = t.stateNode;
            break;
        default:
            throw Error(We(314))
    }
    r !== null && r.delete(e), FG(t, n)
}
var NG;
NG = function(t, e, n) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || Us.current) zs = !0;
        else {
            if (!(t.lanes & n) && !(e.flags & 128)) return zs = !1, pre(t, e, n);
            zs = !!(t.flags & 131072)
        }
    else zs = !1, xr && e.flags & 1048576 && U7(e, ow, e.index);
    switch (e.lanes = 0, e.tag) {
        case 2:
            var r = e.type;
            pS(t, e), t = e.pendingProps;
            var i = Mm(e, as.current);
            rm(e, n), i = vD(null, e, r, t, i, n);
            var s = bD();
            return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, $s(r) ? (s = !0, iw(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, pD(e), i.updater = z2, e.stateNode = i, i._reactInternals = e, gI(e, r, t, n), e = bI(null, e, r, !0, s, n)) : (e.tag = 0, xr && s && oD(e), xs(null, e, i, n), e = e.child), e;
        case 16:
            r = e.elementType;
            e: {
                switch (pS(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = Tre(r), t = Sa(r, t), i) {
                    case 0:
                        e = vI(null, e, r, t, n);
                        break e;
                    case 1:
                        e = rN(null, e, r, t, n);
                        break e;
                    case 11:
                        e = tN(null, e, r, t, n);
                        break e;
                    case 14:
                        e = nN(null, e, r, Sa(r.type, t), n);
                        break e
                }
                throw Error(We(306, r, ""))
            }
            return e;
        case 0:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Sa(r, i), vI(t, e, r, i, n);
        case 1:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Sa(r, i), rN(t, e, r, i, n);
        case 3:
            e: {
                if (_G(e), t === null) throw Error(We(387));r = e.pendingProps,
                s = e.memoizedState,
                i = s.element,
                j7(t, e),
                uw(e, r, null, n);
                var o = e.memoizedState;
                if (r = o.element, s.isDehydrated)
                    if (s = {
                            element: r,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions
                        }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
                        i = Rm(Error(We(423)), e), e = iN(t, e, r, n, i);
                        break e
                    } else if (r !== i) {
                    i = Rm(Error(We(424)), e), e = iN(t, e, r, n, i);
                    break e
                } else
                    for (so = jc(e.stateNode.containerInfo.firstChild), lo = e, xr = !0, Ca = null, n = X7(e, null, r, n), e.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
                else {
                    if (Tm(), r === i) {
                        e = Ru(t, e, n);
                        break e
                    }
                    xs(t, e, r, n)
                }
                e = e.child
            }
            return e;
        case 5:
            return J7(e), t === null && pI(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, lI(r, i) ? o = null : s !== null && lI(r, s) && (e.flags |= 32), xG(t, e), xs(t, e, o, n), e.child;
        case 6:
            return t === null && pI(e), null;
        case 13:
            return SG(t, e, n);
        case 4:
            return hD(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = Pm(e, null, r, n) : xs(t, e, r, n), e.child;
        case 11:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Sa(r, i), tN(t, e, r, i, n);
        case 7:
            return xs(t, e, e.pendingProps, n), e.child;
        case 8:
            return xs(t, e, e.pendingProps.children, n), e.child;
        case 12:
            return xs(t, e, e.pendingProps.children, n), e.child;
        case 10:
            e: {
                if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, sr(aw, r._currentValue), r._currentValue = o, s !== null)
                    if (ja(s.value, o)) {
                        if (s.children === i.children && !Us.current) {
                            e = Ru(t, e, n);
                            break e
                        }
                    } else
                        for (s = e.child, s !== null && (s.return = e); s !== null;) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var l = a.firstContext; l !== null;) {
                                    if (l.context === r) {
                                        if (s.tag === 1) {
                                            l = Eu(-1, n & -n), l.tag = 2;
                                            var u = s.updateQueue;
                                            if (u !== null) {
                                                u = u.shared;
                                                var c = u.pending;
                                                c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l
                                            }
                                        }
                                        s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), hI(s.return, n, e), a.lanes |= n;
                                        break
                                    }
                                    l = l.next
                                }
                            } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (o = s.return, o === null) throw Error(We(341));
                                o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), hI(o, n, e), o = s.sibling
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null;) {
                                    if (o === e) {
                                        o = null;
                                        break
                                    }
                                    if (s = o.sibling, s !== null) {
                                        s.return = o.return, o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                xs(t, e, i.children, n),
                e = e.child
            }
            return e;
        case 9:
            return i = e.type, r = e.pendingProps.children, rm(e, n), i = ea(i), r = r(i), e.flags |= 1, xs(t, e, r, n), e.child;
        case 14:
            return r = e.type, i = Sa(r, e.pendingProps), i = Sa(r.type, i), nN(t, e, r, i, n);
        case 15:
            return vG(t, e, e.type, e.pendingProps, n);
        case 17:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : Sa(r, i), pS(t, e), e.tag = 1, $s(r) ? (t = !0, iw(e)) : t = !1, rm(e, n), K7(e, r, i), gI(e, r, i, n), bI(null, e, r, !0, t, n);
        case 19:
            return wG(t, e, n);
        case 22:
            return bG(t, e, n)
    }
    throw Error(We(156, e.tag))
};

function zG(t, e) {
    return f7(t, e)
}

function Mre(t, e, n, r) {
    this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Wo(t, e, n, r) {
    return new Mre(t, e, n, r)
}

function PD(t) {
    return t = t.prototype, !(!t || !t.isReactComponent)
}

function Tre(t) {
    if (typeof t == "function") return PD(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof, t === qO) return 11;
        if (t === XO) return 14
    }
    return 2
}

function Xc(t, e) {
    var n = t.alternate;
    return n === null ? (n = Wo(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n
}

function gS(t, e, n, r, i, s) {
    var o = 2;
    if (r = t, typeof t == "function") PD(t) && (o = 1);
    else if (typeof t == "string") o = 5;
    else e: switch (t) {
        case Eh:
            return Rd(n.children, i, s, e);
        case KO:
            o = 8, i |= 8;
            break;
        case HP:
            return t = Wo(12, n, e, i | 2), t.elementType = HP, t.lanes = s, t;
        case UP:
            return t = Wo(13, n, e, i), t.elementType = UP, t.lanes = s, t;
        case $P:
            return t = Wo(19, n, e, i), t.elementType = $P, t.lanes = s, t;
        case q$:
            return G2(n, i, s, e);
        default:
            if (typeof t == "object" && t !== null) switch (t.$$typeof) {
                case W$:
                    o = 10;
                    break e;
                case K$:
                    o = 9;
                    break e;
                case qO:
                    o = 11;
                    break e;
                case XO:
                    o = 14;
                    break e;
                case _c:
                    o = 16, r = null;
                    break e
            }
            throw Error(We(130, t == null ? t : typeof t, ""))
    }
    return e = Wo(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e
}

function Rd(t, e, n, r) {
    return t = Wo(7, t, r, e), t.lanes = n, t
}

function G2(t, e, n, r) {
    return t = Wo(22, t, r, e), t.elementType = q$, t.lanes = n, t.stateNode = {
        isHidden: !1
    }, t
}

function bM(t, e, n) {
    return t = Wo(6, t, null, e), t.lanes = n, t
}

function xM(t, e, n) {
    return e = Wo(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    }, e
}

function Pre(t, e, n, r, i) {
    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = eM(0), this.expirationTimes = eM(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = eM(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function ID(t, e, n, r, i, s, o, a, l) {
    return t = new Pre(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Wo(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = {
        element: r,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, pD(s), t
}

function Ire(t, e, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wh,
        key: r == null ? null : "" + r,
        children: t,
        containerInfo: e,
        implementation: n
    }
}

function HG(t) {
    if (!t) return sf;
    t = t._reactInternals;
    e: {
        if (yp(t) !== t || t.tag !== 1) throw Error(We(170));
        var e = t;do {
            switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break e;
                case 1:
                    if ($s(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            e = e.return
        } while (e !== null);
        throw Error(We(171))
    }
    if (t.tag === 1) {
        var n = t.type;
        if ($s(n)) return z7(t, n, e)
    }
    return e
}

function UG(t, e, n, r, i, s, o, a, l) {
    return t = ID(n, r, !0, t, i, s, o, a, l), t.context = HG(null), n = t.current, r = Ss(), i = qc(n), s = Eu(r, i), s.callback = e ? ? null, Wc(n, s, i), t.current.lanes = i, Z0(t, i, r), Gs(t, r), t
}

function V2(t, e, n, r) {
    var i = e.current,
        s = Ss(),
        o = qc(i);
    return n = HG(n), e.context === null ? e.context = n : e.pendingContext = n, e = Eu(s, o), e.payload = {
        element: t
    }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Wc(i, e, o), t !== null && (Fa(t, i, o, s), cS(t, i, o)), o
}

function yw(t) {
    if (t = t.current, !t.child) return null;
    switch (t.child.tag) {
        case 5:
            return t.child.stateNode;
        default:
            return t.child.stateNode
    }
}

function hN(t, e) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var n = t.retryLane;
        t.retryLane = n !== 0 && n < e ? n : e
    }
}

function RD(t, e) {
    hN(t, e), (t = t.alternate) && hN(t, e)
}

function Rre() {
    return null
}
var $G = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
};

function OD(t) {
    this._internalRoot = t
}
j2.prototype.render = OD.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null) throw Error(We(409));
    V2(t, e, null, null)
};
j2.prototype.unmount = OD.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        Jd(function() {
            V2(null, t, null, null)
        }), e[Pu] = null
    }
};

function j2(t) {
    this._internalRoot = t
}
j2.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = v7();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var n = 0; n < Ac.length && e !== 0 && e < Ac[n].priority; n++);
        Ac.splice(n, 0, t), n === 0 && x7(t)
    }
};

function DD(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}

function W2(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}

function mN() {}

function Ore(t, e, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var s = r;
            r = function() {
                var u = yw(o);
                s.call(u)
            }
        }
        var o = UG(e, r, t, 0, null, !1, !1, "", mN);
        return t._reactRootContainer = o, t[Pu] = o.current, Kv(t.nodeType === 8 ? t.parentNode : t), Jd(), o
    }
    for (; i = t.lastChild;) t.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var u = yw(l);
            a.call(u)
        }
    }
    var l = ID(t, 0, !1, null, null, !1, !1, "", mN);
    return t._reactRootContainer = l, t[Pu] = l.current, Kv(t.nodeType === 8 ? t.parentNode : t), Jd(function() {
        V2(e, l, n, r)
    }), l
}

function K2(t, e, n, r, i) {
    var s = n._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = yw(o);
                a.call(l)
            }
        }
        V2(e, o, t, i)
    } else o = Ore(n, e, t, i, r);
    return yw(o)
}
g7 = function(t) {
    switch (t.tag) {
        case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var n = Wy(e.pendingLanes);
                n !== 0 && (QO(e, n | 1), Gs(e, qr()), !(Rn & 6) && (Om = qr() + 500, bf()))
            }
            break;
        case 13:
            Jd(function() {
                var r = Iu(t, 1);
                if (r !== null) {
                    var i = Ss();
                    Fa(r, t, 1, i)
                }
            }), RD(t, 1)
    }
};
ZO = function(t) {
    if (t.tag === 13) {
        var e = Iu(t, 134217728);
        if (e !== null) {
            var n = Ss();
            Fa(e, t, 134217728, n)
        }
        RD(t, 134217728)
    }
};
y7 = function(t) {
    if (t.tag === 13) {
        var e = qc(t),
            n = Iu(t, e);
        if (n !== null) {
            var r = Ss();
            Fa(n, t, e, r)
        }
        RD(t, e)
    }
};
v7 = function() {
    return Vn
};
b7 = function(t, e) {
    var n = Vn;
    try {
        return Vn = t, e()
    } finally {
        Vn = n
    }
};
QP = function(t, e, n) {
    switch (e) {
        case "input":
            if (jP(t, n), e = n.name, n.type === "radio" && e != null) {
                for (n = t; n.parentNode;) n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
                    var r = n[e];
                    if (r !== t && r.form === t.form) {
                        var i = F2(r);
                        if (!i) throw Error(We(90));
                        J$(r), jP(r, i)
                    }
                }
            }
            break;
        case "textarea":
            Q$(t, n);
            break;
        case "select":
            e = n.value, e != null && Zh(t, !!n.multiple, e, !1)
    }
};
s7 = CD;
o7 = Jd;
var Dre = {
        usingClientEntryPoint: !1,
        Events: [t1, Th, F2, r7, i7, CD]
    },
    py = {
        findFiberByHostInstance: pd,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
    },
    Lre = {
        bundleType: py.bundleType,
        version: py.version,
        rendererPackageName: py.rendererPackageName,
        rendererConfig: py.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Gu.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
            return t = u7(t), t === null ? null : t.stateNode
        },
        findFiberByHostInstance: py.findFiberByHostInstance || Rre,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ux = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ux.isDisabled && ux.supportsFiber) try {
        D2 = ux.inject(Lre), El = ux
    } catch {}
}
go.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Dre;
go.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!DD(e)) throw Error(We(200));
    return Ire(t, e, null, n)
};
go.createRoot = function(t, e) {
    if (!DD(t)) throw Error(We(299));
    var n = !1,
        r = "",
        i = $G;
    return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = ID(t, 1, !1, null, null, n, !1, r, i), t[Pu] = e.current, Kv(t.nodeType === 8 ? t.parentNode : t), new OD(e)
};
go.findDOMNode = function(t) {
    if (t == null) return null;
    if (t.nodeType === 1) return t;
    var e = t._reactInternals;
    if (e === void 0) throw typeof t.render == "function" ? Error(We(188)) : (t = Object.keys(t).join(","), Error(We(268, t)));
    return t = u7(e), t = t === null ? null : t.stateNode, t
};
go.flushSync = function(t) {
    return Jd(t)
};
go.hydrate = function(t, e, n) {
    if (!W2(e)) throw Error(We(200));
    return K2(null, t, e, !0, n)
};
go.hydrateRoot = function(t, e, n) {
    if (!DD(t)) throw Error(We(405));
    var r = n != null && n.hydratedSources || null,
        i = !1,
        s = "",
        o = $G;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = UG(e, null, t, 1, n ? ? null, i, !1, s, o), t[Pu] = e.current, Kv(t), r)
        for (t = 0; t < r.length; t++) n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i);
    return new j2(e)
};
go.render = function(t, e, n) {
    if (!W2(e)) throw Error(We(200));
    return K2(null, t, e, !1, n)
};
go.unmountComponentAtNode = function(t) {
    if (!W2(t)) throw Error(We(40));
    return t._reactRootContainer ? (Jd(function() {
        K2(null, null, t, !1, function() {
            t._reactRootContainer = null, t[Pu] = null
        })
    }), !0) : !1
};
go.unstable_batchedUpdates = CD;
go.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
    if (!W2(n)) throw Error(We(200));
    if (t == null || t._reactInternals === void 0) throw Error(We(38));
    return K2(t, e, n, !1, r)
};
go.version = "18.2.0-next-9e3b772b8-20220608";

function GG() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(GG)
    } catch (t) {
        console.error(t)
    }
}
GG(), U$.exports = go;
var r1 = U$.exports;
const kh = la(r1);
var VG, gN = r1;
VG = gN.createRoot, gN.hydrateRoot;
var jG = {
        exports: {}
    },
    WG = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dm = P;

function kre(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var Bre = typeof Object.is == "function" ? Object.is : kre,
    Fre = Dm.useState,
    Nre = Dm.useEffect,
    zre = Dm.useLayoutEffect,
    Hre = Dm.useDebugValue;

function Ure(t, e) {
    var n = e(),
        r = Fre({
            inst: {
                value: n,
                getSnapshot: e
            }
        }),
        i = r[0].inst,
        s = r[1];
    return zre(function() {
        i.value = n, i.getSnapshot = e, _M(i) && s({
            inst: i
        })
    }, [t, n, e]), Nre(function() {
        return _M(i) && s({
            inst: i
        }), t(function() {
            _M(i) && s({
                inst: i
            })
        })
    }, [t]), Hre(n), n
}

function _M(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !Bre(t, n)
    } catch {
        return !0
    }
}

function $re(t, e) {
    return e()
}
var Gre = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? $re : Ure;
WG.useSyncExternalStore = Dm.useSyncExternalStore !== void 0 ? Dm.useSyncExternalStore : Gre;
jG.exports = WG;
var KG = jG.exports,
    qG = {
        exports: {}
    },
    XG = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var q2 = P,
    Vre = KG;

function jre(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var Wre = typeof Object.is == "function" ? Object.is : jre,
    Kre = Vre.useSyncExternalStore,
    qre = q2.useRef,
    Xre = q2.useEffect,
    Jre = q2.useMemo,
    Yre = q2.useDebugValue;
XG.useSyncExternalStoreWithSelector = function(t, e, n, r, i) {
    var s = qre(null);
    if (s.current === null) {
        var o = {
            hasValue: !1,
            value: null
        };
        s.current = o
    } else o = s.current;
    s = Jre(function() {
        function l(p) {
            if (!u) {
                if (u = !0, c = p, p = r(p), i !== void 0 && o.hasValue) {
                    var m = o.value;
                    if (i(m, p)) return f = m
                }
                return f = p
            }
            if (m = f, Wre(c, p)) return m;
            var y = r(p);
            return i !== void 0 && i(m, y) ? m : (c = p, f = y)
        }
        var u = !1,
            c, f, d = n === void 0 ? null : n;
        return [function() {
            return l(e())
        }, d === null ? void 0 : function() {
            return l(d())
        }]
    }, [e, n, r, i]);
    var a = Kre(t, s[0], s[1]);
    return Xre(function() {
        o.hasValue = !0, o.value = a
    }, [a]), Yre(a), a
};
qG.exports = XG;
var Qre = qG.exports;

function Zre(t) {
    t()
}
let JG = Zre;
const eie = t => JG = t,
    tie = () => JG,
    of = P.createContext(null);

function YG() {
    return P.useContext( of )
}
const nie = () => {
    throw new Error("uSES not initialized!")
};
let QG = nie;
const rie = t => {
        QG = t
    },
    iie = (t, e) => t === e;

function sie(t = of ) {
    const e = t === of ? YG : () => P.useContext(t);
    return function(r, i = iie) {
        const {
            store: s,
            subscription: o,
            getServerState: a
        } = e(), l = QG(o.addNestedSub, s.getState, a || s.getState, r, i);
        return P.useDebugValue(l), l
    }
}
const Xze = sie();

function Y() {
    return Y = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, Y.apply(this, arguments)
}
const oie = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Y
}, Symbol.toStringTag, {
    value: "Module"
}));

function Rt(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}
var ZG = {
        exports: {}
    },
    jn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Pi = typeof Symbol == "function" && Symbol.for,
    LD = Pi ? Symbol.for("react.element") : 60103,
    kD = Pi ? Symbol.for("react.portal") : 60106,
    X2 = Pi ? Symbol.for("react.fragment") : 60107,
    J2 = Pi ? Symbol.for("react.strict_mode") : 60108,
    Y2 = Pi ? Symbol.for("react.profiler") : 60114,
    Q2 = Pi ? Symbol.for("react.provider") : 60109,
    Z2 = Pi ? Symbol.for("react.context") : 60110,
    BD = Pi ? Symbol.for("react.async_mode") : 60111,
    eE = Pi ? Symbol.for("react.concurrent_mode") : 60111,
    tE = Pi ? Symbol.for("react.forward_ref") : 60112,
    nE = Pi ? Symbol.for("react.suspense") : 60113,
    aie = Pi ? Symbol.for("react.suspense_list") : 60120,
    rE = Pi ? Symbol.for("react.memo") : 60115,
    iE = Pi ? Symbol.for("react.lazy") : 60116,
    lie = Pi ? Symbol.for("react.block") : 60121,
    uie = Pi ? Symbol.for("react.fundamental") : 60117,
    cie = Pi ? Symbol.for("react.responder") : 60118,
    fie = Pi ? Symbol.for("react.scope") : 60119;

function vo(t) {
    if (typeof t == "object" && t !== null) {
        var e = t.$$typeof;
        switch (e) {
            case LD:
                switch (t = t.type, t) {
                    case BD:
                    case eE:
                    case X2:
                    case Y2:
                    case J2:
                    case nE:
                        return t;
                    default:
                        switch (t = t && t.$$typeof, t) {
                            case Z2:
                            case tE:
                            case iE:
                            case rE:
                            case Q2:
                                return t;
                            default:
                                return e
                        }
                }
            case kD:
                return e
        }
    }
}

function eV(t) {
    return vo(t) === eE
}
jn.AsyncMode = BD;
jn.ConcurrentMode = eE;
jn.ContextConsumer = Z2;
jn.ContextProvider = Q2;
jn.Element = LD;
jn.ForwardRef = tE;
jn.Fragment = X2;
jn.Lazy = iE;
jn.Memo = rE;
jn.Portal = kD;
jn.Profiler = Y2;
jn.StrictMode = J2;
jn.Suspense = nE;
jn.isAsyncMode = function(t) {
    return eV(t) || vo(t) === BD
};
jn.isConcurrentMode = eV;
jn.isContextConsumer = function(t) {
    return vo(t) === Z2
};
jn.isContextProvider = function(t) {
    return vo(t) === Q2
};
jn.isElement = function(t) {
    return typeof t == "object" && t !== null && t.$$typeof === LD
};
jn.isForwardRef = function(t) {
    return vo(t) === tE
};
jn.isFragment = function(t) {
    return vo(t) === X2
};
jn.isLazy = function(t) {
    return vo(t) === iE
};
jn.isMemo = function(t) {
    return vo(t) === rE
};
jn.isPortal = function(t) {
    return vo(t) === kD
};
jn.isProfiler = function(t) {
    return vo(t) === Y2
};
jn.isStrictMode = function(t) {
    return vo(t) === J2
};
jn.isSuspense = function(t) {
    return vo(t) === nE
};
jn.isValidElementType = function(t) {
    return typeof t == "string" || typeof t == "function" || t === X2 || t === eE || t === Y2 || t === J2 || t === nE || t === aie || typeof t == "object" && t !== null && (t.$$typeof === iE || t.$$typeof === rE || t.$$typeof === Q2 || t.$$typeof === Z2 || t.$$typeof === tE || t.$$typeof === uie || t.$$typeof === cie || t.$$typeof === fie || t.$$typeof === lie)
};
jn.typeOf = vo;
ZG.exports = jn;
var die = ZG.exports,
    tV = die,
    pie = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    },
    hie = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    },
    nV = {};
nV[tV.ForwardRef] = pie;
nV[tV.Memo] = hie;
var rV = {
        exports: {}
    },
    Wn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FD = Symbol.for("react.element"),
    ND = Symbol.for("react.portal"),
    sE = Symbol.for("react.fragment"),
    oE = Symbol.for("react.strict_mode"),
    aE = Symbol.for("react.profiler"),
    lE = Symbol.for("react.provider"),
    uE = Symbol.for("react.context"),
    mie = Symbol.for("react.server_context"),
    cE = Symbol.for("react.forward_ref"),
    fE = Symbol.for("react.suspense"),
    dE = Symbol.for("react.suspense_list"),
    pE = Symbol.for("react.memo"),
    hE = Symbol.for("react.lazy"),
    gie = Symbol.for("react.offscreen"),
    iV;
iV = Symbol.for("react.module.reference");

function ua(t) {
    if (typeof t == "object" && t !== null) {
        var e = t.$$typeof;
        switch (e) {
            case FD:
                switch (t = t.type, t) {
                    case sE:
                    case aE:
                    case oE:
                    case fE:
                    case dE:
                        return t;
                    default:
                        switch (t = t && t.$$typeof, t) {
                            case mie:
                            case uE:
                            case cE:
                            case hE:
                            case pE:
                            case lE:
                                return t;
                            default:
                                return e
                        }
                }
            case ND:
                return e
        }
    }
}
Wn.ContextConsumer = uE;
Wn.ContextProvider = lE;
Wn.Element = FD;
Wn.ForwardRef = cE;
Wn.Fragment = sE;
Wn.Lazy = hE;
Wn.Memo = pE;
Wn.Portal = ND;
Wn.Profiler = aE;
Wn.StrictMode = oE;
Wn.Suspense = fE;
Wn.SuspenseList = dE;
Wn.isAsyncMode = function() {
    return !1
};
Wn.isConcurrentMode = function() {
    return !1
};
Wn.isContextConsumer = function(t) {
    return ua(t) === uE
};
Wn.isContextProvider = function(t) {
    return ua(t) === lE
};
Wn.isElement = function(t) {
    return typeof t == "object" && t !== null && t.$$typeof === FD
};
Wn.isForwardRef = function(t) {
    return ua(t) === cE
};
Wn.isFragment = function(t) {
    return ua(t) === sE
};
Wn.isLazy = function(t) {
    return ua(t) === hE
};
Wn.isMemo = function(t) {
    return ua(t) === pE
};
Wn.isPortal = function(t) {
    return ua(t) === ND
};
Wn.isProfiler = function(t) {
    return ua(t) === aE
};
Wn.isStrictMode = function(t) {
    return ua(t) === oE
};
Wn.isSuspense = function(t) {
    return ua(t) === fE
};
Wn.isSuspenseList = function(t) {
    return ua(t) === dE
};
Wn.isValidElementType = function(t) {
    return typeof t == "string" || typeof t == "function" || t === sE || t === aE || t === oE || t === fE || t === dE || t === gie || typeof t == "object" && t !== null && (t.$$typeof === hE || t.$$typeof === pE || t.$$typeof === lE || t.$$typeof === uE || t.$$typeof === cE || t.$$typeof === iV || t.getModuleId !== void 0)
};
Wn.typeOf = ua;
rV.exports = Wn;
var dv = rV.exports;

function yie() {
    const t = tie();
    let e = null,
        n = null;
    return {
        clear() {
            e = null, n = null
        },
        notify() {
            t(() => {
                let r = e;
                for (; r;) r.callback(), r = r.next
            })
        },
        get() {
            let r = [],
                i = e;
            for (; i;) r.push(i), i = i.next;
            return r
        },
        subscribe(r) {
            let i = !0,
                s = n = {
                    callback: r,
                    next: null,
                    prev: n
                };
            return s.prev ? s.prev.next = s : e = s,
                function() {
                    !i || e === null || (i = !1, s.next ? s.next.prev = s.prev : n = s.prev, s.prev ? s.prev.next = s.next : e = s.next)
                }
        }
    }
}
const yN = {
    notify() {},
    get: () => []
};

function vie(t, e) {
    let n, r = yN;

    function i(f) {
        return l(), r.subscribe(f)
    }

    function s() {
        r.notify()
    }

    function o() {
        c.onStateChange && c.onStateChange()
    }

    function a() {
        return !!n
    }

    function l() {
        n || (n = e ? e.addNestedSub(o) : t.subscribe(o), r = yie())
    }

    function u() {
        n && (n(), n = void 0, r.clear(), r = yN)
    }
    const c = {
        addNestedSub: i,
        notifyNestedSubs: s,
        handleChangeWrapper: o,
        isSubscribed: a,
        trySubscribe: l,
        tryUnsubscribe: u,
        getListeners: () => r
    };
    return c
}
const bie = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    xie = bie ? P.useLayoutEffect : P.useEffect;

function vN(t, e) {
    return t === e ? t !== 0 || e !== 0 || 1 / t === 1 / e : t !== t && e !== e
}

function Jze(t, e) {
    if (vN(t, e)) return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
    const n = Object.keys(t),
        r = Object.keys(e);
    if (n.length !== r.length) return !1;
    for (let i = 0; i < n.length; i++)
        if (!Object.prototype.hasOwnProperty.call(e, n[i]) || !vN(t[n[i]], e[n[i]])) return !1;
    return !0
}

function Yze({
    store: t,
    context: e,
    children: n,
    serverState: r
}) {
    const i = P.useMemo(() => {
            const a = vie(t);
            return {
                store: t,
                subscription: a,
                getServerState: r ? () => r : void 0
            }
        }, [t, r]),
        s = P.useMemo(() => t.getState(), [t]);
    xie(() => {
        const {
            subscription: a
        } = i;
        return a.onStateChange = a.notifyNestedSubs, a.trySubscribe(), s !== t.getState() && a.notifyNestedSubs(), () => {
            a.tryUnsubscribe(), a.onStateChange = void 0
        }
    }, [i, s]);
    const o = e || of ;
    return Bt.createElement(o.Provider, {
        value: i
    }, n)
}

function sV(t = of ) {
    const e = t === of ? YG : () => P.useContext(t);
    return function() {
        const {
            store: r
        } = e();
        return r
    }
}
const _ie = sV();

function Sie(t = of ) {
    const e = t === of ? _ie : sV(t);
    return function() {
        return e().dispatch
    }
}
const Qze = Sie();
rie(Qre.useSyncExternalStoreWithSelector);
eie(r1.unstable_batchedUpdates);

function Ia(t) {
    for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    throw Error("[Immer] minified error nr: " + t + (n.length ? " " + n.map(function(i) {
        return "'" + i + "'"
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
}

function af(t) {
    return !!t && !!t[br]
}

function Ou(t) {
    var e;
    return !!t && (function(n) {
        if (!n || typeof n != "object") return !1;
        var r = Object.getPrototypeOf(n);
        if (r === null) return !0;
        var i = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
        return i === Object || typeof i == "function" && Function.toString.call(i) === Rie
    }(t) || Array.isArray(t) || !!t[AN] || !!(!((e = t.constructor) === null || e === void 0) && e[AN]) || zD(t) || HD(t))
}

function Yd(t, e, n) {
    n === void 0 && (n = !1), hg(t) === 0 ? (n ? Object.keys : om)(t).forEach(function(r) {
        n && typeof r == "symbol" || e(r, t[r], t)
    }) : t.forEach(function(r, i) {
        return e(i, r, t)
    })
}

function hg(t) {
    var e = t[br];
    return e ? e.i > 3 ? e.i - 4 : e.i : Array.isArray(t) ? 1 : zD(t) ? 2 : HD(t) ? 3 : 0
}

function sm(t, e) {
    return hg(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e)
}

function wie(t, e) {
    return hg(t) === 2 ? t.get(e) : t[e]
}

function oV(t, e, n) {
    var r = hg(t);
    r === 2 ? t.set(e, n) : r === 3 ? (t.delete(e), t.add(n)) : t[e] = n
}

function aV(t, e) {
    return t === e ? t !== 0 || 1 / t == 1 / e : t != t && e != e
}

function zD(t) {
    return Pie && t instanceof Map
}

function HD(t) {
    return Iie && t instanceof Set
}

function Zf(t) {
    return t.o || t.t
}

function UD(t) {
    if (Array.isArray(t)) return Array.prototype.slice.call(t);
    var e = uV(t);
    delete e[br];
    for (var n = om(e), r = 0; r < n.length; r++) {
        var i = n[r],
            s = e[i];
        s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (e[i] = {
            configurable: !0,
            writable: !0,
            enumerable: s.enumerable,
            value: t[i]
        })
    }
    return Object.create(Object.getPrototypeOf(t), e)
}

function $D(t, e) {
    return e === void 0 && (e = !1), GD(t) || af(t) || !Ou(t) || (hg(t) > 1 && (t.set = t.add = t.clear = t.delete = Eie), Object.freeze(t), e && Yd(t, function(n, r) {
        return $D(r, !0)
    }, !0)), t
}

function Eie() {
    Ia(2)
}

function GD(t) {
    return t == null || typeof t != "object" || Object.isFrozen(t)
}

function Cl(t) {
    var e = LI[t];
    return e || Ia(18, t), e
}

function Aie(t, e) {
    LI[t] || (LI[t] = e)
}

function RI() {
    return n0
}

function SM(t, e) {
    e && (Cl("Patches"), t.u = [], t.s = [], t.v = e)
}

function vw(t) {
    OI(t), t.p.forEach(Cie), t.p = null
}

function OI(t) {
    t === n0 && (n0 = t.l)
}

function bN(t) {
    return n0 = {
        p: [],
        l: n0,
        h: t,
        m: !0,
        _: 0
    }
}

function Cie(t) {
    var e = t[br];
    e.i === 0 || e.i === 1 ? e.j() : e.O = !0
}

function wM(t, e) {
    e._ = e.p.length;
    var n = e.p[0],
        r = t !== void 0 && t !== n;
    return e.h.g || Cl("ES5").S(e, t, r), r ? (n[br].P && (vw(e), Ia(4)), Ou(t) && (t = bw(e, t), e.l || xw(e, t)), e.u && Cl("Patches").M(n[br].t, t, e.u, e.s)) : t = bw(e, n, []), vw(e), e.u && e.v(e.u, e.s), t !== lV ? t : void 0
}

function bw(t, e, n) {
    if (GD(e)) return e;
    var r = e[br];
    if (!r) return Yd(e, function(s, o) {
        return xN(t, r, e, s, o, n)
    }, !0), e;
    if (r.A !== t) return e;
    if (!r.P) return xw(t, r.t, !0), r.t;
    if (!r.I) {
        r.I = !0, r.A._--;
        var i = r.i === 4 || r.i === 5 ? r.o = UD(r.k) : r.o;
        Yd(r.i === 3 ? new Set(i) : i, function(s, o) {
            return xN(t, r, i, s, o, n)
        }), xw(t, i, !1), n && t.u && Cl("Patches").R(r, n, t.u, t.s)
    }
    return r.o
}

function xN(t, e, n, r, i, s) {
    if (af(i)) {
        var o = bw(t, i, s && e && e.i !== 3 && !sm(e.D, r) ? s.concat(r) : void 0);
        if (oV(n, r, o), !af(o)) return;
        t.m = !1
    }
    if (Ou(i) && !GD(i)) {
        if (!t.h.F && t._ < 1) return;
        bw(t, i), e && e.A.l || xw(t, i)
    }
}

function xw(t, e, n) {
    n === void 0 && (n = !1), t.h.F && t.m && $D(e, n)
}

function EM(t, e) {
    var n = t[br];
    return (n ? Zf(n) : t)[e]
}

function _N(t, e) {
    if (e in t)
        for (var n = Object.getPrototypeOf(t); n;) {
            var r = Object.getOwnPropertyDescriptor(n, e);
            if (r) return r;
            n = Object.getPrototypeOf(n)
        }
}

function Mc(t) {
    t.P || (t.P = !0, t.l && Mc(t.l))
}

function AM(t) {
    t.o || (t.o = UD(t.t))
}

function DI(t, e, n) {
    var r = zD(e) ? Cl("MapSet").N(e, n) : HD(e) ? Cl("MapSet").T(e, n) : t.g ? function(i, s) {
        var o = Array.isArray(i),
            a = {
                i: o ? 1 : 0,
                A: s ? s.A : RI(),
                P: !1,
                I: !1,
                D: {},
                l: s,
                t: i,
                k: null,
                o: null,
                j: null,
                C: !1
            },
            l = a,
            u = r0;
        o && (l = [a], u = qy);
        var c = Proxy.revocable(l, u),
            f = c.revoke,
            d = c.proxy;
        return a.k = d, a.j = f, d
    }(e, n) : Cl("ES5").J(e, n);
    return (n ? n.A : RI()).p.push(r), r
}

function Mie(t) {
    return af(t) || Ia(22, t),
        function e(n) {
            if (!Ou(n)) return n;
            var r, i = n[br],
                s = hg(n);
            if (i) {
                if (!i.P && (i.i < 4 || !Cl("ES5").K(i))) return i.t;
                i.I = !0, r = SN(n, s), i.I = !1
            } else r = SN(n, s);
            return Yd(r, function(o, a) {
                i && wie(i.t, o) === a || oV(r, o, e(a))
            }), s === 3 ? new Set(r) : r
        }(t)
}

function SN(t, e) {
    switch (e) {
        case 2:
            return new Map(t);
        case 3:
            return Array.from(t)
    }
    return UD(t)
}

function Tie() {
    function t(s, o) {
        var a = i[s];
        return a ? a.enumerable = o : i[s] = a = {
            configurable: !0,
            enumerable: o,
            get: function() {
                var l = this[br];
                return r0.get(l, s)
            },
            set: function(l) {
                var u = this[br];
                r0.set(u, s, l)
            }
        }, a
    }

    function e(s) {
        for (var o = s.length - 1; o >= 0; o--) {
            var a = s[o][br];
            if (!a.P) switch (a.i) {
                case 5:
                    r(a) && Mc(a);
                    break;
                case 4:
                    n(a) && Mc(a)
            }
        }
    }

    function n(s) {
        for (var o = s.t, a = s.k, l = om(a), u = l.length - 1; u >= 0; u--) {
            var c = l[u];
            if (c !== br) {
                var f = o[c];
                if (f === void 0 && !sm(o, c)) return !0;
                var d = a[c],
                    p = d && d[br];
                if (p ? p.t !== f : !aV(d, f)) return !0
            }
        }
        var m = !!o[br];
        return l.length !== om(o).length + (m ? 0 : 1)
    }

    function r(s) {
        var o = s.k;
        if (o.length !== s.t.length) return !0;
        var a = Object.getOwnPropertyDescriptor(o, o.length - 1);
        if (a && !a.get) return !0;
        for (var l = 0; l < o.length; l++)
            if (!o.hasOwnProperty(l)) return !0;
        return !1
    }
    var i = {};
    Aie("ES5", {
        J: function(s, o) {
            var a = Array.isArray(s),
                l = function(c, f) {
                    if (c) {
                        for (var d = Array(f.length), p = 0; p < f.length; p++) Object.defineProperty(d, "" + p, t(p, !0));
                        return d
                    }
                    var m = uV(f);
                    delete m[br];
                    for (var y = om(m), v = 0; v < y.length; v++) {
                        var b = y[v];
                        m[b] = t(b, c || !!m[b].enumerable)
                    }
                    return Object.create(Object.getPrototypeOf(f), m)
                }(a, s),
                u = {
                    i: a ? 5 : 4,
                    A: o ? o.A : RI(),
                    P: !1,
                    I: !1,
                    D: {},
                    l: o,
                    t: s,
                    k: l,
                    o: null,
                    O: !1,
                    C: !1
                };
            return Object.defineProperty(l, br, {
                value: u,
                writable: !0
            }), l
        },
        S: function(s, o, a) {
            a ? af(o) && o[br].A === s && e(s.p) : (s.u && function l(u) {
                if (u && typeof u == "object") {
                    var c = u[br];
                    if (c) {
                        var f = c.t,
                            d = c.k,
                            p = c.D,
                            m = c.i;
                        if (m === 4) Yd(d, function(x) {
                            x !== br && (f[x] !== void 0 || sm(f, x) ? p[x] || l(d[x]) : (p[x] = !0, Mc(c)))
                        }), Yd(f, function(x) {
                            d[x] !== void 0 || sm(d, x) || (p[x] = !1, Mc(c))
                        });
                        else if (m === 5) {
                            if (r(c) && (Mc(c), p.length = !0), d.length < f.length)
                                for (var y = d.length; y < f.length; y++) p[y] = !1;
                            else
                                for (var v = f.length; v < d.length; v++) p[v] = !0;
                            for (var b = Math.min(d.length, f.length), _ = 0; _ < b; _++) d.hasOwnProperty(_) || (p[_] = !0), p[_] === void 0 && l(d[_])
                        }
                    }
                }
            }(s.p[0]), e(s.p))
        },
        K: function(s) {
            return s.i === 4 ? n(s) : r(s)
        }
    })
}
var wN, n0, VD = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
    Pie = typeof Map < "u",
    Iie = typeof Set < "u",
    EN = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u",
    lV = VD ? Symbol.for("immer-nothing") : ((wN = {})["immer-nothing"] = !0, wN),
    AN = VD ? Symbol.for("immer-draftable") : "__$immer_draftable",
    br = VD ? Symbol.for("immer-state") : "__$immer_state",
    Rie = "" + Object.prototype.constructor,
    om = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(t) {
        return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
    } : Object.getOwnPropertyNames,
    uV = Object.getOwnPropertyDescriptors || function(t) {
        var e = {};
        return om(t).forEach(function(n) {
            e[n] = Object.getOwnPropertyDescriptor(t, n)
        }), e
    },
    LI = {},
    r0 = {
        get: function(t, e) {
            if (e === br) return t;
            var n = Zf(t);
            if (!sm(n, e)) return function(i, s, o) {
                var a, l = _N(s, o);
                return l ? "value" in l ? l.value : (a = l.get) === null || a === void 0 ? void 0 : a.call(i.k) : void 0
            }(t, n, e);
            var r = n[e];
            return t.I || !Ou(r) ? r : r === EM(t.t, e) ? (AM(t), t.o[e] = DI(t.A.h, r, t)) : r
        },
        has: function(t, e) {
            return e in Zf(t)
        },
        ownKeys: function(t) {
            return Reflect.ownKeys(Zf(t))
        },
        set: function(t, e, n) {
            var r = _N(Zf(t), e);
            if (r != null && r.set) return r.set.call(t.k, n), !0;
            if (!t.P) {
                var i = EM(Zf(t), e),
                    s = i == null ? void 0 : i[br];
                if (s && s.t === n) return t.o[e] = n, t.D[e] = !1, !0;
                if (aV(n, i) && (n !== void 0 || sm(t.t, e))) return !0;
                AM(t), Mc(t)
            }
            return t.o[e] === n && typeof n != "number" && (n !== void 0 || e in t.o) || (t.o[e] = n, t.D[e] = !0, !0)
        },
        deleteProperty: function(t, e) {
            return EM(t.t, e) !== void 0 || e in t.t ? (t.D[e] = !1, AM(t), Mc(t)) : delete t.D[e], t.o && delete t.o[e], !0
        },
        getOwnPropertyDescriptor: function(t, e) {
            var n = Zf(t),
                r = Reflect.getOwnPropertyDescriptor(n, e);
            return r && {
                writable: !0,
                configurable: t.i !== 1 || e !== "length",
                enumerable: r.enumerable,
                value: n[e]
            }
        },
        defineProperty: function() {
            Ia(11)
        },
        getPrototypeOf: function(t) {
            return Object.getPrototypeOf(t.t)
        },
        setPrototypeOf: function() {
            Ia(12)
        }
    },
    qy = {};
Yd(r0, function(t, e) {
    qy[t] = function() {
        return arguments[0] = arguments[0][0], e.apply(this, arguments)
    }
}), qy.deleteProperty = function(t, e) {
    return qy.set.call(this, t, e, void 0)
}, qy.set = function(t, e, n) {
    return r0.set.call(this, t[0], e, n, t[0])
};
var Oie = function() {
        function t(n) {
            var r = this;
            this.g = EN, this.F = !0, this.produce = function(i, s, o) {
                if (typeof i == "function" && typeof s != "function") {
                    var a = s;
                    s = i;
                    var l = r;
                    return function(y) {
                        var v = this;
                        y === void 0 && (y = a);
                        for (var b = arguments.length, _ = Array(b > 1 ? b - 1 : 0), x = 1; x < b; x++) _[x - 1] = arguments[x];
                        return l.produce(y, function(S) {
                            var E;
                            return (E = s).call.apply(E, [v, S].concat(_))
                        })
                    }
                }
                var u;
                if (typeof s != "function" && Ia(6), o !== void 0 && typeof o != "function" && Ia(7), Ou(i)) {
                    var c = bN(r),
                        f = DI(r, i, void 0),
                        d = !0;
                    try {
                        u = s(f), d = !1
                    } finally {
                        d ? vw(c) : OI(c)
                    }
                    return typeof Promise < "u" && u instanceof Promise ? u.then(function(y) {
                        return SM(c, o), wM(y, c)
                    }, function(y) {
                        throw vw(c), y
                    }) : (SM(c, o), wM(u, c))
                }
                if (!i || typeof i != "object") {
                    if ((u = s(i)) === void 0 && (u = i), u === lV && (u = void 0), r.F && $D(u, !0), o) {
                        var p = [],
                            m = [];
                        Cl("Patches").M(i, u, p, m), o(p, m)
                    }
                    return u
                }
                Ia(21, i)
            }, this.produceWithPatches = function(i, s) {
                if (typeof i == "function") return function(u) {
                    for (var c = arguments.length, f = Array(c > 1 ? c - 1 : 0), d = 1; d < c; d++) f[d - 1] = arguments[d];
                    return r.produceWithPatches(u, function(p) {
                        return i.apply(void 0, [p].concat(f))
                    })
                };
                var o, a, l = r.produce(i, s, function(u, c) {
                    o = u, a = c
                });
                return typeof Promise < "u" && l instanceof Promise ? l.then(function(u) {
                    return [u, o, a]
                }) : [l, o, a]
            }, typeof(n == null ? void 0 : n.useProxies) == "boolean" && this.setUseProxies(n.useProxies), typeof(n == null ? void 0 : n.autoFreeze) == "boolean" && this.setAutoFreeze(n.autoFreeze)
        }
        var e = t.prototype;
        return e.createDraft = function(n) {
            Ou(n) || Ia(8), af(n) && (n = Mie(n));
            var r = bN(this),
                i = DI(this, n, void 0);
            return i[br].C = !0, OI(r), i
        }, e.finishDraft = function(n, r) {
            var i = n && n[br],
                s = i.A;
            return SM(s, r), wM(void 0, s)
        }, e.setAutoFreeze = function(n) {
            this.F = n
        }, e.setUseProxies = function(n) {
            n && !EN && Ia(20), this.g = n
        }, e.applyPatches = function(n, r) {
            var i;
            for (i = r.length - 1; i >= 0; i--) {
                var s = r[i];
                if (s.path.length === 0 && s.op === "replace") {
                    n = s.value;
                    break
                }
            }
            i > -1 && (r = r.slice(i + 1));
            var o = Cl("Patches").$;
            return af(n) ? o(n, r) : this.produce(n, function(a) {
                return o(a, r)
            })
        }, t
    }(),
    po = new Oie,
    cV = po.produce;
po.produceWithPatches.bind(po);
po.setAutoFreeze.bind(po);
po.setUseProxies.bind(po);
po.applyPatches.bind(po);
po.createDraft.bind(po);
po.finishDraft.bind(po);

function yi(t) {
    "@babel/helpers - typeof";
    return yi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, yi(t)
}

function Die(t, e) {
    if (yi(t) != "object" || !t) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e || "default");
        if (yi(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}

function fV(t) {
    var e = Die(t, "string");
    return yi(e) == "symbol" ? e : e + ""
}

function En(t, e, n) {
    return e = fV(e), e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function CN(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function et(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? CN(Object(n), !0).forEach(function(r) {
            En(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : CN(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}

function rs(t) {
    return "Minified Redux error #" + t + "; visit https://redux.js.org/Errors?code=" + t + " for the full message or use the non-minified dev environment for full errors. "
}
var MN = function() {
        return typeof Symbol == "function" && Symbol.observable || "@@observable"
    }(),
    CM = function() {
        return Math.random().toString(36).substring(7).split("").join(".")
    },
    _w = {
        INIT: "@@redux/INIT" + CM(),
        REPLACE: "@@redux/REPLACE" + CM(),
        PROBE_UNKNOWN_ACTION: function() {
            return "@@redux/PROBE_UNKNOWN_ACTION" + CM()
        }
    };

function Lie(t) {
    if (typeof t != "object" || t === null) return !1;
    for (var e = t; Object.getPrototypeOf(e) !== null;) e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(t) === e
}

function jD(t, e, n) {
    var r;
    if (typeof e == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function") throw new Error(rs(0));
    if (typeof e == "function" && typeof n > "u" && (n = e, e = void 0), typeof n < "u") {
        if (typeof n != "function") throw new Error(rs(1));
        return n(jD)(t, e)
    }
    if (typeof t != "function") throw new Error(rs(2));
    var i = t,
        s = e,
        o = [],
        a = o,
        l = !1;

    function u() {
        a === o && (a = o.slice())
    }

    function c() {
        if (l) throw new Error(rs(3));
        return s
    }

    function f(y) {
        if (typeof y != "function") throw new Error(rs(4));
        if (l) throw new Error(rs(5));
        var v = !0;
        return u(), a.push(y),
            function() {
                if (v) {
                    if (l) throw new Error(rs(6));
                    v = !1, u();
                    var _ = a.indexOf(y);
                    a.splice(_, 1), o = null
                }
            }
    }

    function d(y) {
        if (!Lie(y)) throw new Error(rs(7));
        if (typeof y.type > "u") throw new Error(rs(8));
        if (l) throw new Error(rs(9));
        try {
            l = !0, s = i(s, y)
        } finally {
            l = !1
        }
        for (var v = o = a, b = 0; b < v.length; b++) {
            var _ = v[b];
            _()
        }
        return y
    }

    function p(y) {
        if (typeof y != "function") throw new Error(rs(10));
        i = y, d({
            type: _w.REPLACE
        })
    }

    function m() {
        var y, v = f;
        return y = {
            subscribe: function(_) {
                if (typeof _ != "object" || _ === null) throw new Error(rs(11));

                function x() {
                    _.next && _.next(c())
                }
                x();
                var S = v(x);
                return {
                    unsubscribe: S
                }
            }
        }, y[MN] = function() {
            return this
        }, y
    }
    return d({
        type: _w.INIT
    }), r = {
        dispatch: d,
        subscribe: f,
        getState: c,
        replaceReducer: p
    }, r[MN] = m, r
}

function kie(t) {
    Object.keys(t).forEach(function(e) {
        var n = t[e],
            r = n(void 0, {
                type: _w.INIT
            });
        if (typeof r > "u") throw new Error(rs(12));
        if (typeof n(void 0, {
                type: _w.PROBE_UNKNOWN_ACTION()
            }) > "u") throw new Error(rs(13))
    })
}

function Bie(t) {
    for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++) {
        var i = e[r];
        typeof t[i] == "function" && (n[i] = t[i])
    }
    var s = Object.keys(n),
        o;
    try {
        kie(n)
    } catch (a) {
        o = a
    }
    return function(l, u) {
        if (l === void 0 && (l = {}), o) throw o;
        for (var c = !1, f = {}, d = 0; d < s.length; d++) {
            var p = s[d],
                m = n[p],
                y = l[p],
                v = m(y, u);
            if (typeof v > "u") throw u && u.type, new Error(rs(14));
            f[p] = v, c = c || v !== y
        }
        return c = c || s.length !== Object.keys(l).length, c ? f : l
    }
}

function Sw() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return e.length === 0 ? function(r) {
        return r
    } : e.length === 1 ? e[0] : e.reduce(function(r, i) {
        return function() {
            return r(i.apply(void 0, arguments))
        }
    })
}

function Fie() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return function(r) {
        return function() {
            var i = r.apply(void 0, arguments),
                s = function() {
                    throw new Error(rs(15))
                },
                o = {
                    getState: i.getState,
                    dispatch: function() {
                        return s.apply(void 0, arguments)
                    }
                },
                a = e.map(function(l) {
                    return l(o)
                });
            return s = Sw.apply(void 0, a)(i.dispatch), et(et({}, i), {}, {
                dispatch: s
            })
        }
    }
}
var ww = "NOT_FOUND";

function Nie(t) {
    var e;
    return {
        get: function(r) {
            return e && t(e.key, r) ? e.value : ww
        },
        put: function(r, i) {
            e = {
                key: r,
                value: i
            }
        },
        getEntries: function() {
            return e ? [e] : []
        },
        clear: function() {
            e = void 0
        }
    }
}

function zie(t, e) {
    var n = [];

    function r(a) {
        var l = n.findIndex(function(c) {
            return e(a, c.key)
        });
        if (l > -1) {
            var u = n[l];
            return l > 0 && (n.splice(l, 1), n.unshift(u)), u.value
        }
        return ww
    }

    function i(a, l) {
        r(a) === ww && (n.unshift({
            key: a,
            value: l
        }), n.length > t && n.pop())
    }

    function s() {
        return n
    }

    function o() {
        n = []
    }
    return {
        get: r,
        put: i,
        getEntries: s,
        clear: o
    }
}
var Hie = function(e, n) {
    return e === n
};

function Uie(t) {
    return function(n, r) {
        if (n === null || r === null || n.length !== r.length) return !1;
        for (var i = n.length, s = 0; s < i; s++)
            if (!t(n[s], r[s])) return !1;
        return !0
    }
}

function $ie(t, e) {
    var n = typeof e == "object" ? e : {
            equalityCheck: e
        },
        r = n.equalityCheck,
        i = r === void 0 ? Hie : r,
        s = n.maxSize,
        o = s === void 0 ? 1 : s,
        a = n.resultEqualityCheck,
        l = Uie(i),
        u = o === 1 ? Nie(l) : zie(o, l);

    function c() {
        var f = u.get(arguments);
        if (f === ww) {
            if (f = t.apply(null, arguments), a) {
                var d = u.getEntries(),
                    p = d.find(function(m) {
                        return a(m.value, f)
                    });
                p && (f = p.value)
            }
            u.put(arguments, f)
        }
        return f
    }
    return c.clearCache = function() {
        return u.clear()
    }, c
}

function Gie(t) {
    var e = Array.isArray(t[0]) ? t[0] : t;
    if (!e.every(function(r) {
            return typeof r == "function"
        })) {
        var n = e.map(function(r) {
            return typeof r == "function" ? "function " + (r.name || "unnamed") + "()" : typeof r
        }).join(", ");
        throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + n + "]")
    }
    return e
}

function Vie(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    var i = function() {
        for (var o = arguments.length, a = new Array(o), l = 0; l < o; l++) a[l] = arguments[l];
        var u = 0,
            c, f = {
                memoizeOptions: void 0
            },
            d = a.pop();
        if (typeof d == "object" && (f = d, d = a.pop()), typeof d != "function") throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof d + "]");
        var p = f,
            m = p.memoizeOptions,
            y = m === void 0 ? n : m,
            v = Array.isArray(y) ? y : [y],
            b = Gie(a),
            _ = t.apply(void 0, [function() {
                return u++, d.apply(null, arguments)
            }].concat(v)),
            x = t(function() {
                for (var E = [], A = b.length, T = 0; T < A; T++) E.push(b[T].apply(null, arguments));
                return c = _.apply(null, E), c
            });
        return Object.assign(x, {
            resultFunc: d,
            memoizedResultFunc: _,
            dependencies: b,
            lastResult: function() {
                return c
            },
            recomputations: function() {
                return u
            },
            resetRecomputations: function() {
                return u = 0
            }
        }), x
    };
    return i
}
var Zze = Vie($ie);

function dV(t) {
    var e = function(r) {
        var i = r.dispatch,
            s = r.getState;
        return function(o) {
            return function(a) {
                return typeof a == "function" ? a(i, s, t) : o(a)
            }
        }
    };
    return e
}
var pV = dV();
pV.withExtraArgument = dV;
const TN = pV;
var jie = globalThis && globalThis.__extends || function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(r, i) {
                r.__proto__ = i
            } || function(r, i) {
                for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s])
            }, t(e, n)
        };
        return function(e, n) {
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            t(e, n);

            function r() {
                this.constructor = e
            }
            e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    i1 = globalThis && globalThis.__generator || function(t, e) {
        var n = {
                label: 0,
                sent: function() {
                    if (s[0] & 1) throw s[1];
                    return s[1]
                },
                trys: [],
                ops: []
            },
            r, i, s, o;
        return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
        }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
            return this
        }), o;

        function a(u) {
            return function(c) {
                return l([u, c])
            }
        }

        function l(u) {
            if (r) throw new TypeError("Generator is already executing.");
            for (; n;) try {
                if (r = 1, i && (s = u[0] & 2 ? i.return : u[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, u[1])).done) return s;
                switch (i = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
                    case 0:
                    case 1:
                        s = u;
                        break;
                    case 4:
                        return n.label++, {
                            value: u[1],
                            done: !1
                        };
                    case 5:
                        n.label++, i = u[1], u = [0];
                        continue;
                    case 7:
                        u = n.ops.pop(), n.trys.pop();
                        continue;
                    default:
                        if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                            n = 0;
                            continue
                        }
                        if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
                            n.label = u[1];
                            break
                        }
                        if (u[0] === 6 && n.label < s[1]) {
                            n.label = s[1], s = u;
                            break
                        }
                        if (s && n.label < s[2]) {
                            n.label = s[2], n.ops.push(u);
                            break
                        }
                        s[2] && n.ops.pop(), n.trys.pop();
                        continue
                }
                u = e.call(t, n)
            } catch (c) {
                u = [6, c], i = 0
            } finally {
                r = s = 0
            }
            if (u[0] & 5) throw u[1];
            return {
                value: u[0] ? u[1] : void 0,
                done: !0
            }
        }
    },
    i0 = globalThis && globalThis.__spreadArray || function(t, e) {
        for (var n = 0, r = e.length, i = t.length; n < r; n++, i++) t[i] = e[n];
        return t
    },
    Wie = Object.defineProperty,
    Kie = Object.defineProperties,
    qie = Object.getOwnPropertyDescriptors,
    PN = Object.getOwnPropertySymbols,
    Xie = Object.prototype.hasOwnProperty,
    Jie = Object.prototype.propertyIsEnumerable,
    IN = function(t, e, n) {
        return e in t ? Wie(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
        }) : t[e] = n
    },
    Jc = function(t, e) {
        for (var n in e || (e = {})) Xie.call(e, n) && IN(t, n, e[n]);
        if (PN)
            for (var r = 0, i = PN(e); r < i.length; r++) {
                var n = i[r];
                Jie.call(e, n) && IN(t, n, e[n])
            }
        return t
    },
    MM = function(t, e) {
        return Kie(t, qie(e))
    },
    s1 = function(t, e, n) {
        return new Promise(function(r, i) {
            var s = function(l) {
                    try {
                        a(n.next(l))
                    } catch (u) {
                        i(u)
                    }
                },
                o = function(l) {
                    try {
                        a(n.throw(l))
                    } catch (u) {
                        i(u)
                    }
                },
                a = function(l) {
                    return l.done ? r(l.value) : Promise.resolve(l.value).then(s, o)
                };
            a((n = n.apply(t, e)).next())
        })
    },
    Yie = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
        if (arguments.length !== 0) return typeof arguments[0] == "object" ? Sw : Sw.apply(null, arguments)
    };

function Qie(t) {
    if (typeof t != "object" || t === null) return !1;
    var e = Object.getPrototypeOf(t);
    if (e === null) return !0;
    for (var n = e; Object.getPrototypeOf(n) !== null;) n = Object.getPrototypeOf(n);
    return e === n
}
var Zie = function(t) {
    jie(e, t);

    function e() {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        var i = t.apply(this, n) || this;
        return Object.setPrototypeOf(i, e.prototype), i
    }
    return Object.defineProperty(e, Symbol.species, {
        get: function() {
            return e
        },
        enumerable: !1,
        configurable: !0
    }), e.prototype.concat = function() {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        return t.prototype.concat.apply(this, n)
    }, e.prototype.prepend = function() {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r];
        return n.length === 1 && Array.isArray(n[0]) ? new(e.bind.apply(e, i0([void 0], n[0].concat(this)))) : new(e.bind.apply(e, i0([void 0], n.concat(this))))
    }, e
}(Array);

function kI(t) {
    return Ou(t) ? cV(t, function() {}) : t
}

function ese(t) {
    return typeof t == "boolean"
}

function tse() {
    return function(e) {
        return nse(e)
    }
}

function nse(t) {
    t === void 0 && (t = {});
    var e = t.thunk,
        n = e === void 0 ? !0 : e;
    t.immutableCheck, t.serializableCheck;
    var r = new Zie;
    return n && (ese(n) ? r.push(TN) : r.push(TN.withExtraArgument(n.extraArgument))), r
}
var rse = !0;

function eHe(t) {
    var e = tse(),
        n = t || {},
        r = n.reducer,
        i = r === void 0 ? void 0 : r,
        s = n.middleware,
        o = s === void 0 ? e() : s,
        a = n.devTools,
        l = a === void 0 ? !0 : a,
        u = n.preloadedState,
        c = u === void 0 ? void 0 : u,
        f = n.enhancers,
        d = f === void 0 ? void 0 : f,
        p;
    if (typeof i == "function") p = i;
    else if (Qie(i)) p = Bie(i);
    else throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
    var m = o;
    typeof m == "function" && (m = m(e));
    var y = Fie.apply(void 0, m),
        v = Sw;
    l && (v = Yie(Jc({
        trace: !rse
    }, typeof l == "object" && l)));
    var b = [y];
    Array.isArray(d) ? b = i0([y], d) : typeof d == "function" && (b = d(b));
    var _ = v.apply(void 0, b);
    return jD(p, c, _)
}

function Au(t, e) {
    function n() {
        for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
        if (e) {
            var s = e.apply(void 0, r);
            if (!s) throw new Error("prepareAction did not return an object");
            return Jc(Jc({
                type: t,
                payload: s.payload
            }, "meta" in s && {
                meta: s.meta
            }), "error" in s && {
                error: s.error
            })
        }
        return {
            type: t,
            payload: r[0]
        }
    }
    return n.toString = function() {
        return "" + t
    }, n.type = t, n.match = function(r) {
        return r.type === t
    }, n
}

function hV(t) {
    var e = {},
        n = [],
        r, i = {
            addCase: function(s, o) {
                var a = typeof s == "string" ? s : s.type;
                if (a in e) throw new Error("addCase cannot be called with two reducers for the same action type");
                return e[a] = o, i
            },
            addMatcher: function(s, o) {
                return n.push({
                    matcher: s,
                    reducer: o
                }), i
            },
            addDefaultCase: function(s) {
                return r = s, i
            }
        };
    return t(i), [e, n, r]
}

function ise(t) {
    return typeof t == "function"
}

function sse(t, e, n, r) {
    n === void 0 && (n = []);
    var i = typeof e == "function" ? hV(e) : [e, n, r],
        s = i[0],
        o = i[1],
        a = i[2],
        l;
    if (ise(t)) l = function() {
        return kI(t())
    };
    else {
        var u = kI(t);
        l = function() {
            return u
        }
    }

    function c(f, d) {
        f === void 0 && (f = l());
        var p = i0([s[d.type]], o.filter(function(m) {
            var y = m.matcher;
            return y(d)
        }).map(function(m) {
            var y = m.reducer;
            return y
        }));
        return p.filter(function(m) {
            return !!m
        }).length === 0 && (p = [a]), p.reduce(function(m, y) {
            if (y)
                if (af(m)) {
                    var v = m,
                        b = y(v, d);
                    return b === void 0 ? m : b
                } else {
                    if (Ou(m)) return cV(m, function(_) {
                        return y(_, d)
                    });
                    var b = y(m, d);
                    if (b === void 0) {
                        if (m === null) return m;
                        throw Error("A case reducer on a non-draftable value must not return undefined")
                    }
                    return b
                }
            return m
        }, f)
    }
    return c.getInitialState = l, c
}

function ose(t, e) {
    return t + "/" + e
}

function tHe(t) {
    var e = t.name;
    if (!e) throw new Error("`name` is a required option for createSlice");
    typeof process < "u";
    var n = typeof t.initialState == "function" ? t.initialState : kI(t.initialState),
        r = t.reducers || {},
        i = Object.keys(r),
        s = {},
        o = {},
        a = {};
    i.forEach(function(c) {
        var f = r[c],
            d = ose(e, c),
            p, m;
        "reducer" in f ? (p = f.reducer, m = f.prepare) : p = f, s[c] = p, o[d] = p, a[c] = m ? Au(d, m) : Au(d)
    });

    function l() {
        var c = typeof t.extraReducers == "function" ? hV(t.extraReducers) : [t.extraReducers],
            f = c[0],
            d = f === void 0 ? {} : f,
            p = c[1],
            m = p === void 0 ? [] : p,
            y = c[2],
            v = y === void 0 ? void 0 : y,
            b = Jc(Jc({}, d), o);
        return sse(n, function(_) {
            for (var x in b) _.addCase(x, b[x]);
            for (var S = 0, E = m; S < E.length; S++) {
                var A = E[S];
                _.addMatcher(A.matcher, A.reducer)
            }
            v && _.addDefaultCase(v)
        })
    }
    var u;
    return {
        name: e,
        reducer: function(c, f) {
            return u || (u = l()), u(c, f)
        },
        actions: a,
        caseReducers: s,
        getInitialState: function() {
            return u || (u = l()), u.getInitialState()
        }
    }
}
var ase = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
    mV = function(t) {
        t === void 0 && (t = 21);
        for (var e = "", n = t; n--;) e += ase[Math.random() * 64 | 0];
        return e
    },
    lse = ["name", "message", "stack", "code"],
    TM = function() {
        function t(e, n) {
            this.payload = e, this.meta = n
        }
        return t
    }(),
    RN = function() {
        function t(e, n) {
            this.payload = e, this.meta = n
        }
        return t
    }(),
    use = function(t) {
        if (typeof t == "object" && t !== null) {
            for (var e = {}, n = 0, r = lse; n < r.length; n++) {
                var i = r[n];
                typeof t[i] == "string" && (e[i] = t[i])
            }
            return e
        }
        return {
            message: String(t)
        }
    };
(function() {
    function t(e, n, r) {
        var i = Au(e + "/fulfilled", function(u, c, f, d) {
                return {
                    payload: u,
                    meta: MM(Jc({}, d || {}), {
                        arg: f,
                        requestId: c,
                        requestStatus: "fulfilled"
                    })
                }
            }),
            s = Au(e + "/pending", function(u, c, f) {
                return {
                    payload: void 0,
                    meta: MM(Jc({}, f || {}), {
                        arg: c,
                        requestId: u,
                        requestStatus: "pending"
                    })
                }
            }),
            o = Au(e + "/rejected", function(u, c, f, d, p) {
                return {
                    payload: d,
                    error: (r && r.serializeError || use)(u || "Rejected"),
                    meta: MM(Jc({}, p || {}), {
                        arg: f,
                        requestId: c,
                        rejectedWithValue: !!d,
                        requestStatus: "rejected",
                        aborted: (u == null ? void 0 : u.name) === "AbortError",
                        condition: (u == null ? void 0 : u.name) === "ConditionError"
                    })
                }
            }),
            a = typeof AbortController < "u" ? AbortController : function() {
                function u() {
                    this.signal = {
                        aborted: !1,
                        addEventListener: function() {},
                        dispatchEvent: function() {
                            return !1
                        },
                        onabort: function() {},
                        removeEventListener: function() {},
                        reason: void 0,
                        throwIfAborted: function() {}
                    }
                }
                return u.prototype.abort = function() {}, u
            }();

        function l(u) {
            return function(c, f, d) {
                var p = r != null && r.idGenerator ? r.idGenerator(u) : mV(),
                    m = new a,
                    y;

                function v(_) {
                    y = _, m.abort()
                }
                var b = function() {
                    return s1(this, null, function() {
                        var _, x, S, E, A, T, M;
                        return i1(this, function(I) {
                            switch (I.label) {
                                case 0:
                                    return I.trys.push([0, 4, , 5]), E = (_ = r == null ? void 0 : r.condition) == null ? void 0 : _.call(r, u, {
                                        getState: f,
                                        extra: d
                                    }), fse(E) ? [4, E] : [3, 2];
                                case 1:
                                    E = I.sent(), I.label = 2;
                                case 2:
                                    if (E === !1 || m.signal.aborted) throw {
                                        name: "ConditionError",
                                        message: "Aborted due to condition callback returning false."
                                    };
                                    return A = new Promise(function(O, k) {
                                        return m.signal.addEventListener("abort", function() {
                                            return k({
                                                name: "AbortError",
                                                message: y || "Aborted"
                                            })
                                        })
                                    }), c(s(p, u, (x = r == null ? void 0 : r.getPendingMeta) == null ? void 0 : x.call(r, {
                                        requestId: p,
                                        arg: u
                                    }, {
                                        getState: f,
                                        extra: d
                                    }))), [4, Promise.race([A, Promise.resolve(n(u, {
                                        dispatch: c,
                                        getState: f,
                                        extra: d,
                                        requestId: p,
                                        signal: m.signal,
                                        abort: v,
                                        rejectWithValue: function(O, k) {
                                            return new TM(O, k)
                                        },
                                        fulfillWithValue: function(O, k) {
                                            return new RN(O, k)
                                        }
                                    })).then(function(O) {
                                        if (O instanceof TM) throw O;
                                        return O instanceof RN ? i(O.payload, p, u, O.meta) : i(O, p, u)
                                    })])];
                                case 3:
                                    return S = I.sent(), [3, 5];
                                case 4:
                                    return T = I.sent(), S = T instanceof TM ? o(null, p, u, T.payload, T.meta) : o(T, p, u), [3, 5];
                                case 5:
                                    return M = r && !r.dispatchConditionRejection && o.match(S) && S.meta.condition, M || c(S), [2, S]
                            }
                        })
                    })
                }();
                return Object.assign(b, {
                    abort: v,
                    requestId: p,
                    arg: u,
                    unwrap: function() {
                        return b.then(cse)
                    }
                })
            }
        }
        return Object.assign(l, {
            pending: s,
            rejected: o,
            fulfilled: i,
            typePrefix: e
        })
    }
    return t.withTypes = function() {
        return t
    }, t
})();

function cse(t) {
    if (t.meta && t.meta.rejectedWithValue) throw t.payload;
    if (t.error) throw t.error;
    return t.payload
}

function fse(t) {
    return t !== null && typeof t == "object" && typeof t.then == "function"
}
var WD = function(t, e) {
        if (typeof t != "function") throw new TypeError(e + " is not a function")
    },
    BI = function() {},
    gV = function(t, e) {
        return e === void 0 && (e = BI), t.catch(e), t
    },
    yV = function(t, e) {
        return t.addEventListener("abort", e, {
                once: !0
            }),
            function() {
                return t.removeEventListener("abort", e)
            }
    },
    am = function(t, e) {
        var n = t.signal;
        n.aborted || ("reason" in n || Object.defineProperty(n, "reason", {
            enumerable: !0,
            value: e,
            configurable: !0,
            writable: !0
        }), t.abort(e))
    },
    dse = "task",
    vV = "listener",
    bV = "completed",
    KD = "cancelled",
    pse = "task-" + KD,
    hse = "task-" + bV,
    xV = vV + "-" + KD,
    mse = vV + "-" + bV,
    mE = function() {
        function t(e) {
            this.code = e, this.name = "TaskAbortError", this.message = dse + " " + KD + " (reason: " + e + ")"
        }
        return t
    }(),
    lm = function(t) {
        if (t.aborted) throw new mE(t.reason)
    };

function _V(t, e) {
    var n = BI;
    return new Promise(function(r, i) {
        var s = function() {
            return i(new mE(t.reason))
        };
        if (t.aborted) {
            s();
            return
        }
        n = yV(t, s), e.finally(function() {
            return n()
        }).then(r, i)
    }).finally(function() {
        n = BI
    })
}
var gse = function(t, e) {
        return s1(void 0, null, function() {
            var n, r;
            return i1(this, function(i) {
                switch (i.label) {
                    case 0:
                        return i.trys.push([0, 3, 4, 5]), [4, Promise.resolve()];
                    case 1:
                        return i.sent(), [4, t()];
                    case 2:
                        return n = i.sent(), [2, {
                            status: "ok",
                            value: n
                        }];
                    case 3:
                        return r = i.sent(), [2, {
                            status: r instanceof mE ? "cancelled" : "rejected",
                            error: r
                        }];
                    case 4:
                        return e == null || e(), [7];
                    case 5:
                        return [2]
                }
            })
        })
    },
    Ew = function(t) {
        return function(e) {
            return gV(_V(t, e).then(function(n) {
                return lm(t), n
            }))
        }
    },
    SV = function(t) {
        var e = Ew(t);
        return function(n) {
            return e(new Promise(function(r) {
                return setTimeout(r, n)
            }))
        }
    },
    yse = Object.assign,
    ON = {},
    o1 = "listenerMiddleware",
    vse = function(t) {
        var e = function(n) {
            return yV(t, function() {
                return am(n, t.reason)
            })
        };
        return function(n) {
            WD(n, "taskExecutor");
            var r = new AbortController;
            e(r);
            var i = gse(function() {
                return s1(void 0, null, function() {
                    var s;
                    return i1(this, function(o) {
                        switch (o.label) {
                            case 0:
                                return lm(t), lm(r.signal), [4, n({
                                    pause: Ew(r.signal),
                                    delay: SV(r.signal),
                                    signal: r.signal
                                })];
                            case 1:
                                return s = o.sent(), lm(r.signal), [2, s]
                        }
                    })
                })
            }, function() {
                return am(r, hse)
            });
            return {
                result: Ew(t)(i),
                cancel: function() {
                    am(r, pse)
                }
            }
        }
    },
    bse = function(t, e) {
        var n = function(r, i) {
            return s1(void 0, null, function() {
                var s, o, a, l;
                return i1(this, function(u) {
                    switch (u.label) {
                        case 0:
                            lm(e), s = function() {}, o = new Promise(function(c, f) {
                                var d = t({
                                    predicate: r,
                                    effect: function(p, m) {
                                        m.unsubscribe(), c([p, m.getState(), m.getOriginalState()])
                                    }
                                });
                                s = function() {
                                    d(), f()
                                }
                            }), a = [o], i != null && a.push(new Promise(function(c) {
                                return setTimeout(c, i, null)
                            })), u.label = 1;
                        case 1:
                            return u.trys.push([1, , 3, 4]), [4, _V(e, Promise.race(a))];
                        case 2:
                            return l = u.sent(), lm(e), [2, l];
                        case 3:
                            return s(), [7];
                        case 4:
                            return [2]
                    }
                })
            })
        };
        return function(r, i) {
            return gV(n(r, i))
        }
    },
    wV = function(t) {
        var e = t.type,
            n = t.actionCreator,
            r = t.matcher,
            i = t.predicate,
            s = t.effect;
        if (e) i = Au(e).match;
        else if (n) e = n.type, i = n.match;
        else if (r) i = r;
        else if (!i) throw new Error("Creating or removing a listener requires one of the known fields for matching an action");
        return WD(s, "options.listener"), {
            predicate: i,
            type: e,
            effect: s
        }
    },
    xse = function(t) {
        var e = wV(t),
            n = e.type,
            r = e.predicate,
            i = e.effect,
            s = mV(),
            o = {
                id: s,
                effect: i,
                type: n,
                predicate: r,
                pending: new Set,
                unsubscribe: function() {
                    throw new Error("Unsubscribe not initialized")
                }
            };
        return o
    },
    FI = function(t) {
        t.pending.forEach(function(e) {
            am(e, xV)
        })
    },
    _se = function(t) {
        return function() {
            t.forEach(FI), t.clear()
        }
    },
    DN = function(t, e, n) {
        try {
            t(e, n)
        } catch (r) {
            setTimeout(function() {
                throw r
            }, 0)
        }
    },
    Sse = Au(o1 + "/add"),
    wse = Au(o1 + "/removeAll"),
    Ese = Au(o1 + "/remove"),
    Ase = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        console.error.apply(console, i0([o1 + "/error"], t))
    };

function nHe(t) {
    var e = this;
    t === void 0 && (t = {});
    var n = new Map,
        r = t.extra,
        i = t.onError,
        s = i === void 0 ? Ase : i;
    WD(s, "onError");
    var o = function(p) {
            return p.unsubscribe = function() {
                    return n.delete(p.id)
                }, n.set(p.id, p),
                function(m) {
                    p.unsubscribe(), m != null && m.cancelActive && FI(p)
                }
        },
        a = function(p) {
            for (var m = 0, y = Array.from(n.values()); m < y.length; m++) {
                var v = y[m];
                if (p(v)) return v
            }
        },
        l = function(p) {
            var m = a(function(y) {
                return y.effect === p.effect
            });
            return m || (m = xse(p)), o(m)
        },
        u = function(p) {
            var m = wV(p),
                y = m.type,
                v = m.effect,
                b = m.predicate,
                _ = a(function(x) {
                    var S = typeof y == "string" ? x.type === y : x.predicate === b;
                    return S && x.effect === v
                });
            return _ && (_.unsubscribe(), p.cancelActive && FI(_)), !!_
        },
        c = function(p, m, y, v) {
            return s1(e, null, function() {
                var b, _, x;
                return i1(this, function(S) {
                    switch (S.label) {
                        case 0:
                            b = new AbortController, _ = bse(l, b.signal), S.label = 1;
                        case 1:
                            return S.trys.push([1, 3, 4, 5]), p.pending.add(b), [4, Promise.resolve(p.effect(m, yse({}, y, {
                                getOriginalState: v,
                                condition: function(E, A) {
                                    return _(E, A).then(Boolean)
                                },
                                take: _,
                                delay: SV(b.signal),
                                pause: Ew(b.signal),
                                extra: r,
                                signal: b.signal,
                                fork: vse(b.signal),
                                unsubscribe: p.unsubscribe,
                                subscribe: function() {
                                    n.set(p.id, p)
                                },
                                cancelActiveListeners: function() {
                                    p.pending.forEach(function(E, A, T) {
                                        E !== b && (am(E, xV), T.delete(E))
                                    })
                                }
                            })))];
                        case 2:
                            return S.sent(), [3, 5];
                        case 3:
                            return x = S.sent(), x instanceof mE || DN(s, x, {
                                raisedBy: "effect"
                            }), [3, 5];
                        case 4:
                            return am(b, mse), p.pending.delete(b), [7];
                        case 5:
                            return [2]
                    }
                })
            })
        },
        f = _se(n),
        d = function(p) {
            return function(m) {
                return function(y) {
                    if (Sse.match(y)) return l(y.payload);
                    if (wse.match(y)) {
                        f();
                        return
                    }
                    if (Ese.match(y)) return u(y.payload);
                    var v = p.getState(),
                        b = function() {
                            if (v === ON) throw new Error(o1 + ": getOriginalState can only be called synchronously");
                            return v
                        },
                        _;
                    try {
                        if (_ = m(y), n.size > 0)
                            for (var x = p.getState(), S = Array.from(n.values()), E = 0, A = S; E < A.length; E++) {
                                var T = A[E],
                                    M = !1;
                                try {
                                    M = T.predicate(y, x, v)
                                } catch (I) {
                                    M = !1, DN(s, I, {
                                        raisedBy: "predicate"
                                    })
                                }
                                M && c(T, y, p, b)
                            }
                    } finally {
                        v = ON
                    }
                    return _
                }
            }
        };
    return {
        middleware: d,
        startListening: l,
        stopListening: u,
        clearListeners: f
    }
}
var LN;
typeof queueMicrotask == "function" && queueMicrotask.bind(typeof window < "u" ? window : typeof global < "u" ? global : globalThis);
Tie();
var Cse = {},
    EV = {},
    NI = {
        exports: {}
    }; /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(t, e) {
    (function(n, r) {
        r(e)
    })(_n, function(n) {
        function r() {
            for (var D = arguments.length, z = Array(D), j = 0; j < D; j++) z[j] = arguments[j];
            if (z.length > 1) {
                z[0] = z[0].slice(0, -1);
                for (var X = z.length - 1, te = 1; te < X; ++te) z[te] = z[te].slice(1, -1);
                return z[X] = z[X].slice(1), z.join("")
            } else return z[0]
        }

        function i(D) {
            return "(?:" + D + ")"
        }

        function s(D) {
            return D === void 0 ? "undefined" : D === null ? "null" : Object.prototype.toString.call(D).split(" ").pop().split("]").shift().toLowerCase()
        }

        function o(D) {
            return D.toUpperCase()
        }

        function a(D) {
            return D != null ? D instanceof Array ? D : typeof D.length != "number" || D.split || D.setInterval || D.call ? [D] : Array.prototype.slice.call(D) : []
        }

        function l(D, z) {
            var j = D;
            if (z)
                for (var X in z) j[X] = z[X];
            return j
        }

        function u(D) {
            var z = "[A-Za-z]",
                j = "[0-9]",
                X = r(j, "[A-Fa-f]"),
                te = i(i("%[EFef]" + X + "%" + X + X + "%" + X + X) + "|" + i("%[89A-Fa-f]" + X + "%" + X + X) + "|" + i("%" + X + X)),
                Oe = "[\\:\\/\\?\\#\\[\\]\\@]",
                $e = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
                rt = r(Oe, $e),
                Ze = D ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
                Tt = D ? "[\\uE000-\\uF8FF]" : "[]",
                st = r(z, j, "[\\-\\.\\_\\~]", Ze);
            i(z + r(z, j, "[\\+\\-\\.]") + "*"), i(i(te + "|" + r(st, $e, "[\\:]")) + "*");
            var St = i(i("25[0-5]") + "|" + i("2[0-4]" + j) + "|" + i("1" + j + j) + "|" + i("0?[1-9]" + j) + "|0?0?" + j),
                Qe = i(St + "\\." + St + "\\." + St + "\\." + St),
                ft = i(X + "{1,4}"),
                Vt = i(i(ft + "\\:" + ft) + "|" + Qe),
                bn = i(i(ft + "\\:") + "{6}" + Vt),
                Ht = i("\\:\\:" + i(ft + "\\:") + "{5}" + Vt),
                kt = i(i(ft) + "?\\:\\:" + i(ft + "\\:") + "{4}" + Vt),
                nr = i(i(i(ft + "\\:") + "{0,1}" + ft) + "?\\:\\:" + i(ft + "\\:") + "{3}" + Vt),
                vn = i(i(i(ft + "\\:") + "{0,2}" + ft) + "?\\:\\:" + i(ft + "\\:") + "{2}" + Vt),
                qn = i(i(i(ft + "\\:") + "{0,3}" + ft) + "?\\:\\:" + ft + "\\:" + Vt),
                Ii = i(i(i(ft + "\\:") + "{0,4}" + ft) + "?\\:\\:" + Vt),
                rr = i(i(i(ft + "\\:") + "{0,5}" + ft) + "?\\:\\:" + ft),
                Pn = i(i(i(ft + "\\:") + "{0,6}" + ft) + "?\\:\\:"),
                xn = i([bn, Ht, kt, nr, vn, qn, Ii, rr, Pn].join("|")),
                $t = i(i(st + "|" + te) + "+");
            i("[vV]" + X + "+\\." + r(st, $e, "[\\:]") + "+"), i(i(te + "|" + r(st, $e)) + "*");
            var cn = i(te + "|" + r(st, $e, "[\\:\\@]"));
            return i(i(te + "|" + r(st, $e, "[\\@]")) + "+"), i(i(cn + "|" + r("[\\/\\?]", Tt)) + "*"), {
                NOT_SCHEME: new RegExp(r("[^]", z, j, "[\\+\\-\\.]"), "g"),
                NOT_USERINFO: new RegExp(r("[^\\%\\:]", st, $e), "g"),
                NOT_HOST: new RegExp(r("[^\\%\\[\\]\\:]", st, $e), "g"),
                NOT_PATH: new RegExp(r("[^\\%\\/\\:\\@]", st, $e), "g"),
                NOT_PATH_NOSCHEME: new RegExp(r("[^\\%\\/\\@]", st, $e), "g"),
                NOT_QUERY: new RegExp(r("[^\\%]", st, $e, "[\\:\\@\\/\\?]", Tt), "g"),
                NOT_FRAGMENT: new RegExp(r("[^\\%]", st, $e, "[\\:\\@\\/\\?]"), "g"),
                ESCAPE: new RegExp(r("[^]", st, $e), "g"),
                UNRESERVED: new RegExp(st, "g"),
                OTHER_CHARS: new RegExp(r("[^\\%]", st, rt), "g"),
                PCT_ENCODED: new RegExp(te, "g"),
                IPV4ADDRESS: new RegExp("^(" + Qe + ")$"),
                IPV6ADDRESS: new RegExp("^\\[?(" + xn + ")" + i(i("\\%25|\\%(?!" + X + "{2})") + "(" + $t + ")") + "?\\]?$")
            }
        }
        var c = u(!1),
            f = u(!0),
            d = function() {
                function D(z, j) {
                    var X = [],
                        te = !0,
                        Oe = !1,
                        $e = void 0;
                    try {
                        for (var rt = z[Symbol.iterator](), Ze; !(te = (Ze = rt.next()).done) && (X.push(Ze.value), !(j && X.length === j)); te = !0);
                    } catch (Tt) {
                        Oe = !0, $e = Tt
                    } finally {
                        try {
                            !te && rt.return && rt.return()
                        } finally {
                            if (Oe) throw $e
                        }
                    }
                    return X
                }
                return function(z, j) {
                    if (Array.isArray(z)) return z;
                    if (Symbol.iterator in Object(z)) return D(z, j);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                }
            }(),
            p = function(D) {
                if (Array.isArray(D)) {
                    for (var z = 0, j = Array(D.length); z < D.length; z++) j[z] = D[z];
                    return j
                } else return Array.from(D)
            },
            m = 2147483647,
            y = 36,
            v = 1,
            b = 26,
            _ = 38,
            x = 700,
            S = 72,
            E = 128,
            A = "-",
            T = /^xn--/,
            M = /[^\0-\x7E]/,
            I = /[\x2E\u3002\uFF0E\uFF61]/g,
            O = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            },
            k = y - v,
            H = Math.floor,
            N = String.fromCharCode;

        function B(D) {
            throw new RangeError(O[D])
        }

        function U(D, z) {
            for (var j = [], X = D.length; X--;) j[X] = z(D[X]);
            return j
        }

        function q(D, z) {
            var j = D.split("@"),
                X = "";
            j.length > 1 && (X = j[0] + "@", D = j[1]), D = D.replace(I, ".");
            var te = D.split("."),
                Oe = U(te, z).join(".");
            return X + Oe
        }

        function Q(D) {
            for (var z = [], j = 0, X = D.length; j < X;) {
                var te = D.charCodeAt(j++);
                if (te >= 55296 && te <= 56319 && j < X) {
                    var Oe = D.charCodeAt(j++);
                    (Oe & 64512) == 56320 ? z.push(((te & 1023) << 10) + (Oe & 1023) + 65536) : (z.push(te), j--)
                } else z.push(te)
            }
            return z
        }
        var F = function(z) {
                return String.fromCodePoint.apply(String, p(z))
            },
            G = function(z) {
                return z - 48 < 10 ? z - 22 : z - 65 < 26 ? z - 65 : z - 97 < 26 ? z - 97 : y
            },
            W = function(z, j) {
                return z + 22 + 75 * (z < 26) - ((j != 0) << 5)
            },
            se = function(z, j, X) {
                var te = 0;
                for (z = X ? H(z / x) : z >> 1, z += H(z / j); z > k * b >> 1; te += y) z = H(z / k);
                return H(te + (k + 1) * z / (z + _))
            },
            ee = function(z) {
                var j = [],
                    X = z.length,
                    te = 0,
                    Oe = E,
                    $e = S,
                    rt = z.lastIndexOf(A);
                rt < 0 && (rt = 0);
                for (var Ze = 0; Ze < rt; ++Ze) z.charCodeAt(Ze) >= 128 && B("not-basic"), j.push(z.charCodeAt(Ze));
                for (var Tt = rt > 0 ? rt + 1 : 0; Tt < X;) {
                    for (var st = te, St = 1, Qe = y;; Qe += y) {
                        Tt >= X && B("invalid-input");
                        var ft = G(z.charCodeAt(Tt++));
                        (ft >= y || ft > H((m - te) / St)) && B("overflow"), te += ft * St;
                        var Vt = Qe <= $e ? v : Qe >= $e + b ? b : Qe - $e;
                        if (ft < Vt) break;
                        var bn = y - Vt;
                        St > H(m / bn) && B("overflow"), St *= bn
                    }
                    var Ht = j.length + 1;
                    $e = se(te - st, Ht, st == 0), H(te / Ht) > m - Oe && B("overflow"), Oe += H(te / Ht), te %= Ht, j.splice(te++, 0, Oe)
                }
                return String.fromCodePoint.apply(String, j)
            },
            ae = function(z) {
                var j = [];
                z = Q(z);
                var X = z.length,
                    te = E,
                    Oe = 0,
                    $e = S,
                    rt = !0,
                    Ze = !1,
                    Tt = void 0;
                try {
                    for (var st = z[Symbol.iterator](), St; !(rt = (St = st.next()).done); rt = !0) {
                        var Qe = St.value;
                        Qe < 128 && j.push(N(Qe))
                    }
                } catch (xo) {
                    Ze = !0, Tt = xo
                } finally {
                    try {
                        !rt && st.return && st.return()
                    } finally {
                        if (Ze) throw Tt
                    }
                }
                var ft = j.length,
                    Vt = ft;
                for (ft && j.push(A); Vt < X;) {
                    var bn = m,
                        Ht = !0,
                        kt = !1,
                        nr = void 0;
                    try {
                        for (var vn = z[Symbol.iterator](), qn; !(Ht = (qn = vn.next()).done); Ht = !0) {
                            var Ii = qn.value;
                            Ii >= te && Ii < bn && (bn = Ii)
                        }
                    } catch (xo) {
                        kt = !0, nr = xo
                    } finally {
                        try {
                            !Ht && vn.return && vn.return()
                        } finally {
                            if (kt) throw nr
                        }
                    }
                    var rr = Vt + 1;
                    bn - te > H((m - Oe) / rr) && B("overflow"), Oe += (bn - te) * rr, te = bn;
                    var Pn = !0,
                        xn = !1,
                        $t = void 0;
                    try {
                        for (var cn = z[Symbol.iterator](), zn; !(Pn = (zn = cn.next()).done); Pn = !0) {
                            var Qn = zn.value;
                            if (Qn < te && ++Oe > m && B("overflow"), Qn == te) {
                                for (var ar = Oe, Ir = y;; Ir += y) {
                                    var fs = Ir <= $e ? v : Ir >= $e + b ? b : Ir - $e;
                                    if (ar < fs) break;
                                    var Ur = ar - fs,
                                        fa = y - fs;
                                    j.push(N(W(fs + Ur % fa, 0))), ar = H(Ur / fa)
                                }
                                j.push(N(W(ar, 0))), $e = se(Oe, rr, Vt == ft), Oe = 0, ++Vt
                            }
                        }
                    } catch (xo) {
                        xn = !0, $t = xo
                    } finally {
                        try {
                            !Pn && cn.return && cn.return()
                        } finally {
                            if (xn) throw $t
                        }
                    }++Oe, ++te
                }
                return j.join("")
            },
            de = function(z) {
                return q(z, function(j) {
                    return T.test(j) ? ee(j.slice(4).toLowerCase()) : j
                })
            },
            re = function(z) {
                return q(z, function(j) {
                    return M.test(j) ? "xn--" + ae(j) : j
                })
            },
            _e = {
                version: "2.1.0",
                ucs2: {
                    decode: Q,
                    encode: F
                },
                decode: ee,
                encode: ae,
                toASCII: re,
                toUnicode: de
            },
            fe = {};

        function ue(D) {
            var z = D.charCodeAt(0),
                j = void 0;
            return z < 16 ? j = "%0" + z.toString(16).toUpperCase() : z < 128 ? j = "%" + z.toString(16).toUpperCase() : z < 2048 ? j = "%" + (z >> 6 | 192).toString(16).toUpperCase() + "%" + (z & 63 | 128).toString(16).toUpperCase() : j = "%" + (z >> 12 | 224).toString(16).toUpperCase() + "%" + (z >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (z & 63 | 128).toString(16).toUpperCase(), j
        }

        function ve(D) {
            for (var z = "", j = 0, X = D.length; j < X;) {
                var te = parseInt(D.substr(j + 1, 2), 16);
                if (te < 128) z += String.fromCharCode(te), j += 3;
                else if (te >= 194 && te < 224) {
                    if (X - j >= 6) {
                        var Oe = parseInt(D.substr(j + 4, 2), 16);
                        z += String.fromCharCode((te & 31) << 6 | Oe & 63)
                    } else z += D.substr(j, 6);
                    j += 6
                } else if (te >= 224) {
                    if (X - j >= 9) {
                        var $e = parseInt(D.substr(j + 4, 2), 16),
                            rt = parseInt(D.substr(j + 7, 2), 16);
                        z += String.fromCharCode((te & 15) << 12 | ($e & 63) << 6 | rt & 63)
                    } else z += D.substr(j, 9);
                    j += 9
                } else z += D.substr(j, 3), j += 3
            }
            return z
        }

        function xe(D, z) {
            function j(X) {
                var te = ve(X);
                return te.match(z.UNRESERVED) ? te : X
            }
            return D.scheme && (D.scheme = String(D.scheme).replace(z.PCT_ENCODED, j).toLowerCase().replace(z.NOT_SCHEME, "")), D.userinfo !== void 0 && (D.userinfo = String(D.userinfo).replace(z.PCT_ENCODED, j).replace(z.NOT_USERINFO, ue).replace(z.PCT_ENCODED, o)), D.host !== void 0 && (D.host = String(D.host).replace(z.PCT_ENCODED, j).toLowerCase().replace(z.NOT_HOST, ue).replace(z.PCT_ENCODED, o)), D.path !== void 0 && (D.path = String(D.path).replace(z.PCT_ENCODED, j).replace(D.scheme ? z.NOT_PATH : z.NOT_PATH_NOSCHEME, ue).replace(z.PCT_ENCODED, o)), D.query !== void 0 && (D.query = String(D.query).replace(z.PCT_ENCODED, j).replace(z.NOT_QUERY, ue).replace(z.PCT_ENCODED, o)), D.fragment !== void 0 && (D.fragment = String(D.fragment).replace(z.PCT_ENCODED, j).replace(z.NOT_FRAGMENT, ue).replace(z.PCT_ENCODED, o)), D
        }

        function be(D) {
            return D.replace(/^0*(.*)/, "$1") || "0"
        }

        function he(D, z) {
            var j = D.match(z.IPV4ADDRESS) || [],
                X = d(j, 2),
                te = X[1];
            return te ? te.split(".").map(be).join(".") : D
        }

        function me(D, z) {
            var j = D.match(z.IPV6ADDRESS) || [],
                X = d(j, 3),
                te = X[1],
                Oe = X[2];
            if (te) {
                for (var $e = te.toLowerCase().split("::").reverse(), rt = d($e, 2), Ze = rt[0], Tt = rt[1], st = Tt ? Tt.split(":").map(be) : [], St = Ze.split(":").map(be), Qe = z.IPV4ADDRESS.test(St[St.length - 1]), ft = Qe ? 7 : 8, Vt = St.length - ft, bn = Array(ft), Ht = 0; Ht < ft; ++Ht) bn[Ht] = st[Ht] || St[Vt + Ht] || "";
                Qe && (bn[ft - 1] = he(bn[ft - 1], z));
                var kt = bn.reduce(function(rr, Pn, xn) {
                        if (!Pn || Pn === "0") {
                            var $t = rr[rr.length - 1];
                            $t && $t.index + $t.length === xn ? $t.length++ : rr.push({
                                index: xn,
                                length: 1
                            })
                        }
                        return rr
                    }, []),
                    nr = kt.sort(function(rr, Pn) {
                        return Pn.length - rr.length
                    })[0],
                    vn = void 0;
                if (nr && nr.length > 1) {
                    var qn = bn.slice(0, nr.index),
                        Ii = bn.slice(nr.index + nr.length);
                    vn = qn.join(":") + "::" + Ii.join(":")
                } else vn = bn.join(":");
                return Oe && (vn += "%" + Oe), vn
            } else return D
        }
        var Ce = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
            Ne = "".match(/(){0}/)[1] === void 0;

        function De(D) {
            var z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                j = {},
                X = z.iri !== !1 ? f : c;
            z.reference === "suffix" && (D = (z.scheme ? z.scheme + ":" : "") + "//" + D);
            var te = D.match(Ce);
            if (te) {
                Ne ? (j.scheme = te[1], j.userinfo = te[3], j.host = te[4], j.port = parseInt(te[5], 10), j.path = te[6] || "", j.query = te[7], j.fragment = te[8], isNaN(j.port) && (j.port = te[5])) : (j.scheme = te[1] || void 0, j.userinfo = D.indexOf("@") !== -1 ? te[3] : void 0, j.host = D.indexOf("//") !== -1 ? te[4] : void 0, j.port = parseInt(te[5], 10), j.path = te[6] || "", j.query = D.indexOf("?") !== -1 ? te[7] : void 0, j.fragment = D.indexOf("#") !== -1 ? te[8] : void 0, isNaN(j.port) && (j.port = D.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? te[4] : void 0)), j.host && (j.host = me(he(j.host, X), X)), j.scheme === void 0 && j.userinfo === void 0 && j.host === void 0 && j.port === void 0 && !j.path && j.query === void 0 ? j.reference = "same-document" : j.scheme === void 0 ? j.reference = "relative" : j.fragment === void 0 ? j.reference = "absolute" : j.reference = "uri", z.reference && z.reference !== "suffix" && z.reference !== j.reference && (j.error = j.error || "URI is not a " + z.reference + " reference.");
                var Oe = fe[(z.scheme || j.scheme || "").toLowerCase()];
                if (!z.unicodeSupport && (!Oe || !Oe.unicodeSupport)) {
                    if (j.host && (z.domainHost || Oe && Oe.domainHost)) try {
                        j.host = _e.toASCII(j.host.replace(X.PCT_ENCODED, ve).toLowerCase())
                    } catch ($e) {
                        j.error = j.error || "Host's domain name can not be converted to ASCII via punycode: " + $e
                    }
                    xe(j, c)
                } else xe(j, X);
                Oe && Oe.parse && Oe.parse(j, z)
            } else j.error = j.error || "URI can not be parsed.";
            return j
        }

        function je(D, z) {
            var j = z.iri !== !1 ? f : c,
                X = [];
            return D.userinfo !== void 0 && (X.push(D.userinfo), X.push("@")), D.host !== void 0 && X.push(me(he(String(D.host), j), j).replace(j.IPV6ADDRESS, function(te, Oe, $e) {
                return "[" + Oe + ($e ? "%25" + $e : "") + "]"
            })), (typeof D.port == "number" || typeof D.port == "string") && (X.push(":"), X.push(String(D.port))), X.length ? X.join("") : void 0
        }
        var Ke = /^\.\.?\//,
            He = /^\/\.(\/|$)/,
            qe = /^\/\.\.(\/|$)/,
            Xe = /^\/?(?:.|\n)*?(?=\/|$)/;

        function K(D) {
            for (var z = []; D.length;)
                if (D.match(Ke)) D = D.replace(Ke, "");
                else if (D.match(He)) D = D.replace(He, "/");
            else if (D.match(qe)) D = D.replace(qe, "/"), z.pop();
            else if (D === "." || D === "..") D = "";
            else {
                var j = D.match(Xe);
                if (j) {
                    var X = j[0];
                    D = D.slice(X.length), z.push(X)
                } else throw new Error("Unexpected dot segment condition")
            }
            return z.join("")
        }

        function V(D) {
            var z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                j = z.iri ? f : c,
                X = [],
                te = fe[(z.scheme || D.scheme || "").toLowerCase()];
            if (te && te.serialize && te.serialize(D, z), D.host && !j.IPV6ADDRESS.test(D.host)) {
                if (z.domainHost || te && te.domainHost) try {
                    D.host = z.iri ? _e.toUnicode(D.host) : _e.toASCII(D.host.replace(j.PCT_ENCODED, ve).toLowerCase())
                } catch (rt) {
                    D.error = D.error || "Host's domain name can not be converted to " + (z.iri ? "Unicode" : "ASCII") + " via punycode: " + rt
                }
            }
            xe(D, j), z.reference !== "suffix" && D.scheme && (X.push(D.scheme), X.push(":"));
            var Oe = je(D, z);
            if (Oe !== void 0 && (z.reference !== "suffix" && X.push("//"), X.push(Oe), D.path && D.path.charAt(0) !== "/" && X.push("/")), D.path !== void 0) {
                var $e = D.path;
                !z.absolutePath && (!te || !te.absolutePath) && ($e = K($e)), Oe === void 0 && ($e = $e.replace(/^\/\//, "/%2F")), X.push($e)
            }
            return D.query !== void 0 && (X.push("?"), X.push(D.query)), D.fragment !== void 0 && (X.push("#"), X.push(D.fragment)), X.join("")
        }

        function ge(D, z) {
            var j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                X = arguments[3],
                te = {};
            return X || (D = De(V(D, j), j), z = De(V(z, j), j)), j = j || {}, !j.tolerant && z.scheme ? (te.scheme = z.scheme, te.userinfo = z.userinfo, te.host = z.host, te.port = z.port, te.path = K(z.path || ""), te.query = z.query) : (z.userinfo !== void 0 || z.host !== void 0 || z.port !== void 0 ? (te.userinfo = z.userinfo, te.host = z.host, te.port = z.port, te.path = K(z.path || ""), te.query = z.query) : (z.path ? (z.path.charAt(0) === "/" ? te.path = K(z.path) : ((D.userinfo !== void 0 || D.host !== void 0 || D.port !== void 0) && !D.path ? te.path = "/" + z.path : D.path ? te.path = D.path.slice(0, D.path.lastIndexOf("/") + 1) + z.path : te.path = z.path, te.path = K(te.path)), te.query = z.query) : (te.path = D.path, z.query !== void 0 ? te.query = z.query : te.query = D.query), te.userinfo = D.userinfo, te.host = D.host, te.port = D.port), te.scheme = D.scheme), te.fragment = z.fragment, te
        }

        function Be(D, z, j) {
            var X = l({
                scheme: "null"
            }, j);
            return V(ge(De(D, X), De(z, X), X, !0), X)
        }

        function ze(D, z) {
            return typeof D == "string" ? D = V(De(D, z), z) : s(D) === "object" && (D = De(V(D, z), z)), D
        }

        function Ue(D, z, j) {
            return typeof D == "string" ? D = V(De(D, j), j) : s(D) === "object" && (D = V(D, j)), typeof z == "string" ? z = V(De(z, j), j) : s(z) === "object" && (z = V(z, j)), D === z
        }

        function Ye(D, z) {
            return D && D.toString().replace(!z || !z.iri ? c.ESCAPE : f.ESCAPE, ue)
        }

        function Te(D, z) {
            return D && D.toString().replace(!z || !z.iri ? c.PCT_ENCODED : f.PCT_ENCODED, ve)
        }
        var we = {
                scheme: "http",
                domainHost: !0,
                parse: function(z, j) {
                    return z.host || (z.error = z.error || "HTTP URIs must have a host."), z
                },
                serialize: function(z, j) {
                    var X = String(z.scheme).toLowerCase() === "https";
                    return (z.port === (X ? 443 : 80) || z.port === "") && (z.port = void 0), z.path || (z.path = "/"), z
                }
            },
            lt = {
                scheme: "https",
                domainHost: we.domainHost,
                parse: we.parse,
                serialize: we.serialize
            };

        function nt(D) {
            return typeof D.secure == "boolean" ? D.secure : String(D.scheme).toLowerCase() === "wss"
        }
        var vt = {
                scheme: "ws",
                domainHost: !0,
                parse: function(z, j) {
                    var X = z;
                    return X.secure = nt(X), X.resourceName = (X.path || "/") + (X.query ? "?" + X.query : ""), X.path = void 0, X.query = void 0, X
                },
                serialize: function(z, j) {
                    if ((z.port === (nt(z) ? 443 : 80) || z.port === "") && (z.port = void 0), typeof z.secure == "boolean" && (z.scheme = z.secure ? "wss" : "ws", z.secure = void 0), z.resourceName) {
                        var X = z.resourceName.split("?"),
                            te = d(X, 2),
                            Oe = te[0],
                            $e = te[1];
                        z.path = Oe && Oe !== "/" ? Oe : void 0, z.query = $e, z.resourceName = void 0
                    }
                    return z.fragment = void 0, z
                }
            },
            ht = {
                scheme: "wss",
                domainHost: vt.domainHost,
                parse: vt.parse,
                serialize: vt.serialize
            },
            pt = {},
            le = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
            Ie = "[0-9A-Fa-f]",
            tt = i(i("%[EFef]" + Ie + "%" + Ie + Ie + "%" + Ie + Ie) + "|" + i("%[89A-Fa-f]" + Ie + "%" + Ie + Ie) + "|" + i("%" + Ie + Ie)),
            oe = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
            Ee = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
            Fe = r(Ee, '[\\"\\\\]'),
            Ve = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",
            ct = new RegExp(le, "g"),
            bt = new RegExp(tt, "g"),
            Kt = new RegExp(r("[^]", oe, "[\\.]", '[\\"]', Fe), "g"),
            un = new RegExp(r("[^]", le, Ve), "g"),
            zt = un;

        function Ot(D) {
            var z = ve(D);
            return z.match(ct) ? z : D
        }
        var tn = {
                scheme: "mailto",
                parse: function(z, j) {
                    var X = z,
                        te = X.to = X.path ? X.path.split(",") : [];
                    if (X.path = void 0, X.query) {
                        for (var Oe = !1, $e = {}, rt = X.query.split("&"), Ze = 0, Tt = rt.length; Ze < Tt; ++Ze) {
                            var st = rt[Ze].split("=");
                            switch (st[0]) {
                                case "to":
                                    for (var St = st[1].split(","), Qe = 0, ft = St.length; Qe < ft; ++Qe) te.push(St[Qe]);
                                    break;
                                case "subject":
                                    X.subject = Te(st[1], j);
                                    break;
                                case "body":
                                    X.body = Te(st[1], j);
                                    break;
                                default:
                                    Oe = !0, $e[Te(st[0], j)] = Te(st[1], j);
                                    break
                            }
                        }
                        Oe && (X.headers = $e)
                    }
                    X.query = void 0;
                    for (var Vt = 0, bn = te.length; Vt < bn; ++Vt) {
                        var Ht = te[Vt].split("@");
                        if (Ht[0] = Te(Ht[0]), j.unicodeSupport) Ht[1] = Te(Ht[1], j).toLowerCase();
                        else try {
                            Ht[1] = _e.toASCII(Te(Ht[1], j).toLowerCase())
                        } catch (kt) {
                            X.error = X.error || "Email address's domain name can not be converted to ASCII via punycode: " + kt
                        }
                        te[Vt] = Ht.join("@")
                    }
                    return X
                },
                serialize: function(z, j) {
                    var X = z,
                        te = a(z.to);
                    if (te) {
                        for (var Oe = 0, $e = te.length; Oe < $e; ++Oe) {
                            var rt = String(te[Oe]),
                                Ze = rt.lastIndexOf("@"),
                                Tt = rt.slice(0, Ze).replace(bt, Ot).replace(bt, o).replace(Kt, ue),
                                st = rt.slice(Ze + 1);
                            try {
                                st = j.iri ? _e.toUnicode(st) : _e.toASCII(Te(st, j).toLowerCase())
                            } catch (Vt) {
                                X.error = X.error || "Email address's domain name can not be converted to " + (j.iri ? "Unicode" : "ASCII") + " via punycode: " + Vt
                            }
                            te[Oe] = Tt + "@" + st
                        }
                        X.path = te.join(",")
                    }
                    var St = z.headers = z.headers || {};
                    z.subject && (St.subject = z.subject), z.body && (St.body = z.body);
                    var Qe = [];
                    for (var ft in St) St[ft] !== pt[ft] && Qe.push(ft.replace(bt, Ot).replace(bt, o).replace(un, ue) + "=" + St[ft].replace(bt, Ot).replace(bt, o).replace(zt, ue));
                    return Qe.length && (X.query = Qe.join("&")), X
                }
            },
            Xt = /^([^\:]+)\:(.*)/,
            Hr = {
                scheme: "urn",
                parse: function(z, j) {
                    var X = z.path && z.path.match(Xt),
                        te = z;
                    if (X) {
                        var Oe = j.scheme || te.scheme || "urn",
                            $e = X[1].toLowerCase(),
                            rt = X[2],
                            Ze = Oe + ":" + (j.nid || $e),
                            Tt = fe[Ze];
                        te.nid = $e, te.nss = rt, te.path = void 0, Tt && (te = Tt.parse(te, j))
                    } else te.error = te.error || "URN can not be parsed.";
                    return te
                },
                serialize: function(z, j) {
                    var X = j.scheme || z.scheme || "urn",
                        te = z.nid,
                        Oe = X + ":" + (j.nid || te),
                        $e = fe[Oe];
                    $e && (z = $e.serialize(z, j));
                    var rt = z,
                        Ze = z.nss;
                    return rt.path = (te || j.nid) + ":" + Ze, rt
                }
            },
            cs = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
            Gn = {
                scheme: "urn:uuid",
                parse: function(z, j) {
                    var X = z;
                    return X.uuid = X.nss, X.nss = void 0, !j.tolerant && (!X.uuid || !X.uuid.match(cs)) && (X.error = X.error || "UUID is not valid."), X
                },
                serialize: function(z, j) {
                    var X = z;
                    return X.nss = (z.uuid || "").toLowerCase(), X
                }
            };
        fe[we.scheme] = we, fe[lt.scheme] = lt, fe[vt.scheme] = vt, fe[ht.scheme] = ht, fe[tn.scheme] = tn, fe[Hr.scheme] = Hr, fe[Gn.scheme] = Gn, n.SCHEMES = fe, n.pctEncChar = ue, n.pctDecChars = ve, n.parse = De, n.removeDotSegments = K, n.serialize = V, n.resolveComponents = ge, n.resolve = Be, n.normalize = ze, n.equal = Ue, n.escapeComponent = Ye, n.unescapeComponent = Te, Object.defineProperty(n, "__esModule", {
            value: !0
        })
    })
})(NI, NI.exports);
var Mse = NI.exports,
    gE = function t(e, n) {
        if (e === n) return !0;
        if (e && n && typeof e == "object" && typeof n == "object") {
            if (e.constructor !== n.constructor) return !1;
            var r, i, s;
            if (Array.isArray(e)) {
                if (r = e.length, r != n.length) return !1;
                for (i = r; i-- !== 0;)
                    if (!t(e[i], n[i])) return !1;
                return !0
            }
            if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
            if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
            if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
            if (s = Object.keys(e), r = s.length, r !== Object.keys(n).length) return !1;
            for (i = r; i-- !== 0;)
                if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1;
            for (i = r; i-- !== 0;) {
                var o = s[i];
                if (!t(e[o], n[o])) return !1
            }
            return !0
        }
        return e !== e && n !== n
    };
const Tse = la(gE);
var Pse = function(e) {
        for (var n = 0, r = e.length, i = 0, s; i < r;) n++, s = e.charCodeAt(i++), s >= 55296 && s <= 56319 && i < r && (s = e.charCodeAt(i), (s & 64512) == 56320 && i++);
        return n
    },
    mg = {
        copy: Ise,
        checkDataType: zI,
        checkDataTypes: Rse,
        coerceToTypes: Ose,
        toHash: qD,
        getProperty: XD,
        escapeQuotes: JD,
        equal: gE,
        ucs2length: Pse,
        varOccurences: kse,
        varReplace: Bse,
        schemaHasRules: Fse,
        schemaHasRulesExcept: Nse,
        schemaUnknownRules: zse,
        toQuotedString: HI,
        getPathExpr: Hse,
        getPath: Use,
        getData: Vse,
        unescapeFragment: jse,
        unescapeJsonPointer: QD,
        escapeFragment: Wse,
        escapeJsonPointer: YD
    };

function Ise(t, e) {
    e = e || {};
    for (var n in t) e[n] = t[n];
    return e
}

function zI(t, e, n, r) {
    var i = r ? " !== " : " === ",
        s = r ? " || " : " && ",
        o = r ? "!" : "",
        a = r ? "" : "!";
    switch (t) {
        case "null":
            return e + i + "null";
        case "array":
            return o + "Array.isArray(" + e + ")";
        case "object":
            return "(" + o + e + s + "typeof " + e + i + '"object"' + s + a + "Array.isArray(" + e + "))";
        case "integer":
            return "(typeof " + e + i + '"number"' + s + a + "(" + e + " % 1)" + s + e + i + e + (n ? s + o + "isFinite(" + e + ")" : "") + ")";
        case "number":
            return "(typeof " + e + i + '"' + t + '"' + (n ? s + o + "isFinite(" + e + ")" : "") + ")";
        default:
            return "typeof " + e + i + '"' + t + '"'
    }
}

function Rse(t, e, n) {
    switch (t.length) {
        case 1:
            return zI(t[0], e, n, !0);
        default:
            var r = "",
                i = qD(t);
            i.array && i.object && (r = i.null ? "(" : "(!" + e + " || ", r += "typeof " + e + ' !== "object")', delete i.null, delete i.array, delete i.object), i.number && delete i.integer;
            for (var s in i) r += (r ? " && " : "") + zI(s, e, n, !0);
            return r
    }
}
var kN = qD(["string", "number", "integer", "boolean", "null"]);

function Ose(t, e) {
    if (Array.isArray(e)) {
        for (var n = [], r = 0; r < e.length; r++) {
            var i = e[r];
            (kN[i] || t === "array" && i === "array") && (n[n.length] = i)
        }
        if (n.length) return n
    } else {
        if (kN[e]) return [e];
        if (t === "array" && e === "array") return ["array"]
    }
}

function qD(t) {
    for (var e = {}, n = 0; n < t.length; n++) e[t[n]] = !0;
    return e
}
var Dse = /^[a-z$_][a-z$_0-9]*$/i,
    Lse = /'|\\/g;

function XD(t) {
    return typeof t == "number" ? "[" + t + "]" : Dse.test(t) ? "." + t : "['" + JD(t) + "']"
}

function JD(t) {
    return t.replace(Lse, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t")
}

function kse(t, e) {
    e += "[^0-9]";
    var n = t.match(new RegExp(e, "g"));
    return n ? n.length : 0
}

function Bse(t, e, n) {
    return e += "([^0-9])", n = n.replace(/\$/g, "$$$$"), t.replace(new RegExp(e, "g"), n + "$1")
}

function Fse(t, e) {
    if (typeof t == "boolean") return !t;
    for (var n in t)
        if (e[n]) return !0
}

function Nse(t, e, n) {
    if (typeof t == "boolean") return !t && n != "not";
    for (var r in t)
        if (r != n && e[r]) return !0
}

function zse(t, e) {
    if (typeof t != "boolean") {
        for (var n in t)
            if (!e[n]) return n
    }
}

function HI(t) {
    return "'" + JD(t) + "'"
}

function Hse(t, e, n, r) {
    var i = n ? "'/' + " + e + (r ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : r ? "'[' + " + e + " + ']'" : "'[\\'' + " + e + " + '\\']'";
    return AV(t, i)
}

function Use(t, e, n) {
    var r = HI(n ? "/" + YD(e) : XD(e));
    return AV(t, r)
}
var $se = /^\/(?:[^~]|~0|~1)*$/,
    Gse = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

function Vse(t, e, n) {
    var r, i, s, o;
    if (t === "") return "rootData";
    if (t[0] == "/") {
        if (!$se.test(t)) throw new Error("Invalid JSON-pointer: " + t);
        i = t, s = "rootData"
    } else {
        if (o = t.match(Gse), !o) throw new Error("Invalid JSON-pointer: " + t);
        if (r = +o[1], i = o[2], i == "#") {
            if (r >= e) throw new Error("Cannot access property/index " + r + " levels up, current level is " + e);
            return n[e - r]
        }
        if (r > e) throw new Error("Cannot access data " + r + " levels up, current level is " + e);
        if (s = "data" + (e - r || ""), !i) return s
    }
    for (var a = s, l = i.split("/"), u = 0; u < l.length; u++) {
        var c = l[u];
        c && (s += XD(QD(c)), a += " && " + s)
    }
    return a
}

function AV(t, e) {
    return t == '""' ? e : (t + " + " + e).replace(/([^\\])' \+ '/g, "$1")
}

function jse(t) {
    return QD(decodeURIComponent(t))
}

function Wse(t) {
    return encodeURIComponent(YD(t))
}

function YD(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1")
}

function QD(t) {
    return t.replace(/~1/g, "/").replace(/~0/g, "~")
}
var Kse = mg,
    CV = qse;

function qse(t) {
    Kse.copy(t, this)
}
var MV = {
        exports: {}
    },
    Rc = MV.exports = function(t, e, n) {
        typeof e == "function" && (n = e, e = {}), n = e.cb || n;
        var r = typeof n == "function" ? n : n.pre || function() {},
            i = n.post || function() {};
        yS(e, r, i, t, "", t)
    };
Rc.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0
};
Rc.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
};
Rc.propsKeywords = {
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
};
Rc.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
};

function yS(t, e, n, r, i, s, o, a, l, u) {
    if (r && typeof r == "object" && !Array.isArray(r)) {
        e(r, i, s, o, a, l, u);
        for (var c in r) {
            var f = r[c];
            if (Array.isArray(f)) {
                if (c in Rc.arrayKeywords)
                    for (var d = 0; d < f.length; d++) yS(t, e, n, f[d], i + "/" + c + "/" + d, s, i, c, r, d)
            } else if (c in Rc.propsKeywords) {
                if (f && typeof f == "object")
                    for (var p in f) yS(t, e, n, f[p], i + "/" + c + "/" + Xse(p), s, i, c, r, p)
            } else(c in Rc.keywords || t.allKeys && !(c in Rc.skipKeywords)) && yS(t, e, n, f, i + "/" + c, s, i, c, r)
        }
        n(r, i, s, o, a, l, u)
    }
}

function Xse(t) {
    return t.replace(/~/g, "~0").replace(/\//g, "~1")
}
var Jse = MV.exports,
    a1 = Mse,
    BN = gE,
    yE = mg,
    Aw = CV,
    Yse = Jse,
    ZD = xf;
xf.normalizeId = Yc;
xf.fullPath = Cw;
xf.url = Mw;
xf.ids = noe;
xf.inlineRef = UI;
xf.schema = vE;

function xf(t, e, n) {
    var r = this._refs[n];
    if (typeof r == "string")
        if (this._refs[r]) r = this._refs[r];
        else return xf.call(this, t, e, r);
    if (r = r || this._schemas[n], r instanceof Aw) return UI(r.schema, this._opts.inlineRefs) ? r.schema : r.validate || this._compile(r);
    var i = vE.call(this, e, n),
        s, o, a;
    return i && (s = i.schema, e = i.root, a = i.baseId), s instanceof Aw ? o = s.validate || t.call(this, s.schema, e, void 0, a) : s !== void 0 && (o = UI(s, this._opts.inlineRefs) ? s : t.call(this, s, e, void 0, a)), o
}

function vE(t, e) {
    var n = a1.parse(e),
        r = PV(n),
        i = Cw(this._getId(t.schema));
    if (Object.keys(t.schema).length === 0 || r !== i) {
        var s = Yc(r),
            o = this._refs[s];
        if (typeof o == "string") return Qse.call(this, t, o, n);
        if (o instanceof Aw) o.validate || this._compile(o), t = o;
        else if (o = this._schemas[s], o instanceof Aw) {
            if (o.validate || this._compile(o), s == Yc(e)) return {
                schema: o,
                root: t,
                baseId: i
            };
            t = o
        } else return;
        if (!t.schema) return;
        i = Cw(this._getId(t.schema))
    }
    return TV.call(this, n, i, t.schema, t)
}

function Qse(t, e, n) {
    var r = vE.call(this, t, e);
    if (r) {
        var i = r.schema,
            s = r.baseId;
        t = r.root;
        var o = this._getId(i);
        return o && (s = Mw(s, o)), TV.call(this, n, s, i, t)
    }
}
var Zse = yE.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);

function TV(t, e, n, r) {
    if (t.fragment = t.fragment || "", t.fragment.slice(0, 1) == "/") {
        for (var i = t.fragment.split("/"), s = 1; s < i.length; s++) {
            var o = i[s];
            if (o) {
                if (o = yE.unescapeFragment(o), n = n[o], n === void 0) break;
                var a;
                if (!Zse[o] && (a = this._getId(n), a && (e = Mw(e, a)), n.$ref)) {
                    var l = Mw(e, n.$ref),
                        u = vE.call(this, r, l);
                    u && (n = u.schema, r = u.root, e = u.baseId)
                }
            }
        }
        if (n !== void 0 && n !== r.schema) return {
            schema: n,
            root: r,
            baseId: e
        }
    }
}
var eoe = yE.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]);

function UI(t, e) {
    if (e === !1) return !1;
    if (e === void 0 || e === !0) return $I(t);
    if (e) return GI(t) <= e
}

function $I(t) {
    var e;
    if (Array.isArray(t)) {
        for (var n = 0; n < t.length; n++)
            if (e = t[n], typeof e == "object" && !$I(e)) return !1
    } else
        for (var r in t)
            if (r == "$ref" || (e = t[r], typeof e == "object" && !$I(e))) return !1;
    return !0
}

function GI(t) {
    var e = 0,
        n;
    if (Array.isArray(t)) {
        for (var r = 0; r < t.length; r++)
            if (n = t[r], typeof n == "object" && (e += GI(n)), e == 1 / 0) return 1 / 0
    } else
        for (var i in t) {
            if (i == "$ref") return 1 / 0;
            if (eoe[i]) e++;
            else if (n = t[i], typeof n == "object" && (e += GI(n) + 1), e == 1 / 0) return 1 / 0
        }
    return e
}

function Cw(t, e) {
    e !== !1 && (t = Yc(t));
    var n = a1.parse(t);
    return PV(n)
}

function PV(t) {
    return a1.serialize(t).split("#")[0] + "#"
}
var toe = /#\/?$/;

function Yc(t) {
    return t ? t.replace(toe, "") : ""
}

function Mw(t, e) {
    return e = Yc(e), a1.resolve(t, e)
}

function noe(t) {
    var e = Yc(this._getId(t)),
        n = {
            "": e
        },
        r = {
            "": Cw(e, !1)
        },
        i = {},
        s = this;
    return Yse(t, {
        allKeys: !0
    }, function(o, a, l, u, c, f, d) {
        if (a !== "") {
            var p = s._getId(o),
                m = n[u],
                y = r[u] + "/" + c;
            if (d !== void 0 && (y += "/" + (typeof d == "number" ? d : yE.escapeFragment(d))), typeof p == "string") {
                p = m = Yc(m ? a1.resolve(m, p) : p);
                var v = s._refs[p];
                if (typeof v == "string" && (v = s._refs[v]), v && v.schema) {
                    if (!BN(o, v.schema)) throw new Error('id "' + p + '" resolves to more than one schema')
                } else if (p != Yc(y))
                    if (p[0] == "#") {
                        if (i[p] && !BN(o, i[p])) throw new Error('id "' + p + '" resolves to more than one schema');
                        i[p] = o
                    } else s._refs[p] = y
            }
            n[a] = m, r[a] = y
        }
    }), i
}
var PM = ZD,
    eL = {
        Validation: FN(roe),
        MissingRef: FN(tL)
    };

function roe(t) {
    this.message = "validation failed", this.errors = t, this.ajv = this.validation = !0
}
tL.message = function(t, e) {
    return "can't resolve reference " + e + " from id " + t
};

function tL(t, e, n) {
    this.message = n || tL.message(t, e), this.missingRef = PM.url(t, e), this.missingSchema = PM.normalizeId(PM.fullPath(this.missingRef))
}

function FN(t) {
    return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t
}
var IV = function(t, e) {
        e || (e = {}), typeof e == "function" && (e = {
            cmp: e
        });
        var n = typeof e.cycles == "boolean" ? e.cycles : !1,
            r = e.cmp && function(s) {
                return function(o) {
                    return function(a, l) {
                        var u = {
                                key: a,
                                value: o[a]
                            },
                            c = {
                                key: l,
                                value: o[l]
                            };
                        return s(u, c)
                    }
                }
            }(e.cmp),
            i = [];
        return function s(o) {
            if (o && o.toJSON && typeof o.toJSON == "function" && (o = o.toJSON()), o !== void 0) {
                if (typeof o == "number") return isFinite(o) ? "" + o : "null";
                if (typeof o != "object") return JSON.stringify(o);
                var a, l;
                if (Array.isArray(o)) {
                    for (l = "[", a = 0; a < o.length; a++) a && (l += ","), l += s(o[a]) || "null";
                    return l + "]"
                }
                if (o === null) return "null";
                if (i.indexOf(o) !== -1) {
                    if (n) return JSON.stringify("__cycle__");
                    throw new TypeError("Converting circular structure to JSON")
                }
                var u = i.push(o) - 1,
                    c = Object.keys(o).sort(r && r(o));
                for (l = "", a = 0; a < c.length; a++) {
                    var f = c[a],
                        d = s(o[f]);
                    d && (l && (l += ","), l += JSON.stringify(f) + ":" + d)
                }
                return i.splice(u, 1), "{" + l + "}"
            }
        }(t)
    },
    RV = function(e, n, r) {
        var i = "",
            s = e.schema.$async === !0,
            o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"),
            a = e.self._getId(e.schema);
        if (e.opts.strictKeywords) {
            var l = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
            if (l) {
                var u = "unknown keyword: " + l;
                if (e.opts.strictKeywords === "log") e.logger.warn(u);
                else throw new Error(u)
            }
        }
        if (e.isTop && (i += " var validate = ", s && (e.async = !0, i += "async "), i += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", a && (e.opts.sourceCode || e.opts.processCode) && (i += " " + ("/*# sourceURL=" + a + " */") + " ")), typeof e.schema == "boolean" || !(o || e.schema.$ref)) {
            var n = "false schema",
                c = e.level,
                f = e.dataLevel,
                d = e.schema[n],
                p = e.schemaPath + e.util.getProperty(n),
                m = e.errSchemaPath + "/" + n,
                E = !e.opts.allErrors,
                M, y = "data" + (f || ""),
                S = "valid" + c;
            if (e.schema === !1) {
                e.isTop ? E = !0 : i += " var " + S + " = false; ";
                var v = v || [];
                v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (M || "false schema") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: {} ", e.opts.messages !== !1 && (i += " , message: 'boolean schema is false' "), e.opts.verbose && (i += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + y + " "), i += " } ") : i += " {} ";
                var b = i;
                i = v.pop(), !e.compositeRule && E ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
            } else e.isTop ? s ? i += " return data; " : i += " validate.errors = null; return true; " : i += " var " + S + " = true; ";
            return e.isTop && (i += " }; return validate; "), i
        }
        if (e.isTop) {
            var _ = e.isTop,
                c = e.level = 0,
                f = e.dataLevel = 0,
                y = "data";
            if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [""], e.schema.default !== void 0 && e.opts.useDefaults && e.opts.strictDefaults) {
                var x = "default is ignored in the schema root";
                if (e.opts.strictDefaults === "log") e.logger.warn(x);
                else throw new Error(x)
            }
            i += " var vErrors = null; ", i += " var errors = 0;     ", i += " if (rootData === undefined) rootData = data; "
        } else {
            var c = e.level,
                f = e.dataLevel,
                y = "data" + (f || "");
            if (a && (e.baseId = e.resolve.url(e.baseId, a)), s && !e.async) throw new Error("async schema in sync schema");
            i += " var errs_" + c + " = errors;"
        }
        var S = "valid" + c,
            E = !e.opts.allErrors,
            A = "",
            T = "",
            M, I = e.schema.type,
            O = Array.isArray(I);
        if (I && e.opts.nullable && e.schema.nullable === !0 && (O ? I.indexOf("null") == -1 && (I = I.concat("null")) : I != "null" && (I = [I, "null"], O = !0)), O && I.length == 1 && (I = I[0], O = !1), e.schema.$ref && o) {
            if (e.opts.extendRefs == "fail") throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
            e.opts.extendRefs !== !0 && (o = !1, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'))
        }
        if (e.schema.$comment && e.opts.$comment && (i += " " + e.RULES.all.$comment.code(e, "$comment")), I) {
            if (e.opts.coerceTypes) var k = e.util.coerceToTypes(e.opts.coerceTypes, I);
            var H = e.RULES.types[I];
            if (k || O || H === !0 || H && !He(H)) {
                var p = e.schemaPath + ".type",
                    m = e.errSchemaPath + "/type",
                    p = e.schemaPath + ".type",
                    m = e.errSchemaPath + "/type",
                    N = O ? "checkDataTypes" : "checkDataType";
                if (i += " if (" + e.util[N](I, y, e.opts.strictNumbers, !0) + ") { ", k) {
                    var B = "dataType" + c,
                        U = "coerced" + c;
                    i += " var " + B + " = typeof " + y + "; var " + U + " = undefined; ", e.opts.coerceTypes == "array" && (i += " if (" + B + " == 'object' && Array.isArray(" + y + ") && " + y + ".length == 1) { " + y + " = " + y + "[0]; " + B + " = typeof " + y + "; if (" + e.util.checkDataType(e.schema.type, y, e.opts.strictNumbers) + ") " + U + " = " + y + "; } "), i += " if (" + U + " !== undefined) ; ";
                    var q = k;
                    if (q)
                        for (var Q, F = -1, G = q.length - 1; F < G;) Q = q[F += 1], Q == "string" ? i += " else if (" + B + " == 'number' || " + B + " == 'boolean') " + U + " = '' + " + y + "; else if (" + y + " === null) " + U + " = ''; " : Q == "number" || Q == "integer" ? (i += " else if (" + B + " == 'boolean' || " + y + " === null || (" + B + " == 'string' && " + y + " && " + y + " == +" + y + " ", Q == "integer" && (i += " && !(" + y + " % 1)"), i += ")) " + U + " = +" + y + "; ") : Q == "boolean" ? i += " else if (" + y + " === 'false' || " + y + " === 0 || " + y + " === null) " + U + " = false; else if (" + y + " === 'true' || " + y + " === 1) " + U + " = true; " : Q == "null" ? i += " else if (" + y + " === '' || " + y + " === 0 || " + y + " === false) " + U + " = null; " : e.opts.coerceTypes == "array" && Q == "array" && (i += " else if (" + B + " == 'string' || " + B + " == 'number' || " + B + " == 'boolean' || " + y + " == null) " + U + " = [" + y + "]; ");
                    i += " else {   ";
                    var v = v || [];
                    v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (M || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", O ? i += "" + I.join(",") : i += "" + I, i += "' } ", e.opts.messages !== !1 && (i += " , message: 'should be ", O ? i += "" + I.join(",") : i += "" + I, i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + y + " "), i += " } ") : i += " {} ";
                    var b = i;
                    i = v.pop(), !e.compositeRule && E ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } if (" + U + " !== undefined) {  ";
                    var W = f ? "data" + (f - 1 || "") : "parentData",
                        se = f ? e.dataPathArr[f] : "parentDataProperty";
                    i += " " + y + " = " + U + "; ", f || (i += "if (" + W + " !== undefined)"), i += " " + W + "[" + se + "] = " + U + "; } "
                } else {
                    var v = v || [];
                    v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (M || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", O ? i += "" + I.join(",") : i += "" + I, i += "' } ", e.opts.messages !== !1 && (i += " , message: 'should be ", O ? i += "" + I.join(",") : i += "" + I, i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + y + " "), i += " } ") : i += " {} ";
                    var b = i;
                    i = v.pop(), !e.compositeRule && E ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
                }
                i += " } "
            }
        }
        if (e.schema.$ref && !o) i += " " + e.RULES.all.$ref.code(e, "$ref") + " ", E && (i += " } if (errors === ", _ ? i += "0" : i += "errs_" + c, i += ") { ", T += "}");
        else {
            var ee = e.RULES;
            if (ee) {
                for (var H, ae = -1, de = ee.length - 1; ae < de;)
                    if (H = ee[ae += 1], He(H)) {
                        if (H.type && (i += " if (" + e.util.checkDataType(H.type, y, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) {
                            if (H.type == "object" && e.schema.properties) {
                                var d = e.schema.properties,
                                    re = Object.keys(d),
                                    _e = re;
                                if (_e)
                                    for (var fe, ue = -1, ve = _e.length - 1; ue < ve;) {
                                        fe = _e[ue += 1];
                                        var xe = d[fe];
                                        if (xe.default !== void 0) {
                                            var be = y + e.util.getProperty(fe);
                                            if (e.compositeRule) {
                                                if (e.opts.strictDefaults) {
                                                    var x = "default is ignored for: " + be;
                                                    if (e.opts.strictDefaults === "log") e.logger.warn(x);
                                                    else throw new Error(x)
                                                }
                                            } else i += " if (" + be + " === undefined ", e.opts.useDefaults == "empty" && (i += " || " + be + " === null || " + be + " === '' "), i += " ) " + be + " = ", e.opts.useDefaults == "shared" ? i += " " + e.useDefault(xe.default) + " " : i += " " + JSON.stringify(xe.default) + " ", i += "; "
                                        }
                                    }
                            } else if (H.type == "array" && Array.isArray(e.schema.items)) {
                                var he = e.schema.items;
                                if (he) {
                                    for (var xe, F = -1, me = he.length - 1; F < me;)
                                        if (xe = he[F += 1], xe.default !== void 0) {
                                            var be = y + "[" + F + "]";
                                            if (e.compositeRule) {
                                                if (e.opts.strictDefaults) {
                                                    var x = "default is ignored for: " + be;
                                                    if (e.opts.strictDefaults === "log") e.logger.warn(x);
                                                    else throw new Error(x)
                                                }
                                            } else i += " if (" + be + " === undefined ", e.opts.useDefaults == "empty" && (i += " || " + be + " === null || " + be + " === '' "), i += " ) " + be + " = ", e.opts.useDefaults == "shared" ? i += " " + e.useDefault(xe.default) + " " : i += " " + JSON.stringify(xe.default) + " ", i += "; "
                                        }
                                }
                            }
                        }
                        var Ce = H.rules;
                        if (Ce) {
                            for (var Ne, De = -1, je = Ce.length - 1; De < je;)
                                if (Ne = Ce[De += 1], qe(Ne)) {
                                    var Ke = Ne.code(e, Ne.keyword, H.type);
                                    Ke && (i += " " + Ke + " ", E && (A += "}"))
                                }
                        }
                        if (E && (i += " " + A + " ", A = ""), H.type && (i += " } ", I && I === H.type && !k)) {
                            i += " else { ";
                            var p = e.schemaPath + ".type",
                                m = e.errSchemaPath + "/type",
                                v = v || [];
                            v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (M || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", O ? i += "" + I.join(",") : i += "" + I, i += "' } ", e.opts.messages !== !1 && (i += " , message: 'should be ", O ? i += "" + I.join(",") : i += "" + I, i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + y + " "), i += " } ") : i += " {} ";
                            var b = i;
                            i = v.pop(), !e.compositeRule && E ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } "
                        }
                        E && (i += " if (errors === ", _ ? i += "0" : i += "errs_" + c, i += ") { ", T += "}")
                    }
            }
        }
        E && (i += " " + T + " "), _ ? (s ? (i += " if (errors === 0) return data;           ", i += " else throw new ValidationError(vErrors); ") : (i += " validate.errors = vErrors; ", i += " return errors === 0;       "), i += " }; return validate;") : i += " var " + S + " = errors === errs_" + c + ";";

        function He(K) {
            for (var V = K.rules, ge = 0; ge < V.length; ge++)
                if (qe(V[ge])) return !0
        }

        function qe(K) {
            return e.schema[K.keyword] !== void 0 || K.implements && Xe(K)
        }

        function Xe(K) {
            for (var V = K.implements, ge = 0; ge < V.length; ge++)
                if (e.schema[V[ge]] !== void 0) return !0
        }
        return i
    },
    cx = ZD,
    Tw = mg,
    OV = eL,
    ioe = IV,
    NN = RV,
    soe = Tw.ucs2length,
    ooe = gE,
    aoe = OV.Validation,
    loe = VI;

function VI(t, e, n, r) {
    var i = this,
        s = this._opts,
        o = [void 0],
        a = {},
        l = [],
        u = {},
        c = [],
        f = {},
        d = [];
    e = e || {
        schema: t,
        refVal: o,
        refs: a
    };
    var p = uoe.call(this, t, e, r),
        m = this._compilations[p.index];
    if (p.compiling) return m.callValidate = x;
    var y = this._formats,
        v = this.RULES;
    try {
        var b = S(t, e, n, r);
        m.validate = b;
        var _ = m.callValidate;
        return _ && (_.schema = b.schema, _.errors = null, _.refs = b.refs, _.refVal = b.refVal, _.root = b.root, _.$async = b.$async, s.sourceCode && (_.source = b.source)), b
    } finally {
        coe.call(this, t, e, r)
    }

    function x() {
        var N = m.validate,
            B = N.apply(this, arguments);
        return x.errors = N.errors, B
    }

    function S(N, B, U, q) {
        var Q = !B || B && B.schema == N;
        if (B.schema != e.schema) return VI.call(i, N, B, U, q);
        var F = N.$async === !0,
            G = NN({
                isTop: !0,
                schema: N,
                isRoot: Q,
                baseId: q,
                root: B,
                schemaPath: "",
                errSchemaPath: "#",
                errorPath: '""',
                MissingRefError: OV.MissingRef,
                RULES: v,
                validate: NN,
                util: Tw,
                resolve: cx,
                resolveRef: E,
                usePattern: O,
                useDefault: k,
                useCustomRule: H,
                opts: s,
                formats: y,
                logger: i.logger,
                self: i
            });
        G = fx(o, poe) + fx(l, foe) + fx(c, doe) + fx(d, hoe) + G, s.processCode && (G = s.processCode(G, N));
        var W;
        try {
            var se = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", G);
            W = se(i, v, y, e, o, c, d, ooe, soe, aoe), o[0] = W
        } catch (ee) {
            throw i.logger.error("Error compiling schema, function code:", G), ee
        }
        return W.schema = N, W.errors = null, W.refs = a, W.refVal = o, W.root = Q ? W : B, F && (W.$async = !0), s.sourceCode === !0 && (W.source = {
            code: G,
            patterns: l,
            defaults: c
        }), W
    }

    function E(N, B, U) {
        B = cx.url(N, B);
        var q = a[B],
            Q, F;
        if (q !== void 0) return Q = o[q], F = "refVal[" + q + "]", I(Q, F);
        if (!U && e.refs) {
            var G = e.refs[B];
            if (G !== void 0) return Q = e.refVal[G], F = A(B, Q), I(Q, F)
        }
        F = A(B);
        var W = cx.call(i, S, e, B);
        if (W === void 0) {
            var se = n && n[B];
            se && (W = cx.inlineRef(se, s.inlineRefs) ? se : VI.call(i, se, e, n, N))
        }
        if (W === void 0) T(B);
        else return M(B, W), I(W, F)
    }

    function A(N, B) {
        var U = o.length;
        return o[U] = B, a[N] = U, "refVal" + U
    }

    function T(N) {
        delete a[N]
    }

    function M(N, B) {
        var U = a[N];
        o[U] = B
    }

    function I(N, B) {
        return typeof N == "object" || typeof N == "boolean" ? {
            code: B,
            schema: N,
            inline: !0
        } : {
            code: B,
            $async: N && !!N.$async
        }
    }

    function O(N) {
        var B = u[N];
        return B === void 0 && (B = u[N] = l.length, l[B] = N), "pattern" + B
    }

    function k(N) {
        switch (typeof N) {
            case "boolean":
            case "number":
                return "" + N;
            case "string":
                return Tw.toQuotedString(N);
            case "object":
                if (N === null) return "null";
                var B = ioe(N),
                    U = f[B];
                return U === void 0 && (U = f[B] = c.length, c[U] = N), "default" + U
        }
    }

    function H(N, B, U, q) {
        if (i._opts.validateSchema !== !1) {
            var Q = N.definition.dependencies;
            if (Q && !Q.every(function(_e) {
                    return Object.prototype.hasOwnProperty.call(U, _e)
                })) throw new Error("parent schema must have all required keywords: " + Q.join(","));
            var F = N.definition.validateSchema;
            if (F) {
                var G = F(B);
                if (!G) {
                    var W = "keyword schema is invalid: " + i.errorsText(F.errors);
                    if (i._opts.validateSchema == "log") i.logger.error(W);
                    else throw new Error(W)
                }
            }
        }
        var se = N.definition.compile,
            ee = N.definition.inline,
            ae = N.definition.macro,
            de;
        if (se) de = se.call(i, B, U, q);
        else if (ae) de = ae.call(i, B, U, q), s.validateSchema !== !1 && i.validateSchema(de, !0);
        else if (ee) de = ee.call(i, q, N.keyword, B, U);
        else if (de = N.definition.validate, !de) return;
        if (de === void 0) throw new Error('custom keyword "' + N.keyword + '"failed to compile');
        var re = d.length;
        return d[re] = de, {
            code: "customRule" + re,
            validate: de
        }
    }
}

function uoe(t, e, n) {
    var r = DV.call(this, t, e, n);
    return r >= 0 ? {
        index: r,
        compiling: !0
    } : (r = this._compilations.length, this._compilations[r] = {
        schema: t,
        root: e,
        baseId: n
    }, {
        index: r,
        compiling: !1
    })
}

function coe(t, e, n) {
    var r = DV.call(this, t, e, n);
    r >= 0 && this._compilations.splice(r, 1)
}

function DV(t, e, n) {
    for (var r = 0; r < this._compilations.length; r++) {
        var i = this._compilations[r];
        if (i.schema == t && i.root == e && i.baseId == n) return r
    }
    return -1
}

function foe(t, e) {
    return "var pattern" + t + " = new RegExp(" + Tw.toQuotedString(e[t]) + ");"
}

function doe(t) {
    return "var default" + t + " = defaults[" + t + "];"
}

function poe(t, e) {
    return e[t] === void 0 ? "" : "var refVal" + t + " = refVal[" + t + "];"
}

function hoe(t) {
    return "var customRule" + t + " = customRules[" + t + "];"
}

function fx(t, e) {
    if (!t.length) return "";
    for (var n = "", r = 0; r < t.length; r++) n += e(r, t);
    return n
}
var LV = {
        exports: {}
    },
    bE = LV.exports = function() {
        this._cache = {}
    };
bE.prototype.put = function(e, n) {
    this._cache[e] = n
};
bE.prototype.get = function(e) {
    return this._cache[e]
};
bE.prototype.del = function(e) {
    delete this._cache[e]
};
bE.prototype.clear = function() {
    this._cache = {}
};
var moe = LV.exports,
    goe = mg,
    yoe = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    voe = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    boe = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,
    kV = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    xoe = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    _oe = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    BV = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    FV = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
    NV = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    zV = /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    HV = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    UV = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    Soe = xE;

function xE(t) {
    return t = t == "full" ? "full" : "fast", goe.copy(xE[t])
}
xE.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": BV,
    url: FV,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: kV,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: VV,
    uuid: NV,
    "json-pointer": zV,
    "json-pointer-uri-fragment": HV,
    "relative-json-pointer": UV
};
xE.full = {
    date: $V,
    time: GV,
    "date-time": Aoe,
    uri: Moe,
    "uri-reference": _oe,
    "uri-template": BV,
    url: FV,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: kV,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: VV,
    uuid: NV,
    "json-pointer": zV,
    "json-pointer-uri-fragment": HV,
    "relative-json-pointer": UV
};

function woe(t) {
    return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0)
}

function $V(t) {
    var e = t.match(yoe);
    if (!e) return !1;
    var n = +e[1],
        r = +e[2],
        i = +e[3];
    return r >= 1 && r <= 12 && i >= 1 && i <= (r == 2 && woe(n) ? 29 : voe[r])
}

function GV(t, e) {
    var n = t.match(boe);
    if (!n) return !1;
    var r = n[1],
        i = n[2],
        s = n[3],
        o = n[5];
    return (r <= 23 && i <= 59 && s <= 59 || r == 23 && i == 59 && s == 60) && (!e || o)
}
var Eoe = /t|\s/i;

function Aoe(t) {
    var e = t.split(Eoe);
    return e.length == 2 && $V(e[0]) && GV(e[1], !0)
}
var Coe = /\/|:/;

function Moe(t) {
    return Coe.test(t) && xoe.test(t)
}
var Toe = /[^\\]\\Z/;

function VV(t) {
    if (Toe.test(t)) return !1;
    try {
        return new RegExp(t), !0
    } catch {
        return !1
    }
}
var Poe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.errSchemaPath + "/" + n,
            u = !e.opts.allErrors,
            c = "data" + (o || ""),
            f = "valid" + s,
            d, p;
        if (a == "#" || a == "#/") e.isRoot ? (d = e.async, p = "validate") : (d = e.root.schema.$async === !0, p = "root.refVal[0]");
        else {
            var m = e.resolveRef(e.baseId, a, e.isRoot);
            if (m === void 0) {
                var y = e.MissingRefError.message(e.baseId, a);
                if (e.opts.missingRefs == "fail") {
                    e.logger.error(y);
                    var v = v || [];
                    v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { ref: '" + e.util.escapeQuotes(a) + "' } ", e.opts.messages !== !1 && (i += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(a) + "' "), e.opts.verbose && (i += " , schema: " + e.util.toQuotedString(a) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), i += " } ") : i += " {} ";
                    var b = i;
                    i = v.pop(), !e.compositeRule && u ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u && (i += " if (false) { ")
                } else if (e.opts.missingRefs == "ignore") e.logger.warn(y), u && (i += " if (true) { ");
                else throw new e.MissingRefError(e.baseId, a, y)
            } else if (m.inline) {
                var _ = e.util.copy(e);
                _.level++;
                var x = "valid" + _.level;
                _.schema = m.schema, _.schemaPath = "", _.errSchemaPath = a;
                var S = e.validate(_).replace(/validate\.schema/g, m.code);
                i += " " + S + " ", u && (i += " if (" + x + ") { ")
            } else d = m.$async === !0 || e.async && m.$async !== !1, p = m.code
        }
        if (p) {
            var v = v || [];
            v.push(i), i = "", e.opts.passContext ? i += " " + p + ".call(this, " : i += " " + p + "( ", i += " " + c + ", (dataPath || '')", e.errorPath != '""' && (i += " + " + e.errorPath);
            var E = o ? "data" + (o - 1 || "") : "parentData",
                A = o ? e.dataPathArr[o] : "parentDataProperty";
            i += " , " + E + " , " + A + ", rootData)  ";
            var T = i;
            if (i = v.pop(), d) {
                if (!e.async) throw new Error("async schema referenced by sync schema");
                u && (i += " var " + f + "; "), i += " try { await " + T + "; ", u && (i += " " + f + " = true; "), i += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", u && (i += " " + f + " = false; "), i += " } ", u && (i += " if (" + f + ") { ")
            } else i += " if (!" + T + ") { if (vErrors === null) vErrors = " + p + ".errors; else vErrors = vErrors.concat(" + p + ".errors); errors = vErrors.length; } ", u && (i += " else { ")
        }
        return i
    },
    Ioe = function(e, n, r) {
        var i = " ",
            s = e.schema[n],
            o = e.schemaPath + e.util.getProperty(n),
            a = e.errSchemaPath + "/" + n,
            l = !e.opts.allErrors,
            u = e.util.copy(e),
            c = "";
        u.level++;
        var f = "valid" + u.level,
            d = u.baseId,
            p = !0,
            m = s;
        if (m)
            for (var y, v = -1, b = m.length - 1; v < b;) y = m[v += 1], (e.opts.strictKeywords ? typeof y == "object" && Object.keys(y).length > 0 || y === !1 : e.util.schemaHasRules(y, e.RULES.all)) && (p = !1, u.schema = y, u.schemaPath = o + "[" + v + "]", u.errSchemaPath = a + "/" + v, i += "  " + e.validate(u) + " ", u.baseId = d, l && (i += " if (" + f + ") { ", c += "}"));
        return l && (p ? i += " if (true) { " : i += " " + c.slice(0, -1) + " "), i
    },
    Roe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = "errs__" + s,
            m = e.util.copy(e),
            y = "";
        m.level++;
        var v = "valid" + m.level,
            b = a.every(function(M) {
                return e.opts.strictKeywords ? typeof M == "object" && Object.keys(M).length > 0 || M === !1 : e.util.schemaHasRules(M, e.RULES.all)
            });
        if (b) {
            var _ = m.baseId;
            i += " var " + p + " = errors; var " + d + " = false;  ";
            var x = e.compositeRule;
            e.compositeRule = m.compositeRule = !0;
            var S = a;
            if (S)
                for (var E, A = -1, T = S.length - 1; A < T;) E = S[A += 1], m.schema = E, m.schemaPath = l + "[" + A + "]", m.errSchemaPath = u + "/" + A, i += "  " + e.validate(m) + " ", m.baseId = _, i += " " + d + " = " + d + " || " + v + "; if (!" + d + ") { ", y += "}";
            e.compositeRule = m.compositeRule = x, i += " " + y + " if (!" + d + ") {   var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (i += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? i += " throw new ValidationError(vErrors); " : i += " validate.errors = vErrors; return false; "), i += " } else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } ", e.opts.allErrors && (i += " } ")
        } else c && (i += " if (true) { ");
        return i
    },
    Ooe = function(e, n, r) {
        var i = " ",
            s = e.schema[n],
            o = e.errSchemaPath + "/" + n;
        e.opts.allErrors;
        var a = e.util.toQuotedString(s);
        return e.opts.$comment === !0 ? i += " console.log(" + a + ");" : typeof e.opts.$comment == "function" && (i += " self._opts.$comment(" + a + ", " + e.util.toQuotedString(o) + ", validate.root.schema);"), i
    },
    Doe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = e.opts.$data && a && a.$data;
        p && (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; "), p || (i += " var schema" + s + " = validate.schema" + l + ";"), i += "var " + d + " = equal(" + f + ", schema" + s + "); if (!" + d + ") {   ";
        var m = m || [];
        m.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'const' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValue: schema" + s + " } ", e.opts.messages !== !1 && (i += " , message: 'should be equal to constant' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var y = i;
        return i = m.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + y + "]); " : i += " validate.errors = [" + y + "]; return false; " : i += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " }", c && (i += " else { "), i
    },
    Loe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = "errs__" + s,
            m = e.util.copy(e),
            y = "";
        m.level++;
        var v = "valid" + m.level,
            b = "i" + s,
            _ = m.dataLevel = e.dataLevel + 1,
            x = "data" + _,
            S = e.baseId,
            E = e.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : e.util.schemaHasRules(a, e.RULES.all);
        if (i += "var " + p + " = errors;var " + d + ";", E) {
            var A = e.compositeRule;
            e.compositeRule = m.compositeRule = !0, m.schema = a, m.schemaPath = l, m.errSchemaPath = u, i += " var " + v + " = false; for (var " + b + " = 0; " + b + " < " + f + ".length; " + b + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, b, e.opts.jsonPointers, !0);
            var T = f + "[" + b + "]";
            m.dataPathArr[_] = b;
            var M = e.validate(m);
            m.baseId = S, e.util.varOccurences(M, x) < 2 ? i += " " + e.util.varReplace(M, x, T) + " " : i += " var " + x + " = " + T + "; " + M + " ", i += " if (" + v + ") break; }  ", e.compositeRule = m.compositeRule = A, i += " " + y + " if (!" + v + ") {"
        } else i += " if (" + f + ".length == 0) {";
        var I = I || [];
        I.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (i += " , message: 'should contain a valid item' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var O = i;
        return i = I.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + O + "]); " : i += " validate.errors = [" + O + "]; return false; " : i += " var err = " + O + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } else { ", E && (i += "  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } "), e.opts.allErrors && (i += " } "), i
    },
    koe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "errs__" + s,
            p = e.util.copy(e),
            m = "";
        p.level++;
        var y = "valid" + p.level,
            v = {},
            b = {},
            _ = e.opts.ownProperties;
        for (A in a)
            if (A != "__proto__") {
                var x = a[A],
                    S = Array.isArray(x) ? b : v;
                S[A] = x
            }
        i += "var " + d + " = errors;";
        var E = e.errorPath;
        i += "var missing" + s + ";";
        for (var A in b)
            if (S = b[A], S.length) {
                if (i += " if ( " + f + e.util.getProperty(A) + " !== undefined ", _ && (i += " && Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(A) + "') "), c) {
                    i += " && ( ";
                    var T = S;
                    if (T)
                        for (var M, I = -1, O = T.length - 1; I < O;) {
                            M = T[I += 1], I && (i += " || ");
                            var k = e.util.getProperty(M),
                                H = f + k;
                            i += " ( ( " + H + " === undefined ", _ && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(M) + "') "), i += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? M : k) + ") ) "
                        }
                    i += ")) {  ";
                    var N = "missing" + s,
                        B = "' + " + N + " + '";
                    e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(E, N, !0) : E + " + " + N);
                    var U = U || [];
                    U.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(A) + "', missingProperty: '" + B + "', depsCount: " + S.length + ", deps: '" + e.util.escapeQuotes(S.length == 1 ? S[0] : S.join(", ")) + "' } ", e.opts.messages !== !1 && (i += " , message: 'should have ", S.length == 1 ? i += "property " + e.util.escapeQuotes(S[0]) : i += "properties " + e.util.escapeQuotes(S.join(", ")), i += " when property " + e.util.escapeQuotes(A) + " is present' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
                    var q = i;
                    i = U.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + q + "]); " : i += " validate.errors = [" + q + "]; return false; " : i += " var err = " + q + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
                } else {
                    i += " ) { ";
                    var Q = S;
                    if (Q)
                        for (var M, F = -1, G = Q.length - 1; F < G;) {
                            M = Q[F += 1];
                            var k = e.util.getProperty(M),
                                B = e.util.escapeQuotes(M),
                                H = f + k;
                            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(E, M, e.opts.jsonPointers)), i += " if ( " + H + " === undefined ", _ && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(M) + "') "), i += ") {  var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(A) + "', missingProperty: '" + B + "', depsCount: " + S.length + ", deps: '" + e.util.escapeQuotes(S.length == 1 ? S[0] : S.join(", ")) + "' } ", e.opts.messages !== !1 && (i += " , message: 'should have ", S.length == 1 ? i += "property " + e.util.escapeQuotes(S[0]) : i += "properties " + e.util.escapeQuotes(S.join(", ")), i += " when property " + e.util.escapeQuotes(A) + " is present' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
                        }
                }
                i += " }   ", c && (m += "}", i += " else { ")
            }
        e.errorPath = E;
        var W = p.baseId;
        for (var A in v) {
            var x = v[A];
            (e.opts.strictKeywords ? typeof x == "object" && Object.keys(x).length > 0 || x === !1 : e.util.schemaHasRules(x, e.RULES.all)) && (i += " " + y + " = true; if ( " + f + e.util.getProperty(A) + " !== undefined ", _ && (i += " && Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(A) + "') "), i += ") { ", p.schema = x, p.schemaPath = l + e.util.getProperty(A), p.errSchemaPath = u + "/" + e.util.escapeFragment(A), i += "  " + e.validate(p) + " ", p.baseId = W, i += " }  ", c && (i += " if (" + y + ") { ", m += "}"))
        }
        return c && (i += "   " + m + " if (" + d + " == errors) {"), i
    },
    Boe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = e.opts.$data && a && a.$data;
        p && (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ");
        var m = "i" + s,
            y = "schema" + s;
        p || (i += " var " + y + " = validate.schema" + l + ";"), i += "var " + d + ";", p && (i += " if (schema" + s + " === undefined) " + d + " = true; else if (!Array.isArray(schema" + s + ")) " + d + " = false; else {"), i += "" + d + " = false;for (var " + m + "=0; " + m + "<" + y + ".length; " + m + "++) if (equal(" + f + ", " + y + "[" + m + "])) { " + d + " = true; break; }", p && (i += "  }  "), i += " if (!" + d + ") {   ";
        var v = v || [];
        v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValues: schema" + s + " } ", e.opts.messages !== !1 && (i += " , message: 'should be equal to one of the allowed values' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var b = i;
        return i = v.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " }", c && (i += " else { "), i
    },
    Foe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || "");
        if (e.opts.format === !1) return c && (i += " if (true) { "), i;
        var d = e.opts.$data && a && a.$data,
            p;
        d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a;
        var m = e.opts.unknownFormats,
            y = Array.isArray(m);
        if (d) {
            var v = "format" + s,
                b = "isObject" + s,
                _ = "formatType" + s;
            i += " var " + v + " = formats[" + p + "]; var " + b + " = typeof " + v + " == 'object' && !(" + v + " instanceof RegExp) && " + v + ".validate; var " + _ + " = " + b + " && " + v + ".type || 'string'; if (" + b + ") { ", e.async && (i += " var async" + s + " = " + v + ".async; "), i += " " + v + " = " + v + ".validate; } if (  ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'string') || "), i += " (", m != "ignore" && (i += " (" + p + " && !" + v + " ", y && (i += " && self._opts.unknownFormats.indexOf(" + p + ") == -1 "), i += ") || "), i += " (" + v + " && " + _ + " == '" + r + "' && !(typeof " + v + " == 'function' ? ", e.async ? i += " (async" + s + " ? await " + v + "(" + f + ") : " + v + "(" + f + ")) " : i += " " + v + "(" + f + ") ", i += " : " + v + ".test(" + f + "))))) {"
        } else {
            var v = e.formats[a];
            if (!v) {
                if (m == "ignore") return e.logger.warn('unknown format "' + a + '" ignored in schema at path "' + e.errSchemaPath + '"'), c && (i += " if (true) { "), i;
                if (y && m.indexOf(a) >= 0) return c && (i += " if (true) { "), i;
                throw new Error('unknown format "' + a + '" is used in schema at path "' + e.errSchemaPath + '"')
            }
            var b = typeof v == "object" && !(v instanceof RegExp) && v.validate,
                _ = b && v.type || "string";
            if (b) {
                var x = v.async === !0;
                v = v.validate
            }
            if (_ != r) return c && (i += " if (true) { "), i;
            if (x) {
                if (!e.async) throw new Error("async format in sync schema");
                var S = "formats" + e.util.getProperty(a) + ".validate";
                i += " if (!(await " + S + "(" + f + "))) { "
            } else {
                i += " if (! ";
                var S = "formats" + e.util.getProperty(a);
                b && (S += ".validate"), typeof v == "function" ? i += " " + S + "(" + f + ") " : i += " " + S + ".test(" + f + ") ", i += ") { "
            }
        }
        var E = E || [];
        E.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'format' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { format:  ", d ? i += "" + p : i += "" + e.util.toQuotedString(a), i += "  } ", e.opts.messages !== !1 && (i += ` , message: 'should match format "`, d ? i += "' + " + p + " + '" : i += "" + e.util.escapeQuotes(a), i += `"' `), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + e.util.toQuotedString(a), i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var A = i;
        return i = E.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + A + "]); " : i += " validate.errors = [" + A + "]; return false; " : i += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", c && (i += " else { "), i
    },
    Noe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = "errs__" + s,
            m = e.util.copy(e);
        m.level++;
        var y = "valid" + m.level,
            v = e.schema.then,
            b = e.schema.else,
            _ = v !== void 0 && (e.opts.strictKeywords ? typeof v == "object" && Object.keys(v).length > 0 || v === !1 : e.util.schemaHasRules(v, e.RULES.all)),
            x = b !== void 0 && (e.opts.strictKeywords ? typeof b == "object" && Object.keys(b).length > 0 || b === !1 : e.util.schemaHasRules(b, e.RULES.all)),
            S = m.baseId;
        if (_ || x) {
            var E;
            m.createErrors = !1, m.schema = a, m.schemaPath = l, m.errSchemaPath = u, i += " var " + p + " = errors; var " + d + " = true;  ";
            var A = e.compositeRule;
            e.compositeRule = m.compositeRule = !0, i += "  " + e.validate(m) + " ", m.baseId = S, m.createErrors = !0, i += "  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; }  ", e.compositeRule = m.compositeRule = A, _ ? (i += " if (" + y + ") {  ", m.schema = e.schema.then, m.schemaPath = e.schemaPath + ".then", m.errSchemaPath = e.errSchemaPath + "/then", i += "  " + e.validate(m) + " ", m.baseId = S, i += " " + d + " = " + y + "; ", _ && x ? (E = "ifClause" + s, i += " var " + E + " = 'then'; ") : E = "'then'", i += " } ", x && (i += " else { ")) : i += " if (!" + y + ") { ", x && (m.schema = e.schema.else, m.schemaPath = e.schemaPath + ".else", m.errSchemaPath = e.errSchemaPath + "/else", i += "  " + e.validate(m) + " ", m.baseId = S, i += " " + d + " = " + y + "; ", _ && x ? (E = "ifClause" + s, i += " var " + E + " = 'else'; ") : E = "'else'", i += " } "), i += " if (!" + d + ") {   var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { failingKeyword: " + E + " } ", e.opts.messages !== !1 && (i += ` , message: 'should match "' + ` + E + ` + '" schema' `), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? i += " throw new ValidationError(vErrors); " : i += " validate.errors = vErrors; return false; "), i += " }   ", c && (i += " else { ")
        } else c && (i += " if (true) { ");
        return i
    },
    zoe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = "errs__" + s,
            m = e.util.copy(e),
            y = "";
        m.level++;
        var v = "valid" + m.level,
            b = "i" + s,
            _ = m.dataLevel = e.dataLevel + 1,
            x = "data" + _,
            S = e.baseId;
        if (i += "var " + p + " = errors;var " + d + ";", Array.isArray(a)) {
            var E = e.schema.additionalItems;
            if (E === !1) {
                i += " " + d + " = " + f + ".length <= " + a.length + "; ";
                var A = u;
                u = e.errSchemaPath + "/additionalItems", i += "  if (!" + d + ") {   ";
                var T = T || [];
                T.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + a.length + " } ", e.opts.messages !== !1 && (i += " , message: 'should NOT have more than " + a.length + " items' "), e.opts.verbose && (i += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
                var M = i;
                i = T.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + M + "]); " : i += " validate.errors = [" + M + "]; return false; " : i += " var err = " + M + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", u = A, c && (y += "}", i += " else { ")
            }
            var I = a;
            if (I) {
                for (var O, k = -1, H = I.length - 1; k < H;)
                    if (O = I[k += 1], e.opts.strictKeywords ? typeof O == "object" && Object.keys(O).length > 0 || O === !1 : e.util.schemaHasRules(O, e.RULES.all)) {
                        i += " " + v + " = true; if (" + f + ".length > " + k + ") { ";
                        var N = f + "[" + k + "]";
                        m.schema = O, m.schemaPath = l + "[" + k + "]", m.errSchemaPath = u + "/" + k, m.errorPath = e.util.getPathExpr(e.errorPath, k, e.opts.jsonPointers, !0), m.dataPathArr[_] = k;
                        var B = e.validate(m);
                        m.baseId = S, e.util.varOccurences(B, x) < 2 ? i += " " + e.util.varReplace(B, x, N) + " " : i += " var " + x + " = " + N + "; " + B + " ", i += " }  ", c && (i += " if (" + v + ") { ", y += "}")
                    }
            }
            if (typeof E == "object" && (e.opts.strictKeywords ? typeof E == "object" && Object.keys(E).length > 0 || E === !1 : e.util.schemaHasRules(E, e.RULES.all))) {
                m.schema = E, m.schemaPath = e.schemaPath + ".additionalItems", m.errSchemaPath = e.errSchemaPath + "/additionalItems", i += " " + v + " = true; if (" + f + ".length > " + a.length + ") {  for (var " + b + " = " + a.length + "; " + b + " < " + f + ".length; " + b + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, b, e.opts.jsonPointers, !0);
                var N = f + "[" + b + "]";
                m.dataPathArr[_] = b;
                var B = e.validate(m);
                m.baseId = S, e.util.varOccurences(B, x) < 2 ? i += " " + e.util.varReplace(B, x, N) + " " : i += " var " + x + " = " + N + "; " + B + " ", c && (i += " if (!" + v + ") break; "), i += " } }  ", c && (i += " if (" + v + ") { ", y += "}")
            }
        } else if (e.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : e.util.schemaHasRules(a, e.RULES.all)) {
            m.schema = a, m.schemaPath = l, m.errSchemaPath = u, i += "  for (var " + b + " = 0; " + b + " < " + f + ".length; " + b + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, b, e.opts.jsonPointers, !0);
            var N = f + "[" + b + "]";
            m.dataPathArr[_] = b;
            var B = e.validate(m);
            m.baseId = S, e.util.varOccurences(B, x) < 2 ? i += " " + e.util.varReplace(B, x, N) + " " : i += " var " + x + " = " + N + "; " + B + " ", c && (i += " if (!" + v + ") break; "), i += " }"
        }
        return c && (i += " " + y + " if (" + p + " == errors) {"), i
    },
    zN = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            S, f = "data" + (o || ""),
            d = e.opts.$data && a && a.$data,
            p;
        d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a;
        var m = n == "maximum",
            y = m ? "exclusiveMaximum" : "exclusiveMinimum",
            v = e.schema[y],
            b = e.opts.$data && v && v.$data,
            _ = m ? "<" : ">",
            x = m ? ">" : "<",
            S = void 0;
        if (!(d || typeof a == "number" || a === void 0)) throw new Error(n + " must be number");
        if (!(b || v === void 0 || typeof v == "number" || typeof v == "boolean")) throw new Error(y + " must be number or boolean");
        if (b) {
            var E = e.util.getData(v.$data, o, e.dataPathArr),
                A = "exclusive" + s,
                T = "exclType" + s,
                M = "exclIsNumber" + s,
                I = "op" + s,
                O = "' + " + I + " + '";
            i += " var schemaExcl" + s + " = " + E + "; ", E = "schemaExcl" + s, i += " var " + A + "; var " + T + " = typeof " + E + "; if (" + T + " != 'boolean' && " + T + " != 'undefined' && " + T + " != 'number') { ";
            var S = y,
                k = k || [];
            k.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (S || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (i += " , message: '" + y + " should be boolean' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
            var H = i;
            i = k.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + H + "]); " : i += " validate.errors = [" + H + "]; return false; " : i += " var err = " + H + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } else if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), i += " " + T + " == 'number' ? ( (" + A + " = " + p + " === undefined || " + E + " " + _ + "= " + p + ") ? " + f + " " + x + "= " + E + " : " + f + " " + x + " " + p + " ) : ( (" + A + " = " + E + " === true) ? " + f + " " + x + "= " + p + " : " + f + " " + x + " " + p + " ) || " + f + " !== " + f + ") { var op" + s + " = " + A + " ? '" + _ + "' : '" + _ + "='; ", a === void 0 && (S = y, u = e.errSchemaPath + "/" + y, p = E, d = b)
        } else {
            var M = typeof v == "number",
                O = _;
            if (M && d) {
                var I = "'" + O + "'";
                i += " if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), i += " ( " + p + " === undefined || " + v + " " + _ + "= " + p + " ? " + f + " " + x + "= " + v + " : " + f + " " + x + " " + p + " ) || " + f + " !== " + f + ") { "
            } else {
                M && a === void 0 ? (A = !0, S = y, u = e.errSchemaPath + "/" + y, p = v, x += "=") : (M && (p = Math[m ? "min" : "max"](v, a)), v === (M ? p : !0) ? (A = !0, S = y, u = e.errSchemaPath + "/" + y, x += "=") : (A = !1, O += "="));
                var I = "'" + O + "'";
                i += " if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), i += " " + f + " " + x + " " + p + " || " + f + " !== " + f + ") { "
            }
        }
        S = S || n;
        var k = k || [];
        k.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (S || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + I + ", limit: " + p + ", exclusive: " + A + " } ", e.opts.messages !== !1 && (i += " , message: 'should be " + O + " ", d ? i += "' + " + p : i += "" + p + "'"), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var H = i;
        return i = k.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + H + "]); " : i += " validate.errors = [" + H + "]; return false; " : i += " var err = " + H + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", c && (i += " else { "), i
    },
    HN = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            y, f = "data" + (o || ""),
            d = e.opts.$data && a && a.$data,
            p;
        if (d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a, !(d || typeof a == "number")) throw new Error(n + " must be number");
        var m = n == "maxItems" ? ">" : "<";
        i += "if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), i += " " + f + ".length " + m + " " + p + ") { ";
        var y = n,
            v = v || [];
        v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (y || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ", e.opts.messages !== !1 && (i += " , message: 'should NOT have ", n == "maxItems" ? i += "more" : i += "fewer", i += " than ", d ? i += "' + " + p + " + '" : i += "" + a, i += " items' "), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var b = i;
        return i = v.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", c && (i += " else { "), i
    },
    UN = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            y, f = "data" + (o || ""),
            d = e.opts.$data && a && a.$data,
            p;
        if (d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a, !(d || typeof a == "number")) throw new Error(n + " must be number");
        var m = n == "maxLength" ? ">" : "<";
        i += "if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), e.opts.unicode === !1 ? i += " " + f + ".length " : i += " ucs2length(" + f + ") ", i += " " + m + " " + p + ") { ";
        var y = n,
            v = v || [];
        v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (y || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ", e.opts.messages !== !1 && (i += " , message: 'should NOT be ", n == "maxLength" ? i += "longer" : i += "shorter", i += " than ", d ? i += "' + " + p + " + '" : i += "" + a, i += " characters' "), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var b = i;
        return i = v.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", c && (i += " else { "), i
    },
    $N = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            y, f = "data" + (o || ""),
            d = e.opts.$data && a && a.$data,
            p;
        if (d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a, !(d || typeof a == "number")) throw new Error(n + " must be number");
        var m = n == "maxProperties" ? ">" : "<";
        i += "if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), i += " Object.keys(" + f + ").length " + m + " " + p + ") { ";
        var y = n,
            v = v || [];
        v.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (y || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ", e.opts.messages !== !1 && (i += " , message: 'should NOT have ", n == "maxProperties" ? i += "more" : i += "fewer", i += " than ", d ? i += "' + " + p + " + '" : i += "" + a, i += " properties' "), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var b = i;
        return i = v.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + b + "]); " : i += " validate.errors = [" + b + "]; return false; " : i += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", c && (i += " else { "), i
    },
    Hoe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = e.opts.$data && a && a.$data,
            p;
        if (d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a, !(d || typeof a == "number")) throw new Error(n + " must be number");
        i += "var division" + s + ";if (", d && (i += " " + p + " !== undefined && ( typeof " + p + " != 'number' || "), i += " (division" + s + " = " + f + " / " + p + ", ", e.opts.multipleOfPrecision ? i += " Math.abs(Math.round(division" + s + ") - division" + s + ") > 1e-" + e.opts.multipleOfPrecision + " " : i += " division" + s + " !== parseInt(division" + s + ") ", i += " ) ", d && (i += "  )  "), i += " ) {   ";
        var m = m || [];
        m.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { multipleOf: " + p + " } ", e.opts.messages !== !1 && (i += " , message: 'should be multiple of ", d ? i += "' + " + p : i += "" + p + "'"), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var y = i;
        return i = m.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + y + "]); " : i += " validate.errors = [" + y + "]; return false; " : i += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", c && (i += " else { "), i
    },
    Uoe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "errs__" + s,
            p = e.util.copy(e);
        p.level++;
        var m = "valid" + p.level;
        if (e.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : e.util.schemaHasRules(a, e.RULES.all)) {
            p.schema = a, p.schemaPath = l, p.errSchemaPath = u, i += " var " + d + " = errors;  ";
            var y = e.compositeRule;
            e.compositeRule = p.compositeRule = !0, p.createErrors = !1;
            var v;
            p.opts.allErrors && (v = p.opts.allErrors, p.opts.allErrors = !1), i += " " + e.validate(p) + " ", p.createErrors = !0, v && (p.opts.allErrors = v), e.compositeRule = p.compositeRule = y, i += " if (" + m + ") {   ";
            var b = b || [];
            b.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (i += " , message: 'should NOT be valid' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
            var _ = i;
            i = b.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + _ + "]); " : i += " validate.errors = [" + _ + "]; return false; " : i += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } else {  errors = " + d + "; if (vErrors !== null) { if (" + d + ") vErrors.length = " + d + "; else vErrors = null; } ", e.opts.allErrors && (i += " } ")
        } else i += "  var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (i += " , message: 'should NOT be valid' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c && (i += " if (false) { ");
        return i
    },
    $oe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = "errs__" + s,
            m = e.util.copy(e),
            y = "";
        m.level++;
        var v = "valid" + m.level,
            b = m.baseId,
            _ = "prevValid" + s,
            x = "passingSchemas" + s;
        i += "var " + p + " = errors , " + _ + " = false , " + d + " = false , " + x + " = null; ";
        var S = e.compositeRule;
        e.compositeRule = m.compositeRule = !0;
        var E = a;
        if (E)
            for (var A, T = -1, M = E.length - 1; T < M;) A = E[T += 1], (e.opts.strictKeywords ? typeof A == "object" && Object.keys(A).length > 0 || A === !1 : e.util.schemaHasRules(A, e.RULES.all)) ? (m.schema = A, m.schemaPath = l + "[" + T + "]", m.errSchemaPath = u + "/" + T, i += "  " + e.validate(m) + " ", m.baseId = b) : i += " var " + v + " = true; ", T && (i += " if (" + v + " && " + _ + ") { " + d + " = false; " + x + " = [" + x + ", " + T + "]; } else { ", y += "}"), i += " if (" + v + ") { " + d + " = " + _ + " = true; " + x + " = " + T + "; }";
        return e.compositeRule = m.compositeRule = S, i += "" + y + "if (!" + d + ") {   var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { passingSchemas: " + x + " } ", e.opts.messages !== !1 && (i += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? i += " throw new ValidationError(vErrors); " : i += " validate.errors = vErrors; return false; "), i += "} else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; }", e.opts.allErrors && (i += " } "), i
    },
    Goe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = e.opts.$data && a && a.$data,
            p;
        d ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", p = "schema" + s) : p = a;
        var m = d ? "(new RegExp(" + p + "))" : e.usePattern(a);
        i += "if ( ", d && (i += " (" + p + " !== undefined && typeof " + p + " != 'string') || "), i += " !" + m + ".test(" + f + ") ) {   ";
        var y = y || [];
        y.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { pattern:  ", d ? i += "" + p : i += "" + e.util.toQuotedString(a), i += "  } ", e.opts.messages !== !1 && (i += ` , message: 'should match pattern "`, d ? i += "' + " + p + " + '" : i += "" + e.util.escapeQuotes(a), i += `"' `), e.opts.verbose && (i += " , schema:  ", d ? i += "validate.schema" + l : i += "" + e.util.toQuotedString(a), i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
        var v = i;
        return i = y.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + v + "]); " : i += " validate.errors = [" + v + "]; return false; " : i += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", c && (i += " else { "), i
    },
    Voe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "errs__" + s,
            p = e.util.copy(e),
            m = "";
        p.level++;
        var y = "valid" + p.level,
            v = "key" + s,
            b = "idx" + s,
            _ = p.dataLevel = e.dataLevel + 1,
            x = "data" + _,
            S = "dataProperties" + s,
            E = Object.keys(a || {}).filter(F),
            A = e.schema.patternProperties || {},
            T = Object.keys(A).filter(F),
            M = e.schema.additionalProperties,
            I = E.length || T.length,
            O = M === !1,
            k = typeof M == "object" && Object.keys(M).length,
            H = e.opts.removeAdditional,
            N = O || k || H,
            B = e.opts.ownProperties,
            U = e.baseId,
            q = e.schema.required;
        if (q && !(e.opts.$data && q.$data) && q.length < e.opts.loopRequired) var Q = e.util.toHash(q);

        function F(Ue) {
            return Ue !== "__proto__"
        }
        if (i += "var " + d + " = errors;var " + y + " = true;", B && (i += " var " + S + " = undefined;"), N) {
            if (B ? i += " " + S + " = " + S + " || Object.keys(" + f + "); for (var " + b + "=0; " + b + "<" + S + ".length; " + b + "++) { var " + v + " = " + S + "[" + b + "]; " : i += " for (var " + v + " in " + f + ") { ", I) {
                if (i += " var isAdditional" + s + " = !(false ", E.length)
                    if (E.length > 8) i += " || validate.schema" + l + ".hasOwnProperty(" + v + ") ";
                    else {
                        var G = E;
                        if (G)
                            for (var W, se = -1, ee = G.length - 1; se < ee;) W = G[se += 1], i += " || " + v + " == " + e.util.toQuotedString(W) + " "
                    }
                if (T.length) {
                    var ae = T;
                    if (ae)
                        for (var de, re = -1, _e = ae.length - 1; re < _e;) de = ae[re += 1], i += " || " + e.usePattern(de) + ".test(" + v + ") "
                }
                i += " ); if (isAdditional" + s + ") { "
            }
            if (H == "all") i += " delete " + f + "[" + v + "]; ";
            else {
                var fe = e.errorPath,
                    ue = "' + " + v + " + '";
                if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers)), O)
                    if (H) i += " delete " + f + "[" + v + "]; ";
                    else {
                        i += " " + y + " = false; ";
                        var ve = u;
                        u = e.errSchemaPath + "/additionalProperties";
                        var xe = xe || [];
                        xe.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { additionalProperty: '" + ue + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is an invalid additional property" : i += "should NOT have additional properties", i += "' "), e.opts.verbose && (i += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
                        var be = i;
                        i = xe.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + be + "]); " : i += " validate.errors = [" + be + "]; return false; " : i += " var err = " + be + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u = ve, c && (i += " break; ")
                    }
                else if (k)
                    if (H == "failing") {
                        i += " var " + d + " = errors;  ";
                        var he = e.compositeRule;
                        e.compositeRule = p.compositeRule = !0, p.schema = M, p.schemaPath = e.schemaPath + ".additionalProperties", p.errSchemaPath = e.errSchemaPath + "/additionalProperties", p.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                        var me = f + "[" + v + "]";
                        p.dataPathArr[_] = v;
                        var Ce = e.validate(p);
                        p.baseId = U, e.util.varOccurences(Ce, x) < 2 ? i += " " + e.util.varReplace(Ce, x, me) + " " : i += " var " + x + " = " + me + "; " + Ce + " ", i += " if (!" + y + ") { errors = " + d + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + f + "[" + v + "]; }  ", e.compositeRule = p.compositeRule = he
                    } else {
                        p.schema = M, p.schemaPath = e.schemaPath + ".additionalProperties", p.errSchemaPath = e.errSchemaPath + "/additionalProperties", p.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                        var me = f + "[" + v + "]";
                        p.dataPathArr[_] = v;
                        var Ce = e.validate(p);
                        p.baseId = U, e.util.varOccurences(Ce, x) < 2 ? i += " " + e.util.varReplace(Ce, x, me) + " " : i += " var " + x + " = " + me + "; " + Ce + " ", c && (i += " if (!" + y + ") break; ")
                    }
                e.errorPath = fe
            }
            I && (i += " } "), i += " }  ", c && (i += " if (" + y + ") { ", m += "}")
        }
        var Ne = e.opts.useDefaults && !e.compositeRule;
        if (E.length) {
            var De = E;
            if (De)
                for (var W, je = -1, Ke = De.length - 1; je < Ke;) {
                    W = De[je += 1];
                    var He = a[W];
                    if (e.opts.strictKeywords ? typeof He == "object" && Object.keys(He).length > 0 || He === !1 : e.util.schemaHasRules(He, e.RULES.all)) {
                        var qe = e.util.getProperty(W),
                            me = f + qe,
                            Xe = Ne && He.default !== void 0;
                        p.schema = He, p.schemaPath = l + qe, p.errSchemaPath = u + "/" + e.util.escapeFragment(W), p.errorPath = e.util.getPath(e.errorPath, W, e.opts.jsonPointers), p.dataPathArr[_] = e.util.toQuotedString(W);
                        var Ce = e.validate(p);
                        if (p.baseId = U, e.util.varOccurences(Ce, x) < 2) {
                            Ce = e.util.varReplace(Ce, x, me);
                            var K = me
                        } else {
                            var K = x;
                            i += " var " + x + " = " + me + "; "
                        }
                        if (Xe) i += " " + Ce + " ";
                        else {
                            if (Q && Q[W]) {
                                i += " if ( " + K + " === undefined ", B && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(W) + "') "), i += ") { " + y + " = false; ";
                                var fe = e.errorPath,
                                    ve = u,
                                    V = e.util.escapeQuotes(W);
                                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(fe, W, e.opts.jsonPointers)), u = e.errSchemaPath + "/required";
                                var xe = xe || [];
                                xe.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + V + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is a required property" : i += "should have required property \\'" + V + "\\'", i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
                                var be = i;
                                i = xe.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + be + "]); " : i += " validate.errors = [" + be + "]; return false; " : i += " var err = " + be + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u = ve, e.errorPath = fe, i += " } else { "
                            } else c ? (i += " if ( " + K + " === undefined ", B && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(W) + "') "), i += ") { " + y + " = true; } else { ") : (i += " if (" + K + " !== undefined ", B && (i += " &&   Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(W) + "') "), i += " ) { ");
                            i += " " + Ce + " } "
                        }
                    }
                    c && (i += " if (" + y + ") { ", m += "}")
                }
        }
        if (T.length) {
            var ge = T;
            if (ge)
                for (var de, Be = -1, ze = ge.length - 1; Be < ze;) {
                    de = ge[Be += 1];
                    var He = A[de];
                    if (e.opts.strictKeywords ? typeof He == "object" && Object.keys(He).length > 0 || He === !1 : e.util.schemaHasRules(He, e.RULES.all)) {
                        p.schema = He, p.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(de), p.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(de), B ? i += " " + S + " = " + S + " || Object.keys(" + f + "); for (var " + b + "=0; " + b + "<" + S + ".length; " + b + "++) { var " + v + " = " + S + "[" + b + "]; " : i += " for (var " + v + " in " + f + ") { ", i += " if (" + e.usePattern(de) + ".test(" + v + ")) { ", p.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
                        var me = f + "[" + v + "]";
                        p.dataPathArr[_] = v;
                        var Ce = e.validate(p);
                        p.baseId = U, e.util.varOccurences(Ce, x) < 2 ? i += " " + e.util.varReplace(Ce, x, me) + " " : i += " var " + x + " = " + me + "; " + Ce + " ", c && (i += " if (!" + y + ") break; "), i += " } ", c && (i += " else " + y + " = true; "), i += " }  ", c && (i += " if (" + y + ") { ", m += "}")
                    }
                }
        }
        return c && (i += " " + m + " if (" + d + " == errors) {"), i
    },
    joe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "errs__" + s,
            p = e.util.copy(e),
            m = "";
        p.level++;
        var y = "valid" + p.level;
        if (i += "var " + d + " = errors;", e.opts.strictKeywords ? typeof a == "object" && Object.keys(a).length > 0 || a === !1 : e.util.schemaHasRules(a, e.RULES.all)) {
            p.schema = a, p.schemaPath = l, p.errSchemaPath = u;
            var v = "key" + s,
                b = "idx" + s,
                _ = "i" + s,
                x = "' + " + v + " + '",
                S = p.dataLevel = e.dataLevel + 1,
                E = "data" + S,
                A = "dataProperties" + s,
                T = e.opts.ownProperties,
                M = e.baseId;
            T && (i += " var " + A + " = undefined; "), T ? i += " " + A + " = " + A + " || Object.keys(" + f + "); for (var " + b + "=0; " + b + "<" + A + ".length; " + b + "++) { var " + v + " = " + A + "[" + b + "]; " : i += " for (var " + v + " in " + f + ") { ", i += " var startErrs" + s + " = errors; ";
            var I = v,
                O = e.compositeRule;
            e.compositeRule = p.compositeRule = !0;
            var k = e.validate(p);
            p.baseId = M, e.util.varOccurences(k, E) < 2 ? i += " " + e.util.varReplace(k, E, I) + " " : i += " var " + E + " = " + I + "; " + k + " ", e.compositeRule = p.compositeRule = O, i += " if (!" + y + ") { for (var " + _ + "=startErrs" + s + "; " + _ + "<errors; " + _ + "++) { vErrors[" + _ + "].propertyName = " + v + "; }   var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { propertyName: '" + x + "' } ", e.opts.messages !== !1 && (i += " , message: 'property name \\'" + x + "\\' is invalid' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? i += " throw new ValidationError(vErrors); " : i += " validate.errors = vErrors; return false; "), c && (i += " break; "), i += " } }"
        }
        return c && (i += " " + m + " if (" + d + " == errors) {"), i
    },
    Woe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = e.opts.$data && a && a.$data;
        p && (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ");
        var m = "schema" + s;
        if (!p)
            if (a.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
                var y = [],
                    v = a;
                if (v)
                    for (var b, _ = -1, x = v.length - 1; _ < x;) {
                        b = v[_ += 1];
                        var S = e.schema.properties[b];
                        S && (e.opts.strictKeywords ? typeof S == "object" && Object.keys(S).length > 0 || S === !1 : e.util.schemaHasRules(S, e.RULES.all)) || (y[y.length] = b)
                    }
            } else var y = a;
        if (p || y.length) {
            var E = e.errorPath,
                A = p || y.length >= e.opts.loopRequired,
                T = e.opts.ownProperties;
            if (c)
                if (i += " var missing" + s + "; ", A) {
                    p || (i += " var " + m + " = validate.schema" + l + "; ");
                    var M = "i" + s,
                        I = "schema" + s + "[" + M + "]",
                        O = "' + " + I + " + '";
                    e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(E, I, e.opts.jsonPointers)), i += " var " + d + " = true; ", p && (i += " if (schema" + s + " === undefined) " + d + " = true; else if (!Array.isArray(schema" + s + ")) " + d + " = false; else {"), i += " for (var " + M + " = 0; " + M + " < " + m + ".length; " + M + "++) { " + d + " = " + f + "[" + m + "[" + M + "]] !== undefined ", T && (i += " &&   Object.prototype.hasOwnProperty.call(" + f + ", " + m + "[" + M + "]) "), i += "; if (!" + d + ") break; } ", p && (i += "  }  "), i += "  if (!" + d + ") {   ";
                    var k = k || [];
                    k.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + O + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is a required property" : i += "should have required property \\'" + O + "\\'", i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
                    var H = i;
                    i = k.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + H + "]); " : i += " validate.errors = [" + H + "]; return false; " : i += " var err = " + H + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } else { "
                } else {
                    i += " if ( ";
                    var N = y;
                    if (N)
                        for (var B, M = -1, U = N.length - 1; M < U;) {
                            B = N[M += 1], M && (i += " || ");
                            var q = e.util.getProperty(B),
                                Q = f + q;
                            i += " ( ( " + Q + " === undefined ", T && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(B) + "') "), i += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? B : q) + ") ) "
                        }
                    i += ") {  ";
                    var I = "missing" + s,
                        O = "' + " + I + " + '";
                    e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(E, I, !0) : E + " + " + I);
                    var k = k || [];
                    k.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + O + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is a required property" : i += "should have required property \\'" + O + "\\'", i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
                    var H = i;
                    i = k.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + H + "]); " : i += " validate.errors = [" + H + "]; return false; " : i += " var err = " + H + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } else { "
                }
            else if (A) {
                p || (i += " var " + m + " = validate.schema" + l + "; ");
                var M = "i" + s,
                    I = "schema" + s + "[" + M + "]",
                    O = "' + " + I + " + '";
                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(E, I, e.opts.jsonPointers)), p && (i += " if (" + m + " && !Array.isArray(" + m + ")) {  var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + O + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is a required property" : i += "should have required property \\'" + O + "\\'", i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + m + " !== undefined) { "), i += " for (var " + M + " = 0; " + M + " < " + m + ".length; " + M + "++) { if (" + f + "[" + m + "[" + M + "]] === undefined ", T && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", " + m + "[" + M + "]) "), i += ") {  var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + O + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is a required property" : i += "should have required property \\'" + O + "\\'", i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", p && (i += "  }  ")
            } else {
                var F = y;
                if (F)
                    for (var B, G = -1, W = F.length - 1; G < W;) {
                        B = F[G += 1];
                        var q = e.util.getProperty(B),
                            O = e.util.escapeQuotes(B),
                            Q = f + q;
                        e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(E, B, e.opts.jsonPointers)), i += " if ( " + Q + " === undefined ", T && (i += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(B) + "') "), i += ") {  var err =   ", e.createErrors !== !1 ? (i += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + O + "' } ", e.opts.messages !== !1 && (i += " , message: '", e.opts._errorDataPathProperty ? i += "is a required property" : i += "should have required property \\'" + O + "\\'", i += "' "), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
                    }
            }
            e.errorPath = E
        } else c && (i += " if (true) {");
        return i
    },
    Koe = function(e, n, r) {
        var i = " ",
            s = e.level,
            o = e.dataLevel,
            a = e.schema[n],
            l = e.schemaPath + e.util.getProperty(n),
            u = e.errSchemaPath + "/" + n,
            c = !e.opts.allErrors,
            f = "data" + (o || ""),
            d = "valid" + s,
            p = e.opts.$data && a && a.$data,
            m;
        if (p ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", m = "schema" + s) : m = a, (a || p) && e.opts.uniqueItems !== !1) {
            p && (i += " var " + d + "; if (" + m + " === false || " + m + " === undefined) " + d + " = true; else if (typeof " + m + " != 'boolean') " + d + " = false; else { "), i += " var i = " + f + ".length , " + d + " = true , j; if (i > 1) { ";
            var y = e.schema.items && e.schema.items.type,
                v = Array.isArray(y);
            if (!y || y == "object" || y == "array" || v && (y.indexOf("object") >= 0 || y.indexOf("array") >= 0)) i += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + f + "[i], " + f + "[j])) { " + d + " = false; break outer; } } } ";
            else {
                i += " var itemIndices = {}, item; for (;i--;) { var item = " + f + "[i]; ";
                var b = "checkDataType" + (v ? "s" : "");
                i += " if (" + e.util[b](y, "item", e.opts.strictNumbers, !0) + ") continue; ", v && (i += ` if (typeof item == 'string') item = '"' + item; `), i += " if (typeof itemIndices[item] == 'number') { " + d + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "
            }
            i += " } ", p && (i += "  }  "), i += " if (!" + d + ") {   ";
            var _ = _ || [];
            _.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { i: i, j: j } ", e.opts.messages !== !1 && (i += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (i += " , schema:  ", p ? i += "validate.schema" + l : i += "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), i += " } ") : i += " {} ";
            var x = i;
            i = _.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + x + "]); " : i += " validate.errors = [" + x + "]; return false; " : i += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", c && (i += " else { ")
        } else c && (i += " if (true) { ");
        return i
    },
    qoe = {
        $ref: Poe,
        allOf: Ioe,
        anyOf: Roe,
        $comment: Ooe,
        const: Doe,
        contains: Loe,
        dependencies: koe,
        enum: Boe,
        format: Foe,
        if: Noe,
        items: zoe,
        maximum: zN,
        minimum: zN,
        maxItems: HN,
        minItems: HN,
        maxLength: UN,
        minLength: UN,
        maxProperties: $N,
        minProperties: $N,
        multipleOf: Hoe,
        not: Uoe,
        oneOf: $oe,
        pattern: Goe,
        properties: Voe,
        propertyNames: joe,
        required: Woe,
        uniqueItems: Koe,
        validate: RV
    },
    GN = qoe,
    IM = mg.toHash,
    Xoe = function() {
        var e = [{
                type: "number",
                rules: [{
                    maximum: ["exclusiveMaximum"]
                }, {
                    minimum: ["exclusiveMinimum"]
                }, "multipleOf", "format"]
            }, {
                type: "string",
                rules: ["maxLength", "minLength", "pattern", "format"]
            }, {
                type: "array",
                rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
            }, {
                type: "object",
                rules: ["maxProperties", "minProperties", "required", "dependencies", "propertyNames", {
                    properties: ["additionalProperties", "patternProperties"]
                }]
            }, {
                rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"]
            }],
            n = ["type", "$comment"],
            r = ["$schema", "$id", "id", "$data", "$async", "title", "description", "default", "definitions", "examples", "readOnly", "writeOnly", "contentMediaType", "contentEncoding", "additionalItems", "then", "else"],
            i = ["number", "integer", "string", "array", "object", "boolean", "null"];
        return e.all = IM(n), e.types = IM(i), e.forEach(function(s) {
            s.rules = s.rules.map(function(o) {
                var a;
                if (typeof o == "object") {
                    var l = Object.keys(o)[0];
                    a = o[l], o = l, a.forEach(function(c) {
                        n.push(c), e.all[c] = !0
                    })
                }
                n.push(o);
                var u = e.all[o] = {
                    keyword: o,
                    code: GN[o],
                    implements: a
                };
                return u
            }), e.all.$comment = {
                keyword: "$comment",
                code: GN.$comment
            }, s.type && (e.types[s.type] = s)
        }), e.keywords = IM(n.concat(r)), e.custom = {}, e
    },
    VN = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "additionalItems", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "additionalProperties", "enum", "format", "const"],
    Joe = function(t, e) {
        for (var n = 0; n < e.length; n++) {
            t = JSON.parse(JSON.stringify(t));
            var r = e[n].split("/"),
                i = t,
                s;
            for (s = 1; s < r.length; s++) i = i[r[s]];
            for (s = 0; s < VN.length; s++) {
                var o = VN[s],
                    a = i[o];
                a && (i[o] = {
                    anyOf: [a, {
                        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                    }]
                })
            }
        }
        return t
    },
    Yoe = eL.MissingRef,
    Qoe = jV;

function jV(t, e, n) {
    var r = this;
    if (typeof this._opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
    typeof e == "function" && (n = e, e = void 0);
    var i = s(t).then(function() {
        var a = r._addSchema(t, void 0, e);
        return a.validate || o(a)
    });
    return n && i.then(function(a) {
        n(null, a)
    }, n), i;

    function s(a) {
        var l = a.$schema;
        return l && !r.getSchema(l) ? jV.call(r, {
            $ref: l
        }, !0) : Promise.resolve()
    }

    function o(a) {
        try {
            return r._compile(a)
        } catch (u) {
            if (u instanceof Yoe) return l(u);
            throw u
        }

        function l(u) {
            var c = u.missingSchema;
            if (p(c)) throw new Error("Schema " + c + " is loaded but " + u.missingRef + " cannot be resolved");
            var f = r._loadingSchemas[c];
            return f || (f = r._loadingSchemas[c] = r._opts.loadSchema(c), f.then(d, d)), f.then(function(m) {
                if (!p(c)) return s(m).then(function() {
                    p(c) || r.addSchema(m, c, void 0, e)
                })
            }).then(function() {
                return o(a)
            });

            function d() {
                delete r._loadingSchemas[c]
            }

            function p(m) {
                return r._refs[m] || r._schemas[m]
            }
        }
    }
}
var Zoe = function(e, n, r) {
    var i = " ",
        s = e.level,
        o = e.dataLevel,
        a = e.schema[n],
        l = e.schemaPath + e.util.getProperty(n),
        u = e.errSchemaPath + "/" + n,
        c = !e.opts.allErrors,
        f, d = "data" + (o || ""),
        p = "valid" + s,
        m = "errs__" + s,
        y = e.opts.$data && a && a.$data,
        v;
    y ? (i += " var schema" + s + " = " + e.util.getData(a.$data, o, e.dataPathArr) + "; ", v = "schema" + s) : v = a;
    var b = this,
        _ = "definition" + s,
        x = b.definition,
        S = "",
        E, A, T, M, I;
    if (y && x.$data) {
        I = "keywordValidate" + s;
        var O = x.validateSchema;
        i += " var " + _ + " = RULES.custom['" + n + "'].definition; var " + I + " = " + _ + ".validate;"
    } else {
        if (M = e.useCustomRule(b, a, e.schema, e), !M) return;
        v = "validate.schema" + l, I = M.code, E = x.compile, A = x.inline, T = x.macro
    }
    var k = I + ".errors",
        H = "i" + s,
        N = "ruleErr" + s,
        B = x.async;
    if (B && !e.async) throw new Error("async keyword in sync schema");
    if (A || T || (i += "" + k + " = null;"), i += "var " + m + " = errors;var " + p + ";", y && x.$data && (S += "}", i += " if (" + v + " === undefined) { " + p + " = true; } else { ", O && (S += "}", i += " " + p + " = " + _ + ".validateSchema(" + v + "); if (" + p + ") { ")), A) x.statements ? i += " " + M.validate + " " : i += " " + p + " = " + M.validate + "; ";
    else if (T) {
        var U = e.util.copy(e),
            S = "";
        U.level++;
        var q = "valid" + U.level;
        U.schema = M.validate, U.schemaPath = "";
        var Q = e.compositeRule;
        e.compositeRule = U.compositeRule = !0;
        var F = e.validate(U).replace(/validate\.schema/g, I);
        e.compositeRule = U.compositeRule = Q, i += " " + F
    } else {
        var G = G || [];
        G.push(i), i = "", i += "  " + I + ".call( ", e.opts.passContext ? i += "this" : i += "self", E || x.schema === !1 ? i += " , " + d + " " : i += " , " + v + " , " + d + " , validate.schema" + e.schemaPath + " ", i += " , (dataPath || '')", e.errorPath != '""' && (i += " + " + e.errorPath);
        var W = o ? "data" + (o - 1 || "") : "parentData",
            se = o ? e.dataPathArr[o] : "parentDataProperty";
        i += " , " + W + " , " + se + " , rootData )  ";
        var ee = i;
        i = G.pop(), x.errors === !1 ? (i += " " + p + " = ", B && (i += "await "), i += "" + ee + "; ") : B ? (k = "customErrors" + s, i += " var " + k + " = null; try { " + p + " = await " + ee + "; } catch (e) { " + p + " = false; if (e instanceof ValidationError) " + k + " = e.errors; else throw e; } ") : i += " " + k + " = null; " + p + " = " + ee + "; "
    }
    if (x.modifying && (i += " if (" + W + ") " + d + " = " + W + "[" + se + "];"), i += "" + S, x.valid) c && (i += " if (true) { ");
    else {
        i += " if ( ", x.valid === void 0 ? (i += " !", T ? i += "" + q : i += "" + p) : i += " " + !x.valid + " ", i += ") { ", f = b.keyword;
        var G = G || [];
        G.push(i), i = "";
        var G = G || [];
        G.push(i), i = "", e.createErrors !== !1 ? (i += " { keyword: '" + (f || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + b.keyword + "' } ", e.opts.messages !== !1 && (i += ` , message: 'should pass "` + b.keyword + `" keyword validation' `), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), i += " } ") : i += " {} ";
        var ae = i;
        i = G.pop(), !e.compositeRule && c ? e.async ? i += " throw new ValidationError([" + ae + "]); " : i += " validate.errors = [" + ae + "]; return false; " : i += " var err = " + ae + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        var de = i;
        i = G.pop(), A ? x.errors ? x.errors != "full" && (i += "  for (var " + H + "=" + m + "; " + H + "<errors; " + H + "++) { var " + N + " = vErrors[" + H + "]; if (" + N + ".dataPath === undefined) " + N + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + N + ".schemaPath === undefined) { " + N + '.schemaPath = "' + u + '"; } ', e.opts.verbose && (i += " " + N + ".schema = " + v + "; " + N + ".data = " + d + "; "), i += " } ") : x.errors === !1 ? i += " " + de + " " : (i += " if (" + m + " == errors) { " + de + " } else {  for (var " + H + "=" + m + "; " + H + "<errors; " + H + "++) { var " + N + " = vErrors[" + H + "]; if (" + N + ".dataPath === undefined) " + N + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + N + ".schemaPath === undefined) { " + N + '.schemaPath = "' + u + '"; } ', e.opts.verbose && (i += " " + N + ".schema = " + v + "; " + N + ".data = " + d + "; "), i += " } } ") : T ? (i += "   var err =   ", e.createErrors !== !1 ? (i += " { keyword: '" + (f || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + b.keyword + "' } ", e.opts.messages !== !1 && (i += ` , message: 'should pass "` + b.keyword + `" keyword validation' `), e.opts.verbose && (i += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), i += " } ") : i += " {} ", i += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? i += " throw new ValidationError(vErrors); " : i += " validate.errors = vErrors; return false; ")) : x.errors === !1 ? i += " " + de + " " : (i += " if (Array.isArray(" + k + ")) { if (vErrors === null) vErrors = " + k + "; else vErrors = vErrors.concat(" + k + "); errors = vErrors.length;  for (var " + H + "=" + m + "; " + H + "<errors; " + H + "++) { var " + N + " = vErrors[" + H + "]; if (" + N + ".dataPath === undefined) " + N + ".dataPath = (dataPath || '') + " + e.errorPath + ";  " + N + '.schemaPath = "' + u + '";  ', e.opts.verbose && (i += " " + N + ".schema = " + v + "; " + N + ".data = " + d + "; "), i += " } } else { " + de + " } "), i += " } ", c && (i += " else { ")
    }
    return i
};
const eae = "http://json-schema.org/draft-07/schema#",
    tae = "http://json-schema.org/draft-07/schema#",
    nae = "Core schema meta-schema",
    rae = {
        schemaArray: {
            type: "array",
            minItems: 1,
            items: {
                $ref: "#"
            }
        },
        nonNegativeInteger: {
            type: "integer",
            minimum: 0
        },
        nonNegativeIntegerDefault0: {
            allOf: [{
                $ref: "#/definitions/nonNegativeInteger"
            }, {
                default: 0
            }]
        },
        simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
            type: "array",
            items: {
                type: "string"
            },
            uniqueItems: !0,
            default: []
        }
    },
    iae = ["object", "boolean"],
    sae = {
        $id: {
            type: "string",
            format: "uri-reference"
        },
        $schema: {
            type: "string",
            format: "uri"
        },
        $ref: {
            type: "string",
            format: "uri-reference"
        },
        $comment: {
            type: "string"
        },
        title: {
            type: "string"
        },
        description: {
            type: "string"
        },
        default: !0,
        readOnly: {
            type: "boolean",
            default: !1
        },
        examples: {
            type: "array",
            items: !0
        },
        multipleOf: {
            type: "number",
            exclusiveMinimum: 0
        },
        maximum: {
            type: "number"
        },
        exclusiveMaximum: {
            type: "number"
        },
        minimum: {
            type: "number"
        },
        exclusiveMinimum: {
            type: "number"
        },
        maxLength: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minLength: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        pattern: {
            type: "string",
            format: "regex"
        },
        additionalItems: {
            $ref: "#"
        },
        items: {
            anyOf: [{
                $ref: "#"
            }, {
                $ref: "#/definitions/schemaArray"
            }],
            default: !0
        },
        maxItems: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minItems: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        uniqueItems: {
            type: "boolean",
            default: !1
        },
        contains: {
            $ref: "#"
        },
        maxProperties: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minProperties: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        required: {
            $ref: "#/definitions/stringArray"
        },
        additionalProperties: {
            $ref: "#"
        },
        definitions: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        properties: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        patternProperties: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            propertyNames: {
                format: "regex"
            },
            default: {}
        },
        dependencies: {
            type: "object",
            additionalProperties: {
                anyOf: [{
                    $ref: "#"
                }, {
                    $ref: "#/definitions/stringArray"
                }]
            }
        },
        propertyNames: {
            $ref: "#"
        },
        const: !0,
        enum: {
            type: "array",
            items: !0,
            minItems: 1,
            uniqueItems: !0
        },
        type: {
            anyOf: [{
                $ref: "#/definitions/simpleTypes"
            }, {
                type: "array",
                items: {
                    $ref: "#/definitions/simpleTypes"
                },
                minItems: 1,
                uniqueItems: !0
            }]
        },
        format: {
            type: "string"
        },
        contentMediaType: {
            type: "string"
        },
        contentEncoding: {
            type: "string"
        },
        if: {
            $ref: "#"
        },
        then: {
            $ref: "#"
        },
        else: {
            $ref: "#"
        },
        allOf: {
            $ref: "#/definitions/schemaArray"
        },
        anyOf: {
            $ref: "#/definitions/schemaArray"
        },
        oneOf: {
            $ref: "#/definitions/schemaArray"
        },
        not: {
            $ref: "#"
        }
    },
    WV = {
        $schema: eae,
        $id: tae,
        title: nae,
        definitions: rae,
        type: iae,
        properties: sae,
        default: !0
    };
var jN = WV,
    oae = {
        $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
        definitions: {
            simpleTypes: jN.definitions.simpleTypes
        },
        type: "object",
        dependencies: {
            schema: ["validate"],
            $data: ["validate"],
            statements: ["inline"],
            valid: {
                not: {
                    required: ["macro"]
                }
            }
        },
        properties: {
            type: jN.properties.type,
            schema: {
                type: "boolean"
            },
            statements: {
                type: "boolean"
            },
            dependencies: {
                type: "array",
                items: {
                    type: "string"
                }
            },
            metaSchema: {
                type: "object"
            },
            modifying: {
                type: "boolean"
            },
            valid: {
                type: "boolean"
            },
            $data: {
                type: "boolean"
            },
            async: {
                type: "boolean"
            },
            errors: {
                anyOf: [{
                    type: "boolean"
                }, {
                    const: "full"
                }]
            }
        }
    },
    aae = /^[a-z_$][a-z0-9_$-]*$/i,
    lae = Zoe,
    uae = oae,
    cae = {
        add: fae,
        get: dae,
        remove: pae,
        validate: jI
    };

function fae(t, e) {
    var n = this.RULES;
    if (n.keywords[t]) throw new Error("Keyword " + t + " is already defined");
    if (!aae.test(t)) throw new Error("Keyword " + t + " is not a valid identifier");
    if (e) {
        this.validateKeyword(e, !0);
        var r = e.type;
        if (Array.isArray(r))
            for (var i = 0; i < r.length; i++) o(t, r[i], e);
        else o(t, r, e);
        var s = e.metaSchema;
        s && (e.$data && this._opts.$data && (s = {
            anyOf: [s, {
                $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
            }]
        }), e.validateSchema = this.compile(s, !0))
    }
    n.keywords[t] = n.all[t] = !0;

    function o(a, l, u) {
        for (var c, f = 0; f < n.length; f++) {
            var d = n[f];
            if (d.type == l) {
                c = d;
                break
            }
        }
        c || (c = {
            type: l,
            rules: []
        }, n.push(c));
        var p = {
            keyword: a,
            definition: u,
            custom: !0,
            code: lae,
            implements: u.implements
        };
        c.rules.push(p), n.custom[a] = p
    }
    return this
}

function dae(t) {
    var e = this.RULES.custom[t];
    return e ? e.definition : this.RULES.keywords[t] || !1
}

function pae(t) {
    var e = this.RULES;
    delete e.keywords[t], delete e.all[t], delete e.custom[t];
    for (var n = 0; n < e.length; n++)
        for (var r = e[n].rules, i = 0; i < r.length; i++)
            if (r[i].keyword == t) {
                r.splice(i, 1);
                break
            }
    return this
}

function jI(t, e) {
    jI.errors = null;
    var n = this._validateKeyword = this._validateKeyword || this.compile(uae, !0);
    if (n(t)) return !0;
    if (jI.errors = n.errors, e) throw new Error("custom keyword definition is invalid: " + this.errorsText(n.errors));
    return !1
}
const hae = "http://json-schema.org/draft-07/schema#",
    mae = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    gae = "Meta-schema for $data reference (JSON Schema extension proposal)",
    yae = "object",
    vae = ["$data"],
    bae = {
        $data: {
            type: "string",
            anyOf: [{
                format: "relative-json-pointer"
            }, {
                format: "json-pointer"
            }]
        }
    },
    xae = !1,
    _ae = {
        $schema: hae,
        $id: mae,
        description: gae,
        type: yae,
        required: vae,
        properties: bae,
        additionalProperties: xae
    };
var KV = loe,
    Od = ZD,
    Sae = moe,
    qV = CV,
    wae = IV,
    Eae = Soe,
    Aae = Xoe,
    XV = Joe,
    JV = mg,
    _E = zr;
zr.prototype.validate = Mae;
zr.prototype.compile = Tae;
zr.prototype.addSchema = Pae;
zr.prototype.addMetaSchema = Iae;
zr.prototype.validateSchema = Rae;
zr.prototype.getSchema = Dae;
zr.prototype.removeSchema = kae;
zr.prototype.addFormat = Gae;
zr.prototype.errorsText = $ae;
zr.prototype._addSchema = Bae;
zr.prototype._compile = Fae;
zr.prototype.compileAsync = Qoe;
var SE = cae;
zr.prototype.addKeyword = SE.add;
zr.prototype.getKeyword = SE.get;
zr.prototype.removeKeyword = SE.remove;
zr.prototype.validateKeyword = SE.validate;
var YV = eL;
zr.ValidationError = YV.Validation;
zr.MissingRefError = YV.MissingRef;
zr.$dataMetaSchema = XV;
var Pw = "http://json-schema.org/draft-07/schema",
    WN = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"],
    Cae = ["/properties"];

function zr(t) {
    if (!(this instanceof zr)) return new zr(t);
    t = this._opts = JV.copy(t) || {}, Xae(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = Eae(t.format), this._cache = t.cache || new Sae, this._loadingSchemas = {}, this._compilations = [], this.RULES = Aae(), this._getId = Nae(t), t.loopRequired = t.loopRequired || 1 / 0, t.errorDataPath == "property" && (t._errorDataPathProperty = !0), t.serialize === void 0 && (t.serialize = wae), this._metaOpts = qae(this), t.formats && Wae(this), t.keywords && Kae(this), Vae(this), typeof t.meta == "object" && this.addMetaSchema(t.meta), t.nullable && this.addKeyword("nullable", {
        metaSchema: {
            type: "boolean"
        }
    }), jae(this)
}

function Mae(t, e) {
    var n;
    if (typeof t == "string") {
        if (n = this.getSchema(t), !n) throw new Error('no schema with key or ref "' + t + '"')
    } else {
        var r = this._addSchema(t);
        n = r.validate || this._compile(r)
    }
    var i = n(e);
    return n.$async !== !0 && (this.errors = n.errors), i
}

function Tae(t, e) {
    var n = this._addSchema(t, void 0, e);
    return n.validate || this._compile(n)
}

function Pae(t, e, n, r) {
    if (Array.isArray(t)) {
        for (var i = 0; i < t.length; i++) this.addSchema(t[i], void 0, n, r);
        return this
    }
    var s = this._getId(t);
    if (s !== void 0 && typeof s != "string") throw new Error("schema id must be string");
    return e = Od.normalizeId(e || s), ZV(this, e), this._schemas[e] = this._addSchema(t, n, r, !0), this
}

function Iae(t, e, n) {
    return this.addSchema(t, e, n, !0), this
}

function Rae(t, e) {
    var n = t.$schema;
    if (n !== void 0 && typeof n != "string") throw new Error("$schema must be a string");
    if (n = n || this._opts.defaultMeta || Oae(this), !n) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
    var r = this.validate(n, t);
    if (!r && e) {
        var i = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log") this.logger.error(i);
        else throw new Error(i)
    }
    return r
}

function Oae(t) {
    var e = t._opts.meta;
    return t._opts.defaultMeta = typeof e == "object" ? t._getId(e) || e : t.getSchema(Pw) ? Pw : void 0, t._opts.defaultMeta
}

function Dae(t) {
    var e = QV(this, t);
    switch (typeof e) {
        case "object":
            return e.validate || this._compile(e);
        case "string":
            return this.getSchema(e);
        case "undefined":
            return Lae(this, t)
    }
}

function Lae(t, e) {
    var n = Od.schema.call(t, {
        schema: {}
    }, e);
    if (n) {
        var r = n.schema,
            i = n.root,
            s = n.baseId,
            o = KV.call(t, r, i, void 0, s);
        return t._fragments[e] = new qV({
            ref: e,
            fragment: !0,
            schema: r,
            root: i,
            baseId: s,
            validate: o
        }), o
    }
}

function QV(t, e) {
    return e = Od.normalizeId(e), t._schemas[e] || t._refs[e] || t._fragments[e]
}

function kae(t) {
    if (t instanceof RegExp) return dx(this, this._schemas, t), dx(this, this._refs, t), this;
    switch (typeof t) {
        case "undefined":
            return dx(this, this._schemas), dx(this, this._refs), this._cache.clear(), this;
        case "string":
            var e = QV(this, t);
            return e && this._cache.del(e.cacheKey), delete this._schemas[t], delete this._refs[t], this;
        case "object":
            var n = this._opts.serialize,
                r = n ? n(t) : t;
            this._cache.del(r);
            var i = this._getId(t);
            i && (i = Od.normalizeId(i), delete this._schemas[i], delete this._refs[i])
    }
    return this
}

function dx(t, e, n) {
    for (var r in e) {
        var i = e[r];
        !i.meta && (!n || n.test(r)) && (t._cache.del(i.cacheKey), delete e[r])
    }
}

function Bae(t, e, n, r) {
    if (typeof t != "object" && typeof t != "boolean") throw new Error("schema should be object or boolean");
    var i = this._opts.serialize,
        s = i ? i(t) : t,
        o = this._cache.get(s);
    if (o) return o;
    r = r || this._opts.addUsedSchema !== !1;
    var a = Od.normalizeId(this._getId(t));
    a && r && ZV(this, a);
    var l = this._opts.validateSchema !== !1 && !e,
        u;
    l && !(u = a && a == Od.normalizeId(t.$schema)) && this.validateSchema(t, !0);
    var c = Od.ids.call(this, t),
        f = new qV({
            id: a,
            schema: t,
            localRefs: c,
            cacheKey: s,
            meta: n
        });
    return a[0] != "#" && r && (this._refs[a] = f), this._cache.put(s, f), l && u && this.validateSchema(t, !0), f
}

function Fae(t, e) {
    if (t.compiling) return t.validate = i, i.schema = t.schema, i.errors = null, i.root = e || i, t.schema.$async === !0 && (i.$async = !0), i;
    t.compiling = !0;
    var n;
    t.meta && (n = this._opts, this._opts = this._metaOpts);
    var r;
    try {
        r = KV.call(this, t.schema, e, t.localRefs)
    } catch (s) {
        throw delete t.validate, s
    } finally {
        t.compiling = !1, t.meta && (this._opts = n)
    }
    return t.validate = r, t.refs = r.refs, t.refVal = r.refVal, t.root = r.root, r;

    function i() {
        var s = t.validate,
            o = s.apply(this, arguments);
        return i.errors = s.errors, o
    }
}

function Nae(t) {
    switch (t.schemaId) {
        case "auto":
            return Uae;
        case "id":
            return zae;
        default:
            return Hae
    }
}

function zae(t) {
    return t.$id && this.logger.warn("schema $id ignored", t.$id), t.id
}

function Hae(t) {
    return t.id && this.logger.warn("schema id ignored", t.id), t.$id
}

function Uae(t) {
    if (t.$id && t.id && t.$id != t.id) throw new Error("schema $id is different from id");
    return t.$id || t.id
}

function $ae(t, e) {
    if (t = t || this.errors, !t) return "No errors";
    e = e || {};
    for (var n = e.separator === void 0 ? ", " : e.separator, r = e.dataVar === void 0 ? "data" : e.dataVar, i = "", s = 0; s < t.length; s++) {
        var o = t[s];
        o && (i += r + o.dataPath + " " + o.message + n)
    }
    return i.slice(0, -n.length)
}

function Gae(t, e) {
    return typeof e == "string" && (e = new RegExp(e)), this._formats[t] = e, this
}

function Vae(t) {
    var e;
    if (t._opts.$data && (e = _ae, t.addMetaSchema(e, e.$id, !0)), t._opts.meta !== !1) {
        var n = WV;
        t._opts.$data && (n = XV(n, Cae)), t.addMetaSchema(n, Pw, !0), t._refs["http://json-schema.org/schema"] = Pw
    }
}

function jae(t) {
    var e = t._opts.schemas;
    if (e)
        if (Array.isArray(e)) t.addSchema(e);
        else
            for (var n in e) t.addSchema(e[n], n)
}

function Wae(t) {
    for (var e in t._opts.formats) {
        var n = t._opts.formats[e];
        t.addFormat(e, n)
    }
}

function Kae(t) {
    for (var e in t._opts.keywords) {
        var n = t._opts.keywords[e];
        t.addKeyword(e, n)
    }
}

function ZV(t, e) {
    if (t._schemas[e] || t._refs[e]) throw new Error('schema with key or id "' + e + '" already exists')
}

function qae(t) {
    for (var e = JV.copy(t._opts), n = 0; n < WN.length; n++) delete e[WN[n]];
    return e
}

function Xae(t) {
    var e = t._opts.logger;
    if (e === !1) t.logger = {
        log: RM,
        warn: RM,
        error: RM
    };
    else {
        if (e === void 0 && (e = console), !(typeof e == "object" && e.log && e.warn && e.error)) throw new Error("logger must implement log, warn and error methods");
        t.logger = e
    }
}

function RM() {}
const Jae = "http://json-schema.org/draft-06/schema#",
    Yae = "http://json-schema.org/draft-06/schema#",
    Qae = "Core schema meta-schema",
    Zae = {
        schemaArray: {
            type: "array",
            minItems: 1,
            items: {
                $ref: "#"
            }
        },
        nonNegativeInteger: {
            type: "integer",
            minimum: 0
        },
        nonNegativeIntegerDefault0: {
            allOf: [{
                $ref: "#/definitions/nonNegativeInteger"
            }, {
                default: 0
            }]
        },
        simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
            type: "array",
            items: {
                type: "string"
            },
            uniqueItems: !0,
            default: []
        }
    },
    ele = ["object", "boolean"],
    tle = {
        $id: {
            type: "string",
            format: "uri-reference"
        },
        $schema: {
            type: "string",
            format: "uri"
        },
        $ref: {
            type: "string",
            format: "uri-reference"
        },
        title: {
            type: "string"
        },
        description: {
            type: "string"
        },
        default: {},
        examples: {
            type: "array",
            items: {}
        },
        multipleOf: {
            type: "number",
            exclusiveMinimum: 0
        },
        maximum: {
            type: "number"
        },
        exclusiveMaximum: {
            type: "number"
        },
        minimum: {
            type: "number"
        },
        exclusiveMinimum: {
            type: "number"
        },
        maxLength: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minLength: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        pattern: {
            type: "string",
            format: "regex"
        },
        additionalItems: {
            $ref: "#"
        },
        items: {
            anyOf: [{
                $ref: "#"
            }, {
                $ref: "#/definitions/schemaArray"
            }],
            default: {}
        },
        maxItems: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minItems: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        uniqueItems: {
            type: "boolean",
            default: !1
        },
        contains: {
            $ref: "#"
        },
        maxProperties: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minProperties: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        required: {
            $ref: "#/definitions/stringArray"
        },
        additionalProperties: {
            $ref: "#"
        },
        definitions: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        properties: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        patternProperties: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        dependencies: {
            type: "object",
            additionalProperties: {
                anyOf: [{
                    $ref: "#"
                }, {
                    $ref: "#/definitions/stringArray"
                }]
            }
        },
        propertyNames: {
            $ref: "#"
        },
        const: {},
        enum: {
            type: "array",
            minItems: 1,
            uniqueItems: !0
        },
        type: {
            anyOf: [{
                $ref: "#/definitions/simpleTypes"
            }, {
                type: "array",
                items: {
                    $ref: "#/definitions/simpleTypes"
                },
                minItems: 1,
                uniqueItems: !0
            }]
        },
        format: {
            type: "string"
        },
        allOf: {
            $ref: "#/definitions/schemaArray"
        },
        anyOf: {
            $ref: "#/definitions/schemaArray"
        },
        oneOf: {
            $ref: "#/definitions/schemaArray"
        },
        not: {
            $ref: "#"
        }
    },
    wE = {
        $schema: Jae,
        $id: Yae,
        title: Qae,
        definitions: Zae,
        type: ele,
        properties: tle,
        default: {}
    };
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.isVIADefinitionV3 = t.VIADefinitionV3Schema = t.ajv = void 0;
    var e = JSON.stringify,
        n = _E;
    t.ajv = new n({
        allErrors: !0,
        coerceTypes: !1,
        format: "fast",
        nullable: !0,
        unicode: !0,
        uniqueItems: !0,
        useDefaults: !1
    }), t.ajv.addMetaSchema(wE), t.VIADefinitionV3Schema = {
        $schema: "http://json-schema.org/draft-07/schema#",
        additionalProperties: !1,
        definitions: {
            KeyColorType: {
                enum: ["accent", "alpha", "arrow", "enter", "mod", "space"],
                type: "string"
            }
        },
        properties: {
            customKeycodes: {
                items: {
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string"
                        },
                        shortName: {
                            type: "string"
                        },
                        title: {
                            type: "string"
                        }
                    },
                    required: ["name", "title"],
                    type: "object"
                },
                type: "array"
            },
            firmwareVersion: {
                type: "number"
            },
            keycodes: {
                items: {
                    enum: ["qmk_lighting", "wt_lighting"],
                    type: "string"
                },
                type: "array"
            },
            layouts: {
                additionalProperties: !1,
                properties: {
                    height: {
                        type: "number"
                    },
                    keys: {
                        items: {
                            additionalProperties: !1,
                            properties: {
                                col: {
                                    type: "number"
                                },
                                color: {
                                    $ref: "#/definitions/KeyColorType"
                                },
                                d: {
                                    type: "boolean"
                                },
                                ei: {
                                    type: "number"
                                },
                                h: {
                                    type: "number"
                                },
                                h2: {
                                    type: "number"
                                },
                                li: {
                                    type: "number"
                                },
                                r: {
                                    type: "number"
                                },
                                row: {
                                    type: "number"
                                },
                                rx: {
                                    type: "number"
                                },
                                ry: {
                                    type: "number"
                                },
                                w: {
                                    type: "number"
                                },
                                w2: {
                                    type: "number"
                                },
                                x: {
                                    type: "number"
                                },
                                x2: {
                                    type: "number"
                                },
                                y: {
                                    type: "number"
                                },
                                y2: {
                                    type: "number"
                                }
                            },
                            required: ["col", "color", "d", "h", "r", "row", "rx", "ry", "w", "x", "y"],
                            type: "object"
                        },
                        type: "array"
                    },
                    labels: {
                        items: {
                            anyOf: [{
                                items: {
                                    type: "string"
                                },
                                type: "array"
                            }, {
                                type: "string"
                            }]
                        },
                        type: "array"
                    },
                    optionKeys: {
                        additionalProperties: {
                            additionalProperties: {
                                items: {
                                    additionalProperties: !1,
                                    properties: {
                                        col: {
                                            type: "number"
                                        },
                                        color: {
                                            $ref: "#/definitions/KeyColorType"
                                        },
                                        d: {
                                            type: "boolean"
                                        },
                                        ei: {
                                            type: "number"
                                        },
                                        h: {
                                            type: "number"
                                        },
                                        h2: {
                                            type: "number"
                                        },
                                        li: {
                                            type: "number"
                                        },
                                        r: {
                                            type: "number"
                                        },
                                        row: {
                                            type: "number"
                                        },
                                        rx: {
                                            type: "number"
                                        },
                                        ry: {
                                            type: "number"
                                        },
                                        w: {
                                            type: "number"
                                        },
                                        w2: {
                                            type: "number"
                                        },
                                        x: {
                                            type: "number"
                                        },
                                        x2: {
                                            type: "number"
                                        },
                                        y: {
                                            type: "number"
                                        },
                                        y2: {
                                            type: "number"
                                        }
                                    },
                                    required: ["col", "color", "d", "h", "r", "row", "rx", "ry", "w", "x", "y"],
                                    type: "object"
                                },
                                type: "array"
                            },
                            type: "object"
                        },
                        type: "object"
                    },
                    presets: {
                        additionalProperties: {
                            items: {
                                type: "number"
                            },
                            type: "array"
                        },
                        type: "object"
                    },
                    width: {
                        type: "number"
                    }
                },
                required: ["height", "keys", "optionKeys", "width"],
                type: "object"
            },
            matrix: {
                additionalProperties: !1,
                properties: {
                    cols: {
                        type: "number"
                    },
                    rows: {
                        type: "number"
                    }
                },
                required: ["cols", "rows"],
                type: "object"
            },
            menus: {
                items: {
                    anyOf: [{
                        additionalProperties: !1,
                        properties: {
                            content: {
                                items: {
                                    anyOf: [{
                                        additionalProperties: !1,
                                        properties: {
                                            content: {
                                                items: {
                                                    anyOf: [{
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "number"
                                                                }],
                                                                minItems: 1,
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["button"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        anyOf: [{
                                                                            items: {
                                                                                type: "number"
                                                                            },
                                                                            type: "array"
                                                                        }, {
                                                                            type: "number"
                                                                        }]
                                                                    }, {
                                                                        anyOf: [{
                                                                            items: {
                                                                                type: "number"
                                                                            },
                                                                            type: "array"
                                                                        }, {
                                                                            type: "number"
                                                                        }]
                                                                    }]
                                                                },
                                                                items: [{
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }, {
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }],
                                                                minItems: 2,
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["toggle"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                anyOf: [{
                                                                    items: {
                                                                        type: "string"
                                                                    },
                                                                    type: "array"
                                                                }, {
                                                                    items: {
                                                                        additionalItems: {
                                                                            type: "number"
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 2,
                                                                        type: "array"
                                                                    },
                                                                    type: "array"
                                                                }]
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["dropdown"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "options", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 2,
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["range"],
                                                                type: "string"
                                                            },
                                                            unit: {
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "options", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["keycode"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["color"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["color-palette"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                type: "string"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            content: {
                                                                items: {
                                                                    anyOf: [{
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 1,
                                                                                type: "array"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["button"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        anyOf: [{
                                                                                            items: {
                                                                                                type: "number"
                                                                                            },
                                                                                            type: "array"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }]
                                                                                    }, {
                                                                                        anyOf: [{
                                                                                            items: {
                                                                                                type: "number"
                                                                                            },
                                                                                            type: "array"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }]
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }, {
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }],
                                                                                minItems: 2,
                                                                                type: "array"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["toggle"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    items: {
                                                                                        additionalItems: {
                                                                                            type: "number"
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 2,
                                                                                        type: "array"
                                                                                    },
                                                                                    type: "array"
                                                                                }]
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["dropdown"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "options", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 2,
                                                                                type: "array"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["range"],
                                                                                type: "string"
                                                                            },
                                                                            unit: {
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "options", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["keycode"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["color"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["color-palette"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                type: "string"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label"],
                                                                        type: "object"
                                                                    }]
                                                                },
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content"],
                                                        type: "object"
                                                    }]
                                                },
                                                type: "array"
                                            },
                                            label: {
                                                type: "string"
                                            },
                                            showIf: {
                                                type: "string"
                                            }
                                        },
                                        required: ["content", "label"],
                                        type: "object"
                                    }, {
                                        additionalProperties: !1,
                                        properties: {
                                            content: {
                                                items: {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        content: {
                                                            items: {
                                                                anyOf: [{
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 1,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["button"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }, {
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }, {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["toggle"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "string"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                items: {
                                                                                    additionalItems: {
                                                                                        type: "number"
                                                                                    },
                                                                                    items: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }],
                                                                                    minItems: 2,
                                                                                    type: "array"
                                                                                },
                                                                                type: "array"
                                                                            }]
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["dropdown"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["range"],
                                                                            type: "string"
                                                                        },
                                                                        unit: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["keycode"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color-palette"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            type: "string"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        content: {
                                                                            items: {
                                                                                anyOf: [{
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 1,
                                                                                            type: "array"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["button"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    anyOf: [{
                                                                                                        items: {
                                                                                                            type: "number"
                                                                                                        },
                                                                                                        type: "array"
                                                                                                    }, {
                                                                                                        type: "number"
                                                                                                    }]
                                                                                                }, {
                                                                                                    anyOf: [{
                                                                                                        items: {
                                                                                                            type: "number"
                                                                                                        },
                                                                                                        type: "array"
                                                                                                    }, {
                                                                                                        type: "number"
                                                                                                    }]
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }, {
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }],
                                                                                            minItems: 2,
                                                                                            type: "array"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["toggle"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            anyOf: [{
                                                                                                items: {
                                                                                                    type: "string"
                                                                                                },
                                                                                                type: "array"
                                                                                            }, {
                                                                                                items: {
                                                                                                    additionalItems: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    items: [{
                                                                                                        type: "string"
                                                                                                    }, {
                                                                                                        type: "number"
                                                                                                    }],
                                                                                                    minItems: 2,
                                                                                                    type: "array"
                                                                                                },
                                                                                                type: "array"
                                                                                            }]
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["dropdown"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "options", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 2,
                                                                                            type: "array"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["range"],
                                                                                            type: "string"
                                                                                        },
                                                                                        unit: {
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "options", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["keycode"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["color"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["color-palette"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            type: "string"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label"],
                                                                                    type: "object"
                                                                                }]
                                                                            },
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content"],
                                                                    type: "object"
                                                                }]
                                                            },
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label"],
                                                    type: "object"
                                                },
                                                type: "array"
                                            },
                                            showIf: {
                                                type: "string"
                                            }
                                        },
                                        required: ["content"],
                                        type: "object"
                                    }]
                                },
                                type: "array"
                            },
                            label: {
                                type: "string"
                            },
                            showIf: {
                                type: "string"
                            }
                        },
                        required: ["content", "label"],
                        type: "object"
                    }, {
                        type: "string"
                    }]
                },
                type: "array"
            },
            name: {
                type: "string"
            },
            vendorProductId: {
                type: "number"
            }
        },
        required: ["firmwareVersion", "keycodes", "layouts", "matrix", "menus", "name", "vendorProductId"],
        type: "object"
    }, t.isVIADefinitionV3 = t.ajv.compile(t.VIADefinitionV3Schema);

    function r(i) {
        if ((0, t.isVIADefinitionV3)(i)) return i;
        throw new Error(t.ajv.errorsText(t.isVIADefinitionV3.errors.filter(function(s) {
            return s.keyword !== "if"
        }), {
            dataVar: "VIADefinitionV3"
        }) + `

` + e(i))
    }
    t.default = r
})(EV);
var ej = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.isVIADefinitionV2 = t.VIADefinitionV2Schema = t.ajv = void 0;
    var e = JSON.stringify,
        n = _E;
    t.ajv = new n({
        allErrors: !0,
        coerceTypes: !1,
        format: "fast",
        nullable: !0,
        unicode: !0,
        uniqueItems: !0,
        useDefaults: !1
    }), t.ajv.addMetaSchema(wE), t.VIADefinitionV2Schema = {
        $schema: "http://json-schema.org/draft-07/schema#",
        additionalProperties: !1,
        definitions: {
            KeyColorType: {
                enum: ["accent", "alpha", "arrow", "enter", "mod", "space"],
                type: "string"
            },
            LightingTypeDefinition: {
                enum: ["none", "qmk_backlight", "qmk_backlight_rgblight", "qmk_rgblight", "wt_mono_backlight", "wt_rgb_backlight"],
                type: "string"
            },
            LightingValue: {
                enum: [1, 10, 11, 12, 128, 129, 13, 130, 131, 14, 15, 16, 17, 18, 19, 2, 20, 21, 23, 3, 4, 5, 6, 7, 8, 9],
                type: "number"
            }
        },
        properties: {
            customFeatures: {
                items: {
                    enum: ["rotary-encoder"],
                    type: "string"
                },
                type: "array"
            },
            customKeycodes: {
                items: {
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string"
                        },
                        shortName: {
                            type: "string"
                        },
                        title: {
                            type: "string"
                        }
                    },
                    required: ["name", "title"],
                    type: "object"
                },
                type: "array"
            },
            customMenus: {
                items: {
                    additionalProperties: !1,
                    properties: {
                        content: {
                            items: {
                                anyOf: [{
                                    additionalProperties: !1,
                                    properties: {
                                        content: {
                                            items: {
                                                anyOf: [{
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "number"
                                                            }],
                                                            minItems: 1,
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["button"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }, {
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }]
                                                            },
                                                            items: [{
                                                                anyOf: [{
                                                                    items: {
                                                                        type: "number"
                                                                    },
                                                                    type: "array"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            }, {
                                                                anyOf: [{
                                                                    items: {
                                                                        type: "number"
                                                                    },
                                                                    type: "array"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            }],
                                                            minItems: 2,
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["toggle"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            anyOf: [{
                                                                items: {
                                                                    type: "string"
                                                                },
                                                                type: "array"
                                                            }, {
                                                                items: {
                                                                    additionalItems: {
                                                                        type: "number"
                                                                    },
                                                                    items: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }],
                                                                    minItems: 2,
                                                                    type: "array"
                                                                },
                                                                type: "array"
                                                            }]
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["dropdown"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "options", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 2,
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["range"],
                                                            type: "string"
                                                        },
                                                        unit: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "options", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["keycode"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["color"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["color-palette"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            type: "string"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        content: {
                                                            items: {
                                                                anyOf: [{
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 1,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["button"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }, {
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }, {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["toggle"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "string"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                items: {
                                                                                    additionalItems: {
                                                                                        type: "number"
                                                                                    },
                                                                                    items: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }],
                                                                                    minItems: 2,
                                                                                    type: "array"
                                                                                },
                                                                                type: "array"
                                                                            }]
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["dropdown"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["range"],
                                                                            type: "string"
                                                                        },
                                                                        unit: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["keycode"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color-palette"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            type: "string"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label"],
                                                                    type: "object"
                                                                }]
                                                            },
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content"],
                                                    type: "object"
                                                }]
                                            },
                                            type: "array"
                                        },
                                        label: {
                                            type: "string"
                                        },
                                        showIf: {
                                            type: "string"
                                        }
                                    },
                                    required: ["content", "label"],
                                    type: "object"
                                }, {
                                    additionalProperties: !1,
                                    properties: {
                                        content: {
                                            items: {
                                                additionalProperties: !1,
                                                properties: {
                                                    content: {
                                                        items: {
                                                            anyOf: [{
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 1,
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["button"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }, {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "number"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        }, {
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "number"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        }],
                                                                        minItems: 2,
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["toggle"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        anyOf: [{
                                                                            items: {
                                                                                type: "string"
                                                                            },
                                                                            type: "array"
                                                                        }, {
                                                                            items: {
                                                                                additionalItems: {
                                                                                    type: "number"
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 2,
                                                                                type: "array"
                                                                            },
                                                                            type: "array"
                                                                        }]
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["dropdown"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "options", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 2,
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["range"],
                                                                        type: "string"
                                                                    },
                                                                    unit: {
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "options", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["keycode"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["color"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["color-palette"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        type: "string"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    content: {
                                                                        items: {
                                                                            anyOf: [{
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 1,
                                                                                        type: "array"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["button"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }, {
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            anyOf: [{
                                                                                                items: {
                                                                                                    type: "number"
                                                                                                },
                                                                                                type: "array"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        }, {
                                                                                            anyOf: [{
                                                                                                items: {
                                                                                                    type: "number"
                                                                                                },
                                                                                                type: "array"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        }],
                                                                                        minItems: 2,
                                                                                        type: "array"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["toggle"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        anyOf: [{
                                                                                            items: {
                                                                                                type: "string"
                                                                                            },
                                                                                            type: "array"
                                                                                        }, {
                                                                                            items: {
                                                                                                additionalItems: {
                                                                                                    type: "number"
                                                                                                },
                                                                                                items: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }],
                                                                                                minItems: 2,
                                                                                                type: "array"
                                                                                            },
                                                                                            type: "array"
                                                                                        }]
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["dropdown"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "options", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 2,
                                                                                        type: "array"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["range"],
                                                                                        type: "string"
                                                                                    },
                                                                                    unit: {
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "options", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["keycode"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["color"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["color-palette"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        type: "string"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label"],
                                                                                type: "object"
                                                                            }]
                                                                        },
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content"],
                                                                type: "object"
                                                            }]
                                                        },
                                                        type: "array"
                                                    },
                                                    label: {
                                                        type: "string"
                                                    },
                                                    showIf: {
                                                        type: "string"
                                                    }
                                                },
                                                required: ["content", "label"],
                                                type: "object"
                                            },
                                            type: "array"
                                        },
                                        showIf: {
                                            type: "string"
                                        }
                                    },
                                    required: ["content"],
                                    type: "object"
                                }]
                            },
                            type: "array"
                        },
                        label: {
                            type: "string"
                        },
                        showIf: {
                            type: "string"
                        }
                    },
                    required: ["content", "label"],
                    type: "object"
                },
                type: "array"
            },
            layouts: {
                additionalProperties: !1,
                properties: {
                    height: {
                        type: "number"
                    },
                    keys: {
                        items: {
                            additionalProperties: !1,
                            properties: {
                                col: {
                                    type: "number"
                                },
                                color: {
                                    $ref: "#/definitions/KeyColorType"
                                },
                                d: {
                                    type: "boolean"
                                },
                                ei: {
                                    type: "number"
                                },
                                h: {
                                    type: "number"
                                },
                                h2: {
                                    type: "number"
                                },
                                li: {
                                    type: "number"
                                },
                                r: {
                                    type: "number"
                                },
                                row: {
                                    type: "number"
                                },
                                rx: {
                                    type: "number"
                                },
                                ry: {
                                    type: "number"
                                },
                                w: {
                                    type: "number"
                                },
                                w2: {
                                    type: "number"
                                },
                                x: {
                                    type: "number"
                                },
                                x2: {
                                    type: "number"
                                },
                                y: {
                                    type: "number"
                                },
                                y2: {
                                    type: "number"
                                }
                            },
                            required: ["col", "color", "d", "h", "r", "row", "rx", "ry", "w", "x", "y"],
                            type: "object"
                        },
                        type: "array"
                    },
                    labels: {
                        items: {
                            anyOf: [{
                                items: {
                                    type: "string"
                                },
                                type: "array"
                            }, {
                                type: "string"
                            }]
                        },
                        type: "array"
                    },
                    optionKeys: {
                        additionalProperties: {
                            additionalProperties: {
                                items: {
                                    additionalProperties: !1,
                                    properties: {
                                        col: {
                                            type: "number"
                                        },
                                        color: {
                                            $ref: "#/definitions/KeyColorType"
                                        },
                                        d: {
                                            type: "boolean"
                                        },
                                        ei: {
                                            type: "number"
                                        },
                                        h: {
                                            type: "number"
                                        },
                                        h2: {
                                            type: "number"
                                        },
                                        li: {
                                            type: "number"
                                        },
                                        r: {
                                            type: "number"
                                        },
                                        row: {
                                            type: "number"
                                        },
                                        rx: {
                                            type: "number"
                                        },
                                        ry: {
                                            type: "number"
                                        },
                                        w: {
                                            type: "number"
                                        },
                                        w2: {
                                            type: "number"
                                        },
                                        x: {
                                            type: "number"
                                        },
                                        x2: {
                                            type: "number"
                                        },
                                        y: {
                                            type: "number"
                                        },
                                        y2: {
                                            type: "number"
                                        }
                                    },
                                    required: ["col", "color", "d", "h", "r", "row", "rx", "ry", "w", "x", "y"],
                                    type: "object"
                                },
                                type: "array"
                            },
                            type: "object"
                        },
                        type: "object"
                    },
                    presets: {
                        additionalProperties: {
                            items: {
                                type: "number"
                            },
                            type: "array"
                        },
                        type: "object"
                    },
                    width: {
                        type: "number"
                    }
                },
                required: ["height", "keys", "optionKeys", "width"],
                type: "object"
            },
            lighting: {
                anyOf: [{
                    additionalProperties: !1,
                    properties: {
                        effects: {
                            items: {
                                additionalItems: {
                                    anyOf: [{
                                        type: "string"
                                    }, {
                                        type: "number"
                                    }]
                                },
                                items: [{
                                    type: "string"
                                }, {
                                    type: "number"
                                }],
                                minItems: 2,
                                type: "array"
                            },
                            type: "array"
                        },
                        extends: {
                            $ref: "#/definitions/LightingTypeDefinition"
                        },
                        keycodes: {
                            enum: ["none", "qmk", "wt"],
                            type: "string"
                        },
                        supportedLightingValues: {
                            items: {
                                $ref: "#/definitions/LightingValue"
                            },
                            type: "array"
                        },
                        underglowEffects: {
                            items: {
                                additionalItems: {
                                    anyOf: [{
                                        type: "string"
                                    }, {
                                        type: "number"
                                    }]
                                },
                                items: [{
                                    type: "string"
                                }, {
                                    type: "number"
                                }],
                                minItems: 2,
                                type: "array"
                            },
                            type: "array"
                        }
                    },
                    required: ["extends"],
                    type: "object"
                }, {
                    enum: ["none", "qmk_backlight", "qmk_backlight_rgblight", "qmk_rgblight", "wt_mono_backlight", "wt_rgb_backlight"],
                    type: "string"
                }]
            },
            matrix: {
                additionalProperties: !1,
                properties: {
                    cols: {
                        type: "number"
                    },
                    rows: {
                        type: "number"
                    }
                },
                required: ["cols", "rows"],
                type: "object"
            },
            name: {
                type: "string"
            },
            vendorProductId: {
                type: "number"
            }
        },
        required: ["layouts", "lighting", "matrix", "name", "vendorProductId"],
        type: "object"
    }, t.isVIADefinitionV2 = t.ajv.compile(t.VIADefinitionV2Schema);

    function r(i) {
        if ((0, t.isVIADefinitionV2)(i)) return i;
        throw new Error(t.ajv.errorsText(t.isVIADefinitionV2.errors.filter(function(s) {
            return s.keyword !== "if"
        }), {
            dataVar: "VIADefinitionV2"
        }) + `

` + e(i))
    }
    t.default = r
})(ej);
var nL = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.isKeyboardDefinitionV3 = t.KeyboardDefinitionV3Schema = t.ajv = void 0;
    var e = JSON.stringify,
        n = _E;
    t.ajv = new n({
        allErrors: !0,
        coerceTypes: !1,
        format: "fast",
        nullable: !0,
        unicode: !0,
        uniqueItems: !0,
        useDefaults: !1
    }), t.ajv.addMetaSchema(wE), t.KeyboardDefinitionV3Schema = {
        $schema: "http://json-schema.org/draft-07/schema#",
        additionalProperties: !1,
        definitions: {
            "Partial<Rotation&{a:number;x:number;w:number;h:number;y:number;}&Partial<{x2:number;y2:number;h2:number;w2:number;}>&Formatting&Ghosted&Stepped&Homing&Decal&TextSize&Profile&SwitchInfo>": {
                additionalProperties: !1,
                properties: {
                    a: {
                        type: "number"
                    },
                    c: {
                        type: "string"
                    },
                    d: {
                        type: "boolean"
                    },
                    f: {
                        type: "number"
                    },
                    f2: {
                        type: "number"
                    },
                    fa: {
                        items: {
                            type: "number"
                        },
                        type: "array"
                    },
                    g: {
                        type: "boolean"
                    },
                    h: {
                        type: "number"
                    },
                    h2: {
                        type: "number"
                    },
                    l: {
                        type: "boolean"
                    },
                    n: {
                        type: "boolean"
                    },
                    p: {
                        type: "string"
                    },
                    r: {
                        type: "number"
                    },
                    rx: {
                        type: "number"
                    },
                    ry: {
                        type: "number"
                    },
                    sb: {
                        type: "string"
                    },
                    sm: {
                        type: "string"
                    },
                    st: {
                        type: "string"
                    },
                    t: {
                        type: "string"
                    },
                    w: {
                        type: "number"
                    },
                    w2: {
                        type: "number"
                    },
                    x: {
                        type: "number"
                    },
                    x2: {
                        type: "number"
                    },
                    y: {
                        type: "number"
                    },
                    y2: {
                        type: "number"
                    }
                },
                type: "object"
            }
        },
        properties: {
            customKeycodes: {
                items: {
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string"
                        },
                        shortName: {
                            type: "string"
                        },
                        title: {
                            type: "string"
                        }
                    },
                    required: ["name", "title"],
                    type: "object"
                },
                type: "array"
            },
            firmwareVersion: {
                type: "number"
            },
            keycodes: {
                items: {
                    enum: ["qmk_lighting", "wt_lighting"],
                    type: "string"
                },
                type: "array"
            },
            layouts: {
                additionalProperties: !1,
                properties: {
                    keymap: {
                        items: {
                            anyOf: [{
                                additionalProperties: !1,
                                properties: {
                                    name: {
                                        type: "string"
                                    }
                                },
                                type: "object"
                            }, {
                                items: {
                                    anyOf: [{
                                        $ref: "#/definitions/Partial<Rotation&{a:number;x:number;w:number;h:number;y:number;}&Partial<{x2:number;y2:number;h2:number;w2:number;}>&Formatting&Ghosted&Stepped&Homing&Decal&TextSize&Profile&SwitchInfo>"
                                    }, {
                                        type: "string"
                                    }]
                                },
                                type: "array"
                            }]
                        },
                        type: "array"
                    },
                    labels: {
                        items: {
                            anyOf: [{
                                items: {
                                    type: "string"
                                },
                                type: "array"
                            }, {
                                type: "string"
                            }]
                        },
                        type: "array"
                    },
                    presets: {
                        additionalProperties: {
                            items: {
                                type: "number"
                            },
                            type: "array"
                        },
                        type: "object"
                    }
                },
                required: ["keymap"],
                type: "object"
            },
            matrix: {
                additionalProperties: !1,
                properties: {
                    cols: {
                        type: "number"
                    },
                    rows: {
                        type: "number"
                    }
                },
                required: ["cols", "rows"],
                type: "object"
            },
            menus: {
                items: {
                    anyOf: [{
                        additionalProperties: !1,
                        properties: {
                            content: {
                                items: {
                                    anyOf: [{
                                        additionalProperties: !1,
                                        properties: {
                                            content: {
                                                items: {
                                                    anyOf: [{
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "number"
                                                                }],
                                                                minItems: 1,
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["button"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        anyOf: [{
                                                                            items: {
                                                                                type: "number"
                                                                            },
                                                                            type: "array"
                                                                        }, {
                                                                            type: "number"
                                                                        }]
                                                                    }, {
                                                                        anyOf: [{
                                                                            items: {
                                                                                type: "number"
                                                                            },
                                                                            type: "array"
                                                                        }, {
                                                                            type: "number"
                                                                        }]
                                                                    }]
                                                                },
                                                                items: [{
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }, {
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }],
                                                                minItems: 2,
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["toggle"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                anyOf: [{
                                                                    items: {
                                                                        type: "string"
                                                                    },
                                                                    type: "array"
                                                                }, {
                                                                    items: {
                                                                        additionalItems: {
                                                                            type: "number"
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 2,
                                                                        type: "array"
                                                                    },
                                                                    type: "array"
                                                                }]
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["dropdown"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "options", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            options: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 2,
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["range"],
                                                                type: "string"
                                                            },
                                                            unit: {
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "options", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["keycode"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["color"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                additionalItems: {
                                                                    anyOf: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                },
                                                                items: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }],
                                                                minItems: 3,
                                                                type: "array"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            },
                                                            type: {
                                                                enum: ["color-palette"],
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label", "type"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            bytes: {
                                                                enum: [1, 2, 3, 4],
                                                                type: "number"
                                                            },
                                                            content: {
                                                                type: "string"
                                                            },
                                                            label: {
                                                                type: "string"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content", "label"],
                                                        type: "object"
                                                    }, {
                                                        additionalProperties: !1,
                                                        properties: {
                                                            content: {
                                                                items: {
                                                                    anyOf: [{
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 1,
                                                                                type: "array"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["button"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        anyOf: [{
                                                                                            items: {
                                                                                                type: "number"
                                                                                            },
                                                                                            type: "array"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }]
                                                                                    }, {
                                                                                        anyOf: [{
                                                                                            items: {
                                                                                                type: "number"
                                                                                            },
                                                                                            type: "array"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }]
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }, {
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }],
                                                                                minItems: 2,
                                                                                type: "array"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["toggle"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    items: {
                                                                                        additionalItems: {
                                                                                            type: "number"
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 2,
                                                                                        type: "array"
                                                                                    },
                                                                                    type: "array"
                                                                                }]
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["dropdown"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "options", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            options: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 2,
                                                                                type: "array"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["range"],
                                                                                type: "string"
                                                                            },
                                                                            unit: {
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "options", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["keycode"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["color"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                additionalItems: {
                                                                                    anyOf: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 3,
                                                                                type: "array"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            },
                                                                            type: {
                                                                                enum: ["color-palette"],
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label", "type"],
                                                                        type: "object"
                                                                    }, {
                                                                        additionalProperties: !1,
                                                                        properties: {
                                                                            bytes: {
                                                                                enum: [1, 2, 3, 4],
                                                                                type: "number"
                                                                            },
                                                                            content: {
                                                                                type: "string"
                                                                            },
                                                                            label: {
                                                                                type: "string"
                                                                            },
                                                                            showIf: {
                                                                                type: "string"
                                                                            }
                                                                        },
                                                                        required: ["content", "label"],
                                                                        type: "object"
                                                                    }]
                                                                },
                                                                type: "array"
                                                            },
                                                            showIf: {
                                                                type: "string"
                                                            }
                                                        },
                                                        required: ["content"],
                                                        type: "object"
                                                    }]
                                                },
                                                type: "array"
                                            },
                                            label: {
                                                type: "string"
                                            },
                                            showIf: {
                                                type: "string"
                                            }
                                        },
                                        required: ["content", "label"],
                                        type: "object"
                                    }, {
                                        additionalProperties: !1,
                                        properties: {
                                            content: {
                                                items: {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        content: {
                                                            items: {
                                                                anyOf: [{
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 1,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["button"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }, {
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }, {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["toggle"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "string"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                items: {
                                                                                    additionalItems: {
                                                                                        type: "number"
                                                                                    },
                                                                                    items: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }],
                                                                                    minItems: 2,
                                                                                    type: "array"
                                                                                },
                                                                                type: "array"
                                                                            }]
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["dropdown"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["range"],
                                                                            type: "string"
                                                                        },
                                                                        unit: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["keycode"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color-palette"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            type: "string"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        content: {
                                                                            items: {
                                                                                anyOf: [{
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 1,
                                                                                            type: "array"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["button"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    anyOf: [{
                                                                                                        items: {
                                                                                                            type: "number"
                                                                                                        },
                                                                                                        type: "array"
                                                                                                    }, {
                                                                                                        type: "number"
                                                                                                    }]
                                                                                                }, {
                                                                                                    anyOf: [{
                                                                                                        items: {
                                                                                                            type: "number"
                                                                                                        },
                                                                                                        type: "array"
                                                                                                    }, {
                                                                                                        type: "number"
                                                                                                    }]
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }, {
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }],
                                                                                            minItems: 2,
                                                                                            type: "array"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["toggle"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            anyOf: [{
                                                                                                items: {
                                                                                                    type: "string"
                                                                                                },
                                                                                                type: "array"
                                                                                            }, {
                                                                                                items: {
                                                                                                    additionalItems: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    items: [{
                                                                                                        type: "string"
                                                                                                    }, {
                                                                                                        type: "number"
                                                                                                    }],
                                                                                                    minItems: 2,
                                                                                                    type: "array"
                                                                                                },
                                                                                                type: "array"
                                                                                            }]
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["dropdown"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "options", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        options: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 2,
                                                                                            type: "array"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["range"],
                                                                                            type: "string"
                                                                                        },
                                                                                        unit: {
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "options", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["keycode"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["color"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            additionalItems: {
                                                                                                anyOf: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            },
                                                                                            items: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }],
                                                                                            minItems: 3,
                                                                                            type: "array"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        },
                                                                                        type: {
                                                                                            enum: ["color-palette"],
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label", "type"],
                                                                                    type: "object"
                                                                                }, {
                                                                                    additionalProperties: !1,
                                                                                    properties: {
                                                                                        bytes: {
                                                                                            enum: [1, 2, 3, 4],
                                                                                            type: "number"
                                                                                        },
                                                                                        content: {
                                                                                            type: "string"
                                                                                        },
                                                                                        label: {
                                                                                            type: "string"
                                                                                        },
                                                                                        showIf: {
                                                                                            type: "string"
                                                                                        }
                                                                                    },
                                                                                    required: ["content", "label"],
                                                                                    type: "object"
                                                                                }]
                                                                            },
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content"],
                                                                    type: "object"
                                                                }]
                                                            },
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label"],
                                                    type: "object"
                                                },
                                                type: "array"
                                            },
                                            showIf: {
                                                type: "string"
                                            }
                                        },
                                        required: ["content"],
                                        type: "object"
                                    }]
                                },
                                type: "array"
                            },
                            label: {
                                type: "string"
                            },
                            showIf: {
                                type: "string"
                            }
                        },
                        required: ["content", "label"],
                        type: "object"
                    }, {
                        type: "string"
                    }]
                },
                type: "array"
            },
            name: {
                type: "string"
            },
            productId: {
                type: "string"
            },
            vendorId: {
                type: "string"
            }
        },
        required: ["layouts", "matrix", "name", "productId", "vendorId"],
        type: "object"
    }, t.isKeyboardDefinitionV3 = t.ajv.compile(t.KeyboardDefinitionV3Schema);

    function r(i) {
        if ((0, t.isKeyboardDefinitionV3)(i)) return i;
        throw new Error(t.ajv.errorsText(t.isKeyboardDefinitionV3.errors.filter(function(s) {
            return s.keyword !== "if"
        }), {
            dataVar: "KeyboardDefinitionV3"
        }) + `

` + e(i))
    }
    t.default = r
})(nL);
var rL = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.isKeyboardDefinitionV2 = t.KeyboardDefinitionV2Schema = t.ajv = void 0;
    var e = JSON.stringify,
        n = _E;
    t.ajv = new n({
        allErrors: !0,
        coerceTypes: !1,
        format: "fast",
        nullable: !0,
        unicode: !0,
        uniqueItems: !0,
        useDefaults: !1
    }), t.ajv.addMetaSchema(wE), t.KeyboardDefinitionV2Schema = {
        $schema: "http://json-schema.org/draft-07/schema#",
        additionalProperties: !1,
        definitions: {
            LightingTypeDefinition: {
                enum: ["none", "qmk_backlight", "qmk_backlight_rgblight", "qmk_rgblight", "wt_mono_backlight", "wt_rgb_backlight"],
                type: "string"
            },
            LightingValue: {
                enum: [1, 10, 11, 12, 128, 129, 13, 130, 131, 14, 15, 16, 17, 18, 19, 2, 20, 21, 23, 3, 4, 5, 6, 7, 8, 9],
                type: "number"
            },
            "Partial<Rotation&{a:number;x:number;w:number;h:number;y:number;}&Partial<{x2:number;y2:number;h2:number;w2:number;}>&Formatting&Ghosted&Stepped&Homing&Decal&TextSize&Profile&SwitchInfo>": {
                additionalProperties: !1,
                properties: {
                    a: {
                        type: "number"
                    },
                    c: {
                        type: "string"
                    },
                    d: {
                        type: "boolean"
                    },
                    f: {
                        type: "number"
                    },
                    f2: {
                        type: "number"
                    },
                    fa: {
                        items: {
                            type: "number"
                        },
                        type: "array"
                    },
                    g: {
                        type: "boolean"
                    },
                    h: {
                        type: "number"
                    },
                    h2: {
                        type: "number"
                    },
                    l: {
                        type: "boolean"
                    },
                    n: {
                        type: "boolean"
                    },
                    p: {
                        type: "string"
                    },
                    r: {
                        type: "number"
                    },
                    rx: {
                        type: "number"
                    },
                    ry: {
                        type: "number"
                    },
                    sb: {
                        type: "string"
                    },
                    sm: {
                        type: "string"
                    },
                    st: {
                        type: "string"
                    },
                    t: {
                        type: "string"
                    },
                    w: {
                        type: "number"
                    },
                    w2: {
                        type: "number"
                    },
                    x: {
                        type: "number"
                    },
                    x2: {
                        type: "number"
                    },
                    y: {
                        type: "number"
                    },
                    y2: {
                        type: "number"
                    }
                },
                type: "object"
            }
        },
        properties: {
            customFeatures: {
                items: {
                    enum: ["rotary-encoder"],
                    type: "string"
                },
                type: "array"
            },
            customKeycodes: {
                items: {
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string"
                        },
                        shortName: {
                            type: "string"
                        },
                        title: {
                            type: "string"
                        }
                    },
                    required: ["name", "title"],
                    type: "object"
                },
                type: "array"
            },
            customMenus: {
                items: {
                    additionalProperties: !1,
                    properties: {
                        content: {
                            items: {
                                anyOf: [{
                                    additionalProperties: !1,
                                    properties: {
                                        content: {
                                            items: {
                                                anyOf: [{
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "number"
                                                            }],
                                                            minItems: 1,
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["button"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }, {
                                                                    anyOf: [{
                                                                        items: {
                                                                            type: "number"
                                                                        },
                                                                        type: "array"
                                                                    }, {
                                                                        type: "number"
                                                                    }]
                                                                }]
                                                            },
                                                            items: [{
                                                                anyOf: [{
                                                                    items: {
                                                                        type: "number"
                                                                    },
                                                                    type: "array"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            }, {
                                                                anyOf: [{
                                                                    items: {
                                                                        type: "number"
                                                                    },
                                                                    type: "array"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            }],
                                                            minItems: 2,
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["toggle"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            anyOf: [{
                                                                items: {
                                                                    type: "string"
                                                                },
                                                                type: "array"
                                                            }, {
                                                                items: {
                                                                    additionalItems: {
                                                                        type: "number"
                                                                    },
                                                                    items: [{
                                                                        type: "string"
                                                                    }, {
                                                                        type: "number"
                                                                    }],
                                                                    minItems: 2,
                                                                    type: "array"
                                                                },
                                                                type: "array"
                                                            }]
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["dropdown"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "options", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        options: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 2,
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["range"],
                                                            type: "string"
                                                        },
                                                        unit: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "options", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["keycode"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["color"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            additionalItems: {
                                                                anyOf: [{
                                                                    type: "string"
                                                                }, {
                                                                    type: "number"
                                                                }, {
                                                                    type: "number"
                                                                }]
                                                            },
                                                            items: [{
                                                                type: "string"
                                                            }, {
                                                                type: "number"
                                                            }, {
                                                                type: "number"
                                                            }],
                                                            minItems: 3,
                                                            type: "array"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        },
                                                        type: {
                                                            enum: ["color-palette"],
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label", "type"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        bytes: {
                                                            enum: [1, 2, 3, 4],
                                                            type: "number"
                                                        },
                                                        content: {
                                                            type: "string"
                                                        },
                                                        label: {
                                                            type: "string"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content", "label"],
                                                    type: "object"
                                                }, {
                                                    additionalProperties: !1,
                                                    properties: {
                                                        content: {
                                                            items: {
                                                                anyOf: [{
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 1,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["button"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }, {
                                                                                    anyOf: [{
                                                                                        items: {
                                                                                            type: "number"
                                                                                        },
                                                                                        type: "array"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }]
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }, {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["toggle"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "string"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                items: {
                                                                                    additionalItems: {
                                                                                        type: "number"
                                                                                    },
                                                                                    items: [{
                                                                                        type: "string"
                                                                                    }, {
                                                                                        type: "number"
                                                                                    }],
                                                                                    minItems: 2,
                                                                                    type: "array"
                                                                                },
                                                                                type: "array"
                                                                            }]
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["dropdown"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        options: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 2,
                                                                            type: "array"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["range"],
                                                                            type: "string"
                                                                        },
                                                                        unit: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "options", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["keycode"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            additionalItems: {
                                                                                anyOf: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            },
                                                                            items: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }],
                                                                            minItems: 3,
                                                                            type: "array"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        },
                                                                        type: {
                                                                            enum: ["color-palette"],
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label", "type"],
                                                                    type: "object"
                                                                }, {
                                                                    additionalProperties: !1,
                                                                    properties: {
                                                                        bytes: {
                                                                            enum: [1, 2, 3, 4],
                                                                            type: "number"
                                                                        },
                                                                        content: {
                                                                            type: "string"
                                                                        },
                                                                        label: {
                                                                            type: "string"
                                                                        },
                                                                        showIf: {
                                                                            type: "string"
                                                                        }
                                                                    },
                                                                    required: ["content", "label"],
                                                                    type: "object"
                                                                }]
                                                            },
                                                            type: "array"
                                                        },
                                                        showIf: {
                                                            type: "string"
                                                        }
                                                    },
                                                    required: ["content"],
                                                    type: "object"
                                                }]
                                            },
                                            type: "array"
                                        },
                                        label: {
                                            type: "string"
                                        },
                                        showIf: {
                                            type: "string"
                                        }
                                    },
                                    required: ["content", "label"],
                                    type: "object"
                                }, {
                                    additionalProperties: !1,
                                    properties: {
                                        content: {
                                            items: {
                                                additionalProperties: !1,
                                                properties: {
                                                    content: {
                                                        items: {
                                                            anyOf: [{
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 1,
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["button"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }, {
                                                                                anyOf: [{
                                                                                    items: {
                                                                                        type: "number"
                                                                                    },
                                                                                    type: "array"
                                                                                }, {
                                                                                    type: "number"
                                                                                }]
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "number"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        }, {
                                                                            anyOf: [{
                                                                                items: {
                                                                                    type: "number"
                                                                                },
                                                                                type: "array"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        }],
                                                                        minItems: 2,
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["toggle"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        anyOf: [{
                                                                            items: {
                                                                                type: "string"
                                                                            },
                                                                            type: "array"
                                                                        }, {
                                                                            items: {
                                                                                additionalItems: {
                                                                                    type: "number"
                                                                                },
                                                                                items: [{
                                                                                    type: "string"
                                                                                }, {
                                                                                    type: "number"
                                                                                }],
                                                                                minItems: 2,
                                                                                type: "array"
                                                                            },
                                                                            type: "array"
                                                                        }]
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["dropdown"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "options", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    options: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 2,
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["range"],
                                                                        type: "string"
                                                                    },
                                                                    unit: {
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "options", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["keycode"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["color"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        additionalItems: {
                                                                            anyOf: [{
                                                                                type: "string"
                                                                            }, {
                                                                                type: "number"
                                                                            }, {
                                                                                type: "number"
                                                                            }]
                                                                        },
                                                                        items: [{
                                                                            type: "string"
                                                                        }, {
                                                                            type: "number"
                                                                        }, {
                                                                            type: "number"
                                                                        }],
                                                                        minItems: 3,
                                                                        type: "array"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    },
                                                                    type: {
                                                                        enum: ["color-palette"],
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label", "type"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    bytes: {
                                                                        enum: [1, 2, 3, 4],
                                                                        type: "number"
                                                                    },
                                                                    content: {
                                                                        type: "string"
                                                                    },
                                                                    label: {
                                                                        type: "string"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content", "label"],
                                                                type: "object"
                                                            }, {
                                                                additionalProperties: !1,
                                                                properties: {
                                                                    content: {
                                                                        items: {
                                                                            anyOf: [{
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 1,
                                                                                        type: "array"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["button"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }, {
                                                                                                anyOf: [{
                                                                                                    items: {
                                                                                                        type: "number"
                                                                                                    },
                                                                                                    type: "array"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }]
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            anyOf: [{
                                                                                                items: {
                                                                                                    type: "number"
                                                                                                },
                                                                                                type: "array"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        }, {
                                                                                            anyOf: [{
                                                                                                items: {
                                                                                                    type: "number"
                                                                                                },
                                                                                                type: "array"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        }],
                                                                                        minItems: 2,
                                                                                        type: "array"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["toggle"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        anyOf: [{
                                                                                            items: {
                                                                                                type: "string"
                                                                                            },
                                                                                            type: "array"
                                                                                        }, {
                                                                                            items: {
                                                                                                additionalItems: {
                                                                                                    type: "number"
                                                                                                },
                                                                                                items: [{
                                                                                                    type: "string"
                                                                                                }, {
                                                                                                    type: "number"
                                                                                                }],
                                                                                                minItems: 2,
                                                                                                type: "array"
                                                                                            },
                                                                                            type: "array"
                                                                                        }]
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["dropdown"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "options", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    options: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 2,
                                                                                        type: "array"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["range"],
                                                                                        type: "string"
                                                                                    },
                                                                                    unit: {
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "options", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["keycode"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["color"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        additionalItems: {
                                                                                            anyOf: [{
                                                                                                type: "string"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }, {
                                                                                                type: "number"
                                                                                            }]
                                                                                        },
                                                                                        items: [{
                                                                                            type: "string"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }, {
                                                                                            type: "number"
                                                                                        }],
                                                                                        minItems: 3,
                                                                                        type: "array"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    },
                                                                                    type: {
                                                                                        enum: ["color-palette"],
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label", "type"],
                                                                                type: "object"
                                                                            }, {
                                                                                additionalProperties: !1,
                                                                                properties: {
                                                                                    bytes: {
                                                                                        enum: [1, 2, 3, 4],
                                                                                        type: "number"
                                                                                    },
                                                                                    content: {
                                                                                        type: "string"
                                                                                    },
                                                                                    label: {
                                                                                        type: "string"
                                                                                    },
                                                                                    showIf: {
                                                                                        type: "string"
                                                                                    }
                                                                                },
                                                                                required: ["content", "label"],
                                                                                type: "object"
                                                                            }]
                                                                        },
                                                                        type: "array"
                                                                    },
                                                                    showIf: {
                                                                        type: "string"
                                                                    }
                                                                },
                                                                required: ["content"],
                                                                type: "object"
                                                            }]
                                                        },
                                                        type: "array"
                                                    },
                                                    label: {
                                                        type: "string"
                                                    },
                                                    showIf: {
                                                        type: "string"
                                                    }
                                                },
                                                required: ["content", "label"],
                                                type: "object"
                                            },
                                            type: "array"
                                        },
                                        showIf: {
                                            type: "string"
                                        }
                                    },
                                    required: ["content"],
                                    type: "object"
                                }]
                            },
                            type: "array"
                        },
                        label: {
                            type: "string"
                        },
                        showIf: {
                            type: "string"
                        }
                    },
                    required: ["content", "label"],
                    type: "object"
                },
                type: "array"
            },
            layouts: {
                additionalProperties: !1,
                properties: {
                    keymap: {
                        items: {
                            anyOf: [{
                                additionalProperties: !1,
                                properties: {
                                    name: {
                                        type: "string"
                                    }
                                },
                                type: "object"
                            }, {
                                items: {
                                    anyOf: [{
                                        $ref: "#/definitions/Partial<Rotation&{a:number;x:number;w:number;h:number;y:number;}&Partial<{x2:number;y2:number;h2:number;w2:number;}>&Formatting&Ghosted&Stepped&Homing&Decal&TextSize&Profile&SwitchInfo>"
                                    }, {
                                        type: "string"
                                    }]
                                },
                                type: "array"
                            }]
                        },
                        type: "array"
                    },
                    labels: {
                        items: {
                            anyOf: [{
                                items: {
                                    type: "string"
                                },
                                type: "array"
                            }, {
                                type: "string"
                            }]
                        },
                        type: "array"
                    },
                    presets: {
                        additionalProperties: {
                            items: {
                                type: "number"
                            },
                            type: "array"
                        },
                        type: "object"
                    }
                },
                required: ["keymap"],
                type: "object"
            },
            lighting: {
                anyOf: [{
                    additionalProperties: !1,
                    properties: {
                        effects: {
                            items: {
                                additionalItems: {
                                    anyOf: [{
                                        type: "string"
                                    }, {
                                        type: "number"
                                    }]
                                },
                                items: [{
                                    type: "string"
                                }, {
                                    type: "number"
                                }],
                                minItems: 2,
                                type: "array"
                            },
                            type: "array"
                        },
                        extends: {
                            $ref: "#/definitions/LightingTypeDefinition"
                        },
                        keycodes: {
                            enum: ["none", "qmk", "wt"],
                            type: "string"
                        },
                        supportedLightingValues: {
                            items: {
                                $ref: "#/definitions/LightingValue"
                            },
                            type: "array"
                        },
                        underglowEffects: {
                            items: {
                                additionalItems: {
                                    anyOf: [{
                                        type: "string"
                                    }, {
                                        type: "number"
                                    }]
                                },
                                items: [{
                                    type: "string"
                                }, {
                                    type: "number"
                                }],
                                minItems: 2,
                                type: "array"
                            },
                            type: "array"
                        }
                    },
                    required: ["extends"],
                    type: "object"
                }, {
                    enum: ["none", "qmk_backlight", "qmk_backlight_rgblight", "qmk_rgblight", "wt_mono_backlight", "wt_rgb_backlight"],
                    type: "string"
                }]
            },
            matrix: {
                additionalProperties: !1,
                properties: {
                    cols: {
                        type: "number"
                    },
                    rows: {
                        type: "number"
                    }
                },
                required: ["cols", "rows"],
                type: "object"
            },
            name: {
                type: "string"
            },
            productId: {
                type: "string"
            },
            vendorId: {
                type: "string"
            }
        },
        required: ["layouts", "lighting", "matrix", "name", "productId", "vendorId"],
        type: "object"
    }, t.isKeyboardDefinitionV2 = t.ajv.compile(t.KeyboardDefinitionV2Schema);

    function r(i) {
        if ((0, t.isKeyboardDefinitionV2)(i)) return i;
        throw new Error(t.ajv.errorsText(t.isKeyboardDefinitionV2.errors.filter(function(s) {
            return s.keyword !== "if"
        }), {
            dataVar: "KeyboardDefinitionV2"
        }) + `

` + e(i))
    }
    t.default = r
})(rL);
var tj = {},
    EE = {},
    iL = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.CustomFeaturesV2 = t.LightingTypeDefinition = t.LightingValue = void 0,
        function(e) {
            e[e.BACKLIGHT_USE_SPLIT_BACKSPACE = 1] = "BACKLIGHT_USE_SPLIT_BACKSPACE", e[e.BACKLIGHT_USE_SPLIT_LEFT_SHIFT = 2] = "BACKLIGHT_USE_SPLIT_LEFT_SHIFT", e[e.BACKLIGHT_USE_SPLIT_RIGHT_SHIFT = 3] = "BACKLIGHT_USE_SPLIT_RIGHT_SHIFT", e[e.BACKLIGHT_USE_7U_SPACEBAR = 4] = "BACKLIGHT_USE_7U_SPACEBAR", e[e.BACKLIGHT_USE_ISO_ENTER = 5] = "BACKLIGHT_USE_ISO_ENTER", e[e.BACKLIGHT_DISABLE_HHKB_BLOCKER_LEDS = 6] = "BACKLIGHT_DISABLE_HHKB_BLOCKER_LEDS", e[e.BACKLIGHT_DISABLE_WHEN_USB_SUSPENDED = 7] = "BACKLIGHT_DISABLE_WHEN_USB_SUSPENDED", e[e.BACKLIGHT_DISABLE_AFTER_TIMEOUT = 8] = "BACKLIGHT_DISABLE_AFTER_TIMEOUT", e[e.BACKLIGHT_BRIGHTNESS = 9] = "BACKLIGHT_BRIGHTNESS", e[e.BACKLIGHT_EFFECT = 10] = "BACKLIGHT_EFFECT", e[e.BACKLIGHT_EFFECT_SPEED = 11] = "BACKLIGHT_EFFECT_SPEED", e[e.BACKLIGHT_COLOR_1 = 12] = "BACKLIGHT_COLOR_1", e[e.BACKLIGHT_COLOR_2 = 13] = "BACKLIGHT_COLOR_2", e[e.BACKLIGHT_CAPS_LOCK_INDICATOR_COLOR = 14] = "BACKLIGHT_CAPS_LOCK_INDICATOR_COLOR", e[e.BACKLIGHT_CAPS_LOCK_INDICATOR_ROW_COL = 15] = "BACKLIGHT_CAPS_LOCK_INDICATOR_ROW_COL", e[e.BACKLIGHT_LAYER_1_INDICATOR_COLOR = 16] = "BACKLIGHT_LAYER_1_INDICATOR_COLOR", e[e.BACKLIGHT_LAYER_1_INDICATOR_ROW_COL = 17] = "BACKLIGHT_LAYER_1_INDICATOR_ROW_COL", e[e.BACKLIGHT_LAYER_2_INDICATOR_COLOR = 18] = "BACKLIGHT_LAYER_2_INDICATOR_COLOR", e[e.BACKLIGHT_LAYER_2_INDICATOR_ROW_COL = 19] = "BACKLIGHT_LAYER_2_INDICATOR_ROW_COL", e[e.BACKLIGHT_LAYER_3_INDICATOR_COLOR = 20] = "BACKLIGHT_LAYER_3_INDICATOR_COLOR", e[e.BACKLIGHT_LAYER_3_INDICATOR_ROW_COL = 21] = "BACKLIGHT_LAYER_3_INDICATOR_ROW_COL", e[e.BACKLIGHT_CUSTOM_COLOR = 23] = "BACKLIGHT_CUSTOM_COLOR", e[e.QMK_RGBLIGHT_BRIGHTNESS = 128] = "QMK_RGBLIGHT_BRIGHTNESS", e[e.QMK_RGBLIGHT_EFFECT = 129] = "QMK_RGBLIGHT_EFFECT", e[e.QMK_RGBLIGHT_EFFECT_SPEED = 130] = "QMK_RGBLIGHT_EFFECT_SPEED", e[e.QMK_RGBLIGHT_COLOR = 131] = "QMK_RGBLIGHT_COLOR"
        }(t.LightingValue || (t.LightingValue = {})),
        function(e) {
            e.None = "none", e.QMKLighting = "qmk_backlight", e.QMKRGBLight = "qmk_rgblight", e.QMKBacklightRGBLight = "qmk_backlight_rgblight", e.WTRGBBacklight = "wt_rgb_backlight", e.WTMonoBacklight = "wt_mono_backlight"
        }(t.LightingTypeDefinition || (t.LightingTypeDefinition = {})),
        function(e) {
            e.RotaryEncoder = "rotary-encoder"
        }(t.CustomFeaturesV2 || (t.CustomFeaturesV2 = {}))
})(iL);
var AE = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.KeyColorType = t.KeycodeType = void 0,
        function(e) {
            e.QMK = "qmk", e.WT = "wt", e.None = "none"
        }(t.KeycodeType || (t.KeycodeType = {})),
        function(e) {
            e.Alpha = "alpha", e.Mod = "mod", e.Accent = "accent", e.Enter = "enter", e.Space = "space", e.Arrow = "arrow"
        }(t.KeyColorType || (t.KeyColorType = {}))
})(AE);
var uc;
Object.defineProperty(EE, "__esModule", {
    value: !0
});
EE.LightingPreset = void 0;
var yn = iL,
    Bp = AE;
EE.LightingPreset = (uc = {}, uc[yn.LightingTypeDefinition.None] = {
    effects: [],
    underglowEffects: [],
    keycodes: Bp.KeycodeType.None,
    supportedLightingValues: []
}, uc[yn.LightingTypeDefinition.QMKLighting] = {
    effects: [
        ["Off", 0],
        ["On", 0]
    ],
    underglowEffects: [],
    keycodes: Bp.KeycodeType.QMK,
    supportedLightingValues: [yn.LightingValue.BACKLIGHT_BRIGHTNESS, yn.LightingValue.BACKLIGHT_EFFECT]
}, uc[yn.LightingTypeDefinition.QMKBacklightRGBLight] = {
    effects: [
        ["Off", 0],
        ["On", 0]
    ],
    underglowEffects: [
        ["All Off", 0],
        ["Solid Color", 1],
        ["Breathing 1", 1],
        ["Breathing 2", 1],
        ["Breathing 3", 1],
        ["Breathing 4", 1],
        ["Rainbow Mood 1", 0],
        ["Rainbow Mood 2", 0],
        ["Rainbow Mood 3", 0],
        ["Rainbow Swirl 1", 0],
        ["Rainbow Swirl 2", 0],
        ["Rainbow Swirl 3", 0],
        ["Rainbow Swirl 4", 0],
        ["Rainbow Swirl 5", 0],
        ["Rainbow Swirl 6", 0],
        ["Snake 1", 1],
        ["Snake 2", 1],
        ["Snake 3", 1],
        ["Snake 4", 1],
        ["Snake 5", 1],
        ["Snake 6", 1],
        ["Knight 1", 1],
        ["Knight 2", 1],
        ["Knight 3", 1],
        ["Christmas", 1],
        ["Gradient 1", 1],
        ["Gradient 2", 1],
        ["Gradient 3", 1],
        ["Gradient 4", 1],
        ["Gradient 5", 1],
        ["Gradient 6", 1],
        ["Gradient 7", 1],
        ["Gradient 8", 1],
        ["Gradient 9", 1],
        ["Gradient 10", 1],
        ["RGB Test", 1],
        ["Alternating", 1]
    ],
    keycodes: Bp.KeycodeType.QMK,
    supportedLightingValues: [yn.LightingValue.BACKLIGHT_BRIGHTNESS, yn.LightingValue.BACKLIGHT_EFFECT, yn.LightingValue.QMK_RGBLIGHT_BRIGHTNESS, yn.LightingValue.QMK_RGBLIGHT_EFFECT, yn.LightingValue.QMK_RGBLIGHT_EFFECT_SPEED, yn.LightingValue.QMK_RGBLIGHT_COLOR]
}, uc[yn.LightingTypeDefinition.QMKRGBLight] = {
    effects: [],
    underglowEffects: [
        ["All Off", 0],
        ["Solid Color", 1],
        ["Breathing 1", 1],
        ["Breathing 2", 1],
        ["Breathing 3", 1],
        ["Breathing 4", 1],
        ["Rainbow Mood 1", 0],
        ["Rainbow Mood 2", 0],
        ["Rainbow Mood 3", 0],
        ["Rainbow Swirl 1", 0],
        ["Rainbow Swirl 2", 0],
        ["Rainbow Swirl 3", 0],
        ["Rainbow Swirl 4", 0],
        ["Rainbow Swirl 5", 0],
        ["Rainbow Swirl 6", 0],
        ["Snake 1", 1],
        ["Snake 2", 1],
        ["Snake 3", 1],
        ["Snake 4", 1],
        ["Snake 5", 1],
        ["Snake 6", 1],
        ["Knight 1", 1],
        ["Knight 2", 1],
        ["Knight 3", 1],
        ["Christmas", 1],
        ["Gradient 1", 1],
        ["Gradient 2", 1],
        ["Gradient 3", 1],
        ["Gradient 4", 1],
        ["Gradient 5", 1],
        ["Gradient 6", 1],
        ["Gradient 7", 1],
        ["Gradient 8", 1],
        ["Gradient 9", 1],
        ["Gradient 10", 1],
        ["RGB Test", 1],
        ["Alternating", 1]
    ],
    keycodes: Bp.KeycodeType.QMK,
    supportedLightingValues: [yn.LightingValue.QMK_RGBLIGHT_BRIGHTNESS, yn.LightingValue.QMK_RGBLIGHT_EFFECT, yn.LightingValue.QMK_RGBLIGHT_EFFECT_SPEED, yn.LightingValue.QMK_RGBLIGHT_COLOR]
}, uc[yn.LightingTypeDefinition.WTMonoBacklight] = {
    effects: [
        ["All Off", 0],
        ["All On", 0],
        ["Raindrops", 0]
    ],
    underglowEffects: [],
    keycodes: Bp.KeycodeType.WT,
    supportedLightingValues: [yn.LightingValue.BACKLIGHT_BRIGHTNESS, yn.LightingValue.BACKLIGHT_EFFECT, yn.LightingValue.BACKLIGHT_EFFECT_SPEED, yn.LightingValue.BACKLIGHT_DISABLE_AFTER_TIMEOUT, yn.LightingValue.BACKLIGHT_DISABLE_WHEN_USB_SUSPENDED]
}, uc[yn.LightingTypeDefinition.WTRGBBacklight] = {
    effects: [
        ["All Off", 0],
        ["Solid Color 1", 1],
        ["Alphas/Mods Color 1/2", 2],
        ["Gradient Vertical Color 1/2", 2],
        ["Raindrops Color 1/2", 2],
        ["Cycle All", 0],
        ["Cycle Horizontal", 0],
        ["Cycle Vertical", 0],
        ["Jellybean Raindrops", 0],
        ["Radial All Hues", 0],
        ["Radial Color 1", 1]
    ],
    underglowEffects: [],
    keycodes: Bp.KeycodeType.WT,
    supportedLightingValues: [yn.LightingValue.BACKLIGHT_BRIGHTNESS, yn.LightingValue.BACKLIGHT_EFFECT, yn.LightingValue.BACKLIGHT_EFFECT_SPEED, yn.LightingValue.BACKLIGHT_DISABLE_AFTER_TIMEOUT, yn.LightingValue.BACKLIGHT_DISABLE_WHEN_USB_SUSPENDED, yn.LightingValue.BACKLIGHT_COLOR_1, yn.LightingValue.BACKLIGHT_COLOR_2, yn.LightingValue.BACKLIGHT_CAPS_LOCK_INDICATOR_COLOR, yn.LightingValue.BACKLIGHT_CAPS_LOCK_INDICATOR_ROW_COL, yn.LightingValue.BACKLIGHT_LAYER_1_INDICATOR_COLOR, yn.LightingValue.BACKLIGHT_LAYER_1_INDICATOR_ROW_COL, yn.LightingValue.BACKLIGHT_LAYER_2_INDICATOR_COLOR, yn.LightingValue.BACKLIGHT_LAYER_2_INDICATOR_ROW_COL, yn.LightingValue.BACKLIGHT_LAYER_3_INDICATOR_COLOR, yn.LightingValue.BACKLIGHT_LAYER_3_INDICATOR_ROW_COL]
}, uc);
var Cu = {},
    l1 = {},
    CE = {};
Object.defineProperty(CE, "__esModule", {
    value: !0
});
CE.qmk_audio = void 0;
CE.qmk_audio = [{
    label: "Audio",
    content: [{
        label: "General",
        content: [{
            label: "Audio Enable",
            type: "toggle",
            content: ["id_qmk_audio_enable", 4, 1]
        }, {
            label: "Audio Clicky Enable",
            type: "toggle",
            content: ["id_qmk_audio_clicky_enable", 4, 2]
        }]
    }]
}];
var ME = {};
Object.defineProperty(ME, "__esModule", {
    value: !0
});
ME.qmk_backlight = void 0;
ME.qmk_backlight = [{
    label: "Lighting",
    content: [{
        label: "Backlight",
        content: [{
            label: "Backlight Brightness",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_backlight_brightness", 1, 1]
        }, {
            label: "Backlight Effect",
            type: "dropdown",
            content: ["id_qmk_backlight_effect", 1, 2],
            options: [
                ["Off", 0],
                ["Breathing", 1]
            ]
        }]
    }]
}];
var TE = {};
Object.defineProperty(TE, "__esModule", {
    value: !0
});
TE.qmk_backlight_rgblight = void 0;
TE.qmk_backlight_rgblight = [{
    label: "Lighting",
    content: [{
        label: "Backlight",
        content: [{
            label: "Backlight Brightness",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_backlight_brightness", 1, 1]
        }, {
            label: "Backlight Effect",
            type: "dropdown",
            content: ["id_qmk_backlight_effect", 1, 2],
            options: [
                ["Off", 0],
                ["Breathing", 1]
            ]
        }]
    }, {
        label: "Underglow",
        content: [{
            label: "Brightness",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_rgblight_brightness", 2, 1]
        }, {
            label: "Effect",
            type: "dropdown",
            content: ["id_qmk_rgblight_effect", 2, 2],
            options: ["All Off", "Solid Color", "Breathing 1", "Breathing 2", "Breathing 3", "Breathing 4", "Rainbow Mood 1", "Rainbow Mood 2", "Rainbow Mood 3", "Rainbow Swirl 1", "Rainbow Swirl 2", "Rainbow Swirl 3", "Rainbow Swirl 4", "Rainbow Swirl 5", "Rainbow Swirl 6", "Snake 1", "Snake 2", "Snake 3", "Snake 4", "Snake 5", "Snake 6", "Knight 1", "Knight 2", "Knight 3", "Christmas", "Gradient 1", "Gradient 2", "Gradient 3", "Gradient 4", "Gradient 5", "Gradient 6", "Gradient 7", "Gradient 8", "Gradient 9", "Gradient 10", "RGB Test", "Alternating", "Twinkle 1", "Twinkle 2", "Twinkle 3", "Twinkle 4", "Twinkle 5", "Twinkle 6"]
        }, {
            showIf: "{id_qmk_rgblight_effect} != 0",
            label: "Effect Speed",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_rgblight_effect_speed", 2, 3]
        }, {
            showIf: "{id_qmk_rgblight_effect} != 0 && {id_qmk_rgblight_effect} != 35",
            label: "Color",
            type: "color",
            content: ["id_qmk_rgblight_color", 2, 4]
        }]
    }]
}];
var PE = {};
Object.defineProperty(PE, "__esModule", {
    value: !0
});
PE.qmk_rgblight = void 0;
PE.qmk_rgblight = [{
    label: "Lighting",
    content: [{
        label: "Underglow",
        content: [{
            label: "Brightness",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_rgblight_brightness", 2, 1]
        }, {
            label: "Effect",
            type: "dropdown",
            content: ["id_qmk_rgblight_effect", 2, 2],
            options: ["All Off", "Solid Color", "Breathing 1", "Breathing 2", "Breathing 3", "Breathing 4", "Rainbow Mood 1", "Rainbow Mood 2", "Rainbow Mood 3", "Rainbow Swirl 1", "Rainbow Swirl 2", "Rainbow Swirl 3", "Rainbow Swirl 4", "Rainbow Swirl 5", "Rainbow Swirl 6", "Snake 1", "Snake 2", "Snake 3", "Snake 4", "Snake 5", "Snake 6", "Knight 1", "Knight 2", "Knight 3", "Christmas", "Gradient 1", "Gradient 2", "Gradient 3", "Gradient 4", "Gradient 5", "Gradient 6", "Gradient 7", "Gradient 8", "Gradient 9", "Gradient 10", "RGB Test", "Alternating", "Twinkle 1", "Twinkle 2", "Twinkle 3", "Twinkle 4", "Twinkle 5", "Twinkle 6"]
        }, {
            showIf: "{id_qmk_rgblight_effect} != 0",
            label: "Effect Speed",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_rgblight_effect_speed", 2, 3]
        }, {
            showIf: "{id_qmk_rgblight_effect} != 0 && {id_qmk_rgblight_effect} != 35",
            label: "Color",
            type: "color",
            content: ["id_qmk_rgblight_color", 2, 4]
        }]
    }]
}];
var IE = {};
Object.defineProperty(IE, "__esModule", {
    value: !0
});
IE.qmk_rgb_matrix = void 0;
IE.qmk_rgb_matrix = [{
    label: "Lighting",
    content: [{
        label: "Backlight",
        content: [{
            label: "Brightness",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_rgb_matrix_brightness", 3, 1]
        }, {
            label: "Effect",
            type: "dropdown",
            content: ["id_qmk_rgb_matrix_effect", 3, 2],
            options: ["All Off", "Solid Color", "Alphas Mods", "Gradient Up/Down", "Gradient Left/Right", "Breathing", "Band Sat.", "Band Val.", "Pinwheel Sat.", "Pinwheel Val.", "Spiral Sat.", "Spiral Val.", "Cycle All", "Cycle Left/Right", "Cycle Up/Down", "Rainbow Moving Chevron", "Cycle Out/In", "Cycle Out/In Dual", "Cycle Pinwheel", "Cycle Spiral", "Dual Beacon", "Rainbow Beacon", "Rainbow Pinwheels", "Raindrops", "Jellybean Raindrops", "Hue Breathing", "Hue Pendulum", "Hue Wave", "Pixel Rain", "Pixel Flow", "Pixel Fractal", "Typing Heatmap", "Digital Rain", "Solid Reactive Simple", "Solid Reactive", "Solid Reactive Wide", "Solid Reactive Multi Wide", "Solid Reactive Cross", "Solid Reactive Multi Cross", "Solid Reactive Nexus", "Solid Reactive Multi Nexus", "Spash", "Multi Splash", "Solid Splash", "Solid Multi Splash"]
        }, {
            showIf: "{id_qmk_rgb_matrix_effect} != 0",
            label: "Effect Speed",
            type: "range",
            options: [0, 255],
            content: ["id_qmk_rgb_matrix_effect_speed", 3, 3]
        }, {
            showIf: "{id_qmk_rgb_matrix_effect} != 0 && {id_qmk_rgb_matrix_effect} != 24 && {id_qmk_rgb_matrix_effect} != 28 && {id_qmk_rgb_matrix_effect} != 29 && {id_qmk_rgb_matrix_effect} != 32",
            label: "Color",
            type: "color",
            content: ["id_qmk_rgb_matrix_color", 3, 4]
        }]
    }]
}];
Object.defineProperty(l1, "__esModule", {
    value: !0
});
l1.commonMenus = void 0;
var nle = CE,
    rle = ME,
    ile = TE,
    sle = PE,
    ole = IE;
l1.commonMenus = {
    qmk_audio: nle.qmk_audio,
    qmk_backlight_rgblight: ile.qmk_backlight_rgblight,
    qmk_backlight: rle.qmk_backlight,
    qmk_rgb_matrix: ole.qmk_rgb_matrix,
    qmk_rgblight: sle.qmk_rgblight
};
var _s = {},
    ale = function(t, e, n, r, i, s, o, a) {
        if (!t) {
            var l;
            if (e === void 0) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
            else {
                var u = [n, r, i, s, o, a],
                    c = 0;
                l = new Error(e.replace(/%s/g, function() {
                    return u[c++]
                })), l.name = "Invariant Violation"
            }
            throw l.framesToPop = 1, l
        }
    },
    lle = ale,
    qt = _n && _n.__assign || function() {
        return qt = Object.assign || function(t) {
            for (var e, n = 1, r = arguments.length; n < r; n++) {
                e = arguments[n];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
        }, qt.apply(this, arguments)
    },
    ule = _n && _n.__rest || function(t, e) {
        var n = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (t != null && typeof Object.getOwnPropertySymbols == "function")
            for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
        return n
    },
    Bh = _n && _n.__spreadArray || function(t, e, n) {
        if (n || arguments.length === 2)
            for (var r = 0, i = e.length, s; r < i; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
        return t.concat(s || Array.prototype.slice.call(e))
    },
    cle = _n && _n.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(_s, "__esModule", {
    value: !0
});
_s.kleLayoutToVIALayout = _s.extractGroups = _s.getBoundingBox = _s.findPivot = _s.filterGroups = _s.rawKLEToKLELayout = void 0;
var fle = cle(lle),
    dle = JSON.stringify,
    ed = AE,
    ple = /^[eE]\d+\s*$/,
    hle = /^[lL]\d+\s*$/;

function mle(t) {
    var e = t.split(`,
`);
    return e.map(function(n) {
        return JSON.parse(n.replace(/\n/g, "\\n").replace(/\\/g, "\\\\").replace(/\"\\(?!,)/g, "\\\\").replace(/([{,])([A-Za-z][0-9A-Za-z]?)(:)/g, '$1"$2"$3'))
    })
}
_s.rawKLEToKLELayout = mle;

function nj(t) {
    return t.filter(function(e) {
        return e.group.option === 0
    })
}
_s.filterGroups = nj;

function WI(t) {
    return Bh([], t, !0).sort(function(e, n) {
        var r = e.y - n.y;
        return r !== 0 ? r : e.x - n.x
    })[0]
}
_s.findPivot = WI;

function KN(t) {
    var e = t.x,
        n = t.y,
        r = t.x2,
        i = r === void 0 ? 0 : r,
        s = t.y2,
        o = s === void 0 ? 0 : s,
        a = o === 0 ? e > e + i : o < 0;
    return a ? {
        x: e + i,
        y: n + o
    } : {
        x: e,
        y: n
    }
}

function gle(t, e) {
    var n = KN(t),
        r = KN(e);
    return {
        x: r.x - n.x,
        y: r.y - n.y
    }
}

function rj(t) {
    var e = t.x2,
        n = e === void 0 ? 0 : e,
        r = t.y2,
        i = r === void 0 ? 0 : r,
        s = t.x,
        o = t.y,
        a = t.w,
        l = a === void 0 ? 1 : a,
        u = t.h,
        c = u === void 0 ? 1 : u,
        f = t.r,
        d = f === void 0 ? 0 : f,
        p = t.rx,
        m = p === void 0 ? 0 : p,
        y = t.ry,
        v = y === void 0 ? 0 : y,
        b = t.h2,
        _ = b === void 0 ? c : b,
        x = t.w2,
        S = x === void 0 ? l : x,
        E = [m, v, d],
        A = {
            xStart: Math.min(s, s + n),
            yStart: Math.min(o, o + i),
            xEnd: Math.max(s + l, s + n + S),
            yEnd: Math.max(o + c, o + i + _)
        },
        T = [{
            x: A.xStart,
            y: A.yStart
        }, {
            x: A.xEnd,
            y: A.yStart
        }, {
            x: A.xStart,
            y: A.yEnd
        }, {
            x: A.xEnd,
            y: A.yEnd
        }].map(function(M) {
            return yle.apply(void 0, Bh([M.x, M.y], E, !1))
        });
    return {
        xStart: Math.min.apply(Math, T.map(function(M) {
            return M.x
        })),
        xEnd: Math.max.apply(Math, T.map(function(M) {
            return M.x
        })),
        yStart: Math.min.apply(Math, T.map(function(M) {
            return M.y
        })),
        yEnd: Math.max.apply(Math, T.map(function(M) {
            return M.y
        }))
    }
}
_s.getBoundingBox = rj;

function yle(t, e, n, r, i) {
    var s = i * Math.PI / 180,
        o = [t - n, e - r],
        a = o[0],
        l = o[1];
    return {
        x: n + a * Math.cos(s) - l * Math.sin(s),
        y: r + a * Math.sin(s) + l * Math.cos(s)
    }
}

function ij(t, e, n) {
    var r = t.filter(function(s) {
            return s.group.key !== -1
        }),
        i = r.reduce(function(s, o) {
            var a, l;
            return qt(qt({}, s), (a = {}, a[o.group.key] = qt(qt({}, s[o.group.key] || {}), (l = {}, l[o.group.option] = ((s[o.group.key] || {})[o.group.option] || []).concat(o), l)), a))
        }, {});
    return Object.entries(i).reduce(function(s, o) {
        var a, l = o[0],
            u = o[1],
            c = WI(u[0]),
            f = Object.entries(u).reduce(function(d, p) {
                var m, y = p[0],
                    v = p[1];
                return qt(qt({}, d), (m = {}, m[y] = function(b) {
                    return v.map(function(_) {
                        return qt(qt({}, _), {
                            x: _.x - b.x,
                            y: _.y - b.y
                        })
                    })
                }(gle(c, WI(v))).map(function(b) {
                    return sj(b, e, n)
                }), m))
            }, {});
        return qt(qt({}, s), (a = {}, a[l] = f, a))
    }, {})
}
_s.extractGroups = ij;

function qN(t) {
    if (!t) throw new Error("'Row,col' pairs must be placed in the top-left legend in the KLE keymap provided in the definition.");
    var e = t.split(/[，,]/);
    (0, fle.default)(e.length === 2, "".concat(t, " is not a pair"));
    var n = e.map(function(r) {
        return parseInt(r, 10)
    });
    if (n.some(function(r) {
            return Number.isNaN(r)
        })) throw new Error("Invalid pair: ".concat(t));
    return n
}

function sj(t, e, n) {
    var r = t.c,
        i = t.t;
    t.group;
    var s = ule(t, ["c", "t", "group"]);
    return qt(qt({}, s), {
        x: t.x - e.x,
        y: t.y - e.y,
        rx: t.rx - e.x,
        ry: t.ry - e.y,
        color: n["".concat(r, ":").concat(i)] || ed.KeyColorType.Alpha
    })
}
var vle = [
        [0, 6, 2, 8, 9, 11, 3, 5, 1, 4, 7, 10],
        [1, 7, -1, -1, 9, 11, 4, -1, -1, -1, -1, 10],
        [3, -1, 5, -1, 9, 11, -1, -1, 4, -1, -1, 10],
        [4, -1, -1, -1, 9, 11, -1, -1, -1, -1, -1, 10],
        [0, 6, 2, 8, 10, -1, 3, 5, 1, 4, 7, -1],
        [1, 7, -1, -1, 10, -1, 4, -1, -1, -1, -1, -1],
        [3, -1, 5, -1, 10, -1, -1, -1, 4, -1, -1, -1],
        [4, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1]
    ],
    ble = function(t, e) {
        e === void 0 && (e = 0);
        var n = [],
            r = t.split(`
`);
        return r.forEach(function(i, s) {
            n[vle[e][s]] = i.trim()
        }), n
    },
    Fh;
(function(t) {
    t[t.LED = 6] = "LED", t[t.ROWCOL = 0] = "ROWCOL", t[t.GROUP = 8] = "GROUP", t[t.ENCODER = 4] = "ENCODER"
})(Fh || (Fh = {}));
var xle = function(t, e) {
    var n = {},
        r = [-1, -1],
        i = [-1, 0],
        s = t[Fh.ENCODER];
    s && ple.test(s) && (n.ei = +s.slice(1));
    var o = t[Fh.LED];
    o && hle.test(o) && (n.li = +o.slice(1));
    var a = t[Fh.ROWCOL],
        l = e || n.ei !== void 0 && !a ? r : qN(a),
        u = l[0],
        c = l[1],
        f = t[Fh.GROUP],
        d = f ? qN(f) : i,
        p = d[0],
        m = d[1];
    return qt(qt({}, n), {
        group: {
            key: p,
            option: m
        },
        row: u,
        col: c
    })
};

function _le(t) {
    var e, n = t.filter(function(b) {
            return Array.isArray(b)
        }),
        r = n.reduce(function(b, _) {
            var x = _.reduce(function(S, E) {
                var A, T = S.cursor,
                    M = T.x,
                    I = T.y,
                    O = S.res,
                    k = S.c,
                    H = S.h,
                    N = S.t,
                    B = S.r,
                    U = S.d,
                    q = S.rx,
                    Q = S.ry,
                    F = S.w,
                    G = S.a,
                    W = S.y2,
                    se = S.x2,
                    ee = S.w2,
                    ae = S.h2,
                    de = S.colorCount;
                if (typeof E != "string") {
                    var re = {
                        colorCount: de,
                        a: G,
                        c: k,
                        t: N,
                        h: H,
                        r: B,
                        rx: q,
                        ry: Q,
                        res: O,
                        d: U,
                        w: F,
                        cursor: {
                            x: M,
                            y: I
                        }
                    };
                    return re = ["y2", "x2", "w2", "h2", "r", "rx", "ry", "h", "w"].reduce(function(xe, be) {
                        var he;
                        return typeof E[be] == "number" ? qt(qt({}, xe), (he = {}, he[be] = E[be], he)) : xe
                    }, re), typeof E.d == "boolean" && (re = qt(qt({}, re), {
                        d: E.d
                    })), (typeof E.ry == "number" || typeof E.rx == "number") && (re = qt(qt({}, re), {
                        cursor: qt(qt({}, re.cursor), {
                            y: re.ry
                        })
                    })), typeof E.y == "number" && (re = qt(qt({}, re), {
                        cursor: qt(qt({}, re.cursor), {
                            y: re.cursor.y + E.y
                        })
                    })), typeof E.x == "number" && (re = qt(qt({}, re), {
                        cursor: qt(qt({}, re.cursor), {
                            x: M + E.x
                        })
                    })), typeof E.a == "number" && (re = qt(qt({}, re), {
                        a: E.a
                    })), typeof E.c == "string" && (re = qt(qt({}, re), {
                        c: E.c
                    })), typeof E.t == "string" && (re = qt(qt({}, re), {
                        t: E.t
                    })), re
                } else if (typeof E == "string") {
                    var _e = "".concat(k, ":").concat(N),
                        fe = {},
                        ue = xle(ble(E, G), U),
                        ve = qt(qt({}, de), (A = {}, A[_e] = de[_e] === void 0 ? 1 : de[_e] + 1, A));
                    return fe = qt(qt(qt({}, fe), ue), {
                        c: k,
                        t: N,
                        x: M + q,
                        y: I,
                        r: B,
                        rx: q,
                        ry: Q,
                        d: U,
                        h: H,
                        w: F,
                        w2: ee,
                        y2: W,
                        x2: se,
                        h2: ae
                    }), {
                        h: 1,
                        w: 1,
                        r: B,
                        rx: q,
                        a: G,
                        ry: Q,
                        c: k,
                        d: !1,
                        colorCount: ve,
                        t: N,
                        cursor: {
                            x: M + F,
                            y: I
                        },
                        res: Bh(Bh([], O, !0), [fe], !1)
                    }
                }
                return {
                    a: G,
                    c: k,
                    t: N,
                    h: H,
                    d: U,
                    r: B,
                    w: F,
                    rx: q,
                    ry: Q,
                    res: O,
                    colorCount: de,
                    cursor: {
                        x: M,
                        y: I
                    }
                }
            }, qt(qt({}, b.prevRow), {
                cursor: b.cursor,
                colorCount: b.colorCount,
                h: 1,
                w: 1,
                d: !1,
                res: []
            }));
            return {
                cursor: {
                    x: 0,
                    y: x.cursor.y + 1
                },
                colorCount: x.colorCount,
                prevRow: {
                    c: x.c,
                    t: x.t,
                    r: x.r,
                    rx: x.rx,
                    ry: x.ry,
                    a: x.a
                },
                res: Bh(Bh([], b.res, !0), [x.res], !1)
            }
        }, {
            cursor: {
                x: 0,
                y: 0
            },
            prevRow: {
                c: "#cccccc",
                t: "#000000",
                r: 0,
                rx: 0,
                ry: 0,
                a: 0
            },
            res: [],
            colorCount: {}
        }),
        i = r.colorCount,
        s = r.res,
        o = Object.keys(i);
    if (o.sort(function(b, _) {
            return i[_] - i[b]
        }), o.length > 6) throw new Error(`Please correct layout, too many colors:
` + dle(i));
    var a = (e = {}, e[o[0]] = ed.KeyColorType.Alpha, e[o[1]] = ed.KeyColorType.Mod, e[o[2]] = ed.KeyColorType.Accent, e[o[3]] = ed.KeyColorType.Enter, e[o[4]] = ed.KeyColorType.Space, e[o[5]] = ed.KeyColorType.Arrow, e),
        l = s.flat(),
        u = nj(l),
        c = u.map(rj),
        f = Math.min.apply(Math, c.map(function(b) {
            return b.xStart
        })),
        d = Math.min.apply(Math, c.map(function(b) {
            return b.yStart
        })),
        p = Math.max.apply(Math, c.map(function(b) {
            return b.xEnd
        })) - f,
        m = Math.max.apply(Math, c.map(function(b) {
            return b.yEnd
        })) - d,
        y = u.filter(function(b) {
            return b.group.key === -1
        }).map(function(b) {
            return sj(b, {
                x: f,
                y: d
            }, a)
        }),
        v = ij(l, {
            x: f,
            y: d
        }, a);
    return {
        width: p,
        height: m,
        optionKeys: v,
        keys: y
    }
}
_s.kleLayoutToVIALayout = _le;
Object.defineProperty(Cu, "__esModule", {
    value: !0
});
Cu.validateCommonMenus = Cu.validateKeyBounds = Cu.validateLayouts = void 0;
var Sle = l1,
    wle = _s,
    Ele = function(t) {
        var e = t.labels,
            n = e === void 0 ? [] : e,
            r = t.keymap,
            i = (0, wle.kleLayoutToVIALayout)(r),
            s = n.filter(function(o, a) {
                return i.optionKeys[a] === void 0 || i.optionKeys[a][0] === void 0
            });
        if (s.length > 0) throw new Error("The KLE is missing the group keys for: ".concat(s.join(",")));
        return i
    };
Cu.validateLayouts = Ele;
var Ale = function(t, e) {
    var n = t.rows,
        r = t.cols,
        i = Object.values(e.optionKeys).flatMap(function(o) {
            return Object.values(o).flat()
        }),
        s = e.keys.concat(i).filter(function(o) {
            var a = o.row,
                l = o.col;
            return a >= n || l >= r
        });
    if (s.length !== 0) throw new Error("The following keys reference a row or column outside of dimension defined in the matrix property: ".concat(s.map(function(o) {
        var a = o.row,
            l = o.col;
        return "(".concat(a, ",").concat(l, ")")
    }).join(",")))
};
Cu.validateKeyBounds = Ale;
var Cle = function(t) {
    var e = (t || []).filter(function(n) {
        return typeof n == "string" ? !Object.keys(Sle.commonMenus).includes(n) : !1
    });
    if (e.length) throw Error("Common menus not for found for: ".concat(e.join(", ")))
};
Cu.validateCommonMenus = Cle;
(function(t) {
    var e = _n && _n.__assign || function() {
            return e = Object.assign || function(p) {
                for (var m, y = 1, v = arguments.length; y < v; y++) {
                    m = arguments[y];
                    for (var b in m) Object.prototype.hasOwnProperty.call(m, b) && (p[b] = m[b])
                }
                return p
            }, e.apply(this, arguments)
        },
        n = _n && _n.__rest || function(p, m) {
            var y = {};
            for (var v in p) Object.prototype.hasOwnProperty.call(p, v) && m.indexOf(v) < 0 && (y[v] = p[v]);
            if (p != null && typeof Object.getOwnPropertySymbols == "function")
                for (var b = 0, v = Object.getOwnPropertySymbols(p); b < v.length; b++) m.indexOf(v[b]) < 0 && Object.prototype.propertyIsEnumerable.call(p, v[b]) && (y[v[b]] = p[v[b]]);
            return y
        },
        r = _n && _n.__importDefault || function(p) {
            return p && p.__esModule ? p : {
                default: p
            }
        };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.getLightingDefinition = t.keyboardDefinitionV2ToVIADefinitionV2 = t.keyboardDefinitionV3ToVIADefinitionV3 = t.getVendorProductId = void 0;
    var i = r(nL),
        s = r(rL),
        o = EE,
        a = Cu,
        l = function(p) {
            var m = /^[Oo]x/;
            return p.match(m) ? "Did you mean '".concat(p.replace(m, "0x"), "' instead?") : ""
        },
        u = function(p) {
            var m = p.productId,
                y = p.vendorId;
            if (y.toUpperCase() === "0XFEED") throw new Error("'0xFEED' is not a valid vendorId.");
            var v = parseInt(y, 16),
                b = parseInt(m, 16);
            if (isNaN(v)) throw new Error("vendorId could not be parsed: '".concat(y, "'. ").concat(l(y)));
            if (isNaN(b)) throw new Error("productId could not be parsed: '".concat(m, "'. ").concat(l(m)));
            return v * 65536 + b
        };
    t.getVendorProductId = u;
    var c = function(p) {
        var m = (0, i.default)(p),
            y = m.name,
            v = m.menus,
            b = m.keycodes,
            _ = m.customKeycodes,
            x = m.matrix,
            S = m.layouts,
            E = m.firmwareVersion,
            A = (0, a.validateLayouts)(S);
        S.keymap;
        var T = n(S, ["keymap"]),
            M = e(e({}, T), A);
        return (0, a.validateKeyBounds)(x, M), (0, a.validateCommonMenus)(v ? ? []), {
            name: y,
            vendorProductId: (0, t.getVendorProductId)(p),
            firmwareVersion: E ? ? 0,
            menus: v ? ? [],
            keycodes: b ? ? [],
            customKeycodes: _,
            matrix: x,
            layouts: M
        }
    };
    t.keyboardDefinitionV3ToVIADefinitionV3 = c;
    var f = function(p) {
        var m = (0, s.default)(p),
            y = m.name,
            v = m.customFeatures,
            b = m.customMenus,
            _ = m.customKeycodes,
            x = m.lighting,
            S = m.matrix,
            E = m.layouts,
            A = (0, a.validateLayouts)(E);
        E.keymap;
        var T = n(E, ["keymap"]),
            M = e(e({}, T), A);
        return (0, a.validateKeyBounds)(S, M), {
            name: y,
            lighting: x,
            layouts: M,
            matrix: S,
            customFeatures: v,
            customKeycodes: _,
            customMenus: b,
            vendorProductId: (0, t.getVendorProductId)(p)
        }
    };
    t.keyboardDefinitionV2ToVIADefinitionV2 = f;
    var d = function(p) {
        return typeof p == "string" ? o.LightingPreset[p] : e(e({}, o.LightingPreset[p.extends]), p)
    };
    t.getLightingDefinition = d
})(tj);
var oj = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.defaultKeycodes = t.BuiltInKeycodeModule = void 0,
        function(e) {
            e.QMKLighting = "qmk_lighting", e.WTLighting = "wt_lighting"
        }(t.BuiltInKeycodeModule || (t.BuiltInKeycodeModule = {})), t.defaultKeycodes = []
})(oj);
var aj = {};
Object.defineProperty(aj, "__esModule", {
    value: !0
});
var lj = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.getTheme = t.THEMES = void 0, t.THEMES = {
        RETRO_POINT: {
            alpha: {
                c: "#FFFFFF",
                t: "#000000"
            },
            mod: {
                c: "#A7A8AA",
                t: "#FFFFFF"
            },
            accent: {
                c: "#C3D5F8",
                t: "#FFFFFF"
            },
            enter: {
                c: "#afb0ae",
                t: "#505557"
            },
            space: {
                c: "#afb0ae",
                t: "#505557"
            },
            arrow: {
                c: "#afb0ae",
                t: "#505557"
            }
        },
        SURFFY: {
            alpha: {
                c: "#FFFFFF",
                t: "#F0B323"
            },
            mod: {
                c: "#67809A",
                t: "#FFFFFF"
            },
            accent: {
                c: "#F8C16F",
                t: "#f3eac3"
            },
            enter: {
                c: "#82999B",
                t: "#D1E0D7"
            },
            space: {
                c: "#9DB1B2",
                t: "#505557"
            },
            arrow: {
                c: "#FFCF83",
                t: "#505557"
            }
        },
        VENUS_NAVY: {
            alpha: {
                c: "#353535",
                t: "#FFFFFF"
            },
            mod: {
                c: "#3B455B",
                t: "#FFFFFF"
            },
            accent: {
                c: "#FF9D22",
                t: "#000000"
            },
            enter: {
                c: "#FF9D22",
                t: "#000000"
            },
            space: {
                c: "#FC2319",
                t: "#505557"
            },
            arrow: {
                c: "#FC2319",
                t: "#505557"
            }
        },
        MOCHA_COCOA: {
            alpha: {
                c: "#D0CCC4",
                t: "#864A36"
            },
            mod: {
                c: "#35373B",
                t: "#B8B8B8"
            },
            accent: {
                c: "#A48C61",
                t: "#EFDBB2"
            },
            enter: {
                c: "#A48C61",
                t: "#EFDBB2"
            },
            space: {
                c: "#5D4B3E",
                t: "#B6A193"
            },
            arrow: {
                c: "#5D4B3E",
                t: "#B6A193"
            }
        }
    };
    var e = function() {
        return t.THEMES.RETRO_POINT
    };
    t.getTheme = e
})(lj);
var RE = {};
Object.defineProperty(RE, "__esModule", {
    value: !0
});
RE.isVIAMenu = void 0;

function Mle(t) {
    var e = t;
    return e.label !== void 0 && e.content !== void 0
}
RE.isVIAMenu = Mle;
(function(t) {
    var e = _n && _n.__createBinding || (Object.create ? function(a, l, u, c) {
            c === void 0 && (c = u);
            var f = Object.getOwnPropertyDescriptor(l, u);
            (!f || ("get" in f ? !l.__esModule : f.writable || f.configurable)) && (f = {
                enumerable: !0,
                get: function() {
                    return l[u]
                }
            }), Object.defineProperty(a, c, f)
        } : function(a, l, u, c) {
            c === void 0 && (c = u), a[c] = l[u]
        }),
        n = _n && _n.__exportStar || function(a, l) {
            for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && e(l, a, u)
        };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.isKeyboardDefinitionV2 = t.isKeyboardDefinitionV3 = t.isVIADefinitionV2 = t.isVIADefinitionV3 = void 0;
    var r = EV;
    Object.defineProperty(t, "isVIADefinitionV3", {
        enumerable: !0,
        get: function() {
            return r.isVIADefinitionV3
        }
    });
    var i = ej;
    Object.defineProperty(t, "isVIADefinitionV2", {
        enumerable: !0,
        get: function() {
            return i.isVIADefinitionV2
        }
    });
    var s = nL;
    Object.defineProperty(t, "isKeyboardDefinitionV3", {
        enumerable: !0,
        get: function() {
            return s.isKeyboardDefinitionV3
        }
    });
    var o = rL;
    Object.defineProperty(t, "isKeyboardDefinitionV2", {
        enumerable: !0,
        get: function() {
            return o.isKeyboardDefinitionV2
        }
    }), n(tj, t), n(_s, t), n(oj, t), n(iL, t), n(AE, t), n(aj, t), n(lj, t), n(RE, t), n(Cu, t), n(l1, t)
})(Cse);
var Iw = {
    exports: {}
};
Iw.exports;
(function(t, e) {
    var n = 200,
        r = "__lodash_hash_undefined__",
        i = 800,
        s = 16,
        o = 9007199254740991,
        a = "[object Arguments]",
        l = "[object Array]",
        u = "[object AsyncFunction]",
        c = "[object Boolean]",
        f = "[object Date]",
        d = "[object Error]",
        p = "[object Function]",
        m = "[object GeneratorFunction]",
        y = "[object Map]",
        v = "[object Number]",
        b = "[object Null]",
        _ = "[object Object]",
        x = "[object Proxy]",
        S = "[object RegExp]",
        E = "[object Set]",
        A = "[object String]",
        T = "[object Undefined]",
        M = "[object WeakMap]",
        I = "[object ArrayBuffer]",
        O = "[object DataView]",
        k = "[object Float32Array]",
        H = "[object Float64Array]",
        N = "[object Int8Array]",
        B = "[object Int16Array]",
        U = "[object Int32Array]",
        q = "[object Uint8Array]",
        Q = "[object Uint8ClampedArray]",
        F = "[object Uint16Array]",
        G = "[object Uint32Array]",
        W = /[\\^$.*+?()[\]{}|]/g,
        se = /^\[object .+?Constructor\]$/,
        ee = /^(?:0|[1-9]\d*)$/,
        ae = {};
    ae[k] = ae[H] = ae[N] = ae[B] = ae[U] = ae[q] = ae[Q] = ae[F] = ae[G] = !0, ae[a] = ae[l] = ae[I] = ae[c] = ae[O] = ae[f] = ae[d] = ae[p] = ae[y] = ae[v] = ae[_] = ae[S] = ae[E] = ae[A] = ae[M] = !1;
    var de = typeof _n == "object" && _n && _n.Object === Object && _n,
        re = typeof self == "object" && self && self.Object === Object && self,
        _e = de || re || Function("return this")(),
        fe = e && !e.nodeType && e,
        ue = fe && !0 && t && !t.nodeType && t,
        ve = ue && ue.exports === fe,
        xe = ve && de.process,
        be = function() {
            try {
                var Z = ue && ue.require && ue.require("util").types;
                return Z || xe && xe.binding && xe.binding("util")
            } catch {}
        }(),
        he = be && be.isTypedArray;

    function me(Z, ce, Se) {
        switch (Se.length) {
            case 0:
                return Z.call(ce);
            case 1:
                return Z.call(ce, Se[0]);
            case 2:
                return Z.call(ce, Se[0], Se[1]);
            case 3:
                return Z.call(ce, Se[0], Se[1], Se[2])
        }
        return Z.apply(ce, Se)
    }

    function Ce(Z, ce) {
        for (var Se = -1, ut = Array(Z); ++Se < Z;) ut[Se] = ce(Se);
        return ut
    }

    function Ne(Z) {
        return function(ce) {
            return Z(ce)
        }
    }

    function De(Z, ce) {
        return Z == null ? void 0 : Z[ce]
    }

    function je(Z, ce) {
        return function(Se) {
            return Z(ce(Se))
        }
    }
    var Ke = Array.prototype,
        He = Function.prototype,
        qe = Object.prototype,
        Xe = _e["__core-js_shared__"],
        K = He.toString,
        V = qe.hasOwnProperty,
        ge = function() {
            var Z = /[^.]+$/.exec(Xe && Xe.keys && Xe.keys.IE_PROTO || "");
            return Z ? "Symbol(src)_1." + Z : ""
        }(),
        Be = qe.toString,
        ze = K.call(Object),
        Ue = RegExp("^" + K.call(V).replace(W, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        Ye = ve ? _e.Buffer : void 0,
        Te = _e.Symbol,
        we = _e.Uint8Array,
        lt = Ye ? Ye.allocUnsafe : void 0,
        nt = je(Object.getPrototypeOf, Object),
        vt = Object.create,
        ht = qe.propertyIsEnumerable,
        pt = Ke.splice,
        le = Te ? Te.toStringTag : void 0,
        Ie = function() {
            try {
                var Z = ui(Object, "defineProperty");
                return Z({}, "", {}), Z
            } catch {}
        }(),
        tt = Ye ? Ye.isBuffer : void 0,
        oe = Math.max,
        Ee = Date.now,
        Fe = ui(_e, "Map"),
        Ve = ui(Object, "create"),
        ct = function() {
            function Z() {}
            return function(ce) {
                if (!Ms(ce)) return {};
                if (vt) return vt(ce);
                Z.prototype = ce;
                var Se = new Z;
                return Z.prototype = void 0, Se
            }
        }();

    function bt(Z) {
        var ce = -1,
            Se = Z == null ? 0 : Z.length;
        for (this.clear(); ++ce < Se;) {
            var ut = Z[ce];
            this.set(ut[0], ut[1])
        }
    }

    function Kt() {
        this.__data__ = Ve ? Ve(null) : {}, this.size = 0
    }

    function un(Z) {
        var ce = this.has(Z) && delete this.__data__[Z];
        return this.size -= ce ? 1 : 0, ce
    }

    function zt(Z) {
        var ce = this.__data__;
        if (Ve) {
            var Se = ce[Z];
            return Se === r ? void 0 : Se
        }
        return V.call(ce, Z) ? ce[Z] : void 0
    }

    function Ot(Z) {
        var ce = this.__data__;
        return Ve ? ce[Z] !== void 0 : V.call(ce, Z)
    }

    function tn(Z, ce) {
        var Se = this.__data__;
        return this.size += this.has(Z) ? 0 : 1, Se[Z] = Ve && ce === void 0 ? r : ce, this
    }
    bt.prototype.clear = Kt, bt.prototype.delete = un, bt.prototype.get = zt, bt.prototype.has = Ot, bt.prototype.set = tn;

    function Xt(Z) {
        var ce = -1,
            Se = Z == null ? 0 : Z.length;
        for (this.clear(); ++ce < Se;) {
            var ut = Z[ce];
            this.set(ut[0], ut[1])
        }
    }

    function Hr() {
        this.__data__ = [], this.size = 0
    }

    function cs(Z) {
        var ce = this.__data__,
            Se = kt(ce, Z);
        if (Se < 0) return !1;
        var ut = ce.length - 1;
        return Se == ut ? ce.pop() : pt.call(ce, Se, 1), --this.size, !0
    }

    function Gn(Z) {
        var ce = this.__data__,
            Se = kt(ce, Z);
        return Se < 0 ? void 0 : ce[Se][1]
    }

    function D(Z) {
        return kt(this.__data__, Z) > -1
    }

    function z(Z, ce) {
        var Se = this.__data__,
            ut = kt(Se, Z);
        return ut < 0 ? (++this.size, Se.push([Z, ce])) : Se[ut][1] = ce, this
    }
    Xt.prototype.clear = Hr, Xt.prototype.delete = cs, Xt.prototype.get = Gn, Xt.prototype.has = D, Xt.prototype.set = z;

    function j(Z) {
        var ce = -1,
            Se = Z == null ? 0 : Z.length;
        for (this.clear(); ++ce < Se;) {
            var ut = Z[ce];
            this.set(ut[0], ut[1])
        }
    }

    function X() {
        this.size = 0, this.__data__ = {
            hash: new bt,
            map: new(Fe || Xt),
            string: new bt
        }
    }

    function te(Z) {
        var ce = $l(this, Z).delete(Z);
        return this.size -= ce ? 1 : 0, ce
    }

    function Oe(Z) {
        return $l(this, Z).get(Z)
    }

    function $e(Z) {
        return $l(this, Z).has(Z)
    }

    function rt(Z, ce) {
        var Se = $l(this, Z),
            ut = Se.size;
        return Se.set(Z, ce), this.size += Se.size == ut ? 0 : 1, this
    }
    j.prototype.clear = X, j.prototype.delete = te, j.prototype.get = Oe, j.prototype.has = $e, j.prototype.set = rt;

    function Ze(Z) {
        var ce = this.__data__ = new Xt(Z);
        this.size = ce.size
    }

    function Tt() {
        this.__data__ = new Xt, this.size = 0
    }

    function st(Z) {
        var ce = this.__data__,
            Se = ce.delete(Z);
        return this.size = ce.size, Se
    }

    function St(Z) {
        return this.__data__.get(Z)
    }

    function Qe(Z) {
        return this.__data__.has(Z)
    }

    function ft(Z, ce) {
        var Se = this.__data__;
        if (Se instanceof Xt) {
            var ut = Se.__data__;
            if (!Fe || ut.length < n - 1) return ut.push([Z, ce]), this.size = ++Se.size, this;
            Se = this.__data__ = new j(ut)
        }
        return Se.set(Z, ce), this.size = Se.size, this
    }
    Ze.prototype.clear = Tt, Ze.prototype.delete = st, Ze.prototype.get = St, Ze.prototype.has = Qe, Ze.prototype.set = ft;

    function Vt(Z, ce) {
        var Se = Wl(Z),
            ut = !Se && Qu(Z),
            Jt = !Se && !ut && pa(Z),
            wn = !Se && !ut && !Jt && Kl(Z),
            mn = Se || ut || Jt || wn,
            Yt = mn ? Ce(Z.length, String) : [],
            Cn = Yt.length;
        for (var gr in Z)(ce || V.call(Z, gr)) && !(mn && (gr == "length" || Jt && (gr == "offset" || gr == "parent") || wn && (gr == "buffer" || gr == "byteLength" || gr == "byteOffset") || Ap(gr, Cn))) && Yt.push(gr);
        return Yt
    }

    function bn(Z, ce, Se) {
        (Se !== void 0 && !fn(Z[ce], Se) || Se === void 0 && !(ce in Z)) && nr(Z, ce, Se)
    }

    function Ht(Z, ce, Se) {
        var ut = Z[ce];
        (!(V.call(Z, ce) && fn(ut, Se)) || Se === void 0 && !(ce in Z)) && nr(Z, ce, Se)
    }

    function kt(Z, ce) {
        for (var Se = Z.length; Se--;)
            if (fn(Z[Se][0], ce)) return Se;
        return -1
    }

    function nr(Z, ce, Se) {
        ce == "__proto__" && Ie ? Ie(Z, ce, {
            configurable: !0,
            enumerable: !0,
            value: Se,
            writable: !0
        }) : Z[ce] = Se
    }
    var vn = Mf();

    function qn(Z) {
        return Z == null ? Z === void 0 ? T : b : le && le in Object(Z) ? Bg(Z) : zg(Z)
    }

    function Ii(Z) {
        return Ts(Z) && qn(Z) == a
    }

    function rr(Z) {
        if (!Ms(Z) || Gl(Z)) return !1;
        var ce = kn(Z) ? Ue : se;
        return ce.test(Pf(Z))
    }

    function Pn(Z) {
        return Ts(Z) && Zu(Z.length) && !!ae[qn(Z)]
    }

    function xn(Z) {
        if (!Ms(Z)) return Ng(Z);
        var ce = Vl(Z),
            Se = [];
        for (var ut in Z) ut == "constructor" && (ce || !V.call(Z, ut)) || Se.push(ut);
        return Se
    }

    function $t(Z, ce, Se, ut, Jt) {
        Z !== ce && vn(ce, function(wn, mn) {
            if (Jt || (Jt = new Ze), Ms(wn)) cn(Z, ce, mn, Se, $t, ut, Jt);
            else {
                var Yt = ut ? ut(el(Z, mn), wn, mn + "", Z, ce, Jt) : void 0;
                Yt === void 0 && (Yt = wn), bn(Z, mn, Yt)
            }
        }, If)
    }

    function cn(Z, ce, Se, ut, Jt, wn, mn) {
        var Yt = el(Z, Se),
            Cn = el(ce, Se),
            gr = mn.get(Cn);
        if (gr) {
            bn(Z, Se, gr);
            return
        }
        var $r = wn ? wn(Yt, Cn, Se + "", Z, ce, mn) : void 0,
            ha = $r === void 0;
        if (ha) {
            var ec = Wl(Cn),
                ql = !ec && pa(Cn),
                tc = !ec && !ql && Kl(Cn);
            $r = Cn, ec || ql || tc ? Wl(Yt) ? $r = Yt : Ug(Yt) ? $r = Ur(Yt) : ql ? (ha = !1, $r = ar(Cn, !0)) : tc ? (ha = !1, $r = fs(Cn, !0)) : $r = [] : $g(Cn) || Qu(Cn) ? ($r = Yt, Qu(Yt) ? $r = Ps(Yt) : (!Ms(Yt) || kn(Yt)) && ($r = Fg(Cn))) : ha = !1
        }
        ha && (mn.set(Cn, $r), Jt($r, Cn, ut, wn, mn), mn.delete(Cn)), bn(Z, Se, $r)
    }

    function zn(Z, ce) {
        return jl(Tf(Z, ce, ds), Z + "")
    }
    var Qn = Ie ? function(Z, ce) {
        return Ie(Z, "toString", {
            configurable: !0,
            enumerable: !1,
            value: ji(ce),
            writable: !0
        })
    } : ds;

    function ar(Z, ce) {
        if (ce) return Z.slice();
        var Se = Z.length,
            ut = lt ? lt(Se) : new Z.constructor(Se);
        return Z.copy(ut), ut
    }

    function Ir(Z) {
        var ce = new Z.constructor(Z.byteLength);
        return new we(ce).set(new we(Z)), ce
    }

    function fs(Z, ce) {
        var Se = ce ? Ir(Z.buffer) : Z.buffer;
        return new Z.constructor(Se, Z.byteOffset, Z.length)
    }

    function Ur(Z, ce) {
        var Se = -1,
            ut = Z.length;
        for (ce || (ce = Array(ut)); ++Se < ut;) ce[Se] = Z[Se];
        return ce
    }

    function fa(Z, ce, Se, ut) {
        var Jt = !Se;
        Se || (Se = {});
        for (var wn = -1, mn = ce.length; ++wn < mn;) {
            var Yt = ce[wn],
                Cn = ut ? ut(Se[Yt], Z[Yt], Yt, Se, Z) : void 0;
            Cn === void 0 && (Cn = Z[Yt]), Jt ? nr(Se, Yt, Cn) : Ht(Se, Yt, Cn)
        }
        return Se
    }

    function xo(Z) {
        return zn(function(ce, Se) {
            var ut = -1,
                Jt = Se.length,
                wn = Jt > 1 ? Se[Jt - 1] : void 0,
                mn = Jt > 2 ? Se[2] : void 0;
            for (wn = Z.length > 3 && typeof wn == "function" ? (Jt--, wn) : void 0, mn && Ju(Se[0], Se[1], mn) && (wn = Jt < 3 ? void 0 : wn, Jt = 1), ce = Object(ce); ++ut < Jt;) {
                var Yt = Se[ut];
                Yt && Z(ce, Yt, ut, wn)
            }
            return ce
        })
    }

    function Mf(Z) {
        return function(ce, Se, ut) {
            for (var Jt = -1, wn = Object(ce), mn = ut(ce), Yt = mn.length; Yt--;) {
                var Cn = mn[Z ? Yt : ++Jt];
                if (Se(wn[Cn], Cn, wn) === !1) break
            }
            return ce
        }
    }

    function Ul(Z, ce, Se, ut, Jt, wn) {
        return Ms(Z) && Ms(ce) && (wn.set(ce, Z), $t(Z, ce, void 0, Ul, wn), wn.delete(ce)), Z
    }

    function $l(Z, ce) {
        var Se = Z.__data__;
        return Yu(ce) ? Se[typeof ce == "string" ? "string" : "hash"] : Se.map
    }

    function ui(Z, ce) {
        var Se = De(Z, ce);
        return rr(Se) ? Se : void 0
    }

    function Bg(Z) {
        var ce = V.call(Z, le),
            Se = Z[le];
        try {
            Z[le] = void 0;
            var ut = !0
        } catch {}
        var Jt = Be.call(Z);
        return ut && (ce ? Z[le] = Se : delete Z[le]), Jt
    }

    function Fg(Z) {
        return typeof Z.constructor == "function" && !Vl(Z) ? ct(nt(Z)) : {}
    }

    function Ap(Z, ce) {
        var Se = typeof Z;
        return ce = ce ? ? o, !!ce && (Se == "number" || Se != "symbol" && ee.test(Z)) && Z > -1 && Z % 1 == 0 && Z < ce
    }

    function Ju(Z, ce, Se) {
        if (!Ms(Se)) return !1;
        var ut = typeof ce;
        return (ut == "number" ? da(Se) && Ap(ce, Se.length) : ut == "string" && ce in Se) ? fn(Se[ce], Z) : !1
    }

    function Yu(Z) {
        var ce = typeof Z;
        return ce == "string" || ce == "number" || ce == "symbol" || ce == "boolean" ? Z !== "__proto__" : Z === null
    }

    function Gl(Z) {
        return !!ge && ge in Z
    }

    function Vl(Z) {
        var ce = Z && Z.constructor,
            Se = typeof ce == "function" && ce.prototype || qe;
        return Z === Se
    }

    function Ng(Z) {
        var ce = [];
        if (Z != null)
            for (var Se in Object(Z)) ce.push(Se);
        return ce
    }

    function zg(Z) {
        return Be.call(Z)
    }

    function Tf(Z, ce, Se) {
        return ce = oe(ce === void 0 ? Z.length - 1 : ce, 0),
            function() {
                for (var ut = arguments, Jt = -1, wn = oe(ut.length - ce, 0), mn = Array(wn); ++Jt < wn;) mn[Jt] = ut[ce + Jt];
                Jt = -1;
                for (var Yt = Array(ce + 1); ++Jt < ce;) Yt[Jt] = ut[Jt];
                return Yt[ce] = Se(mn), me(Z, this, Yt)
            }
    }

    function el(Z, ce) {
        if (!(ce === "constructor" && typeof Z[ce] == "function") && ce != "__proto__") return Z[ce]
    }
    var jl = Hg(Qn);

    function Hg(Z) {
        var ce = 0,
            Se = 0;
        return function() {
            var ut = Ee(),
                Jt = s - (ut - Se);
            if (Se = ut, Jt > 0) {
                if (++ce >= i) return arguments[0]
            } else ce = 0;
            return Z.apply(void 0, arguments)
        }
    }

    function Pf(Z) {
        if (Z != null) {
            try {
                return K.call(Z)
            } catch {}
            try {
                return Z + ""
            } catch {}
        }
        return ""
    }

    function fn(Z, ce) {
        return Z === ce || Z !== Z && ce !== ce
    }
    var Qu = Ii(function() {
            return arguments
        }()) ? Ii : function(Z) {
            return Ts(Z) && V.call(Z, "callee") && !ht.call(Z, "callee")
        },
        Wl = Array.isArray;

    function da(Z) {
        return Z != null && Zu(Z.length) && !kn(Z)
    }

    function Ug(Z) {
        return Ts(Z) && da(Z)
    }
    var pa = tt || Rf;

    function kn(Z) {
        if (!Ms(Z)) return !1;
        var ce = qn(Z);
        return ce == p || ce == m || ce == u || ce == x
    }

    function Zu(Z) {
        return typeof Z == "number" && Z > -1 && Z % 1 == 0 && Z <= o
    }

    function Ms(Z) {
        var ce = typeof Z;
        return Z != null && (ce == "object" || ce == "function")
    }

    function Ts(Z) {
        return Z != null && typeof Z == "object"
    }

    function $g(Z) {
        if (!Ts(Z) || qn(Z) != _) return !1;
        var ce = nt(Z);
        if (ce === null) return !0;
        var Se = V.call(ce, "constructor") && ce.constructor;
        return typeof Se == "function" && Se instanceof Se && K.call(Se) == ze
    }
    var Kl = he ? Ne(he) : Pn;

    function Ps(Z) {
        return fa(Z, If(Z))
    }
    var Cp = zn(function(Z) {
        return Z.push(void 0, Ul), me(Is, void 0, Z)
    });

    function If(Z) {
        return da(Z) ? Vt(Z, !0) : xn(Z)
    }
    var Is = xo(function(Z, ce, Se, ut) {
        $t(Z, ce, Se, ut)
    });

    function ji(Z) {
        return function() {
            return Z
        }
    }

    function ds(Z) {
        return Z
    }

    function Rf() {
        return !1
    }
    t.exports = Cp
})(Iw, Iw.exports);
var Tle = Iw.exports;
const rHe = la(Tle);
var Rw = {
    exports: {}
};
Rw.exports;
(function(t, e) {
    var n = 200,
        r = "Expected a function",
        i = "__lodash_hash_undefined__",
        s = 1,
        o = 2,
        a = 1 / 0,
        l = 9007199254740991,
        u = "[object Arguments]",
        c = "[object Array]",
        f = "[object Boolean]",
        d = "[object Date]",
        p = "[object Error]",
        m = "[object Function]",
        y = "[object GeneratorFunction]",
        v = "[object Map]",
        b = "[object Number]",
        _ = "[object Object]",
        x = "[object Promise]",
        S = "[object RegExp]",
        E = "[object Set]",
        A = "[object String]",
        T = "[object Symbol]",
        M = "[object WeakMap]",
        I = "[object ArrayBuffer]",
        O = "[object DataView]",
        k = "[object Float32Array]",
        H = "[object Float64Array]",
        N = "[object Int8Array]",
        B = "[object Int16Array]",
        U = "[object Int32Array]",
        q = "[object Uint8Array]",
        Q = "[object Uint8ClampedArray]",
        F = "[object Uint16Array]",
        G = "[object Uint32Array]",
        W = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        se = /^\w*$/,
        ee = /^\./,
        ae = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        de = /[\\^$.*+?()[\]{}|]/g,
        re = /\\(\\)?/g,
        _e = /^\[object .+?Constructor\]$/,
        fe = /^(?:0|[1-9]\d*)$/,
        ue = {};
    ue[k] = ue[H] = ue[N] = ue[B] = ue[U] = ue[q] = ue[Q] = ue[F] = ue[G] = !0, ue[u] = ue[c] = ue[I] = ue[f] = ue[O] = ue[d] = ue[p] = ue[m] = ue[v] = ue[b] = ue[_] = ue[S] = ue[E] = ue[A] = ue[M] = !1;
    var ve = typeof _n == "object" && _n && _n.Object === Object && _n,
        xe = typeof self == "object" && self && self.Object === Object && self,
        be = ve || xe || Function("return this")(),
        he = e && !e.nodeType && e,
        me = he && !0 && t && !t.nodeType && t,
        Ce = me && me.exports === he,
        Ne = Ce && ve.process,
        De = function() {
            try {
                return Ne && Ne.binding("util")
            } catch {}
        }(),
        je = De && De.isTypedArray;

    function Ke($, ie, Me, Ge) {
        for (var Pt = -1, xt = $ ? $.length : 0; ++Pt < xt;) {
            var an = $[Pt];
            ie(Ge, an, Me(an), $)
        }
        return Ge
    }

    function He($, ie) {
        for (var Me = -1, Ge = $ ? $.length : 0; ++Me < Ge;)
            if (ie($[Me], Me, $)) return !0;
        return !1
    }

    function qe($) {
        return function(ie) {
            return ie == null ? void 0 : ie[$]
        }
    }

    function Xe($, ie) {
        for (var Me = -1, Ge = Array($); ++Me < $;) Ge[Me] = ie(Me);
        return Ge
    }

    function K($) {
        return function(ie) {
            return $(ie)
        }
    }

    function V($, ie) {
        return $ == null ? void 0 : $[ie]
    }

    function ge($) {
        var ie = !1;
        if ($ != null && typeof $.toString != "function") try {
            ie = !!($ + "")
        } catch {}
        return ie
    }

    function Be($) {
        var ie = -1,
            Me = Array($.size);
        return $.forEach(function(Ge, Pt) {
            Me[++ie] = [Pt, Ge]
        }), Me
    }

    function ze($, ie) {
        return function(Me) {
            return $(ie(Me))
        }
    }

    function Ue($) {
        var ie = -1,
            Me = Array($.size);
        return $.forEach(function(Ge) {
            Me[++ie] = Ge
        }), Me
    }
    var Ye = Array.prototype,
        Te = Function.prototype,
        we = Object.prototype,
        lt = be["__core-js_shared__"],
        nt = function() {
            var $ = /[^.]+$/.exec(lt && lt.keys && lt.keys.IE_PROTO || "");
            return $ ? "Symbol(src)_1." + $ : ""
        }(),
        vt = Te.toString,
        ht = we.hasOwnProperty,
        pt = we.toString,
        le = RegExp("^" + vt.call(ht).replace(de, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        Ie = be.Symbol,
        tt = be.Uint8Array,
        oe = we.propertyIsEnumerable,
        Ee = Ye.splice,
        Fe = ze(Object.keys, Object),
        Ve = pa(be, "DataView"),
        ct = pa(be, "Map"),
        bt = pa(be, "Promise"),
        Kt = pa(be, "Set"),
        un = pa(be, "WeakMap"),
        zt = pa(Object, "create"),
        Ot = ds(Ve),
        tn = ds(ct),
        Xt = ds(bt),
        Hr = ds(Kt),
        cs = ds(un),
        Gn = Ie ? Ie.prototype : void 0,
        D = Gn ? Gn.valueOf : void 0,
        z = Gn ? Gn.toString : void 0;

    function j($) {
        var ie = -1,
            Me = $ ? $.length : 0;
        for (this.clear(); ++ie < Me;) {
            var Ge = $[ie];
            this.set(Ge[0], Ge[1])
        }
    }

    function X() {
        this.__data__ = zt ? zt(null) : {}
    }

    function te($) {
        return this.has($) && delete this.__data__[$]
    }

    function Oe($) {
        var ie = this.__data__;
        if (zt) {
            var Me = ie[$];
            return Me === i ? void 0 : Me
        }
        return ht.call(ie, $) ? ie[$] : void 0
    }

    function $e($) {
        var ie = this.__data__;
        return zt ? ie[$] !== void 0 : ht.call(ie, $)
    }

    function rt($, ie) {
        var Me = this.__data__;
        return Me[$] = zt && ie === void 0 ? i : ie, this
    }
    j.prototype.clear = X, j.prototype.delete = te, j.prototype.get = Oe, j.prototype.has = $e, j.prototype.set = rt;

    function Ze($) {
        var ie = -1,
            Me = $ ? $.length : 0;
        for (this.clear(); ++ie < Me;) {
            var Ge = $[ie];
            this.set(Ge[0], Ge[1])
        }
    }

    function Tt() {
        this.__data__ = []
    }

    function st($) {
        var ie = this.__data__,
            Me = Ir(ie, $);
        if (Me < 0) return !1;
        var Ge = ie.length - 1;
        return Me == Ge ? ie.pop() : Ee.call(ie, Me, 1), !0
    }

    function St($) {
        var ie = this.__data__,
            Me = Ir(ie, $);
        return Me < 0 ? void 0 : ie[Me][1]
    }

    function Qe($) {
        return Ir(this.__data__, $) > -1
    }

    function ft($, ie) {
        var Me = this.__data__,
            Ge = Ir(Me, $);
        return Ge < 0 ? Me.push([$, ie]) : Me[Ge][1] = ie, this
    }
    Ze.prototype.clear = Tt, Ze.prototype.delete = st, Ze.prototype.get = St, Ze.prototype.has = Qe, Ze.prototype.set = ft;

    function Vt($) {
        var ie = -1,
            Me = $ ? $.length : 0;
        for (this.clear(); ++ie < Me;) {
            var Ge = $[ie];
            this.set(Ge[0], Ge[1])
        }
    }

    function bn() {
        this.__data__ = {
            hash: new j,
            map: new(ct || Ze),
            string: new j
        }
    }

    function Ht($) {
        return da(this, $).delete($)
    }

    function kt($) {
        return da(this, $).get($)
    }

    function nr($) {
        return da(this, $).has($)
    }

    function vn($, ie) {
        return da(this, $).set($, ie), this
    }
    Vt.prototype.clear = bn, Vt.prototype.delete = Ht, Vt.prototype.get = kt, Vt.prototype.has = nr, Vt.prototype.set = vn;

    function qn($) {
        var ie = -1,
            Me = $ ? $.length : 0;
        for (this.__data__ = new Vt; ++ie < Me;) this.add($[ie])
    }

    function Ii($) {
        return this.__data__.set($, i), this
    }

    function rr($) {
        return this.__data__.has($)
    }
    qn.prototype.add = qn.prototype.push = Ii, qn.prototype.has = rr;

    function Pn($) {
        this.__data__ = new Ze($)
    }

    function xn() {
        this.__data__ = new Ze
    }

    function $t($) {
        return this.__data__.delete($)
    }

    function cn($) {
        return this.__data__.get($)
    }

    function zn($) {
        return this.__data__.has($)
    }

    function Qn($, ie) {
        var Me = this.__data__;
        if (Me instanceof Ze) {
            var Ge = Me.__data__;
            if (!ct || Ge.length < n - 1) return Ge.push([$, ie]), this;
            Me = this.__data__ = new Vt(Ge)
        }
        return Me.set($, ie), this
    }
    Pn.prototype.clear = xn, Pn.prototype.delete = $t, Pn.prototype.get = cn, Pn.prototype.has = zn, Pn.prototype.set = Qn;

    function ar($, ie) {
        var Me = ut($) || Se($) ? Xe($.length, String) : [],
            Ge = Me.length,
            Pt = !!Ge;
        for (var xt in $)(ie || ht.call($, xt)) && !(Pt && (xt == "length" || Ms(xt, Ge))) && Me.push(xt);
        return Me
    }

    function Ir($, ie) {
        for (var Me = $.length; Me--;)
            if (ce($[Me][0], ie)) return Me;
        return -1
    }

    function fs($, ie, Me, Ge) {
        return Ur($, function(Pt, xt, an) {
            ie(Ge, Pt, Me(Pt), an)
        }), Ge
    }
    var Ur = Hg(xo),
        fa = Pf();

    function xo($, ie) {
        return $ && fa($, ie, ma)
    }

    function Mf($, ie) {
        ie = Ts(ie, $) ? [ie] : el(ie);
        for (var Me = 0, Ge = ie.length; $ != null && Me < Ge;) $ = $[ji(ie[Me++])];
        return Me && Me == Ge ? $ : void 0
    }

    function Ul($) {
        return pt.call($)
    }

    function $l($, ie) {
        return $ != null && ie in Object($)
    }

    function ui($, ie, Me, Ge, Pt) {
        return $ === ie ? !0 : $ == null || ie == null || !Cn($) && !gr(ie) ? $ !== $ && ie !== ie : Bg($, ie, ui, Me, Ge, Pt)
    }

    function Bg($, ie, Me, Ge, Pt, xt) {
        var an = ut($),
            Bn = ut(ie),
            ir = c,
            Gr = c;
        an || (ir = kn($), ir = ir == u ? _ : ir), Bn || (Gr = kn(ie), Gr = Gr == u ? _ : Gr);
        var ci = ir == _ && !ge($),
            fi = Gr == _ && !ge(ie),
            Vr = ir == Gr;
        if (Vr && !ci) return xt || (xt = new Pn), an || ha($) ? fn($, ie, Me, Ge, Pt, xt) : Qu($, ie, ir, Me, Ge, Pt, xt);
        if (!(Pt & o)) {
            var ps = ci && ht.call($, "__wrapped__"),
                hs = fi && ht.call(ie, "__wrapped__");
            if (ps || hs) {
                var So = ps ? $.value() : $,
                    Wi = hs ? ie.value() : ie;
                return xt || (xt = new Pn), Me(So, Wi, Ge, Pt, xt)
            }
        }
        return Vr ? (xt || (xt = new Pn), Wl($, ie, Me, Ge, Pt, xt)) : !1
    }

    function Fg($, ie, Me, Ge) {
        var Pt = Me.length,
            xt = Pt,
            an = !Ge;
        if ($ == null) return !xt;
        for ($ = Object($); Pt--;) {
            var Bn = Me[Pt];
            if (an && Bn[2] ? Bn[1] !== $[Bn[0]] : !(Bn[0] in $)) return !1
        }
        for (; ++Pt < xt;) {
            Bn = Me[Pt];
            var ir = Bn[0],
                Gr = $[ir],
                ci = Bn[1];
            if (an && Bn[2]) {
                if (Gr === void 0 && !(ir in $)) return !1
            } else {
                var fi = new Pn;
                if (Ge) var Vr = Ge(Gr, ci, ir, $, ie, fi);
                if (!(Vr === void 0 ? ui(ci, Gr, Ge, s | o, fi) : Vr)) return !1
            }
        }
        return !0
    }

    function Ap($) {
        if (!Cn($) || Kl($)) return !1;
        var ie = mn($) || ge($) ? le : _e;
        return ie.test(ds($))
    }

    function Ju($) {
        return gr($) && Yt($.length) && !!ue[pt.call($)]
    }

    function Yu($) {
        return typeof $ == "function" ? $ : $ == null ? Rs : typeof $ == "object" ? ut($) ? Ng($[0], $[1]) : Vl($) : _o($)
    }

    function Gl($) {
        if (!Ps($)) return Fe($);
        var ie = [];
        for (var Me in Object($)) ht.call($, Me) && Me != "constructor" && ie.push(Me);
        return ie
    }

    function Vl($) {
        var ie = Ug($);
        return ie.length == 1 && ie[0][2] ? If(ie[0][0], ie[0][1]) : function(Me) {
            return Me === $ || Fg(Me, $, ie)
        }
    }

    function Ng($, ie) {
        return Ts($) && Cp(ie) ? If(ji($), ie) : function(Me) {
            var Ge = ql(Me, $);
            return Ge === void 0 && Ge === ie ? tc(Me, $) : ui(ie, Ge, void 0, s | o)
        }
    }

    function zg($) {
        return function(ie) {
            return Mf(ie, $)
        }
    }

    function Tf($) {
        if (typeof $ == "string") return $;
        if ($r($)) return z ? z.call($) : "";
        var ie = $ + "";
        return ie == "0" && 1 / $ == -a ? "-0" : ie
    }

    function el($) {
        return ut($) ? $ : Is($)
    }

    function jl($, ie) {
        return function(Me, Ge) {
            var Pt = ut(Me) ? Ke : fs,
                xt = ie ? ie() : {};
            return Pt(Me, $, Yu(Ge), xt)
        }
    }

    function Hg($, ie) {
        return function(Me, Ge) {
            if (Me == null) return Me;
            if (!Jt(Me)) return $(Me, Ge);
            for (var Pt = Me.length, xt = ie ? Pt : -1, an = Object(Me);
                (ie ? xt-- : ++xt < Pt) && Ge(an[xt], xt, an) !== !1;);
            return Me
        }
    }

    function Pf($) {
        return function(ie, Me, Ge) {
            for (var Pt = -1, xt = Object(ie), an = Ge(ie), Bn = an.length; Bn--;) {
                var ir = an[$ ? Bn : ++Pt];
                if (Me(xt[ir], ir, xt) === !1) break
            }
            return ie
        }
    }

    function fn($, ie, Me, Ge, Pt, xt) {
        var an = Pt & o,
            Bn = $.length,
            ir = ie.length;
        if (Bn != ir && !(an && ir > Bn)) return !1;
        var Gr = xt.get($);
        if (Gr && xt.get(ie)) return Gr == ie;
        var ci = -1,
            fi = !0,
            Vr = Pt & s ? new qn : void 0;
        for (xt.set($, ie), xt.set(ie, $); ++ci < Bn;) {
            var ps = $[ci],
                hs = ie[ci];
            if (Ge) var So = an ? Ge(hs, ps, ci, ie, $, xt) : Ge(ps, hs, ci, $, ie, xt);
            if (So !== void 0) {
                if (So) continue;
                fi = !1;
                break
            }
            if (Vr) {
                if (!He(ie, function(Wi, Os) {
                        if (!Vr.has(Os) && (ps === Wi || Me(ps, Wi, Ge, Pt, xt))) return Vr.add(Os)
                    })) {
                    fi = !1;
                    break
                }
            } else if (!(ps === hs || Me(ps, hs, Ge, Pt, xt))) {
                fi = !1;
                break
            }
        }
        return xt.delete($), xt.delete(ie), fi
    }

    function Qu($, ie, Me, Ge, Pt, xt, an) {
        switch (Me) {
            case O:
                if ($.byteLength != ie.byteLength || $.byteOffset != ie.byteOffset) return !1;
                $ = $.buffer, ie = ie.buffer;
            case I:
                return !($.byteLength != ie.byteLength || !Ge(new tt($), new tt(ie)));
            case f:
            case d:
            case b:
                return ce(+$, +ie);
            case p:
                return $.name == ie.name && $.message == ie.message;
            case S:
            case A:
                return $ == ie + "";
            case v:
                var Bn = Be;
            case E:
                var ir = xt & o;
                if (Bn || (Bn = Ue), $.size != ie.size && !ir) return !1;
                var Gr = an.get($);
                if (Gr) return Gr == ie;
                xt |= s, an.set($, ie);
                var ci = fn(Bn($), Bn(ie), Ge, Pt, xt, an);
                return an.delete($), ci;
            case T:
                if (D) return D.call($) == D.call(ie)
        }
        return !1
    }

    function Wl($, ie, Me, Ge, Pt, xt) {
        var an = Pt & o,
            Bn = ma($),
            ir = Bn.length,
            Gr = ma(ie),
            ci = Gr.length;
        if (ir != ci && !an) return !1;
        for (var fi = ir; fi--;) {
            var Vr = Bn[fi];
            if (!(an ? Vr in ie : ht.call(ie, Vr))) return !1
        }
        var ps = xt.get($);
        if (ps && xt.get(ie)) return ps == ie;
        var hs = !0;
        xt.set($, ie), xt.set(ie, $);
        for (var So = an; ++fi < ir;) {
            Vr = Bn[fi];
            var Wi = $[Vr],
                Os = ie[Vr];
            if (Ge) var Of = an ? Ge(Os, Wi, Vr, ie, $, xt) : Ge(Wi, Os, Vr, $, ie, xt);
            if (!(Of === void 0 ? Wi === Os || Me(Wi, Os, Ge, Pt, xt) : Of)) {
                hs = !1;
                break
            }
            So || (So = Vr == "constructor")
        }
        if (hs && !So) {
            var Xl = $.constructor,
                Ri = ie.constructor;
            Xl != Ri && "constructor" in $ && "constructor" in ie && !(typeof Xl == "function" && Xl instanceof Xl && typeof Ri == "function" && Ri instanceof Ri) && (hs = !1)
        }
        return xt.delete($), xt.delete(ie), hs
    }

    function da($, ie) {
        var Me = $.__data__;
        return $g(ie) ? Me[typeof ie == "string" ? "string" : "hash"] : Me.map
    }

    function Ug($) {
        for (var ie = ma($), Me = ie.length; Me--;) {
            var Ge = ie[Me],
                Pt = $[Ge];
            ie[Me] = [Ge, Pt, Cp(Pt)]
        }
        return ie
    }

    function pa($, ie) {
        var Me = V($, ie);
        return Ap(Me) ? Me : void 0
    }
    var kn = Ul;
    (Ve && kn(new Ve(new ArrayBuffer(1))) != O || ct && kn(new ct) != v || bt && kn(bt.resolve()) != x || Kt && kn(new Kt) != E || un && kn(new un) != M) && (kn = function($) {
        var ie = pt.call($),
            Me = ie == _ ? $.constructor : void 0,
            Ge = Me ? ds(Me) : void 0;
        if (Ge) switch (Ge) {
            case Ot:
                return O;
            case tn:
                return v;
            case Xt:
                return x;
            case Hr:
                return E;
            case cs:
                return M
        }
        return ie
    });

    function Zu($, ie, Me) {
        ie = Ts(ie, $) ? [ie] : el(ie);
        for (var Ge, Pt = -1, an = ie.length; ++Pt < an;) {
            var xt = ji(ie[Pt]);
            if (!(Ge = $ != null && Me($, xt))) break;
            $ = $[xt]
        }
        if (Ge) return Ge;
        var an = $ ? $.length : 0;
        return !!an && Yt(an) && Ms(xt, an) && (ut($) || Se($))
    }

    function Ms($, ie) {
        return ie = ie ? ? l, !!ie && (typeof $ == "number" || fe.test($)) && $ > -1 && $ % 1 == 0 && $ < ie
    }

    function Ts($, ie) {
        if (ut($)) return !1;
        var Me = typeof $;
        return Me == "number" || Me == "symbol" || Me == "boolean" || $ == null || $r($) ? !0 : se.test($) || !W.test($) || ie != null && $ in Object(ie)
    }

    function $g($) {
        var ie = typeof $;
        return ie == "string" || ie == "number" || ie == "symbol" || ie == "boolean" ? $ !== "__proto__" : $ === null
    }

    function Kl($) {
        return !!nt && nt in $
    }

    function Ps($) {
        var ie = $ && $.constructor,
            Me = typeof ie == "function" && ie.prototype || we;
        return $ === Me
    }

    function Cp($) {
        return $ === $ && !Cn($)
    }

    function If($, ie) {
        return function(Me) {
            return Me == null ? !1 : Me[$] === ie && (ie !== void 0 || $ in Object(Me))
        }
    }
    var Is = Z(function($) {
        $ = ec($);
        var ie = [];
        return ee.test($) && ie.push(""), $.replace(ae, function(Me, Ge, Pt, xt) {
            ie.push(Pt ? xt.replace(re, "$1") : Ge || Me)
        }), ie
    });

    function ji($) {
        if (typeof $ == "string" || $r($)) return $;
        var ie = $ + "";
        return ie == "0" && 1 / $ == -a ? "-0" : ie
    }

    function ds($) {
        if ($ != null) {
            try {
                return vt.call($)
            } catch {}
            try {
                return $ + ""
            } catch {}
        }
        return ""
    }
    var Rf = jl(function($, ie, Me) {
        $[Me ? 0 : 1].push(ie)
    }, function() {
        return [
            [],
            []
        ]
    });

    function Z($, ie) {
        if (typeof $ != "function" || ie && typeof ie != "function") throw new TypeError(r);
        var Me = function() {
            var Ge = arguments,
                Pt = ie ? ie.apply(this, Ge) : Ge[0],
                xt = Me.cache;
            if (xt.has(Pt)) return xt.get(Pt);
            var an = $.apply(this, Ge);
            return Me.cache = xt.set(Pt, an), an
        };
        return Me.cache = new(Z.Cache || Vt), Me
    }
    Z.Cache = Vt;

    function ce($, ie) {
        return $ === ie || $ !== $ && ie !== ie
    }

    function Se($) {
        return wn($) && ht.call($, "callee") && (!oe.call($, "callee") || pt.call($) == u)
    }
    var ut = Array.isArray;

    function Jt($) {
        return $ != null && Yt($.length) && !mn($)
    }

    function wn($) {
        return gr($) && Jt($)
    }

    function mn($) {
        var ie = Cn($) ? pt.call($) : "";
        return ie == m || ie == y
    }

    function Yt($) {
        return typeof $ == "number" && $ > -1 && $ % 1 == 0 && $ <= l
    }

    function Cn($) {
        var ie = typeof $;
        return !!$ && (ie == "object" || ie == "function")
    }

    function gr($) {
        return !!$ && typeof $ == "object"
    }

    function $r($) {
        return typeof $ == "symbol" || gr($) && pt.call($) == T
    }
    var ha = je ? K(je) : Ju;

    function ec($) {
        return $ == null ? "" : Tf($)
    }

    function ql($, ie, Me) {
        var Ge = $ == null ? void 0 : Mf($, ie);
        return Ge === void 0 ? Me : Ge
    }

    function tc($, ie) {
        return $ != null && Zu($, ie, $l)
    }

    function ma($) {
        return Jt($) ? ar($) : Gl($)
    }

    function Rs($) {
        return $
    }

    function _o($) {
        return Ts($) ? qe(ji($)) : zg($)
    }
    t.exports = Rf
})(Rw, Rw.exports);
var Ple = Rw.exports;
const iHe = la(Ple);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const vp = "150",
    td = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    nd = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    uj = 0,
    KI = 1,
    cj = 2,
    Ile = 3,
    fj = 0,
    OE = 1,
    pv = 2,
    gd = 3,
    Ol = 0,
    Vs = 1,
    Ra = 2,
    Rle = 2,
    Mu = 0,
    Dd = 1,
    qI = 2,
    XI = 3,
    JI = 4,
    dj = 5,
    ad = 100,
    pj = 101,
    hj = 102,
    YI = 103,
    QI = 104,
    mj = 200,
    gj = 201,
    yj = 202,
    vj = 203,
    sL = 204,
    oL = 205,
    bj = 206,
    xj = 207,
    _j = 208,
    Sj = 209,
    wj = 210,
    Ej = 0,
    Aj = 1,
    Cj = 2,
    Ow = 3,
    Mj = 4,
    Tj = 5,
    Pj = 6,
    Ij = 7,
    u1 = 0,
    Rj = 1,
    Oj = 2,
    Na = 0,
    Dj = 1,
    Lj = 2,
    kj = 3,
    aL = 4,
    Bj = 5,
    DE = 300,
    lf = 301,
    uf = 302,
    s0 = 303,
    o0 = 304,
    gg = 306,
    cf = 1e3,
    zi = 1001,
    Lm = 1002,
    Br = 1003,
    a0 = 1004,
    Ole = 1004,
    um = 1005,
    Dle = 1005,
    fr = 1006,
    LE = 1007,
    Lle = 1007,
    Dl = 1008,
    kle = 1008,
    Du = 1009,
    Fj = 1010,
    Nj = 1011,
    lL = 1012,
    zj = 1013,
    Oc = 1014,
    xl = 1015,
    Qd = 1016,
    Hj = 1017,
    Uj = 1018,
    Ld = 1020,
    $j = 1021,
    Ns = 1023,
    Gj = 1024,
    Vj = 1025,
    Qc = 1026,
    Zd = 1027,
    jj = 1028,
    Wj = 1029,
    Kj = 1030,
    qj = 1031,
    Xj = 1033,
    vS = 33776,
    bS = 33777,
    xS = 33778,
    _S = 33779,
    ZI = 35840,
    e3 = 35841,
    t3 = 35842,
    n3 = 35843,
    Jj = 36196,
    r3 = 37492,
    i3 = 37496,
    s3 = 37808,
    o3 = 37809,
    a3 = 37810,
    l3 = 37811,
    u3 = 37812,
    c3 = 37813,
    f3 = 37814,
    d3 = 37815,
    p3 = 37816,
    h3 = 37817,
    m3 = 37818,
    g3 = 37819,
    y3 = 37820,
    v3 = 37821,
    SS = 36492,
    Yj = 36283,
    b3 = 36284,
    x3 = 36285,
    _3 = 36286,
    Qj = 2200,
    Zj = 2201,
    eW = 2202,
    km = 2300,
    ep = 2301,
    wS = 2302,
    yd = 2400,
    vd = 2401,
    l0 = 2402,
    kE = 2500,
    uL = 2501,
    tW = 0,
    cL = 1,
    Dw = 2,
    Lu = 3e3,
    Xn = 3001,
    nW = 3200,
    rW = 3201,
    _f = 0,
    iW = 1,
    Ble = "",
    Ea = "srgb",
    Bm = "srgb-linear",
    fL = "display-p3",
    Fle = 0,
    ES = 7680,
    Nle = 7681,
    zle = 7682,
    Hle = 7683,
    Ule = 34055,
    $le = 34056,
    Gle = 5386,
    Vle = 512,
    jle = 513,
    Wle = 514,
    Kle = 515,
    qle = 516,
    Xle = 517,
    Jle = 518,
    sW = 519,
    u0 = 35044,
    Yle = 35048,
    Qle = 35040,
    Zle = 35045,
    eue = 35049,
    tue = 35041,
    nue = 35046,
    rue = 35050,
    iue = 35042,
    sue = "100",
    S3 = "300 es",
    Lw = 1035;
class Bl {
    addEventListener(e, n) {
        this._listeners === void 0 && (this._listeners = {});
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n)
    }
    hasEventListener(e, n) {
        if (this._listeners === void 0) return !1;
        const r = this._listeners;
        return r[e] !== void 0 && r[e].indexOf(n) !== -1
    }
    removeEventListener(e, n) {
        if (this._listeners === void 0) return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const s = i.indexOf(n);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const r = this._listeners[e.type];
        if (r !== void 0) {
            e.target = this;
            const i = r.slice(0);
            for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
            e.target = null
        }
    }
}
const Zi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let XN = 1234567;
const kd = Math.PI / 180,
    c0 = 180 / Math.PI;

function uo() {
    const t = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        n = Math.random() * 4294967295 | 0,
        r = Math.random() * 4294967295 | 0;
    return (Zi[t & 255] + Zi[t >> 8 & 255] + Zi[t >> 16 & 255] + Zi[t >> 24 & 255] + "-" + Zi[e & 255] + Zi[e >> 8 & 255] + "-" + Zi[e >> 16 & 15 | 64] + Zi[e >> 24 & 255] + "-" + Zi[n & 63 | 128] + Zi[n >> 8 & 255] + "-" + Zi[n >> 16 & 255] + Zi[n >> 24 & 255] + Zi[r & 255] + Zi[r >> 8 & 255] + Zi[r >> 16 & 255] + Zi[r >> 24 & 255]).toLowerCase()
}

function Xr(t, e, n) {
    return Math.max(e, Math.min(n, t))
}

function dL(t, e) {
    return (t % e + e) % e
}

function oue(t, e, n, r, i) {
    return r + (t - e) * (i - r) / (n - e)
}

function aue(t, e, n) {
    return t !== e ? (n - t) / (e - t) : 0
}

function hv(t, e, n) {
    return (1 - n) * t + n * e
}

function lue(t, e, n, r) {
    return hv(t, e, 1 - Math.exp(-n * r))
}

function uue(t, e = 1) {
    return e - Math.abs(dL(t, e * 2) - e)
}

function cue(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t))
}

function fue(t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10))
}

function due(t, e) {
    return t + Math.floor(Math.random() * (e - t + 1))
}

function pue(t, e) {
    return t + Math.random() * (e - t)
}

function hue(t) {
    return t * (.5 - Math.random())
}

function mue(t) {
    t !== void 0 && (XN = t);
    let e = XN += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function gue(t) {
    return t * kd
}

function yue(t) {
    return t * c0
}

function w3(t) {
    return (t & t - 1) === 0 && t !== 0
}

function oW(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
}

function aW(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
}

function vue(t, e, n, r, i) {
    const s = Math.cos,
        o = Math.sin,
        a = s(n / 2),
        l = o(n / 2),
        u = s((e + r) / 2),
        c = o((e + r) / 2),
        f = s((e - r) / 2),
        d = o((e - r) / 2),
        p = s((r - e) / 2),
        m = o((r - e) / 2);
    switch (i) {
        case "XYX":
            t.set(a * c, l * f, l * d, a * u);
            break;
        case "YZY":
            t.set(l * d, a * c, l * f, a * u);
            break;
        case "ZXZ":
            t.set(l * f, l * d, a * c, a * u);
            break;
        case "XZX":
            t.set(a * c, l * m, l * p, a * u);
            break;
        case "YXY":
            t.set(l * p, a * c, l * m, a * u);
            break;
        case "ZYZ":
            t.set(l * m, l * p, a * c, a * u);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}

function _u(t, e) {
    switch (e.constructor) {
        case Float32Array:
            return t;
        case Uint16Array:
            return t / 65535;
        case Uint8Array:
            return t / 255;
        case Int16Array:
            return Math.max(t / 32767, -1);
        case Int8Array:
            return Math.max(t / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function er(t, e) {
    switch (e.constructor) {
        case Float32Array:
            return t;
        case Uint16Array:
            return Math.round(t * 65535);
        case Uint8Array:
            return Math.round(t * 255);
        case Int16Array:
            return Math.round(t * 32767);
        case Int8Array:
            return Math.round(t * 127);
        default:
            throw new Error("Invalid component type.")
    }
}
const bd = {
    DEG2RAD: kd,
    RAD2DEG: c0,
    generateUUID: uo,
    clamp: Xr,
    euclideanModulo: dL,
    mapLinear: oue,
    inverseLerp: aue,
    lerp: hv,
    damp: lue,
    pingpong: uue,
    smoothstep: cue,
    smootherstep: fue,
    randInt: due,
    randFloat: pue,
    randFloatSpread: hue,
    seededRandom: mue,
    degToRad: gue,
    radToDeg: yue,
    isPowerOfTwo: w3,
    ceilPowerOfTwo: oW,
    floorPowerOfTwo: aW,
    setQuaternionFromProperEuler: vue,
    normalize: er,
    denormalize: _u
};
class ke {
    constructor(e = 0, n = 0) {
        ke.prototype.isVector2 = !0, this.x = e, this.y = n
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, n) {
        return this.x = e, this.y = n, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setComponent(e, n) {
        switch (e) {
            case 0:
                this.x = n;
                break;
            case 1:
                this.y = n;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x, this.y = e.y + n.y, this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n, this.y += e.y * n, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x, this.y = e.y - n.y, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const n = this.x,
            r = this.y,
            i = e.elements;
        return this.x = i[0] * n + i[3] * r + i[6], this.y = i[1] * n + i[4] * r + i[7], this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
    }
    clamp(e, n) {
        return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this
    }
    clampScalar(e, n) {
        return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this
    }
    clampLength(e, n) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const n = this.x - e.x,
            r = this.y - e.y;
        return n * n + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this
    }
    lerpVectors(e, n, r) {
        return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, n = 0) {
        return this.x = e[n], this.y = e[n + 1], this
    }
    toArray(e = [], n = 0) {
        return e[n] = this.x, e[n + 1] = this.y, e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n), this.y = e.getY(n), this
    }
    rotateAround(e, n) {
        const r = Math.cos(n),
            i = Math.sin(n),
            s = this.x - e.x,
            o = this.y - e.y;
        return this.x = s * r - o * i + e.x, this.y = s * i + o * r + e.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
class Hi {
    constructor() {
        Hi.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, n, r, i, s, o, a, l, u) {
        const c = this.elements;
        return c[0] = e, c[1] = i, c[2] = a, c[3] = n, c[4] = s, c[5] = l, c[6] = r, c[7] = o, c[8] = u, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(e) {
        const n = this.elements,
            r = e.elements;
        return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], this
    }
    extractBasis(e, n, r) {
        return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(e) {
        const n = e.elements;
        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, n) {
        const r = e.elements,
            i = n.elements,
            s = this.elements,
            o = r[0],
            a = r[3],
            l = r[6],
            u = r[1],
            c = r[4],
            f = r[7],
            d = r[2],
            p = r[5],
            m = r[8],
            y = i[0],
            v = i[3],
            b = i[6],
            _ = i[1],
            x = i[4],
            S = i[7],
            E = i[2],
            A = i[5],
            T = i[8];
        return s[0] = o * y + a * _ + l * E, s[3] = o * v + a * x + l * A, s[6] = o * b + a * S + l * T, s[1] = u * y + c * _ + f * E, s[4] = u * v + c * x + f * A, s[7] = u * b + c * S + f * T, s[2] = d * y + p * _ + m * E, s[5] = d * v + p * x + m * A, s[8] = d * b + p * S + m * T, this
    }
    multiplyScalar(e) {
        const n = this.elements;
        return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this
    }
    determinant() {
        const e = this.elements,
            n = e[0],
            r = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            u = e[7],
            c = e[8];
        return n * o * c - n * a * u - r * s * c + r * a * l + i * s * u - i * o * l
    }
    invert() {
        const e = this.elements,
            n = e[0],
            r = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            u = e[7],
            c = e[8],
            f = c * o - a * u,
            d = a * l - c * s,
            p = u * s - o * l,
            m = n * f + r * d + i * p;
        if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const y = 1 / m;
        return e[0] = f * y, e[1] = (i * u - c * r) * y, e[2] = (a * r - i * o) * y, e[3] = d * y, e[4] = (c * n - i * l) * y, e[5] = (i * s - a * n) * y, e[6] = p * y, e[7] = (r * l - u * n) * y, e[8] = (o * n - r * s) * y, this
    }
    transpose() {
        let e;
        const n = this.elements;
        return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const n = this.elements;
        return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this
    }
    setUvTransform(e, n, r, i, s, o, a) {
        const l = Math.cos(s),
            u = Math.sin(s);
        return this.set(r * l, r * u, -r * (l * o + u * a) + o + e, -i * u, i * l, -i * (-u * o + l * a) + a + n, 0, 0, 1), this
    }
    scale(e, n) {
        return this.premultiply(OM.makeScale(e, n)), this
    }
    rotate(e) {
        return this.premultiply(OM.makeRotation(-e)), this
    }
    translate(e, n) {
        return this.premultiply(OM.makeTranslation(e, n)), this
    }
    makeTranslation(e, n) {
        return this.set(1, 0, e, 0, 1, n, 0, 0, 1), this
    }
    makeRotation(e) {
        const n = Math.cos(e),
            r = Math.sin(e);
        return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this
    }
    makeScale(e, n) {
        return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this
    }
    equals(e) {
        const n = this.elements,
            r = e.elements;
        for (let i = 0; i < 9; i++)
            if (n[i] !== r[i]) return !1;
        return !0
    }
    fromArray(e, n = 0) {
        for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
        return this
    }
    toArray(e = [], n = 0) {
        const r = this.elements;
        return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const OM = new Hi;

function lW(t) {
    for (let e = t.length - 1; e >= 0; --e)
        if (t[e] >= 65535) return !0;
    return !1
}
const bue = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};

function Nh(t, e) {
    return new bue[t](e)
}

function f0(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t)
}
class Ti {
    constructor(e = 0, n = 0, r = 0, i = 1) {
        this.isQuaternion = !0, this._x = e, this._y = n, this._z = r, this._w = i
    }
    static slerpFlat(e, n, r, i, s, o, a) {
        let l = r[i + 0],
            u = r[i + 1],
            c = r[i + 2],
            f = r[i + 3];
        const d = s[o + 0],
            p = s[o + 1],
            m = s[o + 2],
            y = s[o + 3];
        if (a === 0) {
            e[n + 0] = l, e[n + 1] = u, e[n + 2] = c, e[n + 3] = f;
            return
        }
        if (a === 1) {
            e[n + 0] = d, e[n + 1] = p, e[n + 2] = m, e[n + 3] = y;
            return
        }
        if (f !== y || l !== d || u !== p || c !== m) {
            let v = 1 - a;
            const b = l * d + u * p + c * m + f * y,
                _ = b >= 0 ? 1 : -1,
                x = 1 - b * b;
            if (x > Number.EPSILON) {
                const E = Math.sqrt(x),
                    A = Math.atan2(E, b * _);
                v = Math.sin(v * A) / E, a = Math.sin(a * A) / E
            }
            const S = a * _;
            if (l = l * v + d * S, u = u * v + p * S, c = c * v + m * S, f = f * v + y * S, v === 1 - a) {
                const E = 1 / Math.sqrt(l * l + u * u + c * c + f * f);
                l *= E, u *= E, c *= E, f *= E
            }
        }
        e[n] = l, e[n + 1] = u, e[n + 2] = c, e[n + 3] = f
    }
    static multiplyQuaternionsFlat(e, n, r, i, s, o) {
        const a = r[i],
            l = r[i + 1],
            u = r[i + 2],
            c = r[i + 3],
            f = s[o],
            d = s[o + 1],
            p = s[o + 2],
            m = s[o + 3];
        return e[n] = a * m + c * f + l * p - u * d, e[n + 1] = l * m + c * d + u * f - a * p, e[n + 2] = u * m + c * p + a * d - l * f, e[n + 3] = c * m - a * f - l * d - u * p, e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e, this._onChangeCallback()
    }
    set(e, n, r, i) {
        return this._x = e, this._y = n, this._z = r, this._w = i, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
    }
    setFromEuler(e, n) {
        const r = e._x,
            i = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            u = a(r / 2),
            c = a(i / 2),
            f = a(s / 2),
            d = l(r / 2),
            p = l(i / 2),
            m = l(s / 2);
        switch (o) {
            case "XYZ":
                this._x = d * c * f + u * p * m, this._y = u * p * f - d * c * m, this._z = u * c * m + d * p * f, this._w = u * c * f - d * p * m;
                break;
            case "YXZ":
                this._x = d * c * f + u * p * m, this._y = u * p * f - d * c * m, this._z = u * c * m - d * p * f, this._w = u * c * f + d * p * m;
                break;
            case "ZXY":
                this._x = d * c * f - u * p * m, this._y = u * p * f + d * c * m, this._z = u * c * m + d * p * f, this._w = u * c * f - d * p * m;
                break;
            case "ZYX":
                this._x = d * c * f - u * p * m, this._y = u * p * f + d * c * m, this._z = u * c * m - d * p * f, this._w = u * c * f + d * p * m;
                break;
            case "YZX":
                this._x = d * c * f + u * p * m, this._y = u * p * f + d * c * m, this._z = u * c * m - d * p * f, this._w = u * c * f - d * p * m;
                break;
            case "XZY":
                this._x = d * c * f - u * p * m, this._y = u * p * f - d * c * m, this._z = u * c * m + d * p * f, this._w = u * c * f + d * p * m;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return n !== !1 && this._onChangeCallback(), this
    }
    setFromAxisAngle(e, n) {
        const r = n / 2,
            i = Math.sin(r);
        return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this
    }
    setFromRotationMatrix(e) {
        const n = e.elements,
            r = n[0],
            i = n[4],
            s = n[8],
            o = n[1],
            a = n[5],
            l = n[9],
            u = n[2],
            c = n[6],
            f = n[10],
            d = r + a + f;
        if (d > 0) {
            const p = .5 / Math.sqrt(d + 1);
            this._w = .25 / p, this._x = (c - l) * p, this._y = (s - u) * p, this._z = (o - i) * p
        } else if (r > a && r > f) {
            const p = 2 * Math.sqrt(1 + r - a - f);
            this._w = (c - l) / p, this._x = .25 * p, this._y = (i + o) / p, this._z = (s + u) / p
        } else if (a > f) {
            const p = 2 * Math.sqrt(1 + a - r - f);
            this._w = (s - u) / p, this._x = (i + o) / p, this._y = .25 * p, this._z = (l + c) / p
        } else {
            const p = 2 * Math.sqrt(1 + f - r - a);
            this._w = (o - i) / p, this._x = (s + u) / p, this._y = (l + c) / p, this._z = .25 * p
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(e, n) {
        let r = e.dot(n) + 1;
        return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = r), this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Xr(this.dot(e), -1, 1)))
    }
    rotateTowards(e, n) {
        const r = this.angleTo(e);
        if (r === 0) return this;
        const i = Math.min(1, n / r);
        return this.slerp(e, i), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, n) {
        const r = e._x,
            i = e._y,
            s = e._z,
            o = e._w,
            a = n._x,
            l = n._y,
            u = n._z,
            c = n._w;
        return this._x = r * c + o * a + i * u - s * l, this._y = i * c + o * l + s * a - r * u, this._z = s * c + o * u + r * l - i * a, this._w = o * c - r * a - i * l - s * u, this._onChangeCallback(), this
    }
    slerp(e, n) {
        if (n === 0) return this;
        if (n === 1) return this.copy(e);
        const r = this._x,
            i = this._y,
            s = this._z,
            o = this._w;
        let a = o * e._w + r * e._x + i * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = r, this._y = i, this._z = s, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const p = 1 - n;
            return this._w = p * o + n * this._w, this._x = p * r + n * this._x, this._y = p * i + n * this._y, this._z = p * s + n * this._z, this.normalize(), this._onChangeCallback(), this
        }
        const u = Math.sqrt(l),
            c = Math.atan2(u, a),
            f = Math.sin((1 - n) * c) / u,
            d = Math.sin(n * c) / u;
        return this._w = o * f + this._w * d, this._x = r * f + this._x * d, this._y = i * f + this._y * d, this._z = s * f + this._z * d, this._onChangeCallback(), this
    }
    slerpQuaternions(e, n, r) {
        return this.copy(e).slerp(n, r)
    }
    random() {
        const e = Math.random(),
            n = Math.sqrt(1 - e),
            r = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
        return this.set(n * Math.cos(i), r * Math.sin(s), r * Math.cos(s), n * Math.sin(i))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, n = 0) {
        return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this
    }
    toArray(e = [], n = 0) {
        return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e
    }
    fromBufferAttribute(e, n) {
        return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}
class J {
    constructor(e = 0, n = 0, r = 0) {
        J.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = r
    }
    set(e, n, r) {
        return r === void 0 && (r = this.z), this.x = e, this.y = n, this.z = r, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setComponent(e, n) {
        switch (e) {
            case 0:
                this.x = n;
                break;
            case 1:
                this.y = n;
                break;
            case 2:
                this.z = n;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this
    }
    multiplyVectors(e, n) {
        return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this
    }
    applyEuler(e) {
        return this.applyQuaternion(JN.setFromEuler(e))
    }
    applyAxisAngle(e, n) {
        return this.applyQuaternion(JN.setFromAxisAngle(e, n))
    }
    applyMatrix3(e) {
        const n = this.x,
            r = this.y,
            i = this.z,
            s = e.elements;
        return this.x = s[0] * n + s[3] * r + s[6] * i, this.y = s[1] * n + s[4] * r + s[7] * i, this.z = s[2] * n + s[5] * r + s[8] * i, this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const n = this.x,
            r = this.y,
            i = this.z,
            s = e.elements,
            o = 1 / (s[3] * n + s[7] * r + s[11] * i + s[15]);
        return this.x = (s[0] * n + s[4] * r + s[8] * i + s[12]) * o, this.y = (s[1] * n + s[5] * r + s[9] * i + s[13]) * o, this.z = (s[2] * n + s[6] * r + s[10] * i + s[14]) * o, this
    }
    applyQuaternion(e) {
        const n = this.x,
            r = this.y,
            i = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            u = l * n + o * i - a * r,
            c = l * r + a * n - s * i,
            f = l * i + s * r - o * n,
            d = -s * n - o * r - a * i;
        return this.x = u * l + d * -s + c * -a - f * -o, this.y = c * l + d * -o + f * -s - u * -a, this.z = f * l + d * -a + u * -o - c * -s, this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const n = this.x,
            r = this.y,
            i = this.z,
            s = e.elements;
        return this.x = s[0] * n + s[4] * r + s[8] * i, this.y = s[1] * n + s[5] * r + s[9] * i, this.z = s[2] * n + s[6] * r + s[10] * i, this.normalize()
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
    }
    clamp(e, n) {
        return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this
    }
    clampScalar(e, n) {
        return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this
    }
    clampLength(e, n) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this
    }
    lerpVectors(e, n, r) {
        return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, n) {
        const r = e.x,
            i = e.y,
            s = e.z,
            o = n.x,
            a = n.y,
            l = n.z;
        return this.x = i * l - s * a, this.y = s * o - r * l, this.z = r * a - i * o, this
    }
    projectOnVector(e) {
        const n = e.lengthSq();
        if (n === 0) return this.set(0, 0, 0);
        const r = e.dot(this) / n;
        return this.copy(e).multiplyScalar(r)
    }
    projectOnPlane(e) {
        return DM.copy(this).projectOnVector(e), this.sub(DM)
    }
    reflect(e) {
        return this.sub(DM.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (n === 0) return Math.PI / 2;
        const r = this.dot(e) / n;
        return Math.acos(Xr(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const n = this.x - e.x,
            r = this.y - e.y,
            i = this.z - e.z;
        return n * n + r * r + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, n, r) {
        const i = Math.sin(n) * e;
        return this.x = i * Math.sin(r), this.y = Math.cos(n) * e, this.z = i * Math.cos(r), this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, n, r) {
        return this.x = e * Math.sin(n), this.y = r, this.z = e * Math.cos(n), this
    }
    setFromMatrixPosition(e) {
        const n = e.elements;
        return this.x = n[12], this.y = n[13], this.z = n[14], this
    }
    setFromMatrixScale(e) {
        const n = this.setFromMatrixColumn(e, 0).length(),
            r = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
        return this.x = n, this.y = r, this.z = i, this
    }
    setFromMatrixColumn(e, n) {
        return this.fromArray(e.elements, n * 4)
    }
    setFromMatrix3Column(e, n) {
        return this.fromArray(e.elements, n * 3)
    }
    setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, n = 0) {
        return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this
    }
    toArray(e = [], n = 0) {
        return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2,
            n = Math.random() * Math.PI * 2,
            r = Math.sqrt(1 - e ** 2);
        return this.x = r * Math.cos(n), this.y = r * Math.sin(n), this.z = e, this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}
const DM = new J,
    JN = new Ti;

function cm(t) {
    return t < .04045 ? t * .0773993808 : Math.pow(t * .9478672986 + .0521327014, 2.4)
}

function LM(t) {
    return t < .0031308 ? t * 12.92 : 1.055 * Math.pow(t, .41666) - .055
}
const xue = new Hi().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
    _ue = new Hi().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]),
    Dc = new J;

function Sue(t) {
    return t.convertSRGBToLinear(), Dc.set(t.r, t.g, t.b).applyMatrix3(_ue), t.setRGB(Dc.x, Dc.y, Dc.z)
}

function wue(t) {
    return Dc.set(t.r, t.g, t.b).applyMatrix3(xue), t.setRGB(Dc.x, Dc.y, Dc.z).convertLinearToSRGB()
}
const Eue = {
        [Bm]: t => t,
        [Ea]: t => t.convertSRGBToLinear(),
        [fL]: Sue
    },
    Aue = {
        [Bm]: t => t,
        [Ea]: t => t.convertLinearToSRGB(),
        [fL]: wue
    },
    ts = {
        enabled: !1,
        get legacyMode() {
            return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
        },
        set legacyMode(t) {
            console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !t
        },
        get workingColorSpace() {
            return Bm
        },
        set workingColorSpace(t) {
            console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
        },
        convert: function(t, e, n) {
            if (this.enabled === !1 || e === n || !e || !n) return t;
            const r = Eue[e],
                i = Aue[n];
            if (r === void 0 || i === void 0) throw new Error(`Unsupported color space conversion, "${e}" to "${n}".`);
            return i(r(t))
        },
        fromWorkingColorSpace: function(t, e) {
            return this.convert(t, this.workingColorSpace, e)
        },
        toWorkingColorSpace: function(t, e) {
            return this.convert(t, e, this.workingColorSpace)
        }
    };
let Fp;
class pL {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let n;
        if (e instanceof HTMLCanvasElement) n = e;
        else {
            Fp === void 0 && (Fp = f0("canvas")), Fp.width = e.width, Fp.height = e.height;
            const r = Fp.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), n = Fp
        }
        return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", .6)) : n.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const n = f0("canvas");
            n.width = e.width, n.height = e.height;
            const r = n.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const i = r.getImageData(0, 0, e.width, e.height),
                s = i.data;
            for (let o = 0; o < s.length; o++) s[o] = cm(s[o] / 255) * 255;
            return r.putImageData(i, 0, 0), n
        } else if (e.data) {
            const n = e.data.slice(0);
            for (let r = 0; r < n.length; r++) n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[r] = Math.floor(cm(n[r] / 255) * 255) : n[r] = cm(n[r]);
            return {
                data: n,
                width: e.width,
                height: e.height
            }
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
    }
}
class xd {
    constructor(e = null) {
        this.isSource = !0, this.uuid = uo(), this.data = e, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const r = {
                uuid: this.uuid,
                url: ""
            },
            i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? s.push(kM(i[o].image)) : s.push(kM(i[o]))
            } else s = kM(i);
            r.url = s
        }
        return n || (e.images[this.uuid] = r), r
    }
}

function kM(t) {
    return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? pL.getDataURL(t) : t.data ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let Cue = 0;
class Sr extends Bl {
    constructor(e = Sr.DEFAULT_IMAGE, n = Sr.DEFAULT_MAPPING, r = zi, i = zi, s = fr, o = Dl, a = Ns, l = Du, u = Sr.DEFAULT_ANISOTROPY, c = Lu) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: Cue++
        }), this.uuid = uo(), this.name = "", this.source = new xd(e), this.mipmaps = [], this.mapping = n, this.wrapS = r, this.wrapT = i, this.magFilter = s, this.minFilter = o, this.anisotropy = u, this.format = a, this.internalFormat = null, this.type = l, this.offset = new ke(0, 0), this.repeat = new ke(1, 1), this.center = new ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Hi, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e = null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const r = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (r.userData = this.userData), n || (e.textures[this.uuid] = r), r
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== DE) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case cf:
                e.x = e.x - Math.floor(e.x);
                break;
            case zi:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Lm:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case cf:
                e.y = e.y - Math.floor(e.y);
                break;
            case zi:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Lm:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
        }
        return this.flipY && (e.y = 1 - e.y), e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, this.source.needsUpdate = !0)
    }
}
Sr.DEFAULT_IMAGE = null;
Sr.DEFAULT_MAPPING = DE;
Sr.DEFAULT_ANISOTROPY = 1;
class In {
    constructor(e = 0, n = 0, r = 0, i = 1) {
        In.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = r, this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, n, r, i) {
        return this.x = e, this.y = n, this.z = r, this.w = i, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setW(e) {
        return this.w = e, this
    }
    setComponent(e, n) {
        switch (e) {
            case 0:
                this.x = n;
                break;
            case 1:
                this.y = n;
                break;
            case 2:
                this.z = n;
                break;
            case 3:
                this.w = n;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
    }
    applyMatrix4(e) {
        const n = this.x,
            r = this.y,
            i = this.z,
            s = this.w,
            o = e.elements;
        return this.x = o[0] * n + o[4] * r + o[8] * i + o[12] * s, this.y = o[1] * n + o[5] * r + o[9] * i + o[13] * s, this.z = o[2] * n + o[6] * r + o[10] * i + o[14] * s, this.w = o[3] * n + o[7] * r + o[11] * i + o[15] * s, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const n = Math.sqrt(1 - e.w * e.w);
        return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this
    }
    setAxisAngleFromRotationMatrix(e) {
        let n, r, i, s;
        const l = e.elements,
            u = l[0],
            c = l[4],
            f = l[8],
            d = l[1],
            p = l[5],
            m = l[9],
            y = l[2],
            v = l[6],
            b = l[10];
        if (Math.abs(c - d) < .01 && Math.abs(f - y) < .01 && Math.abs(m - v) < .01) {
            if (Math.abs(c + d) < .1 && Math.abs(f + y) < .1 && Math.abs(m + v) < .1 && Math.abs(u + p + b - 3) < .1) return this.set(1, 0, 0, 0), this;
            n = Math.PI;
            const x = (u + 1) / 2,
                S = (p + 1) / 2,
                E = (b + 1) / 2,
                A = (c + d) / 4,
                T = (f + y) / 4,
                M = (m + v) / 4;
            return x > S && x > E ? x < .01 ? (r = 0, i = .707106781, s = .707106781) : (r = Math.sqrt(x), i = A / r, s = T / r) : S > E ? S < .01 ? (r = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(S), r = A / i, s = M / i) : E < .01 ? (r = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(E), r = T / s, i = M / s), this.set(r, i, s, n), this
        }
        let _ = Math.sqrt((v - m) * (v - m) + (f - y) * (f - y) + (d - c) * (d - c));
        return Math.abs(_) < .001 && (_ = 1), this.x = (v - m) / _, this.y = (f - y) / _, this.z = (d - c) / _, this.w = Math.acos((u + p + b - 1) / 2), this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
    }
    clamp(e, n) {
        return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this
    }
    clampScalar(e, n) {
        return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this
    }
    clampLength(e, n) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(n, r)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this
    }
    lerpVectors(e, n, r) {
        return this.x = e.x + (n.x - e.x) * r, this.y = e.y + (n.y - e.y) * r, this.z = e.z + (n.z - e.z) * r, this.w = e.w + (n.w - e.w) * r, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, n = 0) {
        return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this
    }
    toArray(e = [], n = 0) {
        return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class na extends Bl {
    constructor(e = 1, n = 1, r = {}) {
        super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new In(0, 0, e, n), this.scissorTest = !1, this.viewport = new In(0, 0, e, n);
        const i = {
            width: e,
            height: n,
            depth: 1
        };
        this.texture = new Sr(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : fr, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0
    }
    setSize(e, n, r = 1) {
        (this.width !== e || this.height !== n || this.depth !== r) && (this.width = e, this.height = n, this.depth = r, this.texture.image.width = e, this.texture.image.height = n, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
        const n = Object.assign({}, e.texture.image);
        return this.texture.source = new xd(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class BE extends Sr {
    constructor(e = null, n = 1, r = 1, i = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: n,
            height: r,
            depth: i
        }, this.magFilter = Br, this.minFilter = Br, this.wrapR = zi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class Mue extends na {
    constructor(e = 1, n = 1, r = 1) {
        super(e, n), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new BE(null, e, n, r), this.texture.isRenderTargetTexture = !0
    }
}
class hL extends Sr {
    constructor(e = null, n = 1, r = 1, i = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: n,
            height: r,
            depth: i
        }, this.magFilter = Br, this.minFilter = Br, this.wrapR = zi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class Tue extends na {
    constructor(e = 1, n = 1, r = 1) {
        super(e, n), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new hL(null, e, n, r), this.texture.isRenderTargetTexture = !0
    }
}
class Pue extends na {
    constructor(e = 1, n = 1, r = 1, i = {}) {
        super(e, n, i), this.isWebGLMultipleRenderTargets = !0;
        const s = this.texture;
        this.texture = [];
        for (let o = 0; o < r; o++) this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0
    }
    setSize(e, n, r = 1) {
        if (this.width !== e || this.height !== n || this.depth !== r) {
            this.width = e, this.height = n, this.depth = r;
            for (let i = 0, s = this.texture.length; i < s; i++) this.texture[i].image.width = e, this.texture[i].image.height = n, this.texture[i].image.depth = r;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n), this
    }
    copy(e) {
        this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
        for (let n = 0, r = e.texture.length; n < r; n++) this.texture[n] = e.texture[n].clone(), this.texture[n].isRenderTargetTexture = !0;
        return this
    }
}
class Xa {
    constructor(e = new J(1 / 0, 1 / 0, 1 / 0), n = new J(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = e, this.max = n
    }
    set(e, n) {
        return this.min.copy(e), this.max.copy(n), this
    }
    setFromArray(e) {
        let n = 1 / 0,
            r = 1 / 0,
            i = 1 / 0,
            s = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
        for (let l = 0, u = e.length; l < u; l += 3) {
            const c = e[l],
                f = e[l + 1],
                d = e[l + 2];
            c < n && (n = c), f < r && (r = f), d < i && (i = d), c > s && (s = c), f > o && (o = f), d > a && (a = d)
        }
        return this.min.set(n, r, i), this.max.set(s, o, a), this
    }
    setFromBufferAttribute(e) {
        let n = 1 / 0,
            r = 1 / 0,
            i = 1 / 0,
            s = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
        for (let l = 0, u = e.count; l < u; l++) {
            const c = e.getX(l),
                f = e.getY(l),
                d = e.getZ(l);
            c < n && (n = c), f < r && (r = f), d < i && (i = d), c > s && (s = c), f > o && (o = f), d > a && (a = d)
        }
        return this.min.set(n, r, i), this.max.set(s, o, a), this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
        return this
    }
    setFromCenterAndSize(e, n) {
        const r = $f.copy(n).multiplyScalar(.5);
        return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
    }
    setFromObject(e, n = !1) {
        return this.makeEmpty(), this.expandByObject(e, n)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    expandByObject(e, n = !1) {
        e.updateWorldMatrix(!1, !1);
        const r = e.geometry;
        if (r !== void 0)
            if (n && r.attributes != null && r.attributes.position !== void 0) {
                const s = r.attributes.position;
                for (let o = 0, a = s.count; o < a; o++) $f.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint($f)
            } else r.boundingBox === null && r.computeBoundingBox(), BM.copy(r.boundingBox), BM.applyMatrix4(e.matrixWorld), this.union(BM);
        const i = e.children;
        for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], n);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, n) {
        return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, $f), $f.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let n, r;
        return e.normal.x > 0 ? (n = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, r += e.normal.z * this.min.z), n <= -e.constant && r >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(hy), px.subVectors(this.max, hy), Np.subVectors(e.a, hy), zp.subVectors(e.b, hy), Hp.subVectors(e.c, hy), cc.subVectors(zp, Np), fc.subVectors(Hp, zp), Gf.subVectors(Np, Hp);
        let n = [0, -cc.z, cc.y, 0, -fc.z, fc.y, 0, -Gf.z, Gf.y, cc.z, 0, -cc.x, fc.z, 0, -fc.x, Gf.z, 0, -Gf.x, -cc.y, cc.x, 0, -fc.y, fc.x, 0, -Gf.y, Gf.x, 0];
        return !FM(n, Np, zp, Hp, px) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !FM(n, Np, zp, Hp, px)) ? !1 : (hx.crossVectors(cc, fc), n = [hx.x, hx.y, hx.z], FM(n, Np, zp, Hp, px))
    }
    clampPoint(e, n) {
        return n.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, $f).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize($f).length() * .5), e
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (eu[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), eu[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), eu[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), eu[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), eu[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), eu[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), eu[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), eu[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(eu), this)
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const eu = [new J, new J, new J, new J, new J, new J, new J, new J],
    $f = new J,
    BM = new Xa,
    Np = new J,
    zp = new J,
    Hp = new J,
    cc = new J,
    fc = new J,
    Gf = new J,
    hy = new J,
    px = new J,
    hx = new J,
    Vf = new J;

function FM(t, e, n, r, i) {
    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
        Vf.fromArray(t, s);
        const a = i.x * Math.abs(Vf.x) + i.y * Math.abs(Vf.y) + i.z * Math.abs(Vf.z),
            l = e.dot(Vf),
            u = n.dot(Vf),
            c = r.dot(Vf);
        if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > a) return !1
    }
    return !0
}
const Iue = new Xa,
    my = new J,
    NM = new J;
class Fl {
    constructor(e = new J, n = -1) {
        this.center = e, this.radius = n
    }
    set(e, n) {
        return this.center.copy(e), this.radius = n, this
    }
    setFromPoints(e, n) {
        const r = this.center;
        n !== void 0 ? r.copy(n) : Iue.setFromPoints(e).getCenter(r);
        let i = 0;
        for (let s = 0, o = e.length; s < o; s++) i = Math.max(i, r.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i), this
    }
    copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const n = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= n * n
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, n) {
        const r = this.center.distanceToSquared(e);
        return n.copy(e), r > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
    }
    translate(e) {
        return this.center.add(e), this
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
        my.subVectors(e, this.center);
        const n = my.lengthSq();
        if (n > this.radius * this.radius) {
            const r = Math.sqrt(n),
                i = (r - this.radius) * .5;
            this.center.addScaledVector(my, i / r), this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (NM.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(my.copy(e.center).add(NM)), this.expandByPoint(my.copy(e.center).sub(NM))), this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const tu = new J,
    zM = new J,
    mx = new J,
    dc = new J,
    HM = new J,
    gx = new J,
    UM = new J;
class yg {
    constructor(e = new J, n = new J(0, 0, -1)) {
        this.origin = e, this.direction = n
    }
    set(e, n) {
        return this.origin.copy(e), this.direction.copy(n), this
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this
    }
    at(e, n) {
        return n.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this
    }
    recast(e) {
        return this.origin.copy(this.at(e, tu)), this
    }
    closestPointToPoint(e, n) {
        n.subVectors(e, this.origin);
        const r = n.dot(this.direction);
        return r < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, r)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const n = tu.subVectors(e, this.origin).dot(this.direction);
        return n < 0 ? this.origin.distanceToSquared(e) : (tu.copy(this.origin).addScaledVector(this.direction, n), tu.distanceToSquared(e))
    }
    distanceSqToSegment(e, n, r, i) {
        zM.copy(e).add(n).multiplyScalar(.5), mx.copy(n).sub(e).normalize(), dc.copy(this.origin).sub(zM);
        const s = e.distanceTo(n) * .5,
            o = -this.direction.dot(mx),
            a = dc.dot(this.direction),
            l = -dc.dot(mx),
            u = dc.lengthSq(),
            c = Math.abs(1 - o * o);
        let f, d, p, m;
        if (c > 0)
            if (f = o * l - a, d = o * a - l, m = s * c, f >= 0)
                if (d >= -m)
                    if (d <= m) {
                        const y = 1 / c;
                        f *= y, d *= y, p = f * (f + o * d + 2 * a) + d * (o * f + d + 2 * l) + u
                    } else d = s, f = Math.max(0, -(o * d + a)), p = -f * f + d * (d + 2 * l) + u;
        else d = -s, f = Math.max(0, -(o * d + a)), p = -f * f + d * (d + 2 * l) + u;
        else d <= -m ? (f = Math.max(0, -(-o * s + a)), d = f > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -f * f + d * (d + 2 * l) + u) : d <= m ? (f = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + u) : (f = Math.max(0, -(o * s + a)), d = f > 0 ? s : Math.min(Math.max(-s, -l), s), p = -f * f + d * (d + 2 * l) + u);
        else d = o > 0 ? -s : s, f = Math.max(0, -(o * d + a)), p = -f * f + d * (d + 2 * l) + u;
        return r && r.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(zM).addScaledVector(mx, d), p
    }
    intersectSphere(e, n) {
        tu.subVectors(e.center, this.origin);
        const r = tu.dot(this.direction),
            i = tu.dot(tu) - r * r,
            s = e.radius * e.radius;
        if (i > s) return null;
        const o = Math.sqrt(s - i),
            a = r - o,
            l = r + o;
        return l < 0 ? null : a < 0 ? this.at(l, n) : this.at(a, n)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const n = e.normal.dot(this.direction);
        if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const r = -(this.origin.dot(e.normal) + e.constant) / n;
        return r >= 0 ? r : null
    }
    intersectPlane(e, n) {
        const r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, n)
    }
    intersectsPlane(e) {
        const n = e.distanceToPoint(this.origin);
        return n === 0 || e.normal.dot(this.direction) * n < 0
    }
    intersectBox(e, n) {
        let r, i, s, o, a, l;
        const u = 1 / this.direction.x,
            c = 1 / this.direction.y,
            f = 1 / this.direction.z,
            d = this.origin;
        return u >= 0 ? (r = (e.min.x - d.x) * u, i = (e.max.x - d.x) * u) : (r = (e.max.x - d.x) * u, i = (e.min.x - d.x) * u), c >= 0 ? (s = (e.min.y - d.y) * c, o = (e.max.y - d.y) * c) : (s = (e.max.y - d.y) * c, o = (e.min.y - d.y) * c), r > o || s > i || ((s > r || isNaN(r)) && (r = s), (o < i || isNaN(i)) && (i = o), f >= 0 ? (a = (e.min.z - d.z) * f, l = (e.max.z - d.z) * f) : (a = (e.max.z - d.z) * f, l = (e.min.z - d.z) * f), r > l || a > i) || ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(r >= 0 ? r : i, n)
    }
    intersectsBox(e) {
        return this.intersectBox(e, tu) !== null
    }
    intersectTriangle(e, n, r, i, s) {
        HM.subVectors(n, e), gx.subVectors(r, e), UM.crossVectors(HM, gx);
        let o = this.direction.dot(UM),
            a;
        if (o > 0) {
            if (i) return null;
            a = 1
        } else if (o < 0) a = -1, o = -o;
        else return null;
        dc.subVectors(this.origin, e);
        const l = a * this.direction.dot(gx.crossVectors(dc, gx));
        if (l < 0) return null;
        const u = a * this.direction.dot(HM.cross(dc));
        if (u < 0 || l + u > o) return null;
        const c = -a * dc.dot(UM);
        return c < 0 ? null : this.at(c / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Gt {
    constructor() {
        Gt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, n, r, i, s, o, a, l, u, c, f, d, p, m, y, v) {
        const b = this.elements;
        return b[0] = e, b[4] = n, b[8] = r, b[12] = i, b[1] = s, b[5] = o, b[9] = a, b[13] = l, b[2] = u, b[6] = c, b[10] = f, b[14] = d, b[3] = p, b[7] = m, b[11] = y, b[15] = v, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return new Gt().fromArray(this.elements)
    }
    copy(e) {
        const n = this.elements,
            r = e.elements;
        return n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
    }
    copyPosition(e) {
        const n = this.elements,
            r = e.elements;
        return n[12] = r[12], n[13] = r[13], n[14] = r[14], this
    }
    setFromMatrix3(e) {
        const n = e.elements;
        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(e, n, r) {
        return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this
    }
    makeBasis(e, n, r) {
        return this.set(e.x, n.x, r.x, 0, e.y, n.y, r.y, 0, e.z, n.z, r.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(e) {
        const n = this.elements,
            r = e.elements,
            i = 1 / Up.setFromMatrixColumn(e, 0).length(),
            s = 1 / Up.setFromMatrixColumn(e, 1).length(),
            o = 1 / Up.setFromMatrixColumn(e, 2).length();
        return n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = 0, n[4] = r[4] * s, n[5] = r[5] * s, n[6] = r[6] * s, n[7] = 0, n[8] = r[8] * o, n[9] = r[9] * o, n[10] = r[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
    }
    makeRotationFromEuler(e) {
        const n = this.elements,
            r = e.x,
            i = e.y,
            s = e.z,
            o = Math.cos(r),
            a = Math.sin(r),
            l = Math.cos(i),
            u = Math.sin(i),
            c = Math.cos(s),
            f = Math.sin(s);
        if (e.order === "XYZ") {
            const d = o * c,
                p = o * f,
                m = a * c,
                y = a * f;
            n[0] = l * c, n[4] = -l * f, n[8] = u, n[1] = p + m * u, n[5] = d - y * u, n[9] = -a * l, n[2] = y - d * u, n[6] = m + p * u, n[10] = o * l
        } else if (e.order === "YXZ") {
            const d = l * c,
                p = l * f,
                m = u * c,
                y = u * f;
            n[0] = d + y * a, n[4] = m * a - p, n[8] = o * u, n[1] = o * f, n[5] = o * c, n[9] = -a, n[2] = p * a - m, n[6] = y + d * a, n[10] = o * l
        } else if (e.order === "ZXY") {
            const d = l * c,
                p = l * f,
                m = u * c,
                y = u * f;
            n[0] = d - y * a, n[4] = -o * f, n[8] = m + p * a, n[1] = p + m * a, n[5] = o * c, n[9] = y - d * a, n[2] = -o * u, n[6] = a, n[10] = o * l
        } else if (e.order === "ZYX") {
            const d = o * c,
                p = o * f,
                m = a * c,
                y = a * f;
            n[0] = l * c, n[4] = m * u - p, n[8] = d * u + y, n[1] = l * f, n[5] = y * u + d, n[9] = p * u - m, n[2] = -u, n[6] = a * l, n[10] = o * l
        } else if (e.order === "YZX") {
            const d = o * l,
                p = o * u,
                m = a * l,
                y = a * u;
            n[0] = l * c, n[4] = y - d * f, n[8] = m * f + p, n[1] = f, n[5] = o * c, n[9] = -a * c, n[2] = -u * c, n[6] = p * f + m, n[10] = d - y * f
        } else if (e.order === "XZY") {
            const d = o * l,
                p = o * u,
                m = a * l,
                y = a * u;
            n[0] = l * c, n[4] = -f, n[8] = u * c, n[1] = d * f + y, n[5] = o * c, n[9] = p * f - m, n[2] = m * f - p, n[6] = a * c, n[10] = y * f + d
        }
        return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(Rue, e, Oue)
    }
    lookAt(e, n, r) {
        const i = this.elements;
        return Qs.subVectors(e, n), Qs.lengthSq() === 0 && (Qs.z = 1), Qs.normalize(), pc.crossVectors(r, Qs), pc.lengthSq() === 0 && (Math.abs(r.z) === 1 ? Qs.x += 1e-4 : Qs.z += 1e-4, Qs.normalize(), pc.crossVectors(r, Qs)), pc.normalize(), yx.crossVectors(Qs, pc), i[0] = pc.x, i[4] = yx.x, i[8] = Qs.x, i[1] = pc.y, i[5] = yx.y, i[9] = Qs.y, i[2] = pc.z, i[6] = yx.z, i[10] = Qs.z, this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, n) {
        const r = e.elements,
            i = n.elements,
            s = this.elements,
            o = r[0],
            a = r[4],
            l = r[8],
            u = r[12],
            c = r[1],
            f = r[5],
            d = r[9],
            p = r[13],
            m = r[2],
            y = r[6],
            v = r[10],
            b = r[14],
            _ = r[3],
            x = r[7],
            S = r[11],
            E = r[15],
            A = i[0],
            T = i[4],
            M = i[8],
            I = i[12],
            O = i[1],
            k = i[5],
            H = i[9],
            N = i[13],
            B = i[2],
            U = i[6],
            q = i[10],
            Q = i[14],
            F = i[3],
            G = i[7],
            W = i[11],
            se = i[15];
        return s[0] = o * A + a * O + l * B + u * F, s[4] = o * T + a * k + l * U + u * G, s[8] = o * M + a * H + l * q + u * W, s[12] = o * I + a * N + l * Q + u * se, s[1] = c * A + f * O + d * B + p * F, s[5] = c * T + f * k + d * U + p * G, s[9] = c * M + f * H + d * q + p * W, s[13] = c * I + f * N + d * Q + p * se, s[2] = m * A + y * O + v * B + b * F, s[6] = m * T + y * k + v * U + b * G, s[10] = m * M + y * H + v * q + b * W, s[14] = m * I + y * N + v * Q + b * se, s[3] = _ * A + x * O + S * B + E * F, s[7] = _ * T + x * k + S * U + E * G, s[11] = _ * M + x * H + S * q + E * W, s[15] = _ * I + x * N + S * Q + E * se, this
    }
    multiplyScalar(e) {
        const n = this.elements;
        return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this
    }
    determinant() {
        const e = this.elements,
            n = e[0],
            r = e[4],
            i = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            u = e[13],
            c = e[2],
            f = e[6],
            d = e[10],
            p = e[14],
            m = e[3],
            y = e[7],
            v = e[11],
            b = e[15];
        return m * (+s * l * f - i * u * f - s * a * d + r * u * d + i * a * p - r * l * p) + y * (+n * l * p - n * u * d + s * o * d - i * o * p + i * u * c - s * l * c) + v * (+n * u * f - n * a * p - s * o * f + r * o * p + s * a * c - r * u * c) + b * (-i * a * c - n * l * f + n * a * d + i * o * f - r * o * d + r * l * c)
    }
    transpose() {
        const e = this.elements;
        let n;
        return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this
    }
    setPosition(e, n, r) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = n, i[14] = r), this
    }
    invert() {
        const e = this.elements,
            n = e[0],
            r = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            u = e[7],
            c = e[8],
            f = e[9],
            d = e[10],
            p = e[11],
            m = e[12],
            y = e[13],
            v = e[14],
            b = e[15],
            _ = f * v * u - y * d * u + y * l * p - a * v * p - f * l * b + a * d * b,
            x = m * d * u - c * v * u - m * l * p + o * v * p + c * l * b - o * d * b,
            S = c * y * u - m * f * u + m * a * p - o * y * p - c * a * b + o * f * b,
            E = m * f * l - c * y * l - m * a * d + o * y * d + c * a * v - o * f * v,
            A = n * _ + r * x + i * S + s * E;
        if (A === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / A;
        return e[0] = _ * T, e[1] = (y * d * s - f * v * s - y * i * p + r * v * p + f * i * b - r * d * b) * T, e[2] = (a * v * s - y * l * s + y * i * u - r * v * u - a * i * b + r * l * b) * T, e[3] = (f * l * s - a * d * s - f * i * u + r * d * u + a * i * p - r * l * p) * T, e[4] = x * T, e[5] = (c * v * s - m * d * s + m * i * p - n * v * p - c * i * b + n * d * b) * T, e[6] = (m * l * s - o * v * s - m * i * u + n * v * u + o * i * b - n * l * b) * T, e[7] = (o * d * s - c * l * s + c * i * u - n * d * u - o * i * p + n * l * p) * T, e[8] = S * T, e[9] = (m * f * s - c * y * s - m * r * p + n * y * p + c * r * b - n * f * b) * T, e[10] = (o * y * s - m * a * s + m * r * u - n * y * u - o * r * b + n * a * b) * T, e[11] = (c * a * s - o * f * s - c * r * u + n * f * u + o * r * p - n * a * p) * T, e[12] = E * T, e[13] = (c * y * i - m * f * i + m * r * d - n * y * d - c * r * v + n * f * v) * T, e[14] = (m * a * i - o * y * i - m * r * l + n * y * l + o * r * v - n * a * v) * T, e[15] = (o * f * i - c * a * i + c * r * l - n * f * l - o * r * d + n * a * d) * T, this
    }
    scale(e) {
        const n = this.elements,
            r = e.x,
            i = e.y,
            s = e.z;
        return n[0] *= r, n[4] *= i, n[8] *= s, n[1] *= r, n[5] *= i, n[9] *= s, n[2] *= r, n[6] *= i, n[10] *= s, n[3] *= r, n[7] *= i, n[11] *= s, this
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(n, r, i))
    }
    makeTranslation(e, n, r) {
        return this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1), this
    }
    makeRotationX(e) {
        const n = Math.cos(e),
            r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this
    }
    makeRotationY(e) {
        const n = Math.cos(e),
            r = Math.sin(e);
        return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(e) {
        const n = Math.cos(e),
            r = Math.sin(e);
        return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(e, n) {
        const r = Math.cos(n),
            i = Math.sin(n),
            s = 1 - r,
            o = e.x,
            a = e.y,
            l = e.z,
            u = s * o,
            c = s * a;
        return this.set(u * o + r, u * a - i * l, u * l + i * a, 0, u * a + i * l, c * a + r, c * l - i * o, 0, u * l - i * a, c * l + i * o, s * l * l + r, 0, 0, 0, 0, 1), this
    }
    makeScale(e, n, r) {
        return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this
    }
    makeShear(e, n, r, i, s, o) {
        return this.set(1, r, s, 0, e, 1, o, 0, n, i, 1, 0, 0, 0, 0, 1), this
    }
    compose(e, n, r) {
        const i = this.elements,
            s = n._x,
            o = n._y,
            a = n._z,
            l = n._w,
            u = s + s,
            c = o + o,
            f = a + a,
            d = s * u,
            p = s * c,
            m = s * f,
            y = o * c,
            v = o * f,
            b = a * f,
            _ = l * u,
            x = l * c,
            S = l * f,
            E = r.x,
            A = r.y,
            T = r.z;
        return i[0] = (1 - (y + b)) * E, i[1] = (p + S) * E, i[2] = (m - x) * E, i[3] = 0, i[4] = (p - S) * A, i[5] = (1 - (d + b)) * A, i[6] = (v + _) * A, i[7] = 0, i[8] = (m + x) * T, i[9] = (v - _) * T, i[10] = (1 - (d + y)) * T, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
    }
    decompose(e, n, r) {
        const i = this.elements;
        let s = Up.set(i[0], i[1], i[2]).length();
        const o = Up.set(i[4], i[5], i[6]).length(),
            a = Up.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], va.copy(this);
        const u = 1 / s,
            c = 1 / o,
            f = 1 / a;
        return va.elements[0] *= u, va.elements[1] *= u, va.elements[2] *= u, va.elements[4] *= c, va.elements[5] *= c, va.elements[6] *= c, va.elements[8] *= f, va.elements[9] *= f, va.elements[10] *= f, n.setFromRotationMatrix(va), r.x = s, r.y = o, r.z = a, this
    }
    makePerspective(e, n, r, i, s, o) {
        const a = this.elements,
            l = 2 * s / (n - e),
            u = 2 * s / (r - i),
            c = (n + e) / (n - e),
            f = (r + i) / (r - i),
            d = -(o + s) / (o - s),
            p = -2 * o * s / (o - s);
        return a[0] = l, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = u, a[9] = f, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
    }
    makeOrthographic(e, n, r, i, s, o) {
        const a = this.elements,
            l = 1 / (n - e),
            u = 1 / (r - i),
            c = 1 / (o - s),
            f = (n + e) * l,
            d = (r + i) * u,
            p = (o + s) * c;
        return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -f, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
    }
    equals(e) {
        const n = this.elements,
            r = e.elements;
        for (let i = 0; i < 16; i++)
            if (n[i] !== r[i]) return !1;
        return !0
    }
    fromArray(e, n = 0) {
        for (let r = 0; r < 16; r++) this.elements[r] = e[r + n];
        return this
    }
    toArray(e = [], n = 0) {
        const r = this.elements;
        return e[n] = r[0], e[n + 1] = r[1], e[n + 2] = r[2], e[n + 3] = r[3], e[n + 4] = r[4], e[n + 5] = r[5], e[n + 6] = r[6], e[n + 7] = r[7], e[n + 8] = r[8], e[n + 9] = r[9], e[n + 10] = r[10], e[n + 11] = r[11], e[n + 12] = r[12], e[n + 13] = r[13], e[n + 14] = r[14], e[n + 15] = r[15], e
    }
}
const Up = new J,
    va = new Gt,
    Rue = new J(0, 0, 0),
    Oue = new J(1, 1, 1),
    pc = new J,
    yx = new J,
    Qs = new J,
    YN = new Gt,
    QN = new Ti;
class c1 {
    constructor(e = 0, n = 0, r = 0, i = c1.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = e, this._y = n, this._z = r, this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e, this._onChangeCallback()
    }
    set(e, n, r, i = this._order) {
        return this._x = e, this._y = n, this._z = r, this._order = i, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(e, n = this._order, r = !0) {
        const i = e.elements,
            s = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            u = i[5],
            c = i[9],
            f = i[2],
            d = i[6],
            p = i[10];
        switch (n) {
            case "XYZ":
                this._y = Math.asin(Xr(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, u), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-Xr(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-f, s), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(Xr(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-f, p), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, s));
                break;
            case "ZYX":
                this._y = Math.asin(-Xr(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, u));
                break;
            case "YZX":
                this._z = Math.asin(Xr(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-f, s)) : (this._x = 0, this._y = Math.atan2(a, p));
                break;
            case "XZY":
                this._z = Math.asin(-Xr(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-c, p), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
        }
        return this._order = n, r === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(e, n, r) {
        return YN.makeRotationFromQuaternion(e), this.setFromRotationMatrix(YN, n, r)
    }
    setFromVector3(e, n = this._order) {
        return this.set(e.x, e.y, e.z, n)
    }
    reorder(e) {
        return QN.setFromEuler(this), this.setFromQuaternion(QN, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
    }
    toArray(e = [], n = 0) {
        return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}
c1.DEFAULT_ORDER = "XYZ";
let Bd = class {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0
        }
        enable(e) {
            this.mask |= 1 << e | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e | 0
        }
        disable(e) {
            this.mask &= ~(1 << e | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return (this.mask & e.mask) !== 0
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0
        }
    },
    Due = 0;
const ZN = new J,
    $p = new Ti,
    nu = new Gt,
    vx = new J,
    gy = new J,
    Lue = new J,
    kue = new Ti,
    e6 = new J(1, 0, 0),
    t6 = new J(0, 1, 0),
    n6 = new J(0, 0, 1),
    Bue = {
        type: "added"
    },
    r6 = {
        type: "removed"
    };
class Tn extends Bl {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: Due++
        }), this.uuid = uo(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Tn.DEFAULT_UP.clone();
        const e = new J,
            n = new c1,
            r = new Ti,
            i = new J(1, 1, 1);

        function s() {
            r.setFromEuler(n, !1)
        }

        function o() {
            n.setFromQuaternion(r, void 0, !1)
        }
        n._onChange(s), r._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Gt
            },
            normalMatrix: {
                value: new Hi
            }
        }), this.matrix = new Gt, this.matrixWorld = new Gt, this.matrixAutoUpdate = Tn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Tn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Bd, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this
    }
    setRotationFromAxisAngle(e, n) {
        this.quaternion.setFromAxisAngle(e, n)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, n) {
        return $p.setFromAxisAngle(e, n), this.quaternion.multiply($p), this
    }
    rotateOnWorldAxis(e, n) {
        return $p.setFromAxisAngle(e, n), this.quaternion.premultiply($p), this
    }
    rotateX(e) {
        return this.rotateOnAxis(e6, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(t6, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(n6, e)
    }
    translateOnAxis(e, n) {
        return ZN.copy(e).applyQuaternion(this.quaternion), this.position.add(ZN.multiplyScalar(n)), this
    }
    translateX(e) {
        return this.translateOnAxis(e6, e)
    }
    translateY(e) {
        return this.translateOnAxis(t6, e)
    }
    translateZ(e) {
        return this.translateOnAxis(n6, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(nu.copy(this.matrixWorld).invert())
    }
    lookAt(e, n, r) {
        e.isVector3 ? vx.copy(e) : vx.set(e, n, r);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1), gy.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? nu.lookAt(gy, vx, this.up) : nu.lookAt(vx, gy, this.up), this.quaternion.setFromRotationMatrix(nu), i && (nu.extractRotation(i.matrixWorld), $p.setFromRotationMatrix(nu), this.quaternion.premultiply($p.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Bue)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
            return this
        }
        const n = this.children.indexOf(e);
        return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(r6)), this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const n = this.children[e];
            n.parent = null, n.dispatchEvent(r6)
        }
        return this.children.length = 0, this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1), nu.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), nu.multiply(e.parent.matrixWorld)), e.applyMatrix4(nu), this.add(e), e.updateWorldMatrix(!1, !0), this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, n) {
        if (this[e] === n) return this;
        for (let r = 0, i = this.children.length; r < i; r++) {
            const o = this.children[r].getObjectByProperty(e, n);
            if (o !== void 0) return o
        }
    }
    getObjectsByProperty(e, n) {
        let r = [];
        this[e] === n && r.push(this);
        for (let i = 0, s = this.children.length; i < s; i++) {
            const o = this.children[i].getObjectsByProperty(e, n);
            o.length > 0 && (r = r.concat(o))
        }
        return r
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(gy, e, Lue), e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(gy, kue, e), e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const n = this.matrixWorld.elements;
        return e.set(n[8], n[9], n[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const n = this.children;
        for (let r = 0, i = n.length; r < i; r++) n[r].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const n = this.children;
        for (let r = 0, i = n.length; r < i; r++) n[r].traverseVisible(e)
    }
    traverseAncestors(e) {
        const n = this.parent;
        n !== null && (e(n), n.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
        const n = this.children;
        for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, n) {
        const r = this.parent;
        if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), n === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++) {
                const a = i[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string",
            r = {};
        n && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, r.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));

        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
        }
        if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let u = 0, c = l.length; u < c; u++) {
                        const f = l[u];
                        s(e.shapes, f)
                    } else s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, u = this.material.length; l < u; l++) a.push(s(e.materials, this.material[l]));
                i.material = a
            } else i.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(s(e.animations, l))
            }
        }
        if (n) {
            const a = o(e.geometries),
                l = o(e.materials),
                u = o(e.textures),
                c = o(e.images),
                f = o(e.shapes),
                d = o(e.skeletons),
                p = o(e.animations),
                m = o(e.nodes);
            a.length > 0 && (r.geometries = a), l.length > 0 && (r.materials = l), u.length > 0 && (r.textures = u), c.length > 0 && (r.images = c), f.length > 0 && (r.shapes = f), d.length > 0 && (r.skeletons = d), p.length > 0 && (r.animations = p), m.length > 0 && (r.nodes = m)
        }
        return r.object = i, r;

        function o(a) {
            const l = [];
            for (const u in a) {
                const c = a[u];
                delete c.metadata, l.push(c)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, n = !0) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
            for (let r = 0; r < e.children.length; r++) {
                const i = e.children[r];
                this.add(i.clone())
            }
        return this
    }
}
Tn.DEFAULT_UP = new J(0, 1, 0);
Tn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Tn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ba = new J,
    ru = new J,
    $M = new J,
    iu = new J,
    Gp = new J,
    Vp = new J,
    i6 = new J,
    GM = new J,
    VM = new J,
    jM = new J;
class Go {
    constructor(e = new J, n = new J, r = new J) {
        this.a = e, this.b = n, this.c = r
    }
    static getNormal(e, n, r, i) {
        i.subVectors(r, n), ba.subVectors(e, n), i.cross(ba);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, n, r, i, s) {
        ba.subVectors(i, n), ru.subVectors(r, n), $M.subVectors(e, n);
        const o = ba.dot(ba),
            a = ba.dot(ru),
            l = ba.dot($M),
            u = ru.dot(ru),
            c = ru.dot($M),
            f = o * u - a * a;
        if (f === 0) return s.set(-2, -1, -1);
        const d = 1 / f,
            p = (u * l - a * c) * d,
            m = (o * c - a * l) * d;
        return s.set(1 - p - m, m, p)
    }
    static containsPoint(e, n, r, i) {
        return this.getBarycoord(e, n, r, i, iu), iu.x >= 0 && iu.y >= 0 && iu.x + iu.y <= 1
    }
    static getUV(e, n, r, i, s, o, a, l) {
        return this.getBarycoord(e, n, r, i, iu), l.set(0, 0), l.addScaledVector(s, iu.x), l.addScaledVector(o, iu.y), l.addScaledVector(a, iu.z), l
    }
    static isFrontFacing(e, n, r, i) {
        return ba.subVectors(r, n), ru.subVectors(e, n), ba.cross(ru).dot(i) < 0
    }
    set(e, n, r) {
        return this.a.copy(e), this.b.copy(n), this.c.copy(r), this
    }
    setFromPointsAndIndices(e, n, r, i) {
        return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[i]), this
    }
    setFromAttributeAndIndices(e, n, r, i) {
        return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
    }
    getArea() {
        return ba.subVectors(this.c, this.b), ru.subVectors(this.a, this.b), ba.cross(ru).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Go.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, n) {
        return Go.getBarycoord(e, this.a, this.b, this.c, n)
    }
    getUV(e, n, r, i, s) {
        return Go.getUV(e, this.a, this.b, this.c, n, r, i, s)
    }
    containsPoint(e) {
        return Go.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Go.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, n) {
        const r = this.a,
            i = this.b,
            s = this.c;
        let o, a;
        Gp.subVectors(i, r), Vp.subVectors(s, r), GM.subVectors(e, r);
        const l = Gp.dot(GM),
            u = Vp.dot(GM);
        if (l <= 0 && u <= 0) return n.copy(r);
        VM.subVectors(e, i);
        const c = Gp.dot(VM),
            f = Vp.dot(VM);
        if (c >= 0 && f <= c) return n.copy(i);
        const d = l * f - c * u;
        if (d <= 0 && l >= 0 && c <= 0) return o = l / (l - c), n.copy(r).addScaledVector(Gp, o);
        jM.subVectors(e, s);
        const p = Gp.dot(jM),
            m = Vp.dot(jM);
        if (m >= 0 && p <= m) return n.copy(s);
        const y = p * u - l * m;
        if (y <= 0 && u >= 0 && m <= 0) return a = u / (u - m), n.copy(r).addScaledVector(Vp, a);
        const v = c * m - p * f;
        if (v <= 0 && f - c >= 0 && p - m >= 0) return i6.subVectors(s, i), a = (f - c) / (f - c + (p - m)), n.copy(i).addScaledVector(i6, a);
        const b = 1 / (v + y + d);
        return o = y * b, a = d * b, n.copy(r).addScaledVector(Gp, o).addScaledVector(Vp, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let Fue = 0;
class li extends Bl {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: Fue++
        }), this.uuid = uo(), this.name = "", this.type = "Material", this.blending = Dd, this.side = Ol, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = sL, this.blendDst = oL, this.blendEquation = ad, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Ow, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = sW, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ES, this.stencilZFail = ES, this.stencilZPass = ES, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const n in e) {
                const r = e[n];
                if (r === void 0) {
                    console.warn("THREE.Material: '" + n + "' parameter is undefined.");
                    continue
                }
                const i = this[n];
                if (i === void 0) {
                    console.warn("THREE." + this.type + ": '" + n + "' is not a property of this material.");
                    continue
                }
                i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[n] = r
            }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        n && (e = {
            textures: {},
            images: {}
        });
        const r = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== Dd && (r.blending = this.blending), this.side !== Ol && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData);

        function i(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata, o.push(l)
            }
            return o
        }
        if (n) {
            const s = i(e.textures),
                o = i(e.images);
            s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o)
        }
        return r
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const n = e.clippingPlanes;
        let r = null;
        if (n !== null) {
            const i = n.length;
            r = new Array(i);
            for (let s = 0; s !== i; ++s) r[s] = n[s].clone()
        }
        return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
const uW = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    xa = {
        h: 0,
        s: 0,
        l: 0
    },
    bx = {
        h: 0,
        s: 0,
        l: 0
    };

function WM(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t
}
class dt {
    constructor(e, n, r) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, n === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, n, r)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this
    }
    setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this
    }
    setHex(e, n = Ea) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ts.toWorkingColorSpace(this, n), this
    }
    setRGB(e, n, r, i = ts.workingColorSpace) {
        return this.r = e, this.g = n, this.b = r, ts.toWorkingColorSpace(this, i), this
    }
    setHSL(e, n, r, i = ts.workingColorSpace) {
        if (e = dL(e, 1), n = Xr(n, 0, 1), r = Xr(r, 0, 1), n === 0) this.r = this.g = this.b = r;
        else {
            const s = r <= .5 ? r * (1 + n) : r + n - r * n,
                o = 2 * r - s;
            this.r = WM(o, s, e + 1 / 3), this.g = WM(o, s, e), this.b = WM(o, s, e - 1 / 3)
        }
        return ts.toWorkingColorSpace(this, i), this
    }
    setStyle(e, n = Ea) {
        function r(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1],
                a = i[2];
            switch (o) {
                case "rgb":
                case "rgba":
                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, ts.toWorkingColorSpace(this, n), r(s[4]), this;
                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, ts.toWorkingColorSpace(this, n), r(s[4]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                        const l = parseFloat(s[1]) / 360,
                            u = parseFloat(s[2]) / 100,
                            c = parseFloat(s[3]) / 100;
                        return r(s[4]), this.setHSL(l, u, c, n)
                    }
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1],
                o = s.length;
            if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, ts.toWorkingColorSpace(this, n), this;
            if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, ts.toWorkingColorSpace(this, n), this;
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0) return this.setColorName(e, n);
        return this
    }
    setColorName(e, n = Ea) {
        const r = uW[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, n) : console.warn("THREE.Color: Unknown color " + e), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this
    }
    copySRGBToLinear(e) {
        return this.r = cm(e.r), this.g = cm(e.g), this.b = cm(e.b), this
    }
    copyLinearToSRGB(e) {
        return this.r = LM(e.r), this.g = LM(e.g), this.b = LM(e.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(e = Ea) {
        return ts.fromWorkingColorSpace(es.copy(this), e), Xr(es.r * 255, 0, 255) << 16 ^ Xr(es.g * 255, 0, 255) << 8 ^ Xr(es.b * 255, 0, 255) << 0
    }
    getHexString(e = Ea) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, n = ts.workingColorSpace) {
        ts.fromWorkingColorSpace(es.copy(this), n);
        const r = es.r,
            i = es.g,
            s = es.b,
            o = Math.max(r, i, s),
            a = Math.min(r, i, s);
        let l, u;
        const c = (a + o) / 2;
        if (a === o) l = 0, u = 0;
        else {
            const f = o - a;
            switch (u = c <= .5 ? f / (o + a) : f / (2 - o - a), o) {
                case r:
                    l = (i - s) / f + (i < s ? 6 : 0);
                    break;
                case i:
                    l = (s - r) / f + 2;
                    break;
                case s:
                    l = (r - i) / f + 4;
                    break
            }
            l /= 6
        }
        return e.h = l, e.s = u, e.l = c, e
    }
    getRGB(e, n = ts.workingColorSpace) {
        return ts.fromWorkingColorSpace(es.copy(this), n), e.r = es.r, e.g = es.g, e.b = es.b, e
    }
    getStyle(e = Ea) {
        ts.fromWorkingColorSpace(es.copy(this), e);
        const n = es.r,
            r = es.g,
            i = es.b;
        return e !== Ea ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${n*255|0},${r*255|0},${i*255|0})`
    }
    offsetHSL(e, n, r) {
        return this.getHSL(xa), xa.h += e, xa.s += n, xa.l += r, this.setHSL(xa.h, xa.s, xa.l), this
    }
    add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this
    }
    addColors(e, n) {
        return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this
    }
    addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
    }
    multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
    }
    multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this
    }
    lerp(e, n) {
        return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this
    }
    lerpColors(e, n, r) {
        return this.r = e.r + (n.r - e.r) * r, this.g = e.g + (n.g - e.g) * r, this.b = e.b + (n.b - e.b) * r, this
    }
    lerpHSL(e, n) {
        this.getHSL(xa), e.getHSL(bx);
        const r = hv(xa.h, bx.h, n),
            i = hv(xa.s, bx.s, n),
            s = hv(xa.l, bx.l, n);
        return this.setHSL(r, i, s), this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, n = 0) {
        return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this
    }
    toArray(e = [], n = 0) {
        return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e
    }
    fromBufferAttribute(e, n) {
        return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this
    }
    toJSON() {
        return this.getHex()
    }*[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
const es = new dt;
dt.NAMES = uW;
class oo extends li {
    constructor(e) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new dt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = u1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
const ti = new J,
    xx = new ke;
class Ln {
    constructor(e, n, r = !1) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = r, this.usage = u0, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e, this
    }
    copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
    }
    copyAt(e, n, r) {
        e *= this.itemSize, r *= n.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = n.array[r + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e), this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let n = 0, r = this.count; n < r; n++) xx.fromBufferAttribute(this, n), xx.applyMatrix3(e), this.setXY(n, xx.x, xx.y);
        else if (this.itemSize === 3)
            for (let n = 0, r = this.count; n < r; n++) ti.fromBufferAttribute(this, n), ti.applyMatrix3(e), this.setXYZ(n, ti.x, ti.y, ti.z);
        return this
    }
    applyMatrix4(e) {
        for (let n = 0, r = this.count; n < r; n++) ti.fromBufferAttribute(this, n), ti.applyMatrix4(e), this.setXYZ(n, ti.x, ti.y, ti.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let n = 0, r = this.count; n < r; n++) ti.fromBufferAttribute(this, n), ti.applyNormalMatrix(e), this.setXYZ(n, ti.x, ti.y, ti.z);
        return this
    }
    transformDirection(e) {
        for (let n = 0, r = this.count; n < r; n++) ti.fromBufferAttribute(this, n), ti.transformDirection(e), this.setXYZ(n, ti.x, ti.y, ti.z);
        return this
    }
    set(e, n = 0) {
        return this.array.set(e, n), this
    }
    getX(e) {
        let n = this.array[e * this.itemSize];
        return this.normalized && (n = _u(n, this.array)), n
    }
    setX(e, n) {
        return this.normalized && (n = er(n, this.array)), this.array[e * this.itemSize] = n, this
    }
    getY(e) {
        let n = this.array[e * this.itemSize + 1];
        return this.normalized && (n = _u(n, this.array)), n
    }
    setY(e, n) {
        return this.normalized && (n = er(n, this.array)), this.array[e * this.itemSize + 1] = n, this
    }
    getZ(e) {
        let n = this.array[e * this.itemSize + 2];
        return this.normalized && (n = _u(n, this.array)), n
    }
    setZ(e, n) {
        return this.normalized && (n = er(n, this.array)), this.array[e * this.itemSize + 2] = n, this
    }
    getW(e) {
        let n = this.array[e * this.itemSize + 3];
        return this.normalized && (n = _u(n, this.array)), n
    }
    setW(e, n) {
        return this.normalized && (n = er(n, this.array)), this.array[e * this.itemSize + 3] = n, this
    }
    setXY(e, n, r) {
        return e *= this.itemSize, this.normalized && (n = er(n, this.array), r = er(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this
    }
    setXYZ(e, n, r, i) {
        return e *= this.itemSize, this.normalized && (n = er(n, this.array), r = er(r, this.array), i = er(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = i, this
    }
    setXYZW(e, n, r, i, s) {
        return e *= this.itemSize, this.normalized && (n = er(n, this.array), r = er(r, this.array), i = er(i, this.array), s = er(s, this.array)), this.array[e + 0] = n, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = s, this
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== u0 && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class Nue extends Ln {
    constructor(e, n, r) {
        super(new Int8Array(e), n, r)
    }
}
class zue extends Ln {
    constructor(e, n, r) {
        super(new Uint8Array(e), n, r)
    }
}
class Hue extends Ln {
    constructor(e, n, r) {
        super(new Uint8ClampedArray(e), n, r)
    }
}
class Uue extends Ln {
    constructor(e, n, r) {
        super(new Int16Array(e), n, r)
    }
}
class mL extends Ln {
    constructor(e, n, r) {
        super(new Uint16Array(e), n, r)
    }
}
class $ue extends Ln {
    constructor(e, n, r) {
        super(new Int32Array(e), n, r)
    }
}
class gL extends Ln {
    constructor(e, n, r) {
        super(new Uint32Array(e), n, r)
    }
}
class Gue extends Ln {
    constructor(e, n, r) {
        super(new Uint16Array(e), n, r), this.isFloat16BufferAttribute = !0
    }
}
class Mt extends Ln {
    constructor(e, n, r) {
        super(new Float32Array(e), n, r)
    }
}
class Vue extends Ln {
    constructor(e, n, r) {
        super(new Float64Array(e), n, r)
    }
}
let jue = 0;
const Po = new Gt,
    KM = new Tn,
    jp = new J,
    Zs = new Xa,
    yy = new Xa,
    wi = new J;
class on extends Bl {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: jue++
        }), this.uuid = uo(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new(lW(e) ? gL : mL)(e, 1) : this.index = e, this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, n) {
        return this.attributes[e] = n, this
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, n, r = 0) {
        this.groups.push({
            start: e,
            count: n,
            materialIndex: r
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, n) {
        this.drawRange.start = e, this.drawRange.count = n
    }
    applyMatrix4(e) {
        const n = this.attributes.position;
        n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
        const r = this.attributes.normal;
        if (r !== void 0) {
            const s = new Hi().getNormalMatrix(e);
            r.applyNormalMatrix(s), r.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(e) {
        return Po.makeRotationFromQuaternion(e), this.applyMatrix4(Po), this
    }
    rotateX(e) {
        return Po.makeRotationX(e), this.applyMatrix4(Po), this
    }
    rotateY(e) {
        return Po.makeRotationY(e), this.applyMatrix4(Po), this
    }
    rotateZ(e) {
        return Po.makeRotationZ(e), this.applyMatrix4(Po), this
    }
    translate(e, n, r) {
        return Po.makeTranslation(e, n, r), this.applyMatrix4(Po), this
    }
    scale(e, n, r) {
        return Po.makeScale(e, n, r), this.applyMatrix4(Po), this
    }
    lookAt(e) {
        return KM.lookAt(e), KM.updateMatrix(), this.applyMatrix4(KM.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(jp).negate(), this.translate(jp.x, jp.y, jp.z), this
    }
    setFromPoints(e) {
        const n = [];
        for (let r = 0, i = e.length; r < i; r++) {
            const s = e[r];
            n.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new Mt(n, 3)), this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Xa);
        const e = this.attributes.position,
            n = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new J(-1 / 0, -1 / 0, -1 / 0), new J(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), n)
                for (let r = 0, i = n.length; r < i; r++) {
                    const s = n[r];
                    Zs.setFromBufferAttribute(s), this.morphTargetsRelative ? (wi.addVectors(this.boundingBox.min, Zs.min), this.boundingBox.expandByPoint(wi), wi.addVectors(this.boundingBox.max, Zs.max), this.boundingBox.expandByPoint(wi)) : (this.boundingBox.expandByPoint(Zs.min), this.boundingBox.expandByPoint(Zs.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Fl);
        const e = this.attributes.position,
            n = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new J, 1 / 0);
            return
        }
        if (e) {
            const r = this.boundingSphere.center;
            if (Zs.setFromBufferAttribute(e), n)
                for (let s = 0, o = n.length; s < o; s++) {
                    const a = n[s];
                    yy.setFromBufferAttribute(a), this.morphTargetsRelative ? (wi.addVectors(Zs.min, yy.min), Zs.expandByPoint(wi), wi.addVectors(Zs.max, yy.max), Zs.expandByPoint(wi)) : (Zs.expandByPoint(yy.min), Zs.expandByPoint(yy.max))
                }
            Zs.getCenter(r);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++) wi.fromBufferAttribute(e, s), i = Math.max(i, r.distanceToSquared(wi));
            if (n)
                for (let s = 0, o = n.length; s < o; s++) {
                    const a = n[s],
                        l = this.morphTargetsRelative;
                    for (let u = 0, c = a.count; u < c; u++) wi.fromBufferAttribute(a, u), l && (jp.fromBufferAttribute(e, u), wi.add(jp)), i = Math.max(i, r.distanceToSquared(wi))
                }
            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index,
            n = this.attributes;
        if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const r = e.array,
            i = n.position.array,
            s = n.normal.array,
            o = n.uv.array,
            a = i.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ln(new Float32Array(4 * a), 4));
        const l = this.getAttribute("tangent").array,
            u = [],
            c = [];
        for (let O = 0; O < a; O++) u[O] = new J, c[O] = new J;
        const f = new J,
            d = new J,
            p = new J,
            m = new ke,
            y = new ke,
            v = new ke,
            b = new J,
            _ = new J;

        function x(O, k, H) {
            f.fromArray(i, O * 3), d.fromArray(i, k * 3), p.fromArray(i, H * 3), m.fromArray(o, O * 2), y.fromArray(o, k * 2), v.fromArray(o, H * 2), d.sub(f), p.sub(f), y.sub(m), v.sub(m);
            const N = 1 / (y.x * v.y - v.x * y.y);
            isFinite(N) && (b.copy(d).multiplyScalar(v.y).addScaledVector(p, -y.y).multiplyScalar(N), _.copy(p).multiplyScalar(y.x).addScaledVector(d, -v.x).multiplyScalar(N), u[O].add(b), u[k].add(b), u[H].add(b), c[O].add(_), c[k].add(_), c[H].add(_))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: r.length
        }]);
        for (let O = 0, k = S.length; O < k; ++O) {
            const H = S[O],
                N = H.start,
                B = H.count;
            for (let U = N, q = N + B; U < q; U += 3) x(r[U + 0], r[U + 1], r[U + 2])
        }
        const E = new J,
            A = new J,
            T = new J,
            M = new J;

        function I(O) {
            T.fromArray(s, O * 3), M.copy(T);
            const k = u[O];
            E.copy(k), E.sub(T.multiplyScalar(T.dot(k))).normalize(), A.crossVectors(M, k);
            const N = A.dot(c[O]) < 0 ? -1 : 1;
            l[O * 4] = E.x, l[O * 4 + 1] = E.y, l[O * 4 + 2] = E.z, l[O * 4 + 3] = N
        }
        for (let O = 0, k = S.length; O < k; ++O) {
            const H = S[O],
                N = H.start,
                B = H.count;
            for (let U = N, q = N + B; U < q; U += 3) I(r[U + 0]), I(r[U + 1]), I(r[U + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index,
            n = this.getAttribute("position");
        if (n !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0) r = new Ln(new Float32Array(n.count * 3), 3), this.setAttribute("normal", r);
            else
                for (let d = 0, p = r.count; d < p; d++) r.setXYZ(d, 0, 0, 0);
            const i = new J,
                s = new J,
                o = new J,
                a = new J,
                l = new J,
                u = new J,
                c = new J,
                f = new J;
            if (e)
                for (let d = 0, p = e.count; d < p; d += 3) {
                    const m = e.getX(d + 0),
                        y = e.getX(d + 1),
                        v = e.getX(d + 2);
                    i.fromBufferAttribute(n, m), s.fromBufferAttribute(n, y), o.fromBufferAttribute(n, v), c.subVectors(o, s), f.subVectors(i, s), c.cross(f), a.fromBufferAttribute(r, m), l.fromBufferAttribute(r, y), u.fromBufferAttribute(r, v), a.add(c), l.add(c), u.add(c), r.setXYZ(m, a.x, a.y, a.z), r.setXYZ(y, l.x, l.y, l.z), r.setXYZ(v, u.x, u.y, u.z)
                } else
                    for (let d = 0, p = n.count; d < p; d += 3) i.fromBufferAttribute(n, d + 0), s.fromBufferAttribute(n, d + 1), o.fromBufferAttribute(n, d + 2), c.subVectors(o, s), f.subVectors(i, s), c.cross(f), r.setXYZ(d + 0, c.x, c.y, c.z), r.setXYZ(d + 1, c.x, c.y, c.z), r.setXYZ(d + 2, c.x, c.y, c.z);
            this.normalizeNormals(), r.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let n = 0, r = e.count; n < r; n++) wi.fromBufferAttribute(e, n), wi.normalize(), e.setXYZ(n, wi.x, wi.y, wi.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const u = a.array,
                c = a.itemSize,
                f = a.normalized,
                d = new u.constructor(l.length * c);
            let p = 0,
                m = 0;
            for (let y = 0, v = l.length; y < v; y++) {
                a.isInterleavedBufferAttribute ? p = l[y] * a.data.stride + a.offset : p = l[y] * c;
                for (let b = 0; b < c; b++) d[m++] = u[p++]
            }
            return new Ln(d, c, f)
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const n = new on,
            r = this.index.array,
            i = this.attributes;
        for (const a in i) {
            const l = i[a],
                u = e(l, r);
            n.setAttribute(a, u)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = [],
                u = s[a];
            for (let c = 0, f = u.length; c < f; c++) {
                const d = u[c],
                    p = e(d, r);
                l.push(p)
            }
            n.morphAttributes[a] = l
        }
        n.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const u = o[a];
            n.addGroup(u.start, u.count, u.materialIndex)
        }
        return n
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const u in l) l[u] !== void 0 && (e[u] = l[u]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const n = this.index;
        n !== null && (e.data.index = {
            type: n.array.constructor.name,
            array: Array.prototype.slice.call(n.array)
        });
        const r = this.attributes;
        for (const l in r) {
            const u = r[l];
            e.data.attributes[l] = u.toJSON(e.data)
        }
        const i = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const u = this.morphAttributes[l],
                c = [];
            for (let f = 0, d = u.length; f < d; f++) {
                const p = u[f];
                c.push(p.toJSON(e.data))
            }
            c.length > 0 && (i[l] = c, s = !0)
        }
        s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const n = {};
        this.name = e.name;
        const r = e.index;
        r !== null && this.setIndex(r.clone(n));
        const i = e.attributes;
        for (const u in i) {
            const c = i[u];
            this.setAttribute(u, c.clone(n))
        }
        const s = e.morphAttributes;
        for (const u in s) {
            const c = [],
                f = s[u];
            for (let d = 0, p = f.length; d < p; d++) c.push(f[d].clone(n));
            this.morphAttributes[u] = c
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let u = 0, c = o.length; u < c; u++) {
            const f = o[u];
            this.addGroup(f.start, f.count, f.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const s6 = new Gt,
    sl = new yg,
    _x = new Fl,
    o6 = new J,
    vy = new J,
    by = new J,
    xy = new J,
    qM = new J,
    Sx = new J,
    wx = new ke,
    Ex = new ke,
    Ax = new ke,
    XM = new J,
    Cx = new J;
class mi extends Tn {
    constructor(e = new on, n = new oo) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes,
            r = Object.keys(n);
        if (r.length > 0) {
            const i = n[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, n) {
        const r = this.geometry,
            i = r.attributes.position,
            s = r.morphAttributes.position,
            o = r.morphTargetsRelative;
        n.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Sx.set(0, 0, 0);
            for (let l = 0, u = s.length; l < u; l++) {
                const c = a[l],
                    f = s[l];
                c !== 0 && (qM.fromBufferAttribute(f, e), o ? Sx.addScaledVector(qM, c) : Sx.addScaledVector(qM.sub(n), c))
            }
            n.add(Sx)
        }
        return this.isSkinnedMesh && this.boneTransform(e, n), n
    }
    raycast(e, n) {
        const r = this.geometry,
            i = this.material,
            s = this.matrixWorld;
        if (i === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(), _x.copy(r.boundingSphere), _x.applyMatrix4(s), sl.copy(e.ray).recast(e.near), _x.containsPoint(sl.origin) === !1 && (sl.intersectSphere(_x, o6) === null || sl.origin.distanceToSquared(o6) > (e.far - e.near) ** 2)) || (s6.copy(s).invert(), sl.copy(e.ray).applyMatrix4(s6), r.boundingBox !== null && sl.intersectsBox(r.boundingBox) === !1)) return;
        let o;
        const a = r.index,
            l = r.attributes.position,
            u = r.attributes.uv,
            c = r.attributes.uv2,
            f = r.groups,
            d = r.drawRange;
        if (a !== null)
            if (Array.isArray(i))
                for (let p = 0, m = f.length; p < m; p++) {
                    const y = f[p],
                        v = i[y.materialIndex],
                        b = Math.max(y.start, d.start),
                        _ = Math.min(a.count, Math.min(y.start + y.count, d.start + d.count));
                    for (let x = b, S = _; x < S; x += 3) {
                        const E = a.getX(x),
                            A = a.getX(x + 1),
                            T = a.getX(x + 2);
                        o = Mx(this, v, e, sl, u, c, E, A, T), o && (o.faceIndex = Math.floor(x / 3), o.face.materialIndex = y.materialIndex, n.push(o))
                    }
                } else {
                    const p = Math.max(0, d.start),
                        m = Math.min(a.count, d.start + d.count);
                    for (let y = p, v = m; y < v; y += 3) {
                        const b = a.getX(y),
                            _ = a.getX(y + 1),
                            x = a.getX(y + 2);
                        o = Mx(this, i, e, sl, u, c, b, _, x), o && (o.faceIndex = Math.floor(y / 3), n.push(o))
                    }
                } else if (l !== void 0)
                    if (Array.isArray(i))
                        for (let p = 0, m = f.length; p < m; p++) {
                            const y = f[p],
                                v = i[y.materialIndex],
                                b = Math.max(y.start, d.start),
                                _ = Math.min(l.count, Math.min(y.start + y.count, d.start + d.count));
                            for (let x = b, S = _; x < S; x += 3) {
                                const E = x,
                                    A = x + 1,
                                    T = x + 2;
                                o = Mx(this, v, e, sl, u, c, E, A, T), o && (o.faceIndex = Math.floor(x / 3), o.face.materialIndex = y.materialIndex, n.push(o))
                            }
                        } else {
                            const p = Math.max(0, d.start),
                                m = Math.min(l.count, d.start + d.count);
                            for (let y = p, v = m; y < v; y += 3) {
                                const b = y,
                                    _ = y + 1,
                                    x = y + 2;
                                o = Mx(this, i, e, sl, u, c, b, _, x), o && (o.faceIndex = Math.floor(y / 3), n.push(o))
                            }
                        }
    }
}

function Wue(t, e, n, r, i, s, o, a) {
    let l;
    if (e.side === Vs ? l = r.intersectTriangle(o, s, i, !0, a) : l = r.intersectTriangle(i, s, o, e.side === Ol, a), l === null) return null;
    Cx.copy(a), Cx.applyMatrix4(t.matrixWorld);
    const u = n.ray.origin.distanceTo(Cx);
    return u < n.near || u > n.far ? null : {
        distance: u,
        point: Cx.clone(),
        object: t
    }
}

function Mx(t, e, n, r, i, s, o, a, l) {
    t.getVertexPosition(o, vy), t.getVertexPosition(a, by), t.getVertexPosition(l, xy);
    const u = Wue(t, e, n, r, vy, by, xy, XM);
    if (u) {
        i && (wx.fromBufferAttribute(i, o), Ex.fromBufferAttribute(i, a), Ax.fromBufferAttribute(i, l), u.uv = Go.getUV(XM, vy, by, xy, wx, Ex, Ax, new ke)), s && (wx.fromBufferAttribute(s, o), Ex.fromBufferAttribute(s, a), Ax.fromBufferAttribute(s, l), u.uv2 = Go.getUV(XM, vy, by, xy, wx, Ex, Ax, new ke));
        const c = {
            a: o,
            b: a,
            c: l,
            normal: new J,
            materialIndex: 0
        };
        Go.getNormal(vy, by, xy, c.normal), u.face = c
    }
    return u
}
class Sf extends on {
    constructor(e = 1, n = 1, r = 1, i = 1, s = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: n,
            depth: r,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
        const l = [],
            u = [],
            c = [],
            f = [];
        let d = 0,
            p = 0;
        m("z", "y", "x", -1, -1, r, n, e, o, s, 0), m("z", "y", "x", 1, -1, r, n, -e, o, s, 1), m("x", "z", "y", 1, 1, e, r, n, i, o, 2), m("x", "z", "y", 1, -1, e, r, -n, i, o, 3), m("x", "y", "z", 1, -1, e, n, r, i, s, 4), m("x", "y", "z", -1, -1, e, n, -r, i, s, 5), this.setIndex(l), this.setAttribute("position", new Mt(u, 3)), this.setAttribute("normal", new Mt(c, 3)), this.setAttribute("uv", new Mt(f, 2));

        function m(y, v, b, _, x, S, E, A, T, M, I) {
            const O = S / T,
                k = E / M,
                H = S / 2,
                N = E / 2,
                B = A / 2,
                U = T + 1,
                q = M + 1;
            let Q = 0,
                F = 0;
            const G = new J;
            for (let W = 0; W < q; W++) {
                const se = W * k - N;
                for (let ee = 0; ee < U; ee++) {
                    const ae = ee * O - H;
                    G[y] = ae * _, G[v] = se * x, G[b] = B, u.push(G.x, G.y, G.z), G[y] = 0, G[v] = 0, G[b] = A > 0 ? 1 : -1, c.push(G.x, G.y, G.z), f.push(ee / T), f.push(1 - W / M), Q += 1
                }
            }
            for (let W = 0; W < M; W++)
                for (let se = 0; se < T; se++) {
                    const ee = d + se + U * W,
                        ae = d + se + U * (W + 1),
                        de = d + (se + 1) + U * (W + 1),
                        re = d + (se + 1) + U * W;
                    l.push(ee, ae, re), l.push(ae, de, re), F += 6
                }
            a.addGroup(p, F, I), p += F, d += Q
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Sf(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
    }
}

function Fm(t) {
    const e = {};
    for (const n in t) {
        e[n] = {};
        for (const r in t[n]) {
            const i = t[n][r];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
        }
    }
    return e
}

function vs(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = Fm(t[n]);
        for (const i in r) e[i] = r[i]
    }
    return e
}

function Kue(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) e.push(t[n].clone());
    return e
}

function cW(t) {
    return t.getRenderTarget() === null && t.outputEncoding === Xn ? Ea : Bm
}
const kw = {
    clone: Fm,
    merge: vs
};
var que = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    Xue = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ra extends li {
    constructor(e) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = que, this.fragmentShader = Xue, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Fm(e.uniforms), this.uniformsGroups = Kue(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        n.glslVersion = this.glslVersion, n.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? n.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? n.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? n.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? n.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? n.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? n.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? n.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : n.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader;
        const r = {};
        for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
        return Object.keys(r).length > 0 && (n.extensions = r), n
    }
}
class f1 extends Tn {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Gt, this.projectionMatrix = new Gt, this.projectionMatrixInverse = new Gt
    }
    copy(e, n) {
        return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const n = this.matrixWorld.elements;
        return e.set(-n[8], -n[9], -n[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, n) {
        super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
let dr = class extends f1 {
    constructor(e = 50, n = 1, r = .1, i = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(e, n) {
        return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
    }
    setFocalLength(e) {
        const n = .5 * this.getFilmHeight() / e;
        this.fov = c0 * 2 * Math.atan(n), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(kd * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return c0 * 2 * Math.atan(Math.tan(kd * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, n, r, i, s, o) {
        this.aspect = e / n, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let n = e * Math.tan(kd * .5 * this.fov) / this.zoom,
            r = 2 * n,
            i = this.aspect * r,
            s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
                u = o.fullHeight;
            s += o.offsetX * i / l, n -= o.offsetY * r / u, i *= o.width / l, r *= o.height / u
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, n, n - r, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n
    }
};
const Wp = -90,
    Kp = 1;
class fW extends Tn {
    constructor(e, n, r) {
        super(), this.type = "CubeCamera", this.renderTarget = r;
        const i = new dr(Wp, Kp, e, n);
        i.layers = this.layers, i.up.set(0, 1, 0), i.lookAt(1, 0, 0), this.add(i);
        const s = new dr(Wp, Kp, e, n);
        s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s);
        const o = new dr(Wp, Kp, e, n);
        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o);
        const a = new dr(Wp, Kp, e, n);
        a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a);
        const l = new dr(Wp, Kp, e, n);
        l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
        const u = new dr(Wp, Kp, e, n);
        u.layers = this.layers, u.up.set(0, 1, 0), u.lookAt(0, 0, -1), this.add(u)
    }
    update(e, n) {
        this.parent === null && this.updateMatrixWorld();
        const r = this.renderTarget,
            [i, s, o, a, l, u] = this.children,
            c = e.getRenderTarget(),
            f = e.toneMapping,
            d = e.xr.enabled;
        e.toneMapping = Na, e.xr.enabled = !1;
        const p = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(n, i), e.setRenderTarget(r, 1), e.render(n, s), e.setRenderTarget(r, 2), e.render(n, o), e.setRenderTarget(r, 3), e.render(n, a), e.setRenderTarget(r, 4), e.render(n, l), r.texture.generateMipmaps = p, e.setRenderTarget(r, 5), e.render(n, u), e.setRenderTarget(c), e.toneMapping = f, e.xr.enabled = d, r.texture.needsPMREMUpdate = !0
    }
}
class d1 extends Sr {
    constructor(e, n, r, i, s, o, a, l, u, c) {
        e = e !== void 0 ? e : [], n = n !== void 0 ? n : lf, super(e, n, r, i, s, o, a, l, u, c), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class dW extends na {
    constructor(e = 1, n = {}) {
        super(e, e, n), this.isWebGLCubeRenderTarget = !0;
        const r = {
                width: e,
                height: e,
                depth: 1
            },
            i = [r, r, r, r, r, r];
        this.texture = new d1(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : fr
    }
    fromEquirectangularTexture(e, n) {
        this.texture.type = n.type, this.texture.encoding = n.encoding, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
        const r = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            },
            i = new Sf(5, 5, 5),
            s = new ra({
                name: "CubemapFromEquirect",
                uniforms: Fm(r.uniforms),
                vertexShader: r.vertexShader,
                fragmentShader: r.fragmentShader,
                side: Vs,
                blending: Mu
            });
        s.uniforms.tEquirect.value = n;
        const o = new mi(i, s),
            a = n.minFilter;
        return n.minFilter === Dl && (n.minFilter = fr), new fW(1, 10, this).update(e, o), n.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }
    clear(e, n, r, i) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(n, r, i);
        e.setRenderTarget(s)
    }
}
const JM = new J,
    Jue = new J,
    Yue = new Hi;
class mu {
    constructor(e = new J(1, 0, 0), n = 0) {
        this.isPlane = !0, this.normal = e, this.constant = n
    }
    set(e, n) {
        return this.normal.copy(e), this.constant = n, this
    }
    setComponents(e, n, r, i) {
        return this.normal.set(e, n, r), this.constant = i, this
    }
    setFromNormalAndCoplanarPoint(e, n) {
        return this.normal.copy(e), this.constant = -n.dot(this.normal), this
    }
    setFromCoplanarPoints(e, n, r) {
        const i = JM.subVectors(r, n).cross(Jue.subVectors(e, n)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e), this
    }
    copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, n) {
        return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, n) {
        const r = e.delta(JM),
            i = this.normal.dot(r);
        if (i === 0) return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : n.copy(e.start).addScaledVector(r, s)
    }
    intersectsLine(e) {
        const n = this.distanceToPoint(e.start),
            r = this.distanceToPoint(e.end);
        return n < 0 && r > 0 || r < 0 && n > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, n) {
        const r = n || Yue.getNormalMatrix(e),
            i = this.coplanarPoint(JM).applyMatrix4(e),
            s = this.normal.applyMatrix3(r).normalize();
        return this.constant = -i.dot(s), this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal), this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const qp = new Fl,
    Tx = new J;
class FE {
    constructor(e = new mu, n = new mu, r = new mu, i = new mu, s = new mu, o = new mu) {
        this.planes = [e, n, r, i, s, o]
    }
    set(e, n, r, i, s, o) {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(n), a[2].copy(r), a[3].copy(i), a[4].copy(s), a[5].copy(o), this
    }
    copy(e) {
        const n = this.planes;
        for (let r = 0; r < 6; r++) n[r].copy(e.planes[r]);
        return this
    }
    setFromProjectionMatrix(e) {
        const n = this.planes,
            r = e.elements,
            i = r[0],
            s = r[1],
            o = r[2],
            a = r[3],
            l = r[4],
            u = r[5],
            c = r[6],
            f = r[7],
            d = r[8],
            p = r[9],
            m = r[10],
            y = r[11],
            v = r[12],
            b = r[13],
            _ = r[14],
            x = r[15];
        return n[0].setComponents(a - i, f - l, y - d, x - v).normalize(), n[1].setComponents(a + i, f + l, y + d, x + v).normalize(), n[2].setComponents(a + s, f + u, y + p, x + b).normalize(), n[3].setComponents(a - s, f - u, y - p, x - b).normalize(), n[4].setComponents(a - o, f - c, y - m, x - _).normalize(), n[5].setComponents(a + o, f + c, y + m, x + _).normalize(), this
    }
    intersectsObject(e) {
        const n = e.geometry;
        return n.boundingSphere === null && n.computeBoundingSphere(), qp.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(qp)
    }
    intersectsSprite(e) {
        return qp.center.set(0, 0, 0), qp.radius = .7071067811865476, qp.applyMatrix4(e.matrixWorld), this.intersectsSphere(qp)
    }
    intersectsSphere(e) {
        const n = this.planes,
            r = e.center,
            i = -e.radius;
        for (let s = 0; s < 6; s++)
            if (n[s].distanceToPoint(r) < i) return !1;
        return !0
    }
    intersectsBox(e) {
        const n = this.planes;
        for (let r = 0; r < 6; r++) {
            const i = n[r];
            if (Tx.x = i.normal.x > 0 ? e.max.x : e.min.x, Tx.y = i.normal.y > 0 ? e.max.y : e.min.y, Tx.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Tx) < 0) return !1
        }
        return !0
    }
    containsPoint(e) {
        const n = this.planes;
        for (let r = 0; r < 6; r++)
            if (n[r].distanceToPoint(e) < 0) return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}

function pW() {
    let t = null,
        e = !1,
        n = null,
        r = null;

    function i(s, o) {
        n(s, o), r = t.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && n !== null && (r = t.requestAnimationFrame(i), e = !0)
        },
        stop: function() {
            t.cancelAnimationFrame(r), e = !1
        },
        setAnimationLoop: function(s) {
            n = s
        },
        setContext: function(s) {
            t = s
        }
    }
}

function Que(t, e) {
    const n = e.isWebGL2,
        r = new WeakMap;

    function i(u, c) {
        const f = u.array,
            d = u.usage,
            p = t.createBuffer();
        t.bindBuffer(c, p), t.bufferData(c, f, d), u.onUploadCallback();
        let m;
        if (f instanceof Float32Array) m = 5126;
        else if (f instanceof Uint16Array)
            if (u.isFloat16BufferAttribute)
                if (n) m = 5131;
                else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        else m = 5123;
        else if (f instanceof Int16Array) m = 5122;
        else if (f instanceof Uint32Array) m = 5125;
        else if (f instanceof Int32Array) m = 5124;
        else if (f instanceof Int8Array) m = 5120;
        else if (f instanceof Uint8Array) m = 5121;
        else if (f instanceof Uint8ClampedArray) m = 5121;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
        return {
            buffer: p,
            type: m,
            bytesPerElement: f.BYTES_PER_ELEMENT,
            version: u.version
        }
    }

    function s(u, c, f) {
        const d = c.array,
            p = c.updateRange;
        t.bindBuffer(f, u), p.count === -1 ? t.bufferSubData(f, 0, d) : (n ? t.bufferSubData(f, p.offset * d.BYTES_PER_ELEMENT, d, p.offset, p.count) : t.bufferSubData(f, p.offset * d.BYTES_PER_ELEMENT, d.subarray(p.offset, p.offset + p.count)), p.count = -1), c.onUploadCallback()
    }

    function o(u) {
        return u.isInterleavedBufferAttribute && (u = u.data), r.get(u)
    }

    function a(u) {
        u.isInterleavedBufferAttribute && (u = u.data);
        const c = r.get(u);
        c && (t.deleteBuffer(c.buffer), r.delete(u))
    }

    function l(u, c) {
        if (u.isGLBufferAttribute) {
            const d = r.get(u);
            (!d || d.version < u.version) && r.set(u, {
                buffer: u.buffer,
                type: u.type,
                bytesPerElement: u.elementSize,
                version: u.version
            });
            return
        }
        u.isInterleavedBufferAttribute && (u = u.data);
        const f = r.get(u);
        f === void 0 ? r.set(u, i(u, c)) : f.version < u.version && (s(f.buffer, u, c), f.version = u.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class vg extends on {
    constructor(e = 1, n = 1, r = 1, i = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: n,
            widthSegments: r,
            heightSegments: i
        };
        const s = e / 2,
            o = n / 2,
            a = Math.floor(r),
            l = Math.floor(i),
            u = a + 1,
            c = l + 1,
            f = e / a,
            d = n / l,
            p = [],
            m = [],
            y = [],
            v = [];
        for (let b = 0; b < c; b++) {
            const _ = b * d - o;
            for (let x = 0; x < u; x++) {
                const S = x * f - s;
                m.push(S, -_, 0), y.push(0, 0, 1), v.push(x / a), v.push(1 - b / l)
            }
        }
        for (let b = 0; b < l; b++)
            for (let _ = 0; _ < a; _++) {
                const x = _ + u * b,
                    S = _ + u * (b + 1),
                    E = _ + 1 + u * (b + 1),
                    A = _ + 1 + u * b;
                p.push(x, S, A), p.push(S, E, A)
            }
        this.setIndex(p), this.setAttribute("position", new Mt(m, 3)), this.setAttribute("normal", new Mt(y, 3)), this.setAttribute("uv", new Mt(v, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new vg(e.width, e.height, e.widthSegments, e.heightSegments)
    }
}
var Zue = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
    ece = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    tce = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
    nce = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    rce = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    ice = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    sce = "vec3 transformed = vec3( position );",
    oce = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    ace = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
    lce = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    uce = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    cce = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
    fce = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    dce = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    pce = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    hce = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    mce = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    gce = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    yce = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    vce = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
    bce = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    xce = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    _ce = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    Sce = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
    wce = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    Ece = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    Ace = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    Cce = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    Mce = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    Tce = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    Pce = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    Ice = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    Rce = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    Oce = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    Dce = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    Lce = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    kce = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    Bce = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    Fce = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    Nce = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    zce = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    Hce = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    Uce = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    $ce = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
    Gce = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    Vce = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    jce = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    Wce = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    Kce = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
    qce = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    Xce = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    Jce = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    Yce = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
    Qce = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    Zce = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    efe = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    tfe = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    nfe = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    rfe = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    ife = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    sfe = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    ofe = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    afe = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    lfe = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    ufe = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    cfe = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    ffe = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    dfe = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
    pfe = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    hfe = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    mfe = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    gfe = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    yfe = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
    vfe = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
    bfe = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
    xfe = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
    _fe = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    Sfe = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    wfe = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
    Efe = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    Afe = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    Cfe = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    Mfe = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    Tfe = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    Pfe = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    Ife = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    Rfe = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    Ofe = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    Dfe = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    Lfe = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    kfe = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
    Bfe = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    Ffe = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    Nfe = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    zfe = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    Hfe = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    Ufe = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    $fe = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
    Gfe = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
    Vfe = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
    jfe = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
    Wfe = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    Kfe = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    qfe = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
    Xfe = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
    Jfe = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Yfe = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    Qfe = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    Zfe = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    ede = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    tde = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    nde = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    rde = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    ide = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    sde = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    ode = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    ade = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    lde = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    ude = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    cde = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    fde = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    dde = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    pde = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    hde = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    mde = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    gde = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    yde = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    vde = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    bde = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    xde = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    _de = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    Sde = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    wde = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Ede = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Ade = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    Cde = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    Mde = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Tde = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    Pde = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    Ide = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    pn = {
        alphamap_fragment: Zue,
        alphamap_pars_fragment: ece,
        alphatest_fragment: tce,
        alphatest_pars_fragment: nce,
        aomap_fragment: rce,
        aomap_pars_fragment: ice,
        begin_vertex: sce,
        beginnormal_vertex: oce,
        bsdfs: ace,
        iridescence_fragment: lce,
        bumpmap_pars_fragment: uce,
        clipping_planes_fragment: cce,
        clipping_planes_pars_fragment: fce,
        clipping_planes_pars_vertex: dce,
        clipping_planes_vertex: pce,
        color_fragment: hce,
        color_pars_fragment: mce,
        color_pars_vertex: gce,
        color_vertex: yce,
        common: vce,
        cube_uv_reflection_fragment: bce,
        defaultnormal_vertex: xce,
        displacementmap_pars_vertex: _ce,
        displacementmap_vertex: Sce,
        emissivemap_fragment: wce,
        emissivemap_pars_fragment: Ece,
        encodings_fragment: Ace,
        encodings_pars_fragment: Cce,
        envmap_fragment: Mce,
        envmap_common_pars_fragment: Tce,
        envmap_pars_fragment: Pce,
        envmap_pars_vertex: Ice,
        envmap_physical_pars_fragment: $ce,
        envmap_vertex: Rce,
        fog_vertex: Oce,
        fog_pars_vertex: Dce,
        fog_fragment: Lce,
        fog_pars_fragment: kce,
        gradientmap_pars_fragment: Bce,
        lightmap_fragment: Fce,
        lightmap_pars_fragment: Nce,
        lights_lambert_fragment: zce,
        lights_lambert_pars_fragment: Hce,
        lights_pars_begin: Uce,
        lights_toon_fragment: Gce,
        lights_toon_pars_fragment: Vce,
        lights_phong_fragment: jce,
        lights_phong_pars_fragment: Wce,
        lights_physical_fragment: Kce,
        lights_physical_pars_fragment: qce,
        lights_fragment_begin: Xce,
        lights_fragment_maps: Jce,
        lights_fragment_end: Yce,
        logdepthbuf_fragment: Qce,
        logdepthbuf_pars_fragment: Zce,
        logdepthbuf_pars_vertex: efe,
        logdepthbuf_vertex: tfe,
        map_fragment: nfe,
        map_pars_fragment: rfe,
        map_particle_fragment: ife,
        map_particle_pars_fragment: sfe,
        metalnessmap_fragment: ofe,
        metalnessmap_pars_fragment: afe,
        morphcolor_vertex: lfe,
        morphnormal_vertex: ufe,
        morphtarget_pars_vertex: cfe,
        morphtarget_vertex: ffe,
        normal_fragment_begin: dfe,
        normal_fragment_maps: pfe,
        normal_pars_fragment: hfe,
        normal_pars_vertex: mfe,
        normal_vertex: gfe,
        normalmap_pars_fragment: yfe,
        clearcoat_normal_fragment_begin: vfe,
        clearcoat_normal_fragment_maps: bfe,
        clearcoat_pars_fragment: xfe,
        iridescence_pars_fragment: _fe,
        output_fragment: Sfe,
        packing: wfe,
        premultiplied_alpha_fragment: Efe,
        project_vertex: Afe,
        dithering_fragment: Cfe,
        dithering_pars_fragment: Mfe,
        roughnessmap_fragment: Tfe,
        roughnessmap_pars_fragment: Pfe,
        shadowmap_pars_fragment: Ife,
        shadowmap_pars_vertex: Rfe,
        shadowmap_vertex: Ofe,
        shadowmask_pars_fragment: Dfe,
        skinbase_vertex: Lfe,
        skinning_pars_vertex: kfe,
        skinning_vertex: Bfe,
        skinnormal_vertex: Ffe,
        specularmap_fragment: Nfe,
        specularmap_pars_fragment: zfe,
        tonemapping_fragment: Hfe,
        tonemapping_pars_fragment: Ufe,
        transmission_fragment: $fe,
        transmission_pars_fragment: Gfe,
        uv_pars_fragment: Vfe,
        uv_pars_vertex: jfe,
        uv_vertex: Wfe,
        uv2_pars_fragment: Kfe,
        uv2_pars_vertex: qfe,
        uv2_vertex: Xfe,
        worldpos_vertex: Jfe,
        background_vert: Yfe,
        background_frag: Qfe,
        backgroundCube_vert: Zfe,
        backgroundCube_frag: ede,
        cube_vert: tde,
        cube_frag: nde,
        depth_vert: rde,
        depth_frag: ide,
        distanceRGBA_vert: sde,
        distanceRGBA_frag: ode,
        equirect_vert: ade,
        equirect_frag: lde,
        linedashed_vert: ude,
        linedashed_frag: cde,
        meshbasic_vert: fde,
        meshbasic_frag: dde,
        meshlambert_vert: pde,
        meshlambert_frag: hde,
        meshmatcap_vert: mde,
        meshmatcap_frag: gde,
        meshnormal_vert: yde,
        meshnormal_frag: vde,
        meshphong_vert: bde,
        meshphong_frag: xde,
        meshphysical_vert: _de,
        meshphysical_frag: Sde,
        meshtoon_vert: wde,
        meshtoon_frag: Ede,
        points_vert: Ade,
        points_frag: Cde,
        shadow_vert: Mde,
        shadow_frag: Tde,
        sprite_vert: Pde,
        sprite_frag: Ide
    },
    ot = {
        common: {
            diffuse: {
                value: new dt(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Hi
            },
            uv2Transform: {
                value: new Hi
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new ke(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new dt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new dt(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Hi
            }
        },
        sprite: {
            diffuse: {
                value: new dt(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new ke(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Hi
            }
        }
    },
    Ma = {
        basic: {
            uniforms: vs([ot.common, ot.specularmap, ot.envmap, ot.aomap, ot.lightmap, ot.fog]),
            vertexShader: pn.meshbasic_vert,
            fragmentShader: pn.meshbasic_frag
        },
        lambert: {
            uniforms: vs([ot.common, ot.specularmap, ot.envmap, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.fog, ot.lights, {
                emissive: {
                    value: new dt(0)
                }
            }]),
            vertexShader: pn.meshlambert_vert,
            fragmentShader: pn.meshlambert_frag
        },
        phong: {
            uniforms: vs([ot.common, ot.specularmap, ot.envmap, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.fog, ot.lights, {
                emissive: {
                    value: new dt(0)
                },
                specular: {
                    value: new dt(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: pn.meshphong_vert,
            fragmentShader: pn.meshphong_frag
        },
        standard: {
            uniforms: vs([ot.common, ot.envmap, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.roughnessmap, ot.metalnessmap, ot.fog, ot.lights, {
                emissive: {
                    value: new dt(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: pn.meshphysical_vert,
            fragmentShader: pn.meshphysical_frag
        },
        toon: {
            uniforms: vs([ot.common, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.gradientmap, ot.fog, ot.lights, {
                emissive: {
                    value: new dt(0)
                }
            }]),
            vertexShader: pn.meshtoon_vert,
            fragmentShader: pn.meshtoon_frag
        },
        matcap: {
            uniforms: vs([ot.common, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: pn.meshmatcap_vert,
            fragmentShader: pn.meshmatcap_frag
        },
        points: {
            uniforms: vs([ot.points, ot.fog]),
            vertexShader: pn.points_vert,
            fragmentShader: pn.points_frag
        },
        dashed: {
            uniforms: vs([ot.common, ot.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: pn.linedashed_vert,
            fragmentShader: pn.linedashed_frag
        },
        depth: {
            uniforms: vs([ot.common, ot.displacementmap]),
            vertexShader: pn.depth_vert,
            fragmentShader: pn.depth_frag
        },
        normal: {
            uniforms: vs([ot.common, ot.bumpmap, ot.normalmap, ot.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: pn.meshnormal_vert,
            fragmentShader: pn.meshnormal_frag
        },
        sprite: {
            uniforms: vs([ot.sprite, ot.fog]),
            vertexShader: pn.sprite_vert,
            fragmentShader: pn.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Hi
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: pn.background_vert,
            fragmentShader: pn.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: pn.backgroundCube_vert,
            fragmentShader: pn.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: pn.cube_vert,
            fragmentShader: pn.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: pn.equirect_vert,
            fragmentShader: pn.equirect_frag
        },
        distanceRGBA: {
            uniforms: vs([ot.common, ot.displacementmap, {
                referencePosition: {
                    value: new J
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: pn.distanceRGBA_vert,
            fragmentShader: pn.distanceRGBA_frag
        },
        shadow: {
            uniforms: vs([ot.lights, ot.fog, {
                color: {
                    value: new dt(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: pn.shadow_vert,
            fragmentShader: pn.shadow_frag
        }
    };
Ma.physical = {
    uniforms: vs([Ma.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new ke(1, 1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new dt(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new ke
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new dt(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new dt(1, 1, 1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: pn.meshphysical_vert,
    fragmentShader: pn.meshphysical_frag
};
const Px = {
    r: 0,
    b: 0,
    g: 0
};

function Rde(t, e, n, r, i, s, o) {
    const a = new dt(0);
    let l = s === !0 ? 0 : 1,
        u, c, f = null,
        d = 0,
        p = null;

    function m(v, b) {
        let _ = !1,
            x = b.isScene === !0 ? b.background : null;
        x && x.isTexture && (x = (b.backgroundBlurriness > 0 ? n : e).get(x));
        const S = t.xr,
            E = S.getSession && S.getSession();
        E && E.environmentBlendMode === "additive" && (x = null), x === null ? y(a, l) : x && x.isColor && (y(x, 1), _ = !0), (t.autoClear || _) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), x && (x.isCubeTexture || x.mapping === gg) ? (c === void 0 && (c = new mi(new Sf(1, 1, 1), new ra({
            name: "BackgroundCubeMaterial",
            uniforms: Fm(Ma.backgroundCube.uniforms),
            vertexShader: Ma.backgroundCube.vertexShader,
            fragmentShader: Ma.backgroundCube.fragmentShader,
            side: Vs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(A, T, M) {
            this.matrixWorld.copyPosition(M.matrixWorld)
        }, Object.defineProperty(c.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }), i.update(c)), c.material.uniforms.envMap.value = x, c.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, c.material.toneMapped = x.encoding !== Xn, (f !== x || d !== x.version || p !== t.toneMapping) && (c.material.needsUpdate = !0, f = x, d = x.version, p = t.toneMapping), c.layers.enableAll(), v.unshift(c, c.geometry, c.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new mi(new vg(2, 2), new ra({
            name: "BackgroundMaterial",
            uniforms: Fm(Ma.background.uniforms),
            vertexShader: Ma.background.vertexShader,
            fragmentShader: Ma.background.fragmentShader,
            side: Ol,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }), i.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, u.material.toneMapped = x.encoding !== Xn, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (f !== x || d !== x.version || p !== t.toneMapping) && (u.material.needsUpdate = !0, f = x, d = x.version, p = t.toneMapping), u.layers.enableAll(), v.unshift(u, u.geometry, u.material, 0, 0, null))
    }

    function y(v, b) {
        v.getRGB(Px, cW(t)), r.buffers.color.setClear(Px.r, Px.g, Px.b, b, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(v, b = 1) {
            a.set(v), l = b, y(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(v) {
            l = v, y(a, l)
        },
        render: m
    }
}

function Ode(t, e, n, r) {
    const i = t.getParameter(34921),
        s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = r.isWebGL2 || s !== null,
        a = {},
        l = v(null);
    let u = l,
        c = !1;

    function f(B, U, q, Q, F) {
        let G = !1;
        if (o) {
            const W = y(Q, q, U);
            u !== W && (u = W, p(u.object)), G = b(B, Q, q, F), G && _(B, Q, q, F)
        } else {
            const W = U.wireframe === !0;
            (u.geometry !== Q.id || u.program !== q.id || u.wireframe !== W) && (u.geometry = Q.id, u.program = q.id, u.wireframe = W, G = !0)
        }
        F !== null && n.update(F, 34963), (G || c) && (c = !1, M(B, U, q, Q), F !== null && t.bindBuffer(34963, n.get(F).buffer))
    }

    function d() {
        return r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
    }

    function p(B) {
        return r.isWebGL2 ? t.bindVertexArray(B) : s.bindVertexArrayOES(B)
    }

    function m(B) {
        return r.isWebGL2 ? t.deleteVertexArray(B) : s.deleteVertexArrayOES(B)
    }

    function y(B, U, q) {
        const Q = q.wireframe === !0;
        let F = a[B.id];
        F === void 0 && (F = {}, a[B.id] = F);
        let G = F[U.id];
        G === void 0 && (G = {}, F[U.id] = G);
        let W = G[Q];
        return W === void 0 && (W = v(d()), G[Q] = W), W
    }

    function v(B) {
        const U = [],
            q = [],
            Q = [];
        for (let F = 0; F < i; F++) U[F] = 0, q[F] = 0, Q[F] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: U,
            enabledAttributes: q,
            attributeDivisors: Q,
            object: B,
            attributes: {},
            index: null
        }
    }

    function b(B, U, q, Q) {
        const F = u.attributes,
            G = U.attributes;
        let W = 0;
        const se = q.getAttributes();
        for (const ee in se)
            if (se[ee].location >= 0) {
                const de = F[ee];
                let re = G[ee];
                if (re === void 0 && (ee === "instanceMatrix" && B.instanceMatrix && (re = B.instanceMatrix), ee === "instanceColor" && B.instanceColor && (re = B.instanceColor)), de === void 0 || de.attribute !== re || re && de.data !== re.data) return !0;
                W++
            }
        return u.attributesNum !== W || u.index !== Q
    }

    function _(B, U, q, Q) {
        const F = {},
            G = U.attributes;
        let W = 0;
        const se = q.getAttributes();
        for (const ee in se)
            if (se[ee].location >= 0) {
                let de = G[ee];
                de === void 0 && (ee === "instanceMatrix" && B.instanceMatrix && (de = B.instanceMatrix), ee === "instanceColor" && B.instanceColor && (de = B.instanceColor));
                const re = {};
                re.attribute = de, de && de.data && (re.data = de.data), F[ee] = re, W++
            }
        u.attributes = F, u.attributesNum = W, u.index = Q
    }

    function x() {
        const B = u.newAttributes;
        for (let U = 0, q = B.length; U < q; U++) B[U] = 0
    }

    function S(B) {
        E(B, 0)
    }

    function E(B, U) {
        const q = u.newAttributes,
            Q = u.enabledAttributes,
            F = u.attributeDivisors;
        q[B] = 1, Q[B] === 0 && (t.enableVertexAttribArray(B), Q[B] = 1), F[B] !== U && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, U), F[B] = U)
    }

    function A() {
        const B = u.newAttributes,
            U = u.enabledAttributes;
        for (let q = 0, Q = U.length; q < Q; q++) U[q] !== B[q] && (t.disableVertexAttribArray(q), U[q] = 0)
    }

    function T(B, U, q, Q, F, G) {
        r.isWebGL2 === !0 && (q === 5124 || q === 5125) ? t.vertexAttribIPointer(B, U, q, F, G) : t.vertexAttribPointer(B, U, q, Q, F, G)
    }

    function M(B, U, q, Q) {
        if (r.isWebGL2 === !1 && (B.isInstancedMesh || Q.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
        x();
        const F = Q.attributes,
            G = q.getAttributes(),
            W = U.defaultAttributeValues;
        for (const se in G) {
            const ee = G[se];
            if (ee.location >= 0) {
                let ae = F[se];
                if (ae === void 0 && (se === "instanceMatrix" && B.instanceMatrix && (ae = B.instanceMatrix), se === "instanceColor" && B.instanceColor && (ae = B.instanceColor)), ae !== void 0) {
                    const de = ae.normalized,
                        re = ae.itemSize,
                        _e = n.get(ae);
                    if (_e === void 0) continue;
                    const fe = _e.buffer,
                        ue = _e.type,
                        ve = _e.bytesPerElement;
                    if (ae.isInterleavedBufferAttribute) {
                        const xe = ae.data,
                            be = xe.stride,
                            he = ae.offset;
                        if (xe.isInstancedInterleavedBuffer) {
                            for (let me = 0; me < ee.locationSize; me++) E(ee.location + me, xe.meshPerAttribute);
                            B.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = xe.meshPerAttribute * xe.count)
                        } else
                            for (let me = 0; me < ee.locationSize; me++) S(ee.location + me);
                        t.bindBuffer(34962, fe);
                        for (let me = 0; me < ee.locationSize; me++) T(ee.location + me, re / ee.locationSize, ue, de, be * ve, (he + re / ee.locationSize * me) * ve)
                    } else {
                        if (ae.isInstancedBufferAttribute) {
                            for (let xe = 0; xe < ee.locationSize; xe++) E(ee.location + xe, ae.meshPerAttribute);
                            B.isInstancedMesh !== !0 && Q._maxInstanceCount === void 0 && (Q._maxInstanceCount = ae.meshPerAttribute * ae.count)
                        } else
                            for (let xe = 0; xe < ee.locationSize; xe++) S(ee.location + xe);
                        t.bindBuffer(34962, fe);
                        for (let xe = 0; xe < ee.locationSize; xe++) T(ee.location + xe, re / ee.locationSize, ue, de, re * ve, re / ee.locationSize * xe * ve)
                    }
                } else if (W !== void 0) {
                    const de = W[se];
                    if (de !== void 0) switch (de.length) {
                        case 2:
                            t.vertexAttrib2fv(ee.location, de);
                            break;
                        case 3:
                            t.vertexAttrib3fv(ee.location, de);
                            break;
                        case 4:
                            t.vertexAttrib4fv(ee.location, de);
                            break;
                        default:
                            t.vertexAttrib1fv(ee.location, de)
                    }
                }
            }
        }
        A()
    }

    function I() {
        H();
        for (const B in a) {
            const U = a[B];
            for (const q in U) {
                const Q = U[q];
                for (const F in Q) m(Q[F].object), delete Q[F];
                delete U[q]
            }
            delete a[B]
        }
    }

    function O(B) {
        if (a[B.id] === void 0) return;
        const U = a[B.id];
        for (const q in U) {
            const Q = U[q];
            for (const F in Q) m(Q[F].object), delete Q[F];
            delete U[q]
        }
        delete a[B.id]
    }

    function k(B) {
        for (const U in a) {
            const q = a[U];
            if (q[B.id] === void 0) continue;
            const Q = q[B.id];
            for (const F in Q) m(Q[F].object), delete Q[F];
            delete q[B.id]
        }
    }

    function H() {
        N(), c = !0, u !== l && (u = l, p(u.object))
    }

    function N() {
        l.geometry = null, l.program = null, l.wireframe = !1
    }
    return {
        setup: f,
        reset: H,
        resetDefaultState: N,
        dispose: I,
        releaseStatesOfGeometry: O,
        releaseStatesOfProgram: k,
        initAttributes: x,
        enableAttribute: S,
        disableUnusedAttributes: A
    }
}

function Dde(t, e, n, r) {
    const i = r.isWebGL2;
    let s;

    function o(u) {
        s = u
    }

    function a(u, c) {
        t.drawArrays(s, u, c), n.update(c, s, 1)
    }

    function l(u, c, f) {
        if (f === 0) return;
        let d, p;
        if (i) d = t, p = "drawArraysInstanced";
        else if (d = e.get("ANGLE_instanced_arrays"), p = "drawArraysInstancedANGLE", d === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        d[p](s, u, c, f), n.update(c, s, f)
    }
    this.setMode = o, this.render = a, this.renderInstances = l
}

function Lde(t, e, n) {
    let r;

    function i() {
        if (r !== void 0) return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const T = e.get("EXT_texture_filter_anisotropic");
            r = t.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else r = 0;
        return r
    }

    function s(T) {
        if (T === "highp") {
            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            T = "mediump"
        }
        return T === "mediump" && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext;
    let a = n.precision !== void 0 ? n.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
    const u = o || e.has("WEBGL_draw_buffers"),
        c = n.logarithmicDepthBuffer === !0,
        f = t.getParameter(34930),
        d = t.getParameter(35660),
        p = t.getParameter(3379),
        m = t.getParameter(34076),
        y = t.getParameter(34921),
        v = t.getParameter(36347),
        b = t.getParameter(36348),
        _ = t.getParameter(36349),
        x = d > 0,
        S = o || e.has("OES_texture_float"),
        E = x && S,
        A = o ? t.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: u,
        getMaxAnisotropy: i,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: c,
        maxTextures: f,
        maxVertexTextures: d,
        maxTextureSize: p,
        maxCubemapSize: m,
        maxAttributes: y,
        maxVertexUniforms: v,
        maxVaryings: b,
        maxFragmentUniforms: _,
        vertexTextures: x,
        floatFragmentTextures: S,
        floatVertexTextures: E,
        maxSamples: A
    }
}

function kde(t) {
    const e = this;
    let n = null,
        r = 0,
        i = !1,
        s = !1;
    const o = new mu,
        a = new Hi,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, d) {
        const p = f.length !== 0 || d || r !== 0 || i;
        return i = d, r = f.length, p
    }, this.beginShadows = function() {
        s = !0, c(null)
    }, this.endShadows = function() {
        s = !1
    }, this.setGlobalState = function(f, d) {
        n = c(f, d, 0)
    }, this.setState = function(f, d, p) {
        const m = f.clippingPlanes,
            y = f.clipIntersection,
            v = f.clipShadows,
            b = t.get(f);
        if (!i || m === null || m.length === 0 || s && !v) s ? c(null) : u();
        else {
            const _ = s ? 0 : r,
                x = _ * 4;
            let S = b.clippingState || null;
            l.value = S, S = c(m, d, x, p);
            for (let E = 0; E !== x; ++E) S[E] = n[E];
            b.clippingState = S, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _
        }
    };

    function u() {
        l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
    }

    function c(f, d, p, m) {
        const y = f !== null ? f.length : 0;
        let v = null;
        if (y !== 0) {
            if (v = l.value, m !== !0 || v === null) {
                const b = p + y * 4,
                    _ = d.matrixWorldInverse;
                a.getNormalMatrix(_), (v === null || v.length < b) && (v = new Float32Array(b));
                for (let x = 0, S = p; x !== y; ++x, S += 4) o.copy(f[x]).applyMatrix4(_, a), o.normal.toArray(v, S), v[S + 3] = o.constant
            }
            l.value = v, l.needsUpdate = !0
        }
        return e.numPlanes = y, e.numIntersection = 0, v
    }
}

function Bde(t) {
    let e = new WeakMap;

    function n(o, a) {
        return a === s0 ? o.mapping = lf : a === o0 && (o.mapping = uf), o
    }

    function r(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === s0 || a === o0)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return n(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const u = new dW(l.height / 2);
                        return u.fromEquirectangularTexture(t, o), e.set(o, u), o.addEventListener("dispose", i), n(u.texture, o.mapping)
                    } else return null
                }
        }
        return o
    }

    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose())
    }

    function s() {
        e = new WeakMap
    }
    return {
        get: r,
        dispose: s
    }
}
class Ko extends f1 {
    constructor(e = -1, n = 1, r = 1, i = -1, s = .1, o = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = r, this.bottom = i, this.near = s, this.far = o, this.updateProjectionMatrix()
    }
    copy(e, n) {
        return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
    }
    setViewOffset(e, n, r, i, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            n = (this.top - this.bottom) / (2 * this.zoom),
            r = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
        let s = r - e,
            o = r + e,
            a = i + n,
            l = i - n;
        if (this.view !== null && this.view.enabled) {
            const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
                c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += u * this.view.offsetX, o = s + u * this.view.width, a -= c * this.view.offsetY, l = a - c * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n
    }
}
const zh = 4,
    a6 = [.125, .215, .35, .446, .526, .582],
    ld = 20,
    YM = new Ko,
    l6 = new dt;
let QM = null;
const rd = (1 + Math.sqrt(5)) / 2,
    Xp = 1 / rd,
    u6 = [new J(1, 1, 1), new J(-1, 1, 1), new J(1, 1, -1), new J(-1, 1, -1), new J(0, rd, Xp), new J(0, rd, -Xp), new J(Xp, 0, rd), new J(-Xp, 0, rd), new J(rd, Xp, 0), new J(-rd, Xp, 0)];
class E3 {
    constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, n = 0, r = .1, i = 100) {
        QM = this._renderer.getRenderTarget(), this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(e, r, i, s), n > 0 && this._blur(s, 0, 0, n), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(e, n = null) {
        return this._fromTexture(e, n)
    }
    fromCubemap(e, n = null) {
        return this._fromTexture(e, n)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = d6(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = f6(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(QM), e.scissorTest = !1, Ix(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, n) {
        e.mapping === lf || e.mapping === uf ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), QM = this._renderer.getRenderTarget();
        const r = n || this._allocateTargets();
        return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            n = 4 * this._cubeSize,
            r = {
                magFilter: fr,
                minFilter: fr,
                generateMipmaps: !1,
                type: Qd,
                format: Ns,
                encoding: Lu,
                depthBuffer: !1
            },
            i = c6(e, n, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = c6(e, n, r);
            const {
                _lodMax: s
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = Fde(s)), this._blurMaterial = Nde(s, e, n)
        }
        return i
    }
    _compileMaterial(e) {
        const n = new mi(this._lodPlanes[0], e);
        this._renderer.compile(n, YM)
    }
    _sceneToCubeUV(e, n, r, i) {
        const a = new dr(90, 1, n, r),
            l = [1, -1, 1, 1, 1, 1],
            u = [1, 1, 1, -1, -1, -1],
            c = this._renderer,
            f = c.autoClear,
            d = c.toneMapping;
        c.getClearColor(l6), c.toneMapping = Na, c.autoClear = !1;
        const p = new oo({
                name: "PMREM.Background",
                side: Vs,
                depthWrite: !1,
                depthTest: !1
            }),
            m = new mi(new Sf, p);
        let y = !1;
        const v = e.background;
        v ? v.isColor && (p.color.copy(v), e.background = null, y = !0) : (p.color.copy(l6), y = !0);
        for (let b = 0; b < 6; b++) {
            const _ = b % 3;
            _ === 0 ? (a.up.set(0, l[b], 0), a.lookAt(u[b], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[b]), a.lookAt(0, u[b], 0)) : (a.up.set(0, l[b], 0), a.lookAt(0, 0, u[b]));
            const x = this._cubeSize;
            Ix(i, _ * x, b > 2 ? x : 0, x, x), c.setRenderTarget(i), y && c.render(m, a), c.render(e, a)
        }
        m.geometry.dispose(), m.material.dispose(), c.toneMapping = d, c.autoClear = f, e.background = v
    }
    _textureToCubeUV(e, n) {
        const r = this._renderer,
            i = e.mapping === lf || e.mapping === uf;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = d6()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = f6());
        const s = i ? this._cubemapMaterial : this._equirectMaterial,
            o = new mi(this._lodPlanes[0], s),
            a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Ix(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(o, YM)
    }
    _applyPMREM(e) {
        const n = this._renderer,
            r = n.autoClear;
        n.autoClear = !1;
        for (let i = 1; i < this._lodPlanes.length; i++) {
            const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]),
                o = u6[(i - 1) % u6.length];
            this._blur(e, i - 1, i, s, o)
        }
        n.autoClear = r
    }
    _blur(e, n, r, i, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, n, r, i, "latitudinal", s), this._halfBlur(o, e, r, r, i, "longitudinal", s)
    }
    _halfBlur(e, n, r, i, s, o, a) {
        const l = this._renderer,
            u = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = 3,
            f = new mi(this._lodPlanes[i], u),
            d = u.uniforms,
            p = this._sizeLods[r] - 1,
            m = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * ld - 1),
            y = s / m,
            v = isFinite(s) ? 1 + Math.floor(c * y) : ld;
        v > ld && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${ld}`);
        const b = [];
        let _ = 0;
        for (let T = 0; T < ld; ++T) {
            const M = T / y,
                I = Math.exp(-M * M / 2);
            b.push(I), T === 0 ? _ += I : T < v && (_ += 2 * I)
        }
        for (let T = 0; T < b.length; T++) b[T] = b[T] / _;
        d.envMap.value = e.texture, d.samples.value = v, d.weights.value = b, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a);
        const {
            _lodMax: x
        } = this;
        d.dTheta.value = m, d.mipInt.value = x - r;
        const S = this._sizeLods[i],
            E = 3 * S * (i > x - zh ? i - x + zh : 0),
            A = 4 * (this._cubeSize - S);
        Ix(n, E, A, 3 * S, 2 * S), l.setRenderTarget(n), l.render(f, YM)
    }
}

function Fde(t) {
    const e = [],
        n = [],
        r = [];
    let i = t;
    const s = t - zh + 1 + a6.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        n.push(a);
        let l = 1 / a;
        o > t - zh ? l = a6[o - t + zh - 1] : o === 0 && (l = 0), r.push(l);
        const u = 1 / (a - 2),
            c = -u,
            f = 1 + u,
            d = [c, c, f, c, f, f, c, c, f, f, c, f],
            p = 6,
            m = 6,
            y = 3,
            v = 2,
            b = 1,
            _ = new Float32Array(y * m * p),
            x = new Float32Array(v * m * p),
            S = new Float32Array(b * m * p);
        for (let A = 0; A < p; A++) {
            const T = A % 3 * 2 / 3 - 1,
                M = A > 2 ? 0 : -1,
                I = [T, M, 0, T + 2 / 3, M, 0, T + 2 / 3, M + 1, 0, T, M, 0, T + 2 / 3, M + 1, 0, T, M + 1, 0];
            _.set(I, y * m * A), x.set(d, v * m * A);
            const O = [A, A, A, A, A, A];
            S.set(O, b * m * A)
        }
        const E = new on;
        E.setAttribute("position", new Ln(_, y)), E.setAttribute("uv", new Ln(x, v)), E.setAttribute("faceIndex", new Ln(S, b)), e.push(E), i > zh && i--
    }
    return {
        lodPlanes: e,
        sizeLods: n,
        sigmas: r
    }
}

function c6(t, e, n) {
    const r = new na(t, e, n);
    return r.texture.mapping = gg, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
}

function Ix(t, e, n, r, i) {
    t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
}

function Nde(t, e, n) {
    const r = new Float32Array(ld),
        i = new J(0, 1, 0);
    return new ra({
        name: "SphericalGaussianBlur",
        defines: {
            n: ld,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / n,
            CUBEUV_MAX_MIP: `${t}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: yL(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Mu,
        depthTest: !1,
        depthWrite: !1
    })
}

function f6() {
    return new ra({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: yL(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Mu,
        depthTest: !1,
        depthWrite: !1
    })
}

function d6() {
    return new ra({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: yL(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Mu,
        depthTest: !1,
        depthWrite: !1
    })
}

function yL() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function zde(t) {
    let e = new WeakMap,
        n = null;

    function r(a) {
        if (a && a.isTexture) {
            const l = a.mapping,
                u = l === s0 || l === o0,
                c = l === lf || l === uf;
            if (u || c)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let f = e.get(a);
                    return n === null && (n = new E3(t)), f = u ? n.fromEquirectangular(a, f) : n.fromCubemap(a, f), e.set(a, f), f.texture
                } else {
                    if (e.has(a)) return e.get(a).texture; {
                        const f = a.image;
                        if (u && f && f.height > 0 || c && f && i(f)) {
                            n === null && (n = new E3(t));
                            const d = u ? n.fromEquirectangular(a) : n.fromCubemap(a);
                            return e.set(a, d), a.addEventListener("dispose", s), d.texture
                        } else return null
                    }
                }
        }
        return a
    }

    function i(a) {
        let l = 0;
        const u = 6;
        for (let c = 0; c < u; c++) a[c] !== void 0 && l++;
        return l === u
    }

    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const u = e.get(l);
        u !== void 0 && (e.delete(l), u.dispose())
    }

    function o() {
        e = new WeakMap, n !== null && (n.dispose(), n = null)
    }
    return {
        get: r,
        dispose: o
    }
}

function Hde(t) {
    const e = {};

    function n(r) {
        if (e[r] !== void 0) return e[r];
        let i;
        switch (r) {
            case "WEBGL_depth_texture":
                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i = t.getExtension(r)
        }
        return e[r] = i, i
    }
    return {
        has: function(r) {
            return n(r) !== null
        },
        init: function(r) {
            r.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
        },
        get: function(r) {
            const i = n(r);
            return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i
        }
    }
}

function Ude(t, e, n, r) {
    const i = {},
        s = new WeakMap;

    function o(f) {
        const d = f.target;
        d.index !== null && e.remove(d.index);
        for (const m in d.attributes) e.remove(d.attributes[m]);
        d.removeEventListener("dispose", o), delete i[d.id];
        const p = s.get(d);
        p && (e.remove(p), s.delete(d)), r.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, n.memory.geometries--
    }

    function a(f, d) {
        return i[d.id] === !0 || (d.addEventListener("dispose", o), i[d.id] = !0, n.memory.geometries++), d
    }

    function l(f) {
        const d = f.attributes;
        for (const m in d) e.update(d[m], 34962);
        const p = f.morphAttributes;
        for (const m in p) {
            const y = p[m];
            for (let v = 0, b = y.length; v < b; v++) e.update(y[v], 34962)
        }
    }

    function u(f) {
        const d = [],
            p = f.index,
            m = f.attributes.position;
        let y = 0;
        if (p !== null) {
            const _ = p.array;
            y = p.version;
            for (let x = 0, S = _.length; x < S; x += 3) {
                const E = _[x + 0],
                    A = _[x + 1],
                    T = _[x + 2];
                d.push(E, A, A, T, T, E)
            }
        } else {
            const _ = m.array;
            y = m.version;
            for (let x = 0, S = _.length / 3 - 1; x < S; x += 3) {
                const E = x + 0,
                    A = x + 1,
                    T = x + 2;
                d.push(E, A, A, T, T, E)
            }
        }
        const v = new(lW(d) ? gL : mL)(d, 1);
        v.version = y;
        const b = s.get(f);
        b && e.remove(b), s.set(f, v)
    }

    function c(f) {
        const d = s.get(f);
        if (d) {
            const p = f.index;
            p !== null && d.version < p.version && u(f)
        } else u(f);
        return s.get(f)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: c
    }
}

function $de(t, e, n, r) {
    const i = r.isWebGL2;
    let s;

    function o(d) {
        s = d
    }
    let a, l;

    function u(d) {
        a = d.type, l = d.bytesPerElement
    }

    function c(d, p) {
        t.drawElements(s, p, a, d * l), n.update(p, s, 1)
    }

    function f(d, p, m) {
        if (m === 0) return;
        let y, v;
        if (i) y = t, v = "drawElementsInstanced";
        else if (y = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", y === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        y[v](s, p, a, d * l, m), n.update(p, s, m)
    }
    this.setMode = o, this.setIndex = u, this.render = c, this.renderInstances = f
}

function Gde(t) {
    const e = {
            geometries: 0,
            textures: 0
        },
        n = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

    function r(s, o, a) {
        switch (n.calls++, o) {
            case 4:
                n.triangles += a * (s / 3);
                break;
            case 1:
                n.lines += a * (s / 2);
                break;
            case 3:
                n.lines += a * (s - 1);
                break;
            case 2:
                n.lines += a * s;
                break;
            case 0:
                n.points += a * s;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break
        }
    }

    function i() {
        n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
    }
    return {
        memory: e,
        render: n,
        programs: null,
        autoReset: !0,
        reset: i,
        update: r
    }
}

function Vde(t, e) {
    return t[0] - e[0]
}

function jde(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1])
}

function Wde(t, e, n) {
    const r = {},
        i = new Float32Array(8),
        s = new WeakMap,
        o = new In,
        a = [];
    for (let u = 0; u < 8; u++) a[u] = [u, 0];

    function l(u, c, f) {
        const d = u.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const p = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                m = p !== void 0 ? p.length : 0;
            let y = s.get(c);
            if (y === void 0 || y.count !== m) {
                let B = function() {
                    H.dispose(), s.delete(c), c.removeEventListener("dispose", B)
                };
                y !== void 0 && y.texture.dispose();
                const _ = c.morphAttributes.position !== void 0,
                    x = c.morphAttributes.normal !== void 0,
                    S = c.morphAttributes.color !== void 0,
                    E = c.morphAttributes.position || [],
                    A = c.morphAttributes.normal || [],
                    T = c.morphAttributes.color || [];
                let M = 0;
                _ === !0 && (M = 1), x === !0 && (M = 2), S === !0 && (M = 3);
                let I = c.attributes.position.count * M,
                    O = 1;
                I > e.maxTextureSize && (O = Math.ceil(I / e.maxTextureSize), I = e.maxTextureSize);
                const k = new Float32Array(I * O * 4 * m),
                    H = new BE(k, I, O, m);
                H.type = xl, H.needsUpdate = !0;
                const N = M * 4;
                for (let U = 0; U < m; U++) {
                    const q = E[U],
                        Q = A[U],
                        F = T[U],
                        G = I * O * 4 * U;
                    for (let W = 0; W < q.count; W++) {
                        const se = W * N;
                        _ === !0 && (o.fromBufferAttribute(q, W), k[G + se + 0] = o.x, k[G + se + 1] = o.y, k[G + se + 2] = o.z, k[G + se + 3] = 0), x === !0 && (o.fromBufferAttribute(Q, W), k[G + se + 4] = o.x, k[G + se + 5] = o.y, k[G + se + 6] = o.z, k[G + se + 7] = 0), S === !0 && (o.fromBufferAttribute(F, W), k[G + se + 8] = o.x, k[G + se + 9] = o.y, k[G + se + 10] = o.z, k[G + se + 11] = F.itemSize === 4 ? o.w : 1)
                    }
                }
                y = {
                    count: m,
                    texture: H,
                    size: new ke(I, O)
                }, s.set(c, y), c.addEventListener("dispose", B)
            }
            let v = 0;
            for (let _ = 0; _ < d.length; _++) v += d[_];
            const b = c.morphTargetsRelative ? 1 : 1 - v;
            f.getUniforms().setValue(t, "morphTargetBaseInfluence", b), f.getUniforms().setValue(t, "morphTargetInfluences", d), f.getUniforms().setValue(t, "morphTargetsTexture", y.texture, n), f.getUniforms().setValue(t, "morphTargetsTextureSize", y.size)
        } else {
            const p = d === void 0 ? 0 : d.length;
            let m = r[c.id];
            if (m === void 0 || m.length !== p) {
                m = [];
                for (let x = 0; x < p; x++) m[x] = [x, 0];
                r[c.id] = m
            }
            for (let x = 0; x < p; x++) {
                const S = m[x];
                S[0] = x, S[1] = d[x]
            }
            m.sort(jde);
            for (let x = 0; x < 8; x++) x < p && m[x][1] ? (a[x][0] = m[x][0], a[x][1] = m[x][1]) : (a[x][0] = Number.MAX_SAFE_INTEGER, a[x][1] = 0);
            a.sort(Vde);
            const y = c.morphAttributes.position,
                v = c.morphAttributes.normal;
            let b = 0;
            for (let x = 0; x < 8; x++) {
                const S = a[x],
                    E = S[0],
                    A = S[1];
                E !== Number.MAX_SAFE_INTEGER && A ? (y && c.getAttribute("morphTarget" + x) !== y[E] && c.setAttribute("morphTarget" + x, y[E]), v && c.getAttribute("morphNormal" + x) !== v[E] && c.setAttribute("morphNormal" + x, v[E]), i[x] = A, b += A) : (y && c.hasAttribute("morphTarget" + x) === !0 && c.deleteAttribute("morphTarget" + x), v && c.hasAttribute("morphNormal" + x) === !0 && c.deleteAttribute("morphNormal" + x), i[x] = 0)
            }
            const _ = c.morphTargetsRelative ? 1 : 1 - b;
            f.getUniforms().setValue(t, "morphTargetBaseInfluence", _), f.getUniforms().setValue(t, "morphTargetInfluences", i)
        }
    }
    return {
        update: l
    }
}

function Kde(t, e, n, r) {
    let i = new WeakMap;

    function s(l) {
        const u = r.render.frame,
            c = l.geometry,
            f = e.get(l, c);
        return i.get(f) !== u && (e.update(f), i.set(f, u)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), n.update(l.instanceMatrix, 34962), l.instanceColor !== null && n.update(l.instanceColor, 34962)), f
    }

    function o() {
        i = new WeakMap
    }

    function a(l) {
        const u = l.target;
        u.removeEventListener("dispose", a), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const hW = new Sr,
    mW = new BE,
    gW = new hL,
    yW = new d1,
    p6 = [],
    h6 = [],
    m6 = new Float32Array(16),
    g6 = new Float32Array(9),
    y6 = new Float32Array(4);

function bg(t, e, n) {
    const r = t[0];
    if (r <= 0 || r > 0) return t;
    const i = e * n;
    let s = p6[i];
    if (s === void 0 && (s = new Float32Array(i), p6[i] = s), e !== 0) {
        r.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o) a += n, t[o].toArray(s, a)
    }
    return s
}

function vi(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, r = t.length; n < r; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}

function bi(t, e) {
    for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
}

function NE(t, e) {
    let n = h6[e];
    n === void 0 && (n = new Int32Array(e), h6[e] = n);
    for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
    return n
}

function qde(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
}

function Xde(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
    else {
        if (vi(n, e)) return;
        t.uniform2fv(this.addr, e), bi(n, e)
    }
}

function Jde(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
    else if (e.r !== void 0)(n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
    else {
        if (vi(n, e)) return;
        t.uniform3fv(this.addr, e), bi(n, e)
    }
}

function Yde(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
    else {
        if (vi(n, e)) return;
        t.uniform4fv(this.addr, e), bi(n, e)
    }
}

function Qde(t, e) {
    const n = this.cache,
        r = e.elements;
    if (r === void 0) {
        if (vi(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), bi(n, e)
    } else {
        if (vi(n, r)) return;
        y6.set(r), t.uniformMatrix2fv(this.addr, !1, y6), bi(n, r)
    }
}

function Zde(t, e) {
    const n = this.cache,
        r = e.elements;
    if (r === void 0) {
        if (vi(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), bi(n, e)
    } else {
        if (vi(n, r)) return;
        g6.set(r), t.uniformMatrix3fv(this.addr, !1, g6), bi(n, r)
    }
}

function epe(t, e) {
    const n = this.cache,
        r = e.elements;
    if (r === void 0) {
        if (vi(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), bi(n, e)
    } else {
        if (vi(n, r)) return;
        m6.set(r), t.uniformMatrix4fv(this.addr, !1, m6), bi(n, r)
    }
}

function tpe(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
}

function npe(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
    else {
        if (vi(n, e)) return;
        t.uniform2iv(this.addr, e), bi(n, e)
    }
}

function rpe(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
    else {
        if (vi(n, e)) return;
        t.uniform3iv(this.addr, e), bi(n, e)
    }
}

function ipe(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
    else {
        if (vi(n, e)) return;
        t.uniform4iv(this.addr, e), bi(n, e)
    }
}

function spe(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
}

function ope(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
    else {
        if (vi(n, e)) return;
        t.uniform2uiv(this.addr, e), bi(n, e)
    }
}

function ape(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
    else {
        if (vi(n, e)) return;
        t.uniform3uiv(this.addr, e), bi(n, e)
    }
}

function lpe(t, e) {
    const n = this.cache;
    if (e.x !== void 0)(n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
    else {
        if (vi(n, e)) return;
        t.uniform4uiv(this.addr, e), bi(n, e)
    }
}

function upe(t, e, n) {
    const r = this.cache,
        i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(e || hW, i)
}

function cpe(t, e, n) {
    const r = this.cache,
        i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || gW, i)
}

function fpe(t, e, n) {
    const r = this.cache,
        i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(e || yW, i)
}

function dpe(t, e, n) {
    const r = this.cache,
        i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || mW, i)
}

function ppe(t) {
    switch (t) {
        case 5126:
            return qde;
        case 35664:
            return Xde;
        case 35665:
            return Jde;
        case 35666:
            return Yde;
        case 35674:
            return Qde;
        case 35675:
            return Zde;
        case 35676:
            return epe;
        case 5124:
        case 35670:
            return tpe;
        case 35667:
        case 35671:
            return npe;
        case 35668:
        case 35672:
            return rpe;
        case 35669:
        case 35673:
            return ipe;
        case 5125:
            return spe;
        case 36294:
            return ope;
        case 36295:
            return ape;
        case 36296:
            return lpe;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return upe;
        case 35679:
        case 36299:
        case 36307:
            return cpe;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return fpe;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return dpe
    }
}

function hpe(t, e) {
    t.uniform1fv(this.addr, e)
}

function mpe(t, e) {
    const n = bg(e, this.size, 2);
    t.uniform2fv(this.addr, n)
}

function gpe(t, e) {
    const n = bg(e, this.size, 3);
    t.uniform3fv(this.addr, n)
}

function ype(t, e) {
    const n = bg(e, this.size, 4);
    t.uniform4fv(this.addr, n)
}

function vpe(t, e) {
    const n = bg(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n)
}

function bpe(t, e) {
    const n = bg(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n)
}

function xpe(t, e) {
    const n = bg(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n)
}

function _pe(t, e) {
    t.uniform1iv(this.addr, e)
}

function Spe(t, e) {
    t.uniform2iv(this.addr, e)
}

function wpe(t, e) {
    t.uniform3iv(this.addr, e)
}

function Epe(t, e) {
    t.uniform4iv(this.addr, e)
}

function Ape(t, e) {
    t.uniform1uiv(this.addr, e)
}

function Cpe(t, e) {
    t.uniform2uiv(this.addr, e)
}

function Mpe(t, e) {
    t.uniform3uiv(this.addr, e)
}

function Tpe(t, e) {
    t.uniform4uiv(this.addr, e)
}

function Ppe(t, e, n) {
    const r = this.cache,
        i = e.length,
        s = NE(n, i);
    vi(r, s) || (t.uniform1iv(this.addr, s), bi(r, s));
    for (let o = 0; o !== i; ++o) n.setTexture2D(e[o] || hW, s[o])
}

function Ipe(t, e, n) {
    const r = this.cache,
        i = e.length,
        s = NE(n, i);
    vi(r, s) || (t.uniform1iv(this.addr, s), bi(r, s));
    for (let o = 0; o !== i; ++o) n.setTexture3D(e[o] || gW, s[o])
}

function Rpe(t, e, n) {
    const r = this.cache,
        i = e.length,
        s = NE(n, i);
    vi(r, s) || (t.uniform1iv(this.addr, s), bi(r, s));
    for (let o = 0; o !== i; ++o) n.setTextureCube(e[o] || yW, s[o])
}

function Ope(t, e, n) {
    const r = this.cache,
        i = e.length,
        s = NE(n, i);
    vi(r, s) || (t.uniform1iv(this.addr, s), bi(r, s));
    for (let o = 0; o !== i; ++o) n.setTexture2DArray(e[o] || mW, s[o])
}

function Dpe(t) {
    switch (t) {
        case 5126:
            return hpe;
        case 35664:
            return mpe;
        case 35665:
            return gpe;
        case 35666:
            return ype;
        case 35674:
            return vpe;
        case 35675:
            return bpe;
        case 35676:
            return xpe;
        case 5124:
        case 35670:
            return _pe;
        case 35667:
        case 35671:
            return Spe;
        case 35668:
        case 35672:
            return wpe;
        case 35669:
        case 35673:
            return Epe;
        case 5125:
            return Ape;
        case 36294:
            return Cpe;
        case 36295:
            return Mpe;
        case 36296:
            return Tpe;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return Ppe;
        case 35679:
        case 36299:
        case 36307:
            return Ipe;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return Rpe;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return Ope
    }
}
class Lpe {
    constructor(e, n, r) {
        this.id = e, this.addr = r, this.cache = [], this.setValue = ppe(n.type)
    }
}
class kpe {
    constructor(e, n, r) {
        this.id = e, this.addr = r, this.cache = [], this.size = n.size, this.setValue = Dpe(n.type)
    }
}
class Bpe {
    constructor(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    setValue(e, n, r) {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, n[a.id], r)
        }
    }
}
const ZM = /(\w+)(\])?(\[|\.)?/g;

function v6(t, e) {
    t.seq.push(e), t.map[e.id] = e
}

function Fpe(t, e, n) {
    const r = t.name,
        i = r.length;
    for (ZM.lastIndex = 0;;) {
        const s = ZM.exec(r),
            o = ZM.lastIndex;
        let a = s[1];
        const l = s[2] === "]",
            u = s[3];
        if (l && (a = a | 0), u === void 0 || u === "[" && o + 2 === i) {
            v6(n, u === void 0 ? new Lpe(a, t, e) : new kpe(a, t, e));
            break
        } else {
            let f = n.map[a];
            f === void 0 && (f = new Bpe(a), v6(n, f)), n = f
        }
    }
}
class AS {
    constructor(e, n) {
        this.seq = [], this.map = {};
        const r = e.getProgramParameter(n, 35718);
        for (let i = 0; i < r; ++i) {
            const s = e.getActiveUniform(n, i),
                o = e.getUniformLocation(n, s.name);
            Fpe(s, o, this)
        }
    }
    setValue(e, n, r, i) {
        const s = this.map[n];
        s !== void 0 && s.setValue(e, r, i)
    }
    setOptional(e, n, r) {
        const i = n[r];
        i !== void 0 && this.setValue(e, r, i)
    }
    static upload(e, n, r, i) {
        for (let s = 0, o = n.length; s !== o; ++s) {
            const a = n[s],
                l = r[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
        }
    }
    static seqWithValue(e, n) {
        const r = [];
        for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in n && r.push(o)
        }
        return r
    }
}

function b6(t, e, n) {
    const r = t.createShader(e);
    return t.shaderSource(r, n), t.compileShader(r), r
}
let Npe = 0;

function zpe(t, e) {
    const n = t.split(`
`),
        r = [],
        i = Math.max(e - 6, 0),
        s = Math.min(e + 6, n.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        r.push(`${a===e?">":" "} ${a}: ${n[o]}`)
    }
    return r.join(`
`)
}

function Hpe(t) {
    switch (t) {
        case Lu:
            return ["Linear", "( value )"];
        case Xn:
            return ["sRGB", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
    }
}

function x6(t, e, n) {
    const r = t.getShaderParameter(e, 35713),
        i = t.getShaderInfoLog(e).trim();
    if (r && i === "") return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return n.toUpperCase() + `

` + i + `

` + zpe(t.getShaderSource(e), o)
    } else return i
}

function Upe(t, e) {
    const n = Hpe(e);
    return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
}

function $pe(t, e) {
    let n;
    switch (e) {
        case Dj:
            n = "Linear";
            break;
        case Lj:
            n = "Reinhard";
            break;
        case kj:
            n = "OptimizedCineon";
            break;
        case aL:
            n = "ACESFilmic";
            break;
        case Bj:
            n = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
    }
    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}

function Gpe(t) {
    return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || t.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Xy).join(`
`)
}

function Vpe(t) {
    const e = [];
    for (const n in t) {
        const r = t[n];
        r !== !1 && e.push("#define " + n + " " + r)
    }
    return e.join(`
`)
}

function jpe(t, e) {
    const n = {},
        r = t.getProgramParameter(e, 35721);
    for (let i = 0; i < r; i++) {
        const s = t.getActiveAttrib(e, i),
            o = s.name;
        let a = 1;
        s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), n[o] = {
            type: s.type,
            location: t.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return n
}

function Xy(t) {
    return t !== ""
}

function _6(t, e) {
    const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function S6(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Wpe = /^[ \t]*#include +<([\w\d./]+)>/gm;

function A3(t) {
    return t.replace(Wpe, Kpe)
}

function Kpe(t, e) {
    const n = pn[e];
    if (n === void 0) throw new Error("Can not resolve #include <" + e + ">");
    return A3(n)
}
const qpe = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function w6(t) {
    return t.replace(qpe, Xpe)
}

function Xpe(t, e, n, r) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(n); s++) i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}

function E6(t) {
    let e = "precision " + t.precision + ` float;
precision ` + t.precision + " int;";
    return t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function Jpe(t) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return t.shadowMapType === OE ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === pv ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === gd && (e = "SHADOWMAP_TYPE_VSM"), e
}

function Ype(t) {
    let e = "ENVMAP_TYPE_CUBE";
    if (t.envMap) switch (t.envMapMode) {
        case lf:
        case uf:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case gg:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
    }
    return e
}

function Qpe(t) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (t.envMap) switch (t.envMapMode) {
        case uf:
            e = "ENVMAP_MODE_REFRACTION";
            break
    }
    return e
}

function Zpe(t) {
    let e = "ENVMAP_BLENDING_NONE";
    if (t.envMap) switch (t.combine) {
        case u1:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case Rj:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case Oj:
            e = "ENVMAP_BLENDING_ADD";
            break
    }
    return e
}

function ehe(t) {
    const e = t.envMapCubeUVHeight;
    if (e === null) return null;
    const n = Math.log2(e) - 2,
        r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
        texelHeight: r,
        maxMip: n
    }
}

function the(t, e, n, r) {
    const i = t.getContext(),
        s = n.defines;
    let o = n.vertexShader,
        a = n.fragmentShader;
    const l = Jpe(n),
        u = Ype(n),
        c = Qpe(n),
        f = Zpe(n),
        d = ehe(n),
        p = n.isWebGL2 ? "" : Gpe(n),
        m = Vpe(s),
        y = i.createProgram();
    let v, b, _ = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
    n.isRawShaderMaterial ? (v = [m].filter(Xy).join(`
`), v.length > 0 && (v += `
`), b = [p, m].filter(Xy).join(`
`), b.length > 0 && (b += `
`)) : (v = [E6(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Xy).join(`
`), b = [p, E6(n), "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + f : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Na ? "#define TONE_MAPPING" : "", n.toneMapping !== Na ? pn.tonemapping_pars_fragment : "", n.toneMapping !== Na ? $pe("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", pn.encodings_pars_fragment, Upe("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(Xy).join(`
`)), o = A3(o), o = _6(o, n), o = S6(o, n), a = A3(a), a = _6(a, n), a = S6(a, n), o = w6(o), a = w6(a), n.isWebGL2 && n.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + v, b = ["#define varying in", n.glslVersion === S3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === S3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + b);
    const x = _ + v + o,
        S = _ + b + a,
        E = b6(i, 35633, x),
        A = b6(i, 35632, S);
    if (i.attachShader(y, E), i.attachShader(y, A), n.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, n.index0AttributeName) : n.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y), t.debug.checkShaderErrors) {
        const I = i.getProgramInfoLog(y).trim(),
            O = i.getShaderInfoLog(E).trim(),
            k = i.getShaderInfoLog(A).trim();
        let H = !0,
            N = !0;
        if (i.getProgramParameter(y, 35714) === !1) {
            H = !1;
            const B = x6(i, E, "vertex"),
                U = x6(i, A, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, 35715) + `

Program Info Log: ` + I + `
` + B + `
` + U)
        } else I !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", I) : (O === "" || k === "") && (N = !1);
        N && (this.diagnostics = {
            runnable: H,
            programLog: I,
            vertexShader: {
                log: O,
                prefix: v
            },
            fragmentShader: {
                log: k,
                prefix: b
            }
        })
    }
    i.deleteShader(E), i.deleteShader(A);
    let T;
    this.getUniforms = function() {
        return T === void 0 && (T = new AS(i, y)), T
    };
    let M;
    return this.getAttributes = function() {
        return M === void 0 && (M = jpe(i, y)), M
    }, this.destroy = function() {
        r.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0
    }, this.name = n.shaderName, this.id = Npe++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = E, this.fragmentShader = A, this
}
let nhe = 0;
class rhe {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(e) {
        const n = e.vertexShader,
            r = e.fragmentShader,
            i = this._getShaderStage(n),
            s = this._getShaderStage(r),
            o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
    }
    remove(e) {
        const n = this.materialCache.get(e);
        for (const r of n) r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e), this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const n = this.materialCache;
        let r = n.get(e);
        return r === void 0 && (r = new Set, n.set(e, r)), r
    }
    _getShaderStage(e) {
        const n = this.shaderCache;
        let r = n.get(e);
        return r === void 0 && (r = new ihe(e), n.set(e, r)), r
    }
}
class ihe {
    constructor(e) {
        this.id = nhe++, this.code = e, this.usedTimes = 0
    }
}

function she(t, e, n, r, i, s, o) {
    const a = new Bd,
        l = new rhe,
        u = [],
        c = i.isWebGL2,
        f = i.logarithmicDepthBuffer,
        d = i.vertexTextures;
    let p = i.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function y(M, I, O, k, H) {
        const N = k.fog,
            B = H.geometry,
            U = M.isMeshStandardMaterial ? k.environment : null,
            q = (M.isMeshStandardMaterial ? n : e).get(M.envMap || U),
            Q = q && q.mapping === gg ? q.image.height : null,
            F = m[M.type];
        M.precision !== null && (p = i.getMaxPrecision(M.precision), p !== M.precision && console.warn("THREE.WebGLProgram.getParameters:", M.precision, "not supported, using", p, "instead."));
        const G = B.morphAttributes.position || B.morphAttributes.normal || B.morphAttributes.color,
            W = G !== void 0 ? G.length : 0;
        let se = 0;
        B.morphAttributes.position !== void 0 && (se = 1), B.morphAttributes.normal !== void 0 && (se = 2), B.morphAttributes.color !== void 0 && (se = 3);
        let ee, ae, de, re;
        if (F) {
            const be = Ma[F];
            ee = be.vertexShader, ae = be.fragmentShader
        } else ee = M.vertexShader, ae = M.fragmentShader, l.update(M), de = l.getVertexShaderID(M), re = l.getFragmentShaderID(M);
        const _e = t.getRenderTarget(),
            fe = M.alphaTest > 0,
            ue = M.clearcoat > 0,
            ve = M.iridescence > 0;
        return {
            isWebGL2: c,
            shaderID: F,
            shaderName: M.type,
            vertexShader: ee,
            fragmentShader: ae,
            defines: M.defines,
            customVertexShaderID: de,
            customFragmentShaderID: re,
            isRawShaderMaterial: M.isRawShaderMaterial === !0,
            glslVersion: M.glslVersion,
            precision: p,
            instancing: H.isInstancedMesh === !0,
            instancingColor: H.isInstancedMesh === !0 && H.instanceColor !== null,
            supportsVertexTextures: d,
            outputEncoding: _e === null ? t.outputEncoding : _e.isXRRenderTarget === !0 ? _e.texture.encoding : Lu,
            map: !!M.map,
            matcap: !!M.matcap,
            envMap: !!q,
            envMapMode: q && q.mapping,
            envMapCubeUVHeight: Q,
            lightMap: !!M.lightMap,
            aoMap: !!M.aoMap,
            emissiveMap: !!M.emissiveMap,
            bumpMap: !!M.bumpMap,
            normalMap: !!M.normalMap,
            objectSpaceNormalMap: M.normalMapType === iW,
            tangentSpaceNormalMap: M.normalMapType === _f,
            decodeVideoTexture: !!M.map && M.map.isVideoTexture === !0 && M.map.encoding === Xn,
            clearcoat: ue,
            clearcoatMap: ue && !!M.clearcoatMap,
            clearcoatRoughnessMap: ue && !!M.clearcoatRoughnessMap,
            clearcoatNormalMap: ue && !!M.clearcoatNormalMap,
            iridescence: ve,
            iridescenceMap: ve && !!M.iridescenceMap,
            iridescenceThicknessMap: ve && !!M.iridescenceThicknessMap,
            displacementMap: !!M.displacementMap,
            roughnessMap: !!M.roughnessMap,
            metalnessMap: !!M.metalnessMap,
            specularMap: !!M.specularMap,
            specularIntensityMap: !!M.specularIntensityMap,
            specularColorMap: !!M.specularColorMap,
            opaque: M.transparent === !1 && M.blending === Dd,
            alphaMap: !!M.alphaMap,
            alphaTest: fe,
            gradientMap: !!M.gradientMap,
            sheen: M.sheen > 0,
            sheenColorMap: !!M.sheenColorMap,
            sheenRoughnessMap: !!M.sheenRoughnessMap,
            transmission: M.transmission > 0,
            transmissionMap: !!M.transmissionMap,
            thicknessMap: !!M.thicknessMap,
            combine: M.combine,
            vertexTangents: !!M.normalMap && !!B.attributes.tangent,
            vertexColors: M.vertexColors,
            vertexAlphas: M.vertexColors === !0 && !!B.attributes.color && B.attributes.color.itemSize === 4,
            vertexUvs: !!M.map || !!M.bumpMap || !!M.normalMap || !!M.specularMap || !!M.alphaMap || !!M.emissiveMap || !!M.roughnessMap || !!M.metalnessMap || !!M.clearcoatMap || !!M.clearcoatRoughnessMap || !!M.clearcoatNormalMap || !!M.iridescenceMap || !!M.iridescenceThicknessMap || !!M.displacementMap || !!M.transmissionMap || !!M.thicknessMap || !!M.specularIntensityMap || !!M.specularColorMap || !!M.sheenColorMap || !!M.sheenRoughnessMap,
            uvsVertexOnly: !(M.map || M.bumpMap || M.normalMap || M.specularMap || M.alphaMap || M.emissiveMap || M.roughnessMap || M.metalnessMap || M.clearcoatNormalMap || M.iridescenceMap || M.iridescenceThicknessMap || M.transmission > 0 || M.transmissionMap || M.thicknessMap || M.specularIntensityMap || M.specularColorMap || M.sheen > 0 || M.sheenColorMap || M.sheenRoughnessMap) && !!M.displacementMap,
            fog: !!N,
            useFog: M.fog === !0,
            fogExp2: N && N.isFogExp2,
            flatShading: !!M.flatShading,
            sizeAttenuation: M.sizeAttenuation,
            logarithmicDepthBuffer: f,
            skinning: H.isSkinnedMesh === !0,
            morphTargets: B.morphAttributes.position !== void 0,
            morphNormals: B.morphAttributes.normal !== void 0,
            morphColors: B.morphAttributes.color !== void 0,
            morphTargetsCount: W,
            morphTextureStride: se,
            numDirLights: I.directional.length,
            numPointLights: I.point.length,
            numSpotLights: I.spot.length,
            numSpotLightMaps: I.spotLightMap.length,
            numRectAreaLights: I.rectArea.length,
            numHemiLights: I.hemi.length,
            numDirLightShadows: I.directionalShadowMap.length,
            numPointLightShadows: I.pointShadowMap.length,
            numSpotLightShadows: I.spotShadowMap.length,
            numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: M.dithering,
            shadowMapEnabled: t.shadowMap.enabled && O.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: M.toneMapped ? t.toneMapping : Na,
            useLegacyLights: t.useLegacyLights,
            premultipliedAlpha: M.premultipliedAlpha,
            doubleSided: M.side === Ra,
            flipSided: M.side === Vs,
            useDepthPacking: !!M.depthPacking,
            depthPacking: M.depthPacking || 0,
            index0AttributeName: M.index0AttributeName,
            extensionDerivatives: M.extensions && M.extensions.derivatives,
            extensionFragDepth: M.extensions && M.extensions.fragDepth,
            extensionDrawBuffers: M.extensions && M.extensions.drawBuffers,
            extensionShaderTextureLOD: M.extensions && M.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: c || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: c || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: M.customProgramCacheKey()
        }
    }

    function v(M) {
        const I = [];
        if (M.shaderID ? I.push(M.shaderID) : (I.push(M.customVertexShaderID), I.push(M.customFragmentShaderID)), M.defines !== void 0)
            for (const O in M.defines) I.push(O), I.push(M.defines[O]);
        return M.isRawShaderMaterial === !1 && (b(I, M), _(I, M), I.push(t.outputEncoding)), I.push(M.customProgramCacheKey), I.join()
    }

    function b(M, I) {
        M.push(I.precision), M.push(I.outputEncoding), M.push(I.envMapMode), M.push(I.envMapCubeUVHeight), M.push(I.combine), M.push(I.vertexUvs), M.push(I.fogExp2), M.push(I.sizeAttenuation), M.push(I.morphTargetsCount), M.push(I.morphAttributeCount), M.push(I.numDirLights), M.push(I.numPointLights), M.push(I.numSpotLights), M.push(I.numSpotLightMaps), M.push(I.numHemiLights), M.push(I.numRectAreaLights), M.push(I.numDirLightShadows), M.push(I.numPointLightShadows), M.push(I.numSpotLightShadows), M.push(I.numSpotLightShadowsWithMaps), M.push(I.shadowMapType), M.push(I.toneMapping), M.push(I.numClippingPlanes), M.push(I.numClipIntersection), M.push(I.depthPacking)
    }

    function _(M, I) {
        a.disableAll(), I.isWebGL2 && a.enable(0), I.supportsVertexTextures && a.enable(1), I.instancing && a.enable(2), I.instancingColor && a.enable(3), I.map && a.enable(4), I.matcap && a.enable(5), I.envMap && a.enable(6), I.lightMap && a.enable(7), I.aoMap && a.enable(8), I.emissiveMap && a.enable(9), I.bumpMap && a.enable(10), I.normalMap && a.enable(11), I.objectSpaceNormalMap && a.enable(12), I.tangentSpaceNormalMap && a.enable(13), I.clearcoat && a.enable(14), I.clearcoatMap && a.enable(15), I.clearcoatRoughnessMap && a.enable(16), I.clearcoatNormalMap && a.enable(17), I.iridescence && a.enable(18), I.iridescenceMap && a.enable(19), I.iridescenceThicknessMap && a.enable(20), I.displacementMap && a.enable(21), I.specularMap && a.enable(22), I.roughnessMap && a.enable(23), I.metalnessMap && a.enable(24), I.gradientMap && a.enable(25), I.alphaMap && a.enable(26), I.alphaTest && a.enable(27), I.vertexColors && a.enable(28), I.vertexAlphas && a.enable(29), I.vertexUvs && a.enable(30), I.vertexTangents && a.enable(31), I.uvsVertexOnly && a.enable(32), M.push(a.mask), a.disableAll(), I.fog && a.enable(0), I.useFog && a.enable(1), I.flatShading && a.enable(2), I.logarithmicDepthBuffer && a.enable(3), I.skinning && a.enable(4), I.morphTargets && a.enable(5), I.morphNormals && a.enable(6), I.morphColors && a.enable(7), I.premultipliedAlpha && a.enable(8), I.shadowMapEnabled && a.enable(9), I.useLegacyLights && a.enable(10), I.doubleSided && a.enable(11), I.flipSided && a.enable(12), I.useDepthPacking && a.enable(13), I.dithering && a.enable(14), I.specularIntensityMap && a.enable(15), I.specularColorMap && a.enable(16), I.transmission && a.enable(17), I.transmissionMap && a.enable(18), I.thicknessMap && a.enable(19), I.sheen && a.enable(20), I.sheenColorMap && a.enable(21), I.sheenRoughnessMap && a.enable(22), I.decodeVideoTexture && a.enable(23), I.opaque && a.enable(24), M.push(a.mask)
    }

    function x(M) {
        const I = m[M.type];
        let O;
        if (I) {
            const k = Ma[I];
            O = kw.clone(k.uniforms)
        } else O = M.uniforms;
        return O
    }

    function S(M, I) {
        let O;
        for (let k = 0, H = u.length; k < H; k++) {
            const N = u[k];
            if (N.cacheKey === I) {
                O = N, ++O.usedTimes;
                break
            }
        }
        return O === void 0 && (O = new the(t, I, M, s), u.push(O)), O
    }

    function E(M) {
        if (--M.usedTimes === 0) {
            const I = u.indexOf(M);
            u[I] = u[u.length - 1], u.pop(), M.destroy()
        }
    }

    function A(M) {
        l.remove(M)
    }

    function T() {
        l.dispose()
    }
    return {
        getParameters: y,
        getProgramCacheKey: v,
        getUniforms: x,
        acquireProgram: S,
        releaseProgram: E,
        releaseShaderCache: A,
        programs: u,
        dispose: T
    }
}

function ohe() {
    let t = new WeakMap;

    function e(s) {
        let o = t.get(s);
        return o === void 0 && (o = {}, t.set(s, o)), o
    }

    function n(s) {
        t.delete(s)
    }

    function r(s, o, a) {
        t.get(s)[o] = a
    }

    function i() {
        t = new WeakMap
    }
    return {
        get: e,
        remove: n,
        update: r,
        dispose: i
    }
}

function ahe(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
}

function A6(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
}

function C6() {
    const t = [];
    let e = 0;
    const n = [],
        r = [],
        i = [];

    function s() {
        e = 0, n.length = 0, r.length = 0, i.length = 0
    }

    function o(f, d, p, m, y, v) {
        let b = t[e];
        return b === void 0 ? (b = {
            id: f.id,
            object: f,
            geometry: d,
            material: p,
            groupOrder: m,
            renderOrder: f.renderOrder,
            z: y,
            group: v
        }, t[e] = b) : (b.id = f.id, b.object = f, b.geometry = d, b.material = p, b.groupOrder = m, b.renderOrder = f.renderOrder, b.z = y, b.group = v), e++, b
    }

    function a(f, d, p, m, y, v) {
        const b = o(f, d, p, m, y, v);
        p.transmission > 0 ? r.push(b) : p.transparent === !0 ? i.push(b) : n.push(b)
    }

    function l(f, d, p, m, y, v) {
        const b = o(f, d, p, m, y, v);
        p.transmission > 0 ? r.unshift(b) : p.transparent === !0 ? i.unshift(b) : n.unshift(b)
    }

    function u(f, d) {
        n.length > 1 && n.sort(f || ahe), r.length > 1 && r.sort(d || A6), i.length > 1 && i.sort(d || A6)
    }

    function c() {
        for (let f = e, d = t.length; f < d; f++) {
            const p = t[f];
            if (p.id === null) break;
            p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null
        }
    }
    return {
        opaque: n,
        transmissive: r,
        transparent: i,
        init: s,
        push: a,
        unshift: l,
        finish: c,
        sort: u
    }
}

function lhe() {
    let t = new WeakMap;

    function e(r, i) {
        const s = t.get(r);
        let o;
        return s === void 0 ? (o = new C6, t.set(r, [o])) : i >= s.length ? (o = new C6, s.push(o)) : o = s[i], o
    }

    function n() {
        t = new WeakMap
    }
    return {
        get: e,
        dispose: n
    }
}

function uhe() {
    const t = {};
    return {
        get: function(e) {
            if (t[e.id] !== void 0) return t[e.id];
            let n;
            switch (e.type) {
                case "DirectionalLight":
                    n = {
                        direction: new J,
                        color: new dt
                    };
                    break;
                case "SpotLight":
                    n = {
                        position: new J,
                        direction: new J,
                        color: new dt,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n = {
                        position: new J,
                        color: new dt,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n = {
                        direction: new J,
                        skyColor: new dt,
                        groundColor: new dt
                    };
                    break;
                case "RectAreaLight":
                    n = {
                        color: new dt,
                        position: new J,
                        halfWidth: new J,
                        halfHeight: new J
                    };
                    break
            }
            return t[e.id] = n, n
        }
    }
}

function che() {
    const t = {};
    return {
        get: function(e) {
            if (t[e.id] !== void 0) return t[e.id];
            let n;
            switch (e.type) {
                case "DirectionalLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new ke
                    };
                    break;
                case "SpotLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new ke
                    };
                    break;
                case "PointLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new ke,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
            }
            return t[e.id] = n, n
        }
    }
}
let fhe = 0;

function dhe(t, e) {
    return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
}

function phe(t, e) {
    const n = new uhe,
        r = che(),
        i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0
        };
    for (let c = 0; c < 9; c++) i.probe.push(new J);
    const s = new J,
        o = new Gt,
        a = new Gt;

    function l(c, f) {
        let d = 0,
            p = 0,
            m = 0;
        for (let k = 0; k < 9; k++) i.probe[k].set(0, 0, 0);
        let y = 0,
            v = 0,
            b = 0,
            _ = 0,
            x = 0,
            S = 0,
            E = 0,
            A = 0,
            T = 0,
            M = 0;
        c.sort(dhe);
        const I = f === !0 ? Math.PI : 1;
        for (let k = 0, H = c.length; k < H; k++) {
            const N = c[k],
                B = N.color,
                U = N.intensity,
                q = N.distance,
                Q = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
            if (N.isAmbientLight) d += B.r * U * I, p += B.g * U * I, m += B.b * U * I;
            else if (N.isLightProbe)
                for (let F = 0; F < 9; F++) i.probe[F].addScaledVector(N.sh.coefficients[F], U);
            else if (N.isDirectionalLight) {
                const F = n.get(N);
                if (F.color.copy(N.color).multiplyScalar(N.intensity * I), N.castShadow) {
                    const G = N.shadow,
                        W = r.get(N);
                    W.shadowBias = G.bias, W.shadowNormalBias = G.normalBias, W.shadowRadius = G.radius, W.shadowMapSize = G.mapSize, i.directionalShadow[y] = W, i.directionalShadowMap[y] = Q, i.directionalShadowMatrix[y] = N.shadow.matrix, S++
                }
                i.directional[y] = F, y++
            } else if (N.isSpotLight) {
                const F = n.get(N);
                F.position.setFromMatrixPosition(N.matrixWorld), F.color.copy(B).multiplyScalar(U * I), F.distance = q, F.coneCos = Math.cos(N.angle), F.penumbraCos = Math.cos(N.angle * (1 - N.penumbra)), F.decay = N.decay, i.spot[b] = F;
                const G = N.shadow;
                if (N.map && (i.spotLightMap[T] = N.map, T++, G.updateMatrices(N), N.castShadow && M++), i.spotLightMatrix[b] = G.matrix, N.castShadow) {
                    const W = r.get(N);
                    W.shadowBias = G.bias, W.shadowNormalBias = G.normalBias, W.shadowRadius = G.radius, W.shadowMapSize = G.mapSize, i.spotShadow[b] = W, i.spotShadowMap[b] = Q, A++
                }
                b++
            } else if (N.isRectAreaLight) {
                const F = n.get(N);
                F.color.copy(B).multiplyScalar(U), F.halfWidth.set(N.width * .5, 0, 0), F.halfHeight.set(0, N.height * .5, 0), i.rectArea[_] = F, _++
            } else if (N.isPointLight) {
                const F = n.get(N);
                if (F.color.copy(N.color).multiplyScalar(N.intensity * I), F.distance = N.distance, F.decay = N.decay, N.castShadow) {
                    const G = N.shadow,
                        W = r.get(N);
                    W.shadowBias = G.bias, W.shadowNormalBias = G.normalBias, W.shadowRadius = G.radius, W.shadowMapSize = G.mapSize, W.shadowCameraNear = G.camera.near, W.shadowCameraFar = G.camera.far, i.pointShadow[v] = W, i.pointShadowMap[v] = Q, i.pointShadowMatrix[v] = N.shadow.matrix, E++
                }
                i.point[v] = F, v++
            } else if (N.isHemisphereLight) {
                const F = n.get(N);
                F.skyColor.copy(N.color).multiplyScalar(U * I), F.groundColor.copy(N.groundColor).multiplyScalar(U * I), i.hemi[x] = F, x++
            }
        }
        _ > 0 && (e.isWebGL2 || t.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = ot.LTC_FLOAT_1, i.rectAreaLTC2 = ot.LTC_FLOAT_2) : t.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = ot.LTC_HALF_1, i.rectAreaLTC2 = ot.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = d, i.ambient[1] = p, i.ambient[2] = m;
        const O = i.hash;
        (O.directionalLength !== y || O.pointLength !== v || O.spotLength !== b || O.rectAreaLength !== _ || O.hemiLength !== x || O.numDirectionalShadows !== S || O.numPointShadows !== E || O.numSpotShadows !== A || O.numSpotMaps !== T) && (i.directional.length = y, i.spot.length = b, i.rectArea.length = _, i.point.length = v, i.hemi.length = x, i.directionalShadow.length = S, i.directionalShadowMap.length = S, i.pointShadow.length = E, i.pointShadowMap.length = E, i.spotShadow.length = A, i.spotShadowMap.length = A, i.directionalShadowMatrix.length = S, i.pointShadowMatrix.length = E, i.spotLightMatrix.length = A + T - M, i.spotLightMap.length = T, i.numSpotLightShadowsWithMaps = M, O.directionalLength = y, O.pointLength = v, O.spotLength = b, O.rectAreaLength = _, O.hemiLength = x, O.numDirectionalShadows = S, O.numPointShadows = E, O.numSpotShadows = A, O.numSpotMaps = T, i.version = fhe++)
    }

    function u(c, f) {
        let d = 0,
            p = 0,
            m = 0,
            y = 0,
            v = 0;
        const b = f.matrixWorldInverse;
        for (let _ = 0, x = c.length; _ < x; _++) {
            const S = c[_];
            if (S.isDirectionalLight) {
                const E = i.directional[d];
                E.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), E.direction.sub(s), E.direction.transformDirection(b), d++
            } else if (S.isSpotLight) {
                const E = i.spot[m];
                E.position.setFromMatrixPosition(S.matrixWorld), E.position.applyMatrix4(b), E.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), E.direction.sub(s), E.direction.transformDirection(b), m++
            } else if (S.isRectAreaLight) {
                const E = i.rectArea[y];
                E.position.setFromMatrixPosition(S.matrixWorld), E.position.applyMatrix4(b), a.identity(), o.copy(S.matrixWorld), o.premultiply(b), a.extractRotation(o), E.halfWidth.set(S.width * .5, 0, 0), E.halfHeight.set(0, S.height * .5, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), y++
            } else if (S.isPointLight) {
                const E = i.point[p];
                E.position.setFromMatrixPosition(S.matrixWorld), E.position.applyMatrix4(b), p++
            } else if (S.isHemisphereLight) {
                const E = i.hemi[v];
                E.direction.setFromMatrixPosition(S.matrixWorld), E.direction.transformDirection(b), v++
            }
        }
    }
    return {
        setup: l,
        setupView: u,
        state: i
    }
}

function M6(t, e) {
    const n = new phe(t, e),
        r = [],
        i = [];

    function s() {
        r.length = 0, i.length = 0
    }

    function o(f) {
        r.push(f)
    }

    function a(f) {
        i.push(f)
    }

    function l(f) {
        n.setup(r, f)
    }

    function u(f) {
        n.setupView(r, f)
    }
    return {
        init: s,
        state: {
            lightsArray: r,
            shadowsArray: i,
            lights: n
        },
        setupLights: l,
        setupLightsView: u,
        pushLight: o,
        pushShadow: a
    }
}

function hhe(t, e) {
    let n = new WeakMap;

    function r(s, o = 0) {
        const a = n.get(s);
        let l;
        return a === void 0 ? (l = new M6(t, e), n.set(s, [l])) : o >= a.length ? (l = new M6(t, e), a.push(l)) : l = a[o], l
    }

    function i() {
        n = new WeakMap
    }
    return {
        get: r,
        dispose: i
    }
}
class vL extends li {
    constructor(e) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = nW, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }
}
class bL extends li {
    constructor(e) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new J, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }
}
const mhe = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    ghe = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function yhe(t, e, n) {
    let r = new FE;
    const i = new ke,
        s = new ke,
        o = new In,
        a = new vL({
            depthPacking: rW
        }),
        l = new bL,
        u = {},
        c = n.maxTextureSize,
        f = {
            [Ol]: Vs,
            [Vs]: Ol,
            [Ra]: Ra
        },
        d = new ra({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new ke
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: mhe,
            fragmentShader: ghe
        }),
        p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const m = new on;
    m.setAttribute("position", new Ln(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const y = new mi(m, d),
        v = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = OE, this.render = function(S, E, A) {
        if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || S.length === 0) return;
        const T = t.getRenderTarget(),
            M = t.getActiveCubeFace(),
            I = t.getActiveMipmapLevel(),
            O = t.state;
        O.setBlending(Mu), O.buffers.color.setClear(1, 1, 1, 1), O.buffers.depth.setTest(!0), O.setScissorTest(!1);
        for (let k = 0, H = S.length; k < H; k++) {
            const N = S[k],
                B = N.shadow;
            if (B === void 0) {
                console.warn("THREE.WebGLShadowMap:", N, "has no shadow.");
                continue
            }
            if (B.autoUpdate === !1 && B.needsUpdate === !1) continue;
            i.copy(B.mapSize);
            const U = B.getFrameExtents();
            if (i.multiply(U), s.copy(B.mapSize), (i.x > c || i.y > c) && (i.x > c && (s.x = Math.floor(c / U.x), i.x = s.x * U.x, B.mapSize.x = s.x), i.y > c && (s.y = Math.floor(c / U.y), i.y = s.y * U.y, B.mapSize.y = s.y)), B.map === null) {
                const Q = this.type !== gd ? {
                    minFilter: Br,
                    magFilter: Br
                } : {};
                B.map = new na(i.x, i.y, Q), B.map.texture.name = N.name + ".shadowMap", B.camera.updateProjectionMatrix()
            }
            t.setRenderTarget(B.map), t.clear();
            const q = B.getViewportCount();
            for (let Q = 0; Q < q; Q++) {
                const F = B.getViewport(Q);
                o.set(s.x * F.x, s.y * F.y, s.x * F.z, s.y * F.w), O.viewport(o), B.updateMatrices(N, Q), r = B.getFrustum(), x(E, A, B.camera, N, this.type)
            }
            B.isPointLightShadow !== !0 && this.type === gd && b(B, A), B.needsUpdate = !1
        }
        v.needsUpdate = !1, t.setRenderTarget(T, M, I)
    };

    function b(S, E) {
        const A = e.update(y);
        d.defines.VSM_SAMPLES !== S.blurSamples && (d.defines.VSM_SAMPLES = S.blurSamples, p.defines.VSM_SAMPLES = S.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), S.mapPass === null && (S.mapPass = new na(i.x, i.y)), d.uniforms.shadow_pass.value = S.map.texture, d.uniforms.resolution.value = S.mapSize, d.uniforms.radius.value = S.radius, t.setRenderTarget(S.mapPass), t.clear(), t.renderBufferDirect(E, null, A, d, y, null), p.uniforms.shadow_pass.value = S.mapPass.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, t.setRenderTarget(S.map), t.clear(), t.renderBufferDirect(E, null, A, p, y, null)
    }

    function _(S, E, A, T, M, I) {
        let O = null;
        const k = A.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
        if (k !== void 0) O = k;
        else if (O = A.isPointLight === !0 ? l : a, t.localClippingEnabled && E.clipShadows === !0 && Array.isArray(E.clippingPlanes) && E.clippingPlanes.length !== 0 || E.displacementMap && E.displacementScale !== 0 || E.alphaMap && E.alphaTest > 0 || E.map && E.alphaTest > 0) {
            const H = O.uuid,
                N = E.uuid;
            let B = u[H];
            B === void 0 && (B = {}, u[H] = B);
            let U = B[N];
            U === void 0 && (U = O.clone(), B[N] = U), O = U
        }
        return O.visible = E.visible, O.wireframe = E.wireframe, I === gd ? O.side = E.shadowSide !== null ? E.shadowSide : E.side : O.side = E.shadowSide !== null ? E.shadowSide : f[E.side], O.alphaMap = E.alphaMap, O.alphaTest = E.alphaTest, O.map = E.map, O.clipShadows = E.clipShadows, O.clippingPlanes = E.clippingPlanes, O.clipIntersection = E.clipIntersection, O.displacementMap = E.displacementMap, O.displacementScale = E.displacementScale, O.displacementBias = E.displacementBias, O.wireframeLinewidth = E.wireframeLinewidth, O.linewidth = E.linewidth, A.isPointLight === !0 && O.isMeshDistanceMaterial === !0 && (O.referencePosition.setFromMatrixPosition(A.matrixWorld), O.nearDistance = T, O.farDistance = M), O
    }

    function x(S, E, A, T, M) {
        if (S.visible === !1) return;
        if (S.layers.test(E.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && M === gd) && (!S.frustumCulled || r.intersectsObject(S))) {
            S.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, S.matrixWorld);
            const k = e.update(S),
                H = S.material;
            if (Array.isArray(H)) {
                const N = k.groups;
                for (let B = 0, U = N.length; B < U; B++) {
                    const q = N[B],
                        Q = H[q.materialIndex];
                    if (Q && Q.visible) {
                        const F = _(S, Q, T, A.near, A.far, M);
                        t.renderBufferDirect(A, null, k, F, S, q)
                    }
                }
            } else if (H.visible) {
                const N = _(S, H, T, A.near, A.far, M);
                t.renderBufferDirect(A, null, k, N, S, null)
            }
        }
        const O = S.children;
        for (let k = 0, H = O.length; k < H; k++) x(O[k], E, A, T, M)
    }
}

function vhe(t, e, n) {
    const r = n.isWebGL2;

    function i() {
        let oe = !1;
        const Ee = new In;
        let Fe = null;
        const Ve = new In(0, 0, 0, 0);
        return {
            setMask: function(ct) {
                Fe !== ct && !oe && (t.colorMask(ct, ct, ct, ct), Fe = ct)
            },
            setLocked: function(ct) {
                oe = ct
            },
            setClear: function(ct, bt, Kt, un, zt) {
                zt === !0 && (ct *= un, bt *= un, Kt *= un), Ee.set(ct, bt, Kt, un), Ve.equals(Ee) === !1 && (t.clearColor(ct, bt, Kt, un), Ve.copy(Ee))
            },
            reset: function() {
                oe = !1, Fe = null, Ve.set(-1, 0, 0, 0)
            }
        }
    }

    function s() {
        let oe = !1,
            Ee = null,
            Fe = null,
            Ve = null;
        return {
            setTest: function(ct) {
                ct ? fe(2929) : ue(2929)
            },
            setMask: function(ct) {
                Ee !== ct && !oe && (t.depthMask(ct), Ee = ct)
            },
            setFunc: function(ct) {
                if (Fe !== ct) {
                    switch (ct) {
                        case Ej:
                            t.depthFunc(512);
                            break;
                        case Aj:
                            t.depthFunc(519);
                            break;
                        case Cj:
                            t.depthFunc(513);
                            break;
                        case Ow:
                            t.depthFunc(515);
                            break;
                        case Mj:
                            t.depthFunc(514);
                            break;
                        case Tj:
                            t.depthFunc(518);
                            break;
                        case Pj:
                            t.depthFunc(516);
                            break;
                        case Ij:
                            t.depthFunc(517);
                            break;
                        default:
                            t.depthFunc(515)
                    }
                    Fe = ct
                }
            },
            setLocked: function(ct) {
                oe = ct
            },
            setClear: function(ct) {
                Ve !== ct && (t.clearDepth(ct), Ve = ct)
            },
            reset: function() {
                oe = !1, Ee = null, Fe = null, Ve = null
            }
        }
    }

    function o() {
        let oe = !1,
            Ee = null,
            Fe = null,
            Ve = null,
            ct = null,
            bt = null,
            Kt = null,
            un = null,
            zt = null;
        return {
            setTest: function(Ot) {
                oe || (Ot ? fe(2960) : ue(2960))
            },
            setMask: function(Ot) {
                Ee !== Ot && !oe && (t.stencilMask(Ot), Ee = Ot)
            },
            setFunc: function(Ot, tn, Xt) {
                (Fe !== Ot || Ve !== tn || ct !== Xt) && (t.stencilFunc(Ot, tn, Xt), Fe = Ot, Ve = tn, ct = Xt)
            },
            setOp: function(Ot, tn, Xt) {
                (bt !== Ot || Kt !== tn || un !== Xt) && (t.stencilOp(Ot, tn, Xt), bt = Ot, Kt = tn, un = Xt)
            },
            setLocked: function(Ot) {
                oe = Ot
            },
            setClear: function(Ot) {
                zt !== Ot && (t.clearStencil(Ot), zt = Ot)
            },
            reset: function() {
                oe = !1, Ee = null, Fe = null, Ve = null, ct = null, bt = null, Kt = null, un = null, zt = null
            }
        }
    }
    const a = new i,
        l = new s,
        u = new o,
        c = new WeakMap,
        f = new WeakMap;
    let d = {},
        p = {},
        m = new WeakMap,
        y = [],
        v = null,
        b = !1,
        _ = null,
        x = null,
        S = null,
        E = null,
        A = null,
        T = null,
        M = null,
        I = !1,
        O = null,
        k = null,
        H = null,
        N = null,
        B = null;
    const U = t.getParameter(35661);
    let q = !1,
        Q = 0;
    const F = t.getParameter(7938);
    F.indexOf("WebGL") !== -1 ? (Q = parseFloat(/^WebGL (\d)/.exec(F)[1]), q = Q >= 1) : F.indexOf("OpenGL ES") !== -1 && (Q = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), q = Q >= 2);
    let G = null,
        W = {};
    const se = t.getParameter(3088),
        ee = t.getParameter(2978),
        ae = new In().fromArray(se),
        de = new In().fromArray(ee);

    function re(oe, Ee, Fe) {
        const Ve = new Uint8Array(4),
            ct = t.createTexture();
        t.bindTexture(oe, ct), t.texParameteri(oe, 10241, 9728), t.texParameteri(oe, 10240, 9728);
        for (let bt = 0; bt < Fe; bt++) t.texImage2D(Ee + bt, 0, 6408, 1, 1, 0, 6408, 5121, Ve);
        return ct
    }
    const _e = {};
    _e[3553] = re(3553, 3553, 1), _e[34067] = re(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), u.setClear(0), fe(2929), l.setFunc(Ow), De(!1), je(KI), fe(2884), Ce(Mu);

    function fe(oe) {
        d[oe] !== !0 && (t.enable(oe), d[oe] = !0)
    }

    function ue(oe) {
        d[oe] !== !1 && (t.disable(oe), d[oe] = !1)
    }

    function ve(oe, Ee) {
        return p[oe] !== Ee ? (t.bindFramebuffer(oe, Ee), p[oe] = Ee, r && (oe === 36009 && (p[36160] = Ee), oe === 36160 && (p[36009] = Ee)), !0) : !1
    }

    function xe(oe, Ee) {
        let Fe = y,
            Ve = !1;
        if (oe)
            if (Fe = m.get(Ee), Fe === void 0 && (Fe = [], m.set(Ee, Fe)), oe.isWebGLMultipleRenderTargets) {
                const ct = oe.texture;
                if (Fe.length !== ct.length || Fe[0] !== 36064) {
                    for (let bt = 0, Kt = ct.length; bt < Kt; bt++) Fe[bt] = 36064 + bt;
                    Fe.length = ct.length, Ve = !0
                }
            } else Fe[0] !== 36064 && (Fe[0] = 36064, Ve = !0);
        else Fe[0] !== 1029 && (Fe[0] = 1029, Ve = !0);
        Ve && (n.isWebGL2 ? t.drawBuffers(Fe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Fe))
    }

    function be(oe) {
        return v !== oe ? (t.useProgram(oe), v = oe, !0) : !1
    }
    const he = {
        [ad]: 32774,
        [pj]: 32778,
        [hj]: 32779
    };
    if (r) he[YI] = 32775, he[QI] = 32776;
    else {
        const oe = e.get("EXT_blend_minmax");
        oe !== null && (he[YI] = oe.MIN_EXT, he[QI] = oe.MAX_EXT)
    }
    const me = {
        [mj]: 0,
        [gj]: 1,
        [yj]: 768,
        [sL]: 770,
        [wj]: 776,
        [_j]: 774,
        [bj]: 772,
        [vj]: 769,
        [oL]: 771,
        [Sj]: 775,
        [xj]: 773
    };

    function Ce(oe, Ee, Fe, Ve, ct, bt, Kt, un) {
        if (oe === Mu) {
            b === !0 && (ue(3042), b = !1);
            return
        }
        if (b === !1 && (fe(3042), b = !0), oe !== dj) {
            if (oe !== _ || un !== I) {
                if ((x !== ad || A !== ad) && (t.blendEquation(32774), x = ad, A = ad), un) switch (oe) {
                    case Dd:
                        t.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case qI:
                        t.blendFunc(1, 1);
                        break;
                    case XI:
                        t.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case JI:
                        t.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", oe);
                        break
                } else switch (oe) {
                    case Dd:
                        t.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case qI:
                        t.blendFunc(770, 1);
                        break;
                    case XI:
                        t.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case JI:
                        t.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", oe);
                        break
                }
                S = null, E = null, T = null, M = null, _ = oe, I = un
            }
            return
        }
        ct = ct || Ee, bt = bt || Fe, Kt = Kt || Ve, (Ee !== x || ct !== A) && (t.blendEquationSeparate(he[Ee], he[ct]), x = Ee, A = ct), (Fe !== S || Ve !== E || bt !== T || Kt !== M) && (t.blendFuncSeparate(me[Fe], me[Ve], me[bt], me[Kt]), S = Fe, E = Ve, T = bt, M = Kt), _ = oe, I = !1
    }

    function Ne(oe, Ee) {
        oe.side === Ra ? ue(2884) : fe(2884);
        let Fe = oe.side === Vs;
        Ee && (Fe = !Fe), De(Fe), oe.blending === Dd && oe.transparent === !1 ? Ce(Mu) : Ce(oe.blending, oe.blendEquation, oe.blendSrc, oe.blendDst, oe.blendEquationAlpha, oe.blendSrcAlpha, oe.blendDstAlpha, oe.premultipliedAlpha), l.setFunc(oe.depthFunc), l.setTest(oe.depthTest), l.setMask(oe.depthWrite), a.setMask(oe.colorWrite);
        const Ve = oe.stencilWrite;
        u.setTest(Ve), Ve && (u.setMask(oe.stencilWriteMask), u.setFunc(oe.stencilFunc, oe.stencilRef, oe.stencilFuncMask), u.setOp(oe.stencilFail, oe.stencilZFail, oe.stencilZPass)), He(oe.polygonOffset, oe.polygonOffsetFactor, oe.polygonOffsetUnits), oe.alphaToCoverage === !0 ? fe(32926) : ue(32926)
    }

    function De(oe) {
        O !== oe && (oe ? t.frontFace(2304) : t.frontFace(2305), O = oe)
    }

    function je(oe) {
        oe !== uj ? (fe(2884), oe !== k && (oe === KI ? t.cullFace(1029) : oe === cj ? t.cullFace(1028) : t.cullFace(1032))) : ue(2884), k = oe
    }

    function Ke(oe) {
        oe !== H && (q && t.lineWidth(oe), H = oe)
    }

    function He(oe, Ee, Fe) {
        oe ? (fe(32823), (N !== Ee || B !== Fe) && (t.polygonOffset(Ee, Fe), N = Ee, B = Fe)) : ue(32823)
    }

    function qe(oe) {
        oe ? fe(3089) : ue(3089)
    }

    function Xe(oe) {
        oe === void 0 && (oe = 33984 + U - 1), G !== oe && (t.activeTexture(oe), G = oe)
    }

    function K(oe, Ee, Fe) {
        Fe === void 0 && (G === null ? Fe = 33984 + U - 1 : Fe = G);
        let Ve = W[Fe];
        Ve === void 0 && (Ve = {
            type: void 0,
            texture: void 0
        }, W[Fe] = Ve), (Ve.type !== oe || Ve.texture !== Ee) && (G !== Fe && (t.activeTexture(Fe), G = Fe), t.bindTexture(oe, Ee || _e[oe]), Ve.type = oe, Ve.texture = Ee)
    }

    function V() {
        const oe = W[G];
        oe !== void 0 && oe.type !== void 0 && (t.bindTexture(oe.type, null), oe.type = void 0, oe.texture = void 0)
    }

    function ge() {
        try {
            t.compressedTexImage2D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function Be() {
        try {
            t.compressedTexImage3D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function ze() {
        try {
            t.texSubImage2D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function Ue() {
        try {
            t.texSubImage3D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function Ye() {
        try {
            t.compressedTexSubImage2D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function Te() {
        try {
            t.compressedTexSubImage3D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function we() {
        try {
            t.texStorage2D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function lt() {
        try {
            t.texStorage3D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function nt() {
        try {
            t.texImage2D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function vt() {
        try {
            t.texImage3D.apply(t, arguments)
        } catch (oe) {
            console.error("THREE.WebGLState:", oe)
        }
    }

    function ht(oe) {
        ae.equals(oe) === !1 && (t.scissor(oe.x, oe.y, oe.z, oe.w), ae.copy(oe))
    }

    function pt(oe) {
        de.equals(oe) === !1 && (t.viewport(oe.x, oe.y, oe.z, oe.w), de.copy(oe))
    }

    function le(oe, Ee) {
        let Fe = f.get(Ee);
        Fe === void 0 && (Fe = new WeakMap, f.set(Ee, Fe));
        let Ve = Fe.get(oe);
        Ve === void 0 && (Ve = t.getUniformBlockIndex(Ee, oe.name), Fe.set(oe, Ve))
    }

    function Ie(oe, Ee) {
        const Ve = f.get(Ee).get(oe);
        c.get(Ee) !== Ve && (t.uniformBlockBinding(Ee, Ve, oe.__bindingPointIndex), c.set(Ee, Ve))
    }

    function tt() {
        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), r === !0 && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), d = {}, G = null, W = {}, p = {}, m = new WeakMap, y = [], v = null, b = !1, _ = null, x = null, S = null, E = null, A = null, T = null, M = null, I = !1, O = null, k = null, H = null, N = null, B = null, ae.set(0, 0, t.canvas.width, t.canvas.height), de.set(0, 0, t.canvas.width, t.canvas.height), a.reset(), l.reset(), u.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: u
        },
        enable: fe,
        disable: ue,
        bindFramebuffer: ve,
        drawBuffers: xe,
        useProgram: be,
        setBlending: Ce,
        setMaterial: Ne,
        setFlipSided: De,
        setCullFace: je,
        setLineWidth: Ke,
        setPolygonOffset: He,
        setScissorTest: qe,
        activeTexture: Xe,
        bindTexture: K,
        unbindTexture: V,
        compressedTexImage2D: ge,
        compressedTexImage3D: Be,
        texImage2D: nt,
        texImage3D: vt,
        updateUBOMapping: le,
        uniformBlockBinding: Ie,
        texStorage2D: we,
        texStorage3D: lt,
        texSubImage2D: ze,
        texSubImage3D: Ue,
        compressedTexSubImage2D: Ye,
        compressedTexSubImage3D: Te,
        scissor: ht,
        viewport: pt,
        reset: tt
    }
}

function bhe(t, e, n, r, i, s, o) {
    const a = i.isWebGL2,
        l = i.maxTextures,
        u = i.maxCubemapSize,
        c = i.maxTextureSize,
        f = i.maxSamples,
        d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
        p = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        m = new WeakMap;
    let y;
    const v = new WeakMap;
    let b = !1;
    try {
        b = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {}

    function _(K, V) {
        return b ? new OffscreenCanvas(K, V) : f0("canvas")
    }

    function x(K, V, ge, Be) {
        let ze = 1;
        if ((K.width > Be || K.height > Be) && (ze = Be / Math.max(K.width, K.height)), ze < 1 || V === !0)
            if (typeof HTMLImageElement < "u" && K instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && K instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && K instanceof ImageBitmap) {
                const Ue = V ? aW : Math.floor,
                    Ye = Ue(ze * K.width),
                    Te = Ue(ze * K.height);
                y === void 0 && (y = _(Ye, Te));
                const we = ge ? _(Ye, Te) : y;
                return we.width = Ye, we.height = Te, we.getContext("2d").drawImage(K, 0, 0, Ye, Te), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + K.width + "x" + K.height + ") to (" + Ye + "x" + Te + ")."), we
            } else return "data" in K && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + K.width + "x" + K.height + ")."), K;
        return K
    }

    function S(K) {
        return w3(K.width) && w3(K.height)
    }

    function E(K) {
        return a ? !1 : K.wrapS !== zi || K.wrapT !== zi || K.minFilter !== Br && K.minFilter !== fr
    }

    function A(K, V) {
        return K.generateMipmaps && V && K.minFilter !== Br && K.minFilter !== fr
    }

    function T(K) {
        t.generateMipmap(K)
    }

    function M(K, V, ge, Be, ze = !1) {
        if (a === !1) return V;
        if (K !== null) {
            if (t[K] !== void 0) return t[K];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + K + "'")
        }
        let Ue = V;
        return V === 6403 && (ge === 5126 && (Ue = 33326), ge === 5131 && (Ue = 33325), ge === 5121 && (Ue = 33321)), V === 33319 && (ge === 5126 && (Ue = 33328), ge === 5131 && (Ue = 33327), ge === 5121 && (Ue = 33323)), V === 6408 && (ge === 5126 && (Ue = 34836), ge === 5131 && (Ue = 34842), ge === 5121 && (Ue = Be === Xn && ze === !1 ? 35907 : 32856), ge === 32819 && (Ue = 32854), ge === 32820 && (Ue = 32855)), (Ue === 33325 || Ue === 33326 || Ue === 33327 || Ue === 33328 || Ue === 34842 || Ue === 34836) && e.get("EXT_color_buffer_float"), Ue
    }

    function I(K, V, ge) {
        return A(K, ge) === !0 || K.isFramebufferTexture && K.minFilter !== Br && K.minFilter !== fr ? Math.log2(Math.max(V.width, V.height)) + 1 : K.mipmaps !== void 0 && K.mipmaps.length > 0 ? K.mipmaps.length : K.isCompressedTexture && Array.isArray(K.image) ? V.mipmaps.length : 1
    }

    function O(K) {
        return K === Br || K === a0 || K === um ? 9728 : 9729
    }

    function k(K) {
        const V = K.target;
        V.removeEventListener("dispose", k), N(V), V.isVideoTexture && m.delete(V)
    }

    function H(K) {
        const V = K.target;
        V.removeEventListener("dispose", H), U(V)
    }

    function N(K) {
        const V = r.get(K);
        if (V.__webglInit === void 0) return;
        const ge = K.source,
            Be = v.get(ge);
        if (Be) {
            const ze = Be[V.__cacheKey];
            ze.usedTimes--, ze.usedTimes === 0 && B(K), Object.keys(Be).length === 0 && v.delete(ge)
        }
        r.remove(K)
    }

    function B(K) {
        const V = r.get(K);
        t.deleteTexture(V.__webglTexture);
        const ge = K.source,
            Be = v.get(ge);
        delete Be[V.__cacheKey], o.memory.textures--
    }

    function U(K) {
        const V = K.texture,
            ge = r.get(K),
            Be = r.get(V);
        if (Be.__webglTexture !== void 0 && (t.deleteTexture(Be.__webglTexture), o.memory.textures--), K.depthTexture && K.depthTexture.dispose(), K.isWebGLCubeRenderTarget)
            for (let ze = 0; ze < 6; ze++) t.deleteFramebuffer(ge.__webglFramebuffer[ze]), ge.__webglDepthbuffer && t.deleteRenderbuffer(ge.__webglDepthbuffer[ze]);
        else {
            if (t.deleteFramebuffer(ge.__webglFramebuffer), ge.__webglDepthbuffer && t.deleteRenderbuffer(ge.__webglDepthbuffer), ge.__webglMultisampledFramebuffer && t.deleteFramebuffer(ge.__webglMultisampledFramebuffer), ge.__webglColorRenderbuffer)
                for (let ze = 0; ze < ge.__webglColorRenderbuffer.length; ze++) ge.__webglColorRenderbuffer[ze] && t.deleteRenderbuffer(ge.__webglColorRenderbuffer[ze]);
            ge.__webglDepthRenderbuffer && t.deleteRenderbuffer(ge.__webglDepthRenderbuffer)
        }
        if (K.isWebGLMultipleRenderTargets)
            for (let ze = 0, Ue = V.length; ze < Ue; ze++) {
                const Ye = r.get(V[ze]);
                Ye.__webglTexture && (t.deleteTexture(Ye.__webglTexture), o.memory.textures--), r.remove(V[ze])
            }
        r.remove(V), r.remove(K)
    }
    let q = 0;

    function Q() {
        q = 0
    }

    function F() {
        const K = q;
        return K >= l && console.warn("THREE.WebGLTextures: Trying to use " + K + " texture units while this GPU supports only " + l), q += 1, K
    }

    function G(K) {
        const V = [];
        return V.push(K.wrapS), V.push(K.wrapT), V.push(K.wrapR || 0), V.push(K.magFilter), V.push(K.minFilter), V.push(K.anisotropy), V.push(K.internalFormat), V.push(K.format), V.push(K.type), V.push(K.generateMipmaps), V.push(K.premultiplyAlpha), V.push(K.flipY), V.push(K.unpackAlignment), V.push(K.encoding), V.join()
    }

    function W(K, V) {
        const ge = r.get(K);
        if (K.isVideoTexture && qe(K), K.isRenderTargetTexture === !1 && K.version > 0 && ge.__version !== K.version) {
            const Be = K.image;
            if (Be === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Be.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ue(ge, K, V);
                return
            }
        }
        n.bindTexture(3553, ge.__webglTexture, 33984 + V)
    }

    function se(K, V) {
        const ge = r.get(K);
        if (K.version > 0 && ge.__version !== K.version) {
            ue(ge, K, V);
            return
        }
        n.bindTexture(35866, ge.__webglTexture, 33984 + V)
    }

    function ee(K, V) {
        const ge = r.get(K);
        if (K.version > 0 && ge.__version !== K.version) {
            ue(ge, K, V);
            return
        }
        n.bindTexture(32879, ge.__webglTexture, 33984 + V)
    }

    function ae(K, V) {
        const ge = r.get(K);
        if (K.version > 0 && ge.__version !== K.version) {
            ve(ge, K, V);
            return
        }
        n.bindTexture(34067, ge.__webglTexture, 33984 + V)
    }
    const de = {
            [cf]: 10497,
            [zi]: 33071,
            [Lm]: 33648
        },
        re = {
            [Br]: 9728,
            [a0]: 9984,
            [um]: 9986,
            [fr]: 9729,
            [LE]: 9985,
            [Dl]: 9987
        };

    function _e(K, V, ge) {
        if (ge ? (t.texParameteri(K, 10242, de[V.wrapS]), t.texParameteri(K, 10243, de[V.wrapT]), (K === 32879 || K === 35866) && t.texParameteri(K, 32882, de[V.wrapR]), t.texParameteri(K, 10240, re[V.magFilter]), t.texParameteri(K, 10241, re[V.minFilter])) : (t.texParameteri(K, 10242, 33071), t.texParameteri(K, 10243, 33071), (K === 32879 || K === 35866) && t.texParameteri(K, 32882, 33071), (V.wrapS !== zi || V.wrapT !== zi) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(K, 10240, O(V.magFilter)), t.texParameteri(K, 10241, O(V.minFilter)), V.minFilter !== Br && V.minFilter !== fr && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
            const Be = e.get("EXT_texture_filter_anisotropic");
            if (V.magFilter === Br || V.minFilter !== um && V.minFilter !== Dl || V.type === xl && e.has("OES_texture_float_linear") === !1 || a === !1 && V.type === Qd && e.has("OES_texture_half_float_linear") === !1) return;
            (V.anisotropy > 1 || r.get(V).__currentAnisotropy) && (t.texParameterf(K, Be.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(V.anisotropy, i.getMaxAnisotropy())), r.get(V).__currentAnisotropy = V.anisotropy)
        }
    }

    function fe(K, V) {
        let ge = !1;
        K.__webglInit === void 0 && (K.__webglInit = !0, V.addEventListener("dispose", k));
        const Be = V.source;
        let ze = v.get(Be);
        ze === void 0 && (ze = {}, v.set(Be, ze));
        const Ue = G(V);
        if (Ue !== K.__cacheKey) {
            ze[Ue] === void 0 && (ze[Ue] = {
                texture: t.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, ge = !0), ze[Ue].usedTimes++;
            const Ye = ze[K.__cacheKey];
            Ye !== void 0 && (ze[K.__cacheKey].usedTimes--, Ye.usedTimes === 0 && B(V)), K.__cacheKey = Ue, K.__webglTexture = ze[Ue].texture
        }
        return ge
    }

    function ue(K, V, ge) {
        let Be = 3553;
        (V.isDataArrayTexture || V.isCompressedArrayTexture) && (Be = 35866), V.isData3DTexture && (Be = 32879);
        const ze = fe(K, V),
            Ue = V.source;
        n.bindTexture(Be, K.__webglTexture, 33984 + ge);
        const Ye = r.get(Ue);
        if (Ue.version !== Ye.__version || ze === !0) {
            n.activeTexture(33984 + ge), t.pixelStorei(37440, V.flipY), t.pixelStorei(37441, V.premultiplyAlpha), t.pixelStorei(3317, V.unpackAlignment), t.pixelStorei(37443, 0);
            const Te = E(V) && S(V.image) === !1;
            let we = x(V.image, Te, !1, c);
            we = Xe(V, we);
            const lt = S(we) || a,
                nt = s.convert(V.format, V.encoding);
            let vt = s.convert(V.type),
                ht = M(V.internalFormat, nt, vt, V.encoding, V.isVideoTexture);
            _e(Be, V, lt);
            let pt;
            const le = V.mipmaps,
                Ie = a && V.isVideoTexture !== !0,
                tt = Ye.__version === void 0 || ze === !0,
                oe = I(V, we, lt);
            if (V.isDepthTexture) ht = 6402, a ? V.type === xl ? ht = 36012 : V.type === Oc ? ht = 33190 : V.type === Ld ? ht = 35056 : ht = 33189 : V.type === xl && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), V.format === Qc && ht === 6402 && V.type !== lL && V.type !== Oc && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), V.type = Oc, vt = s.convert(V.type)), V.format === Zd && ht === 6402 && (ht = 34041, V.type !== Ld && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), V.type = Ld, vt = s.convert(V.type))), tt && (Ie ? n.texStorage2D(3553, 1, ht, we.width, we.height) : n.texImage2D(3553, 0, ht, we.width, we.height, 0, nt, vt, null));
            else if (V.isDataTexture)
                if (le.length > 0 && lt) {
                    Ie && tt && n.texStorage2D(3553, oe, ht, le[0].width, le[0].height);
                    for (let Ee = 0, Fe = le.length; Ee < Fe; Ee++) pt = le[Ee], Ie ? n.texSubImage2D(3553, Ee, 0, 0, pt.width, pt.height, nt, vt, pt.data) : n.texImage2D(3553, Ee, ht, pt.width, pt.height, 0, nt, vt, pt.data);
                    V.generateMipmaps = !1
                } else Ie ? (tt && n.texStorage2D(3553, oe, ht, we.width, we.height), n.texSubImage2D(3553, 0, 0, 0, we.width, we.height, nt, vt, we.data)) : n.texImage2D(3553, 0, ht, we.width, we.height, 0, nt, vt, we.data);
            else if (V.isCompressedTexture)
                if (V.isCompressedArrayTexture) {
                    Ie && tt && n.texStorage3D(35866, oe, ht, le[0].width, le[0].height, we.depth);
                    for (let Ee = 0, Fe = le.length; Ee < Fe; Ee++) pt = le[Ee], V.format !== Ns ? nt !== null ? Ie ? n.compressedTexSubImage3D(35866, Ee, 0, 0, 0, pt.width, pt.height, we.depth, nt, pt.data, 0, 0) : n.compressedTexImage3D(35866, Ee, ht, pt.width, pt.height, we.depth, 0, pt.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ie ? n.texSubImage3D(35866, Ee, 0, 0, 0, pt.width, pt.height, we.depth, nt, vt, pt.data) : n.texImage3D(35866, Ee, ht, pt.width, pt.height, we.depth, 0, nt, vt, pt.data)
                } else {
                    Ie && tt && n.texStorage2D(3553, oe, ht, le[0].width, le[0].height);
                    for (let Ee = 0, Fe = le.length; Ee < Fe; Ee++) pt = le[Ee], V.format !== Ns ? nt !== null ? Ie ? n.compressedTexSubImage2D(3553, Ee, 0, 0, pt.width, pt.height, nt, pt.data) : n.compressedTexImage2D(3553, Ee, ht, pt.width, pt.height, 0, pt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ie ? n.texSubImage2D(3553, Ee, 0, 0, pt.width, pt.height, nt, vt, pt.data) : n.texImage2D(3553, Ee, ht, pt.width, pt.height, 0, nt, vt, pt.data)
                }
            else if (V.isDataArrayTexture) Ie ? (tt && n.texStorage3D(35866, oe, ht, we.width, we.height, we.depth), n.texSubImage3D(35866, 0, 0, 0, 0, we.width, we.height, we.depth, nt, vt, we.data)) : n.texImage3D(35866, 0, ht, we.width, we.height, we.depth, 0, nt, vt, we.data);
            else if (V.isData3DTexture) Ie ? (tt && n.texStorage3D(32879, oe, ht, we.width, we.height, we.depth), n.texSubImage3D(32879, 0, 0, 0, 0, we.width, we.height, we.depth, nt, vt, we.data)) : n.texImage3D(32879, 0, ht, we.width, we.height, we.depth, 0, nt, vt, we.data);
            else if (V.isFramebufferTexture) {
                if (tt)
                    if (Ie) n.texStorage2D(3553, oe, ht, we.width, we.height);
                    else {
                        let Ee = we.width,
                            Fe = we.height;
                        for (let Ve = 0; Ve < oe; Ve++) n.texImage2D(3553, Ve, ht, Ee, Fe, 0, nt, vt, null), Ee >>= 1, Fe >>= 1
                    }
            } else if (le.length > 0 && lt) {
                Ie && tt && n.texStorage2D(3553, oe, ht, le[0].width, le[0].height);
                for (let Ee = 0, Fe = le.length; Ee < Fe; Ee++) pt = le[Ee], Ie ? n.texSubImage2D(3553, Ee, 0, 0, nt, vt, pt) : n.texImage2D(3553, Ee, ht, nt, vt, pt);
                V.generateMipmaps = !1
            } else Ie ? (tt && n.texStorage2D(3553, oe, ht, we.width, we.height), n.texSubImage2D(3553, 0, 0, 0, nt, vt, we)) : n.texImage2D(3553, 0, ht, nt, vt, we);
            A(V, lt) && T(Be), Ye.__version = Ue.version, V.onUpdate && V.onUpdate(V)
        }
        K.__version = V.version
    }

    function ve(K, V, ge) {
        if (V.image.length !== 6) return;
        const Be = fe(K, V),
            ze = V.source;
        n.bindTexture(34067, K.__webglTexture, 33984 + ge);
        const Ue = r.get(ze);
        if (ze.version !== Ue.__version || Be === !0) {
            n.activeTexture(33984 + ge), t.pixelStorei(37440, V.flipY), t.pixelStorei(37441, V.premultiplyAlpha), t.pixelStorei(3317, V.unpackAlignment), t.pixelStorei(37443, 0);
            const Ye = V.isCompressedTexture || V.image[0].isCompressedTexture,
                Te = V.image[0] && V.image[0].isDataTexture,
                we = [];
            for (let Ee = 0; Ee < 6; Ee++) !Ye && !Te ? we[Ee] = x(V.image[Ee], !1, !0, u) : we[Ee] = Te ? V.image[Ee].image : V.image[Ee], we[Ee] = Xe(V, we[Ee]);
            const lt = we[0],
                nt = S(lt) || a,
                vt = s.convert(V.format, V.encoding),
                ht = s.convert(V.type),
                pt = M(V.internalFormat, vt, ht, V.encoding),
                le = a && V.isVideoTexture !== !0,
                Ie = Ue.__version === void 0 || Be === !0;
            let tt = I(V, lt, nt);
            _e(34067, V, nt);
            let oe;
            if (Ye) {
                le && Ie && n.texStorage2D(34067, tt, pt, lt.width, lt.height);
                for (let Ee = 0; Ee < 6; Ee++) {
                    oe = we[Ee].mipmaps;
                    for (let Fe = 0; Fe < oe.length; Fe++) {
                        const Ve = oe[Fe];
                        V.format !== Ns ? vt !== null ? le ? n.compressedTexSubImage2D(34069 + Ee, Fe, 0, 0, Ve.width, Ve.height, vt, Ve.data) : n.compressedTexImage2D(34069 + Ee, Fe, pt, Ve.width, Ve.height, 0, Ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : le ? n.texSubImage2D(34069 + Ee, Fe, 0, 0, Ve.width, Ve.height, vt, ht, Ve.data) : n.texImage2D(34069 + Ee, Fe, pt, Ve.width, Ve.height, 0, vt, ht, Ve.data)
                    }
                }
            } else {
                oe = V.mipmaps, le && Ie && (oe.length > 0 && tt++, n.texStorage2D(34067, tt, pt, we[0].width, we[0].height));
                for (let Ee = 0; Ee < 6; Ee++)
                    if (Te) {
                        le ? n.texSubImage2D(34069 + Ee, 0, 0, 0, we[Ee].width, we[Ee].height, vt, ht, we[Ee].data) : n.texImage2D(34069 + Ee, 0, pt, we[Ee].width, we[Ee].height, 0, vt, ht, we[Ee].data);
                        for (let Fe = 0; Fe < oe.length; Fe++) {
                            const ct = oe[Fe].image[Ee].image;
                            le ? n.texSubImage2D(34069 + Ee, Fe + 1, 0, 0, ct.width, ct.height, vt, ht, ct.data) : n.texImage2D(34069 + Ee, Fe + 1, pt, ct.width, ct.height, 0, vt, ht, ct.data)
                        }
                    } else {
                        le ? n.texSubImage2D(34069 + Ee, 0, 0, 0, vt, ht, we[Ee]) : n.texImage2D(34069 + Ee, 0, pt, vt, ht, we[Ee]);
                        for (let Fe = 0; Fe < oe.length; Fe++) {
                            const Ve = oe[Fe];
                            le ? n.texSubImage2D(34069 + Ee, Fe + 1, 0, 0, vt, ht, Ve.image[Ee]) : n.texImage2D(34069 + Ee, Fe + 1, pt, vt, ht, Ve.image[Ee])
                        }
                    }
            }
            A(V, nt) && T(34067), Ue.__version = ze.version, V.onUpdate && V.onUpdate(V)
        }
        K.__version = V.version
    }

    function xe(K, V, ge, Be, ze) {
        const Ue = s.convert(ge.format, ge.encoding),
            Ye = s.convert(ge.type),
            Te = M(ge.internalFormat, Ue, Ye, ge.encoding);
        r.get(V).__hasExternalTextures || (ze === 32879 || ze === 35866 ? n.texImage3D(ze, 0, Te, V.width, V.height, V.depth, 0, Ue, Ye, null) : n.texImage2D(ze, 0, Te, V.width, V.height, 0, Ue, Ye, null)), n.bindFramebuffer(36160, K), He(V) ? d.framebufferTexture2DMultisampleEXT(36160, Be, ze, r.get(ge).__webglTexture, 0, Ke(V)) : (ze === 3553 || ze >= 34069 && ze <= 34074) && t.framebufferTexture2D(36160, Be, ze, r.get(ge).__webglTexture, 0), n.bindFramebuffer(36160, null)
    }

    function be(K, V, ge) {
        if (t.bindRenderbuffer(36161, K), V.depthBuffer && !V.stencilBuffer) {
            let Be = 33189;
            if (ge || He(V)) {
                const ze = V.depthTexture;
                ze && ze.isDepthTexture && (ze.type === xl ? Be = 36012 : ze.type === Oc && (Be = 33190));
                const Ue = Ke(V);
                He(V) ? d.renderbufferStorageMultisampleEXT(36161, Ue, Be, V.width, V.height) : t.renderbufferStorageMultisample(36161, Ue, Be, V.width, V.height)
            } else t.renderbufferStorage(36161, Be, V.width, V.height);
            t.framebufferRenderbuffer(36160, 36096, 36161, K)
        } else if (V.depthBuffer && V.stencilBuffer) {
            const Be = Ke(V);
            ge && He(V) === !1 ? t.renderbufferStorageMultisample(36161, Be, 35056, V.width, V.height) : He(V) ? d.renderbufferStorageMultisampleEXT(36161, Be, 35056, V.width, V.height) : t.renderbufferStorage(36161, 34041, V.width, V.height), t.framebufferRenderbuffer(36160, 33306, 36161, K)
        } else {
            const Be = V.isWebGLMultipleRenderTargets === !0 ? V.texture : [V.texture];
            for (let ze = 0; ze < Be.length; ze++) {
                const Ue = Be[ze],
                    Ye = s.convert(Ue.format, Ue.encoding),
                    Te = s.convert(Ue.type),
                    we = M(Ue.internalFormat, Ye, Te, Ue.encoding),
                    lt = Ke(V);
                ge && He(V) === !1 ? t.renderbufferStorageMultisample(36161, lt, we, V.width, V.height) : He(V) ? d.renderbufferStorageMultisampleEXT(36161, lt, we, V.width, V.height) : t.renderbufferStorage(36161, we, V.width, V.height)
            }
        }
        t.bindRenderbuffer(36161, null)
    }

    function he(K, V) {
        if (V && V.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(36160, K), !(V.depthTexture && V.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!r.get(V.depthTexture).__webglTexture || V.depthTexture.image.width !== V.width || V.depthTexture.image.height !== V.height) && (V.depthTexture.image.width = V.width, V.depthTexture.image.height = V.height, V.depthTexture.needsUpdate = !0), W(V.depthTexture, 0);
        const Be = r.get(V.depthTexture).__webglTexture,
            ze = Ke(V);
        if (V.depthTexture.format === Qc) He(V) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Be, 0, ze) : t.framebufferTexture2D(36160, 36096, 3553, Be, 0);
        else if (V.depthTexture.format === Zd) He(V) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Be, 0, ze) : t.framebufferTexture2D(36160, 33306, 3553, Be, 0);
        else throw new Error("Unknown depthTexture format")
    }

    function me(K) {
        const V = r.get(K),
            ge = K.isWebGLCubeRenderTarget === !0;
        if (K.depthTexture && !V.__autoAllocateDepthBuffer) {
            if (ge) throw new Error("target.depthTexture not supported in Cube render targets");
            he(V.__webglFramebuffer, K)
        } else if (ge) {
            V.__webglDepthbuffer = [];
            for (let Be = 0; Be < 6; Be++) n.bindFramebuffer(36160, V.__webglFramebuffer[Be]), V.__webglDepthbuffer[Be] = t.createRenderbuffer(), be(V.__webglDepthbuffer[Be], K, !1)
        } else n.bindFramebuffer(36160, V.__webglFramebuffer), V.__webglDepthbuffer = t.createRenderbuffer(), be(V.__webglDepthbuffer, K, !1);
        n.bindFramebuffer(36160, null)
    }

    function Ce(K, V, ge) {
        const Be = r.get(K);
        V !== void 0 && xe(Be.__webglFramebuffer, K, K.texture, 36064, 3553), ge !== void 0 && me(K)
    }

    function Ne(K) {
        const V = K.texture,
            ge = r.get(K),
            Be = r.get(V);
        K.addEventListener("dispose", H), K.isWebGLMultipleRenderTargets !== !0 && (Be.__webglTexture === void 0 && (Be.__webglTexture = t.createTexture()), Be.__version = V.version, o.memory.textures++);
        const ze = K.isWebGLCubeRenderTarget === !0,
            Ue = K.isWebGLMultipleRenderTargets === !0,
            Ye = S(K) || a;
        if (ze) {
            ge.__webglFramebuffer = [];
            for (let Te = 0; Te < 6; Te++) ge.__webglFramebuffer[Te] = t.createFramebuffer()
        } else {
            if (ge.__webglFramebuffer = t.createFramebuffer(), Ue)
                if (i.drawBuffers) {
                    const Te = K.texture;
                    for (let we = 0, lt = Te.length; we < lt; we++) {
                        const nt = r.get(Te[we]);
                        nt.__webglTexture === void 0 && (nt.__webglTexture = t.createTexture(), o.memory.textures++)
                    }
                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && K.samples > 0 && He(K) === !1) {
                const Te = Ue ? V : [V];
                ge.__webglMultisampledFramebuffer = t.createFramebuffer(), ge.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, ge.__webglMultisampledFramebuffer);
                for (let we = 0; we < Te.length; we++) {
                    const lt = Te[we];
                    ge.__webglColorRenderbuffer[we] = t.createRenderbuffer(), t.bindRenderbuffer(36161, ge.__webglColorRenderbuffer[we]);
                    const nt = s.convert(lt.format, lt.encoding),
                        vt = s.convert(lt.type),
                        ht = M(lt.internalFormat, nt, vt, lt.encoding, K.isXRRenderTarget === !0),
                        pt = Ke(K);
                    t.renderbufferStorageMultisample(36161, pt, ht, K.width, K.height), t.framebufferRenderbuffer(36160, 36064 + we, 36161, ge.__webglColorRenderbuffer[we])
                }
                t.bindRenderbuffer(36161, null), K.depthBuffer && (ge.__webglDepthRenderbuffer = t.createRenderbuffer(), be(ge.__webglDepthRenderbuffer, K, !0)), n.bindFramebuffer(36160, null)
            }
        }
        if (ze) {
            n.bindTexture(34067, Be.__webglTexture), _e(34067, V, Ye);
            for (let Te = 0; Te < 6; Te++) xe(ge.__webglFramebuffer[Te], K, V, 36064, 34069 + Te);
            A(V, Ye) && T(34067), n.unbindTexture()
        } else if (Ue) {
            const Te = K.texture;
            for (let we = 0, lt = Te.length; we < lt; we++) {
                const nt = Te[we],
                    vt = r.get(nt);
                n.bindTexture(3553, vt.__webglTexture), _e(3553, nt, Ye), xe(ge.__webglFramebuffer, K, nt, 36064 + we, 3553), A(nt, Ye) && T(3553)
            }
            n.unbindTexture()
        } else {
            let Te = 3553;
            (K.isWebGL3DRenderTarget || K.isWebGLArrayRenderTarget) && (a ? Te = K.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(Te, Be.__webglTexture), _e(Te, V, Ye), xe(ge.__webglFramebuffer, K, V, 36064, Te), A(V, Ye) && T(Te), n.unbindTexture()
        }
        K.depthBuffer && me(K)
    }

    function De(K) {
        const V = S(K) || a,
            ge = K.isWebGLMultipleRenderTargets === !0 ? K.texture : [K.texture];
        for (let Be = 0, ze = ge.length; Be < ze; Be++) {
            const Ue = ge[Be];
            if (A(Ue, V)) {
                const Ye = K.isWebGLCubeRenderTarget ? 34067 : 3553,
                    Te = r.get(Ue).__webglTexture;
                n.bindTexture(Ye, Te), T(Ye), n.unbindTexture()
            }
        }
    }

    function je(K) {
        if (a && K.samples > 0 && He(K) === !1) {
            const V = K.isWebGLMultipleRenderTargets ? K.texture : [K.texture],
                ge = K.width,
                Be = K.height;
            let ze = 16384;
            const Ue = [],
                Ye = K.stencilBuffer ? 33306 : 36096,
                Te = r.get(K),
                we = K.isWebGLMultipleRenderTargets === !0;
            if (we)
                for (let lt = 0; lt < V.length; lt++) n.bindFramebuffer(36160, Te.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + lt, 36161, null), n.bindFramebuffer(36160, Te.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + lt, 3553, null, 0);
            n.bindFramebuffer(36008, Te.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, Te.__webglFramebuffer);
            for (let lt = 0; lt < V.length; lt++) {
                Ue.push(36064 + lt), K.depthBuffer && Ue.push(Ye);
                const nt = Te.__ignoreDepthValues !== void 0 ? Te.__ignoreDepthValues : !1;
                if (nt === !1 && (K.depthBuffer && (ze |= 256), K.stencilBuffer && (ze |= 1024)), we && t.framebufferRenderbuffer(36008, 36064, 36161, Te.__webglColorRenderbuffer[lt]), nt === !0 && (t.invalidateFramebuffer(36008, [Ye]), t.invalidateFramebuffer(36009, [Ye])), we) {
                    const vt = r.get(V[lt]).__webglTexture;
                    t.framebufferTexture2D(36009, 36064, 3553, vt, 0)
                }
                t.blitFramebuffer(0, 0, ge, Be, 0, 0, ge, Be, ze, 9728), p && t.invalidateFramebuffer(36008, Ue)
            }
            if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), we)
                for (let lt = 0; lt < V.length; lt++) {
                    n.bindFramebuffer(36160, Te.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064 + lt, 36161, Te.__webglColorRenderbuffer[lt]);
                    const nt = r.get(V[lt]).__webglTexture;
                    n.bindFramebuffer(36160, Te.__webglFramebuffer), t.framebufferTexture2D(36009, 36064 + lt, 3553, nt, 0)
                }
            n.bindFramebuffer(36009, Te.__webglMultisampledFramebuffer)
        }
    }

    function Ke(K) {
        return Math.min(f, K.samples)
    }

    function He(K) {
        const V = r.get(K);
        return a && K.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && V.__useRenderToTexture !== !1
    }

    function qe(K) {
        const V = o.render.frame;
        m.get(K) !== V && (m.set(K, V), K.update())
    }

    function Xe(K, V) {
        const ge = K.encoding,
            Be = K.format,
            ze = K.type;
        return K.isCompressedTexture === !0 || K.isVideoTexture === !0 || K.format === Lw || ge !== Lu && (ge === Xn ? a === !1 ? e.has("EXT_sRGB") === !0 && Be === Ns ? (K.format = Lw, K.minFilter = fr, K.generateMipmaps = !1) : V = pL.sRGBToLinear(V) : (Be !== Ns || ze !== Du) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", ge)), V
    }
    this.allocateTextureUnit = F, this.resetTextureUnits = Q, this.setTexture2D = W, this.setTexture2DArray = se, this.setTexture3D = ee, this.setTextureCube = ae, this.rebindTextures = Ce, this.setupRenderTarget = Ne, this.updateRenderTargetMipmap = De, this.updateMultisampleRenderTarget = je, this.setupDepthRenderbuffer = me, this.setupFrameBufferTexture = xe, this.useMultisampledRTT = He
}

function vW(t, e, n) {
    const r = n.isWebGL2;

    function i(s, o = null) {
        let a;
        if (s === Du) return 5121;
        if (s === Hj) return 32819;
        if (s === Uj) return 32820;
        if (s === Fj) return 5120;
        if (s === Nj) return 5122;
        if (s === lL) return 5123;
        if (s === zj) return 5124;
        if (s === Oc) return 5125;
        if (s === xl) return 5126;
        if (s === Qd) return r ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
        if (s === $j) return 6406;
        if (s === Ns) return 6408;
        if (s === Gj) return 6409;
        if (s === Vj) return 6410;
        if (s === Qc) return 6402;
        if (s === Zd) return 34041;
        if (s === Lw) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === jj) return 6403;
        if (s === Wj) return 36244;
        if (s === Kj) return 33319;
        if (s === qj) return 33320;
        if (s === Xj) return 36249;
        if (s === vS || s === bS || s === xS || s === _S)
            if (o === Xn)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
                    if (s === vS) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === bS) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === xS) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === _S) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else return null;
        else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
            if (s === vS) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (s === bS) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (s === xS) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (s === _S) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null;
        if (s === ZI || s === e3 || s === t3 || s === n3)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
                if (s === ZI) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === e3) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === t3) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === n3) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
        if (s === Jj) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === r3 || s === i3)
            if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
                if (s === r3) return o === Xn ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === i3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
        if (s === s3 || s === o3 || s === a3 || s === l3 || s === u3 || s === c3 || s === f3 || s === d3 || s === p3 || s === h3 || s === m3 || s === g3 || s === y3 || s === v3)
            if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
                if (s === s3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === o3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === a3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === l3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === u3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === c3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === f3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === d3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === p3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === h3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === m3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === g3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === y3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === v3) return o === Xn ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
        if (s === SS)
            if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
                if (s === SS) return o === Xn ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else return null;
        if (s === Yj || s === b3 || s === x3 || s === _3)
            if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
                if (s === SS) return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === b3) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === x3) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === _3) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
        return s === Ld ? r ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : t[s] !== void 0 ? t[s] : null
    }
    return {
        convert: i
    }
}
class bW extends dr {
    constructor(e = []) {
        super(), this.isArrayCamera = !0, this.cameras = e
    }
}
let Su = class extends Tn {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
};
const xhe = {
    type: "move"
};
class eT {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Su, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Su, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new J, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new J), this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Su, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new J, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new J), this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
    }
    connect(e) {
        if (e && e.hand) {
            const n = this._hand;
            if (n)
                for (const r of e.hand.values()) this._getHandJoint(n, r)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }), this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(e, n, r) {
        let i = null,
            s = null,
            o = null;
        const a = this._targetRay,
            l = this._grip,
            u = this._hand;
        if (e && n.session.visibilityState !== "visible-blurred") {
            if (u && e.hand) {
                o = !0;
                for (const y of e.hand.values()) {
                    const v = n.getJointPose(y, r),
                        b = this._getHandJoint(u, y);
                    v !== null && (b.matrix.fromArray(v.transform.matrix), b.matrix.decompose(b.position, b.rotation, b.scale), b.jointRadius = v.radius), b.visible = v !== null
                }
                const c = u.joints["index-finger-tip"],
                    f = u.joints["thumb-tip"],
                    d = c.position.distanceTo(f.position),
                    p = .02,
                    m = .005;
                u.inputState.pinching && d > p + m ? (u.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !u.inputState.pinching && d <= p - m && (u.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else l !== null && e.gripSpace && (s = n.getPose(e.gripSpace, r), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = n.getPose(e.targetRaySpace, r), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(xhe)))
        }
        return a !== null && (a.visible = i !== null), l !== null && (l.visible = s !== null), u !== null && (u.visible = o !== null), this
    }
    _getHandJoint(e, n) {
        if (e.joints[n.jointName] === void 0) {
            const r = new Su;
            r.matrixAutoUpdate = !1, r.visible = !1, e.joints[n.jointName] = r, e.add(r)
        }
        return e.joints[n.jointName]
    }
}
class xL extends Sr {
    constructor(e, n, r, i, s, o, a, l, u, c) {
        if (c = c !== void 0 ? c : Qc, c !== Qc && c !== Zd) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        r === void 0 && c === Qc && (r = Oc), r === void 0 && c === Zd && (r = Ld), super(null, i, s, o, a, l, c, r, u), this.isDepthTexture = !0, this.image = {
            width: e,
            height: n
        }, this.magFilter = a !== void 0 ? a : Br, this.minFilter = l !== void 0 ? l : Br, this.flipY = !1, this.generateMipmaps = !1
    }
}
class _he extends Bl {
    constructor(e, n) {
        super();
        const r = this;
        let i = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            u = null,
            c = null,
            f = null,
            d = null,
            p = null,
            m = null;
        const y = n.getContextAttributes();
        let v = null,
            b = null;
        const _ = [],
            x = [],
            S = new Set,
            E = new Map,
            A = new dr;
        A.layers.enable(1), A.viewport = new In;
        const T = new dr;
        T.layers.enable(2), T.viewport = new In;
        const M = [A, T],
            I = new bW;
        I.layers.enable(1), I.layers.enable(2);
        let O = null,
            k = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ee) {
            let ae = _[ee];
            return ae === void 0 && (ae = new eT, _[ee] = ae), ae.getTargetRaySpace()
        }, this.getControllerGrip = function(ee) {
            let ae = _[ee];
            return ae === void 0 && (ae = new eT, _[ee] = ae), ae.getGripSpace()
        }, this.getHand = function(ee) {
            let ae = _[ee];
            return ae === void 0 && (ae = new eT, _[ee] = ae), ae.getHandSpace()
        };

        function H(ee) {
            const ae = x.indexOf(ee.inputSource);
            if (ae === -1) return;
            const de = _[ae];
            de !== void 0 && de.dispatchEvent({
                type: ee.type,
                data: ee.inputSource
            })
        }

        function N() {
            i.removeEventListener("select", H), i.removeEventListener("selectstart", H), i.removeEventListener("selectend", H), i.removeEventListener("squeeze", H), i.removeEventListener("squeezestart", H), i.removeEventListener("squeezeend", H), i.removeEventListener("end", N), i.removeEventListener("inputsourceschange", B);
            for (let ee = 0; ee < _.length; ee++) {
                const ae = x[ee];
                ae !== null && (x[ee] = null, _[ee].disconnect(ae))
            }
            O = null, k = null, e.setRenderTarget(v), p = null, d = null, f = null, i = null, b = null, se.stop(), r.isPresenting = !1, r.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(ee) {
            s = ee, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(ee) {
            a = ee, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return u || o
        }, this.setReferenceSpace = function(ee) {
            u = ee
        }, this.getBaseLayer = function() {
            return d !== null ? d : p
        }, this.getBinding = function() {
            return f
        }, this.getFrame = function() {
            return m
        }, this.getSession = function() {
            return i
        }, this.setSession = async function(ee) {
            if (i = ee, i !== null) {
                if (v = e.getRenderTarget(), i.addEventListener("select", H), i.addEventListener("selectstart", H), i.addEventListener("selectend", H), i.addEventListener("squeeze", H), i.addEventListener("squeezestart", H), i.addEventListener("squeezeend", H), i.addEventListener("end", N), i.addEventListener("inputsourceschange", B), y.xrCompatible !== !0 && await n.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const ae = {
                        antialias: i.renderState.layers === void 0 ? y.antialias : !0,
                        alpha: y.alpha,
                        depth: y.depth,
                        stencil: y.stencil,
                        framebufferScaleFactor: s
                    };
                    p = new XRWebGLLayer(i, n, ae), i.updateRenderState({
                        baseLayer: p
                    }), b = new na(p.framebufferWidth, p.framebufferHeight, {
                        format: Ns,
                        type: Du,
                        encoding: e.outputEncoding,
                        stencilBuffer: y.stencil
                    })
                } else {
                    let ae = null,
                        de = null,
                        re = null;
                    y.depth && (re = y.stencil ? 35056 : 33190, ae = y.stencil ? Zd : Qc, de = y.stencil ? Ld : Oc);
                    const _e = {
                        colorFormat: 32856,
                        depthFormat: re,
                        scaleFactor: s
                    };
                    f = new XRWebGLBinding(i, n), d = f.createProjectionLayer(_e), i.updateRenderState({
                        layers: [d]
                    }), b = new na(d.textureWidth, d.textureHeight, {
                        format: Ns,
                        type: Du,
                        depthTexture: new xL(d.textureWidth, d.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, ae),
                        stencilBuffer: y.stencil,
                        encoding: e.outputEncoding,
                        samples: y.antialias ? 4 : 0
                    });
                    const fe = e.properties.get(b);
                    fe.__ignoreDepthValues = d.ignoreDepthValues
                }
                b.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await i.requestReferenceSpace(a), se.setContext(i), se.start(), r.isPresenting = !0, r.dispatchEvent({
                    type: "sessionstart"
                })
            }
        };

        function B(ee) {
            for (let ae = 0; ae < ee.removed.length; ae++) {
                const de = ee.removed[ae],
                    re = x.indexOf(de);
                re >= 0 && (x[re] = null, _[re].disconnect(de))
            }
            for (let ae = 0; ae < ee.added.length; ae++) {
                const de = ee.added[ae];
                let re = x.indexOf(de);
                if (re === -1) {
                    for (let fe = 0; fe < _.length; fe++)
                        if (fe >= x.length) {
                            x.push(de), re = fe;
                            break
                        } else if (x[fe] === null) {
                        x[fe] = de, re = fe;
                        break
                    }
                    if (re === -1) break
                }
                const _e = _[re];
                _e && _e.connect(de)
            }
        }
        const U = new J,
            q = new J;

        function Q(ee, ae, de) {
            U.setFromMatrixPosition(ae.matrixWorld), q.setFromMatrixPosition(de.matrixWorld);
            const re = U.distanceTo(q),
                _e = ae.projectionMatrix.elements,
                fe = de.projectionMatrix.elements,
                ue = _e[14] / (_e[10] - 1),
                ve = _e[14] / (_e[10] + 1),
                xe = (_e[9] + 1) / _e[5],
                be = (_e[9] - 1) / _e[5],
                he = (_e[8] - 1) / _e[0],
                me = (fe[8] + 1) / fe[0],
                Ce = ue * he,
                Ne = ue * me,
                De = re / (-he + me),
                je = De * -he;
            ae.matrixWorld.decompose(ee.position, ee.quaternion, ee.scale), ee.translateX(je), ee.translateZ(De), ee.matrixWorld.compose(ee.position, ee.quaternion, ee.scale), ee.matrixWorldInverse.copy(ee.matrixWorld).invert();
            const Ke = ue + De,
                He = ve + De,
                qe = Ce - je,
                Xe = Ne + (re - je),
                K = xe * ve / He * Ke,
                V = be * ve / He * Ke;
            ee.projectionMatrix.makePerspective(qe, Xe, K, V, Ke, He)
        }

        function F(ee, ae) {
            ae === null ? ee.matrixWorld.copy(ee.matrix) : ee.matrixWorld.multiplyMatrices(ae.matrixWorld, ee.matrix), ee.matrixWorldInverse.copy(ee.matrixWorld).invert()
        }
        this.updateCamera = function(ee) {
            if (i === null) return;
            I.near = T.near = A.near = ee.near, I.far = T.far = A.far = ee.far, (O !== I.near || k !== I.far) && (i.updateRenderState({
                depthNear: I.near,
                depthFar: I.far
            }), O = I.near, k = I.far);
            const ae = ee.parent,
                de = I.cameras;
            F(I, ae);
            for (let _e = 0; _e < de.length; _e++) F(de[_e], ae);
            I.matrixWorld.decompose(I.position, I.quaternion, I.scale), ee.matrix.copy(I.matrix), ee.matrix.decompose(ee.position, ee.quaternion, ee.scale);
            const re = ee.children;
            for (let _e = 0, fe = re.length; _e < fe; _e++) re[_e].updateMatrixWorld(!0);
            de.length === 2 ? Q(I, A, T) : I.projectionMatrix.copy(A.projectionMatrix)
        }, this.getCamera = function() {
            return I
        }, this.getFoveation = function() {
            if (!(d === null && p === null)) return l
        }, this.setFoveation = function(ee) {
            l = ee, d !== null && (d.fixedFoveation = ee), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = ee)
        }, this.getPlanes = function() {
            return S
        };
        let G = null;

        function W(ee, ae) {
            if (c = ae.getViewerPose(u || o), m = ae, c !== null) {
                const de = c.views;
                p !== null && (e.setRenderTargetFramebuffer(b, p.framebuffer), e.setRenderTarget(b));
                let re = !1;
                de.length !== I.cameras.length && (I.cameras.length = 0, re = !0);
                for (let _e = 0; _e < de.length; _e++) {
                    const fe = de[_e];
                    let ue = null;
                    if (p !== null) ue = p.getViewport(fe);
                    else {
                        const xe = f.getViewSubImage(d, fe);
                        ue = xe.viewport, _e === 0 && (e.setRenderTargetTextures(b, xe.colorTexture, d.ignoreDepthValues ? void 0 : xe.depthStencilTexture), e.setRenderTarget(b))
                    }
                    let ve = M[_e];
                    ve === void 0 && (ve = new dr, ve.layers.enable(_e), ve.viewport = new In, M[_e] = ve), ve.matrix.fromArray(fe.transform.matrix), ve.projectionMatrix.fromArray(fe.projectionMatrix), ve.viewport.set(ue.x, ue.y, ue.width, ue.height), _e === 0 && I.matrix.copy(ve.matrix), re === !0 && I.cameras.push(ve)
                }
            }
            for (let de = 0; de < _.length; de++) {
                const re = x[de],
                    _e = _[de];
                re !== null && _e !== void 0 && _e.update(re, ae, u || o)
            }
            if (G && G(ee, ae), ae.detectedPlanes) {
                r.dispatchEvent({
                    type: "planesdetected",
                    data: ae.detectedPlanes
                });
                let de = null;
                for (const re of S) ae.detectedPlanes.has(re) || (de === null && (de = []), de.push(re));
                if (de !== null)
                    for (const re of de) S.delete(re), E.delete(re), r.dispatchEvent({
                        type: "planeremoved",
                        data: re
                    });
                for (const re of ae.detectedPlanes)
                    if (!S.has(re)) S.add(re), E.set(re, ae.lastChangedTime), r.dispatchEvent({
                        type: "planeadded",
                        data: re
                    });
                    else {
                        const _e = E.get(re);
                        re.lastChangedTime > _e && (E.set(re, re.lastChangedTime), r.dispatchEvent({
                            type: "planechanged",
                            data: re
                        }))
                    }
            }
            m = null
        }
        const se = new pW;
        se.setAnimationLoop(W), this.setAnimationLoop = function(ee) {
            G = ee
        }, this.dispose = function() {}
    }
}

function She(t, e) {
    function n(y, v) {
        v.color.getRGB(y.fogColor.value, cW(t)), v.isFog ? (y.fogNear.value = v.near, y.fogFar.value = v.far) : v.isFogExp2 && (y.fogDensity.value = v.density)
    }

    function r(y, v, b, _, x) {
        v.isMeshBasicMaterial || v.isMeshLambertMaterial ? i(y, v) : v.isMeshToonMaterial ? (i(y, v), c(y, v)) : v.isMeshPhongMaterial ? (i(y, v), u(y, v)) : v.isMeshStandardMaterial ? (i(y, v), f(y, v), v.isMeshPhysicalMaterial && d(y, v, x)) : v.isMeshMatcapMaterial ? (i(y, v), p(y, v)) : v.isMeshDepthMaterial ? i(y, v) : v.isMeshDistanceMaterial ? (i(y, v), m(y, v)) : v.isMeshNormalMaterial ? i(y, v) : v.isLineBasicMaterial ? (s(y, v), v.isLineDashedMaterial && o(y, v)) : v.isPointsMaterial ? a(y, v, b, _) : v.isSpriteMaterial ? l(y, v) : v.isShadowMaterial ? (y.color.value.copy(v.color), y.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1)
    }

    function i(y, v) {
        y.opacity.value = v.opacity, v.color && y.diffuse.value.copy(v.color), v.emissive && y.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (y.map.value = v.map), v.alphaMap && (y.alphaMap.value = v.alphaMap), v.bumpMap && (y.bumpMap.value = v.bumpMap, y.bumpScale.value = v.bumpScale, v.side === Vs && (y.bumpScale.value *= -1)), v.displacementMap && (y.displacementMap.value = v.displacementMap, y.displacementScale.value = v.displacementScale, y.displacementBias.value = v.displacementBias), v.emissiveMap && (y.emissiveMap.value = v.emissiveMap), v.normalMap && (y.normalMap.value = v.normalMap, y.normalScale.value.copy(v.normalScale), v.side === Vs && y.normalScale.value.negate()), v.specularMap && (y.specularMap.value = v.specularMap), v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
        const b = e.get(v).envMap;
        if (b && (y.envMap.value = b, y.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = v.reflectivity, y.ior.value = v.ior, y.refractionRatio.value = v.refractionRatio), v.lightMap) {
            y.lightMap.value = v.lightMap;
            const S = t.useLegacyLights === !0 ? Math.PI : 1;
            y.lightMapIntensity.value = v.lightMapIntensity * S
        }
        v.aoMap && (y.aoMap.value = v.aoMap, y.aoMapIntensity.value = v.aoMapIntensity);
        let _;
        v.map ? _ = v.map : v.specularMap ? _ = v.specularMap : v.displacementMap ? _ = v.displacementMap : v.normalMap ? _ = v.normalMap : v.bumpMap ? _ = v.bumpMap : v.roughnessMap ? _ = v.roughnessMap : v.metalnessMap ? _ = v.metalnessMap : v.alphaMap ? _ = v.alphaMap : v.emissiveMap ? _ = v.emissiveMap : v.clearcoatMap ? _ = v.clearcoatMap : v.clearcoatNormalMap ? _ = v.clearcoatNormalMap : v.clearcoatRoughnessMap ? _ = v.clearcoatRoughnessMap : v.iridescenceMap ? _ = v.iridescenceMap : v.iridescenceThicknessMap ? _ = v.iridescenceThicknessMap : v.specularIntensityMap ? _ = v.specularIntensityMap : v.specularColorMap ? _ = v.specularColorMap : v.transmissionMap ? _ = v.transmissionMap : v.thicknessMap ? _ = v.thicknessMap : v.sheenColorMap ? _ = v.sheenColorMap : v.sheenRoughnessMap && (_ = v.sheenRoughnessMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), y.uvTransform.value.copy(_.matrix));
        let x;
        v.aoMap ? x = v.aoMap : v.lightMap && (x = v.lightMap), x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture), x.matrixAutoUpdate === !0 && x.updateMatrix(), y.uv2Transform.value.copy(x.matrix))
    }

    function s(y, v) {
        y.diffuse.value.copy(v.color), y.opacity.value = v.opacity
    }

    function o(y, v) {
        y.dashSize.value = v.dashSize, y.totalSize.value = v.dashSize + v.gapSize, y.scale.value = v.scale
    }

    function a(y, v, b, _) {
        y.diffuse.value.copy(v.color), y.opacity.value = v.opacity, y.size.value = v.size * b, y.scale.value = _ * .5, v.map && (y.map.value = v.map), v.alphaMap && (y.alphaMap.value = v.alphaMap), v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
        let x;
        v.map ? x = v.map : v.alphaMap && (x = v.alphaMap), x !== void 0 && (x.matrixAutoUpdate === !0 && x.updateMatrix(), y.uvTransform.value.copy(x.matrix))
    }

    function l(y, v) {
        y.diffuse.value.copy(v.color), y.opacity.value = v.opacity, y.rotation.value = v.rotation, v.map && (y.map.value = v.map), v.alphaMap && (y.alphaMap.value = v.alphaMap), v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
        let b;
        v.map ? b = v.map : v.alphaMap && (b = v.alphaMap), b !== void 0 && (b.matrixAutoUpdate === !0 && b.updateMatrix(), y.uvTransform.value.copy(b.matrix))
    }

    function u(y, v) {
        y.specular.value.copy(v.specular), y.shininess.value = Math.max(v.shininess, 1e-4)
    }

    function c(y, v) {
        v.gradientMap && (y.gradientMap.value = v.gradientMap)
    }

    function f(y, v) {
        y.roughness.value = v.roughness, y.metalness.value = v.metalness, v.roughnessMap && (y.roughnessMap.value = v.roughnessMap), v.metalnessMap && (y.metalnessMap.value = v.metalnessMap), e.get(v).envMap && (y.envMapIntensity.value = v.envMapIntensity)
    }

    function d(y, v, b) {
        y.ior.value = v.ior, v.sheen > 0 && (y.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), y.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (y.sheenColorMap.value = v.sheenColorMap), v.sheenRoughnessMap && (y.sheenRoughnessMap.value = v.sheenRoughnessMap)), v.clearcoat > 0 && (y.clearcoat.value = v.clearcoat, y.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (y.clearcoatMap.value = v.clearcoatMap), v.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap), v.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), y.clearcoatNormalMap.value = v.clearcoatNormalMap, v.side === Vs && y.clearcoatNormalScale.value.negate())), v.iridescence > 0 && (y.iridescence.value = v.iridescence, y.iridescenceIOR.value = v.iridescenceIOR, y.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (y.iridescenceMap.value = v.iridescenceMap), v.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = v.iridescenceThicknessMap)), v.transmission > 0 && (y.transmission.value = v.transmission, y.transmissionSamplerMap.value = b.texture, y.transmissionSamplerSize.value.set(b.width, b.height), v.transmissionMap && (y.transmissionMap.value = v.transmissionMap), y.thickness.value = v.thickness, v.thicknessMap && (y.thicknessMap.value = v.thicknessMap), y.attenuationDistance.value = v.attenuationDistance, y.attenuationColor.value.copy(v.attenuationColor)), y.specularIntensity.value = v.specularIntensity, y.specularColor.value.copy(v.specularColor), v.specularIntensityMap && (y.specularIntensityMap.value = v.specularIntensityMap), v.specularColorMap && (y.specularColorMap.value = v.specularColorMap)
    }

    function p(y, v) {
        v.matcap && (y.matcap.value = v.matcap)
    }

    function m(y, v) {
        y.referencePosition.value.copy(v.referencePosition), y.nearDistance.value = v.nearDistance, y.farDistance.value = v.farDistance
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: r
    }
}

function whe(t, e, n, r) {
    let i = {},
        s = {},
        o = [];
    const a = n.isWebGL2 ? t.getParameter(35375) : 0;

    function l(_, x) {
        const S = x.program;
        r.uniformBlockBinding(_, S)
    }

    function u(_, x) {
        let S = i[_.id];
        S === void 0 && (m(_), S = c(_), i[_.id] = S, _.addEventListener("dispose", v));
        const E = x.program;
        r.updateUBOMapping(_, E);
        const A = e.render.frame;
        s[_.id] !== A && (d(_), s[_.id] = A)
    }

    function c(_) {
        const x = f();
        _.__bindingPointIndex = x;
        const S = t.createBuffer(),
            E = _.__size,
            A = _.usage;
        return t.bindBuffer(35345, S), t.bufferData(35345, E, A), t.bindBuffer(35345, null), t.bindBufferBase(35345, x, S), S
    }

    function f() {
        for (let _ = 0; _ < a; _++)
            if (o.indexOf(_) === -1) return o.push(_), _;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function d(_) {
        const x = i[_.id],
            S = _.uniforms,
            E = _.__cache;
        t.bindBuffer(35345, x);
        for (let A = 0, T = S.length; A < T; A++) {
            const M = S[A];
            if (p(M, A, E) === !0) {
                const I = M.__offset,
                    O = Array.isArray(M.value) ? M.value : [M.value];
                let k = 0;
                for (let H = 0; H < O.length; H++) {
                    const N = O[H],
                        B = y(N);
                    typeof N == "number" ? (M.__data[0] = N, t.bufferSubData(35345, I + k, M.__data)) : N.isMatrix3 ? (M.__data[0] = N.elements[0], M.__data[1] = N.elements[1], M.__data[2] = N.elements[2], M.__data[3] = N.elements[0], M.__data[4] = N.elements[3], M.__data[5] = N.elements[4], M.__data[6] = N.elements[5], M.__data[7] = N.elements[0], M.__data[8] = N.elements[6], M.__data[9] = N.elements[7], M.__data[10] = N.elements[8], M.__data[11] = N.elements[0]) : (N.toArray(M.__data, k), k += B.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                t.bufferSubData(35345, I, M.__data)
            }
        }
        t.bindBuffer(35345, null)
    }

    function p(_, x, S) {
        const E = _.value;
        if (S[x] === void 0) {
            if (typeof E == "number") S[x] = E;
            else {
                const A = Array.isArray(E) ? E : [E],
                    T = [];
                for (let M = 0; M < A.length; M++) T.push(A[M].clone());
                S[x] = T
            }
            return !0
        } else if (typeof E == "number") {
            if (S[x] !== E) return S[x] = E, !0
        } else {
            const A = Array.isArray(S[x]) ? S[x] : [S[x]],
                T = Array.isArray(E) ? E : [E];
            for (let M = 0; M < A.length; M++) {
                const I = A[M];
                if (I.equals(T[M]) === !1) return I.copy(T[M]), !0
            }
        }
        return !1
    }

    function m(_) {
        const x = _.uniforms;
        let S = 0;
        const E = 16;
        let A = 0;
        for (let T = 0, M = x.length; T < M; T++) {
            const I = x[T],
                O = {
                    boundary: 0,
                    storage: 0
                },
                k = Array.isArray(I.value) ? I.value : [I.value];
            for (let H = 0, N = k.length; H < N; H++) {
                const B = k[H],
                    U = y(B);
                O.boundary += U.boundary, O.storage += U.storage
            }
            if (I.__data = new Float32Array(O.storage / Float32Array.BYTES_PER_ELEMENT), I.__offset = S, T > 0) {
                A = S % E;
                const H = E - A;
                A !== 0 && H - O.boundary < 0 && (S += E - A, I.__offset = S)
            }
            S += O.storage
        }
        return A = S % E, A > 0 && (S += E - A), _.__size = S, _.__cache = {}, this
    }

    function y(_) {
        const x = {
            boundary: 0,
            storage: 0
        };
        return typeof _ == "number" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x
    }

    function v(_) {
        const x = _.target;
        x.removeEventListener("dispose", v);
        const S = o.indexOf(x.__bindingPointIndex);
        o.splice(S, 1), t.deleteBuffer(i[x.id]), delete i[x.id], delete s[x.id]
    }

    function b() {
        for (const _ in i) t.deleteBuffer(i[_]);
        o = [], i = {}, s = {}
    }
    return {
        bind: l,
        update: u,
        dispose: b
    }
}

function Ehe() {
    const t = f0("canvas");
    return t.style.display = "block", t
}

function zE(t = {}) {
    this.isWebGLRenderer = !0;
    const e = t.canvas !== void 0 ? t.canvas : Ehe(),
        n = t.context !== void 0 ? t.context : null,
        r = t.depth !== void 0 ? t.depth : !0,
        i = t.stencil !== void 0 ? t.stencil : !0,
        s = t.antialias !== void 0 ? t.antialias : !1,
        o = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0,
        a = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1,
        l = t.powerPreference !== void 0 ? t.powerPreference : "default",
        u = t.failIfMajorPerformanceCaveat !== void 0 ? t.failIfMajorPerformanceCaveat : !1;
    let c;
    n !== null ? c = n.getContextAttributes().alpha : c = t.alpha !== void 0 ? t.alpha : !1;
    let f = null,
        d = null;
    const p = [],
        m = [];
    this.domElement = e, this.debug = {
        checkShaderErrors: !0
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Lu, this.useLegacyLights = !0, this.toneMapping = Na, this.toneMappingExposure = 1;
    const y = this;
    let v = !1,
        b = 0,
        _ = 0,
        x = null,
        S = -1,
        E = null;
    const A = new In,
        T = new In;
    let M = null,
        I = e.width,
        O = e.height,
        k = 1,
        H = null,
        N = null;
    const B = new In(0, 0, I, O),
        U = new In(0, 0, I, O);
    let q = !1;
    const Q = new FE;
    let F = !1,
        G = !1,
        W = null;
    const se = new Gt,
        ee = new J,
        ae = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };

    function de() {
        return x === null ? k : 1
    }
    let re = n;

    function _e(D, z) {
        for (let j = 0; j < D.length; j++) {
            const X = D[j],
                te = e.getContext(X, z);
            if (te !== null) return te
        }
        return null
    }
    try {
        const D = {
            alpha: !0,
            depth: r,
            stencil: i,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: u
        };
        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${vp}`), e.addEventListener("webglcontextlost", vt, !1), e.addEventListener("webglcontextrestored", ht, !1), e.addEventListener("webglcontextcreationerror", pt, !1), re === null) {
            const z = ["webgl2", "webgl", "experimental-webgl"];
            if (y.isWebGL1Renderer === !0 && z.shift(), re = _e(z, D), re === null) throw _e(z) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        re.getShaderPrecisionFormat === void 0 && (re.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        })
    } catch (D) {
        throw console.error("THREE.WebGLRenderer: " + D.message), D
    }
    let fe, ue, ve, xe, be, he, me, Ce, Ne, De, je, Ke, He, qe, Xe, K, V, ge, Be, ze, Ue, Ye, Te, we;

    function lt() {
        fe = new Hde(re), ue = new Lde(re, fe, t), fe.init(ue), Ye = new vW(re, fe, ue), ve = new vhe(re, fe, ue), xe = new Gde, be = new ohe, he = new bhe(re, fe, ve, be, ue, Ye, xe), me = new Bde(y), Ce = new zde(y), Ne = new Que(re, ue), Te = new Ode(re, fe, Ne, ue), De = new Ude(re, Ne, xe, Te), je = new Kde(re, De, Ne, xe), Be = new Wde(re, ue, he), K = new kde(be), Ke = new she(y, me, Ce, fe, ue, Te, K), He = new She(y, be), qe = new lhe, Xe = new hhe(fe, ue), ge = new Rde(y, me, Ce, ve, je, c, o), V = new yhe(y, je, ue), we = new whe(re, xe, ue, ve), ze = new Dde(re, fe, xe, ue), Ue = new $de(re, fe, xe, ue), xe.programs = Ke.programs, y.capabilities = ue, y.extensions = fe, y.properties = be, y.renderLists = qe, y.shadowMap = V, y.state = ve, y.info = xe
    }
    lt();
    const nt = new _he(y, re);
    this.xr = nt, this.getContext = function() {
        return re
    }, this.getContextAttributes = function() {
        return re.getContextAttributes()
    }, this.forceContextLoss = function() {
        const D = fe.get("WEBGL_lose_context");
        D && D.loseContext()
    }, this.forceContextRestore = function() {
        const D = fe.get("WEBGL_lose_context");
        D && D.restoreContext()
    }, this.getPixelRatio = function() {
        return k
    }, this.setPixelRatio = function(D) {
        D !== void 0 && (k = D, this.setSize(I, O, !1))
    }, this.getSize = function(D) {
        return D.set(I, O)
    }, this.setSize = function(D, z, j = !0) {
        if (nt.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        I = D, O = z, e.width = Math.floor(D * k), e.height = Math.floor(z * k), j === !0 && (e.style.width = D + "px", e.style.height = z + "px"), this.setViewport(0, 0, D, z)
    }, this.getDrawingBufferSize = function(D) {
        return D.set(I * k, O * k).floor()
    }, this.setDrawingBufferSize = function(D, z, j) {
        I = D, O = z, k = j, e.width = Math.floor(D * j), e.height = Math.floor(z * j), this.setViewport(0, 0, D, z)
    }, this.getCurrentViewport = function(D) {
        return D.copy(A)
    }, this.getViewport = function(D) {
        return D.copy(B)
    }, this.setViewport = function(D, z, j, X) {
        D.isVector4 ? B.set(D.x, D.y, D.z, D.w) : B.set(D, z, j, X), ve.viewport(A.copy(B).multiplyScalar(k).floor())
    }, this.getScissor = function(D) {
        return D.copy(U)
    }, this.setScissor = function(D, z, j, X) {
        D.isVector4 ? U.set(D.x, D.y, D.z, D.w) : U.set(D, z, j, X), ve.scissor(T.copy(U).multiplyScalar(k).floor())
    }, this.getScissorTest = function() {
        return q
    }, this.setScissorTest = function(D) {
        ve.setScissorTest(q = D)
    }, this.setOpaqueSort = function(D) {
        H = D
    }, this.setTransparentSort = function(D) {
        N = D
    }, this.getClearColor = function(D) {
        return D.copy(ge.getClearColor())
    }, this.setClearColor = function() {
        ge.setClearColor.apply(ge, arguments)
    }, this.getClearAlpha = function() {
        return ge.getClearAlpha()
    }, this.setClearAlpha = function() {
        ge.setClearAlpha.apply(ge, arguments)
    }, this.clear = function(D = !0, z = !0, j = !0) {
        let X = 0;
        D && (X |= 16384), z && (X |= 256), j && (X |= 1024), re.clear(X)
    }, this.clearColor = function() {
        this.clear(!0, !1, !1)
    }, this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }, this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }, this.dispose = function() {
        e.removeEventListener("webglcontextlost", vt, !1), e.removeEventListener("webglcontextrestored", ht, !1), e.removeEventListener("webglcontextcreationerror", pt, !1), qe.dispose(), Xe.dispose(), be.dispose(), me.dispose(), Ce.dispose(), je.dispose(), Te.dispose(), we.dispose(), Ke.dispose(), nt.dispose(), nt.removeEventListener("sessionstart", Fe), nt.removeEventListener("sessionend", Ve), W && (W.dispose(), W = null), ct.stop()
    };

    function vt(D) {
        D.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
    }

    function ht() {
        console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
        const D = xe.autoReset,
            z = V.enabled,
            j = V.autoUpdate,
            X = V.needsUpdate,
            te = V.type;
        lt(), xe.autoReset = D, V.enabled = z, V.autoUpdate = j, V.needsUpdate = X, V.type = te
    }

    function pt(D) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", D.statusMessage)
    }

    function le(D) {
        const z = D.target;
        z.removeEventListener("dispose", le), Ie(z)
    }

    function Ie(D) {
        tt(D), be.remove(D)
    }

    function tt(D) {
        const z = be.get(D).programs;
        z !== void 0 && (z.forEach(function(j) {
            Ke.releaseProgram(j)
        }), D.isShaderMaterial && Ke.releaseShaderCache(D))
    }
    this.renderBufferDirect = function(D, z, j, X, te, Oe) {
        z === null && (z = ae);
        const $e = te.isMesh && te.matrixWorld.determinant() < 0,
            rt = Hr(D, z, j, X, te);
        ve.setMaterial(X, $e);
        let Ze = j.index,
            Tt = 1;
        X.wireframe === !0 && (Ze = De.getWireframeAttribute(j), Tt = 2);
        const st = j.drawRange,
            St = j.attributes.position;
        let Qe = st.start * Tt,
            ft = (st.start + st.count) * Tt;
        Oe !== null && (Qe = Math.max(Qe, Oe.start * Tt), ft = Math.min(ft, (Oe.start + Oe.count) * Tt)), Ze !== null ? (Qe = Math.max(Qe, 0), ft = Math.min(ft, Ze.count)) : St != null && (Qe = Math.max(Qe, 0), ft = Math.min(ft, St.count));
        const Vt = ft - Qe;
        if (Vt < 0 || Vt === 1 / 0) return;
        Te.setup(te, X, rt, j, Ze);
        let bn, Ht = ze;
        if (Ze !== null && (bn = Ne.get(Ze), Ht = Ue, Ht.setIndex(bn)), te.isMesh) X.wireframe === !0 ? (ve.setLineWidth(X.wireframeLinewidth * de()), Ht.setMode(1)) : Ht.setMode(4);
        else if (te.isLine) {
            let kt = X.linewidth;
            kt === void 0 && (kt = 1), ve.setLineWidth(kt * de()), te.isLineSegments ? Ht.setMode(1) : te.isLineLoop ? Ht.setMode(2) : Ht.setMode(3)
        } else te.isPoints ? Ht.setMode(0) : te.isSprite && Ht.setMode(4);
        if (te.isInstancedMesh) Ht.renderInstances(Qe, Vt, te.count);
        else if (j.isInstancedBufferGeometry) {
            const kt = j._maxInstanceCount !== void 0 ? j._maxInstanceCount : 1 / 0,
                nr = Math.min(j.instanceCount, kt);
            Ht.renderInstances(Qe, Vt, nr)
        } else Ht.render(Qe, Vt)
    }, this.compile = function(D, z) {
        function j(X, te, Oe) {
            X.transparent === !0 && X.side === Ra && X.forceSinglePass === !1 ? (X.side = Vs, X.needsUpdate = !0, tn(X, te, Oe), X.side = Ol, X.needsUpdate = !0, tn(X, te, Oe), X.side = Ra) : tn(X, te, Oe)
        }
        d = Xe.get(D), d.init(), m.push(d), D.traverseVisible(function(X) {
            X.isLight && X.layers.test(z.layers) && (d.pushLight(X), X.castShadow && d.pushShadow(X))
        }), d.setupLights(y.useLegacyLights), D.traverse(function(X) {
            const te = X.material;
            if (te)
                if (Array.isArray(te))
                    for (let Oe = 0; Oe < te.length; Oe++) {
                        const $e = te[Oe];
                        j($e, D, X)
                    } else j(te, D, X)
        }), m.pop(), d = null
    };
    let oe = null;

    function Ee(D) {
        oe && oe(D)
    }

    function Fe() {
        ct.stop()
    }

    function Ve() {
        ct.start()
    }
    const ct = new pW;
    ct.setAnimationLoop(Ee), typeof self < "u" && ct.setContext(self), this.setAnimationLoop = function(D) {
        oe = D, nt.setAnimationLoop(D), D === null ? ct.stop() : ct.start()
    }, nt.addEventListener("sessionstart", Fe), nt.addEventListener("sessionend", Ve), this.render = function(D, z) {
        if (z !== void 0 && z.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (v === !0) return;
        D.matrixWorldAutoUpdate === !0 && D.updateMatrixWorld(), z.parent === null && z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(), nt.enabled === !0 && nt.isPresenting === !0 && (nt.cameraAutoUpdate === !0 && nt.updateCamera(z), z = nt.getCamera()), D.isScene === !0 && D.onBeforeRender(y, D, z, x), d = Xe.get(D, m.length), d.init(), m.push(d), se.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse), Q.setFromProjectionMatrix(se), G = this.localClippingEnabled, F = K.init(this.clippingPlanes, G), f = qe.get(D, p.length), f.init(), p.push(f), bt(D, z, 0, y.sortObjects), f.finish(), y.sortObjects === !0 && f.sort(H, N), F === !0 && K.beginShadows();
        const j = d.state.shadowsArray;
        if (V.render(j, D, z), F === !0 && K.endShadows(), this.info.autoReset === !0 && this.info.reset(), ge.render(f, D), d.setupLights(y.useLegacyLights), z.isArrayCamera) {
            const X = z.cameras;
            for (let te = 0, Oe = X.length; te < Oe; te++) {
                const $e = X[te];
                Kt(f, D, $e, $e.viewport)
            }
        } else Kt(f, D, z);
        x !== null && (he.updateMultisampleRenderTarget(x), he.updateRenderTargetMipmap(x)), D.isScene === !0 && D.onAfterRender(y, D, z), Te.resetDefaultState(), S = -1, E = null, m.pop(), m.length > 0 ? d = m[m.length - 1] : d = null, p.pop(), p.length > 0 ? f = p[p.length - 1] : f = null
    };

    function bt(D, z, j, X) {
        if (D.visible === !1) return;
        if (D.layers.test(z.layers)) {
            if (D.isGroup) j = D.renderOrder;
            else if (D.isLOD) D.autoUpdate === !0 && D.update(z);
            else if (D.isLight) d.pushLight(D), D.castShadow && d.pushShadow(D);
            else if (D.isSprite) {
                if (!D.frustumCulled || Q.intersectsSprite(D)) {
                    X && ee.setFromMatrixPosition(D.matrixWorld).applyMatrix4(se);
                    const $e = je.update(D),
                        rt = D.material;
                    rt.visible && f.push(D, $e, rt, j, ee.z, null)
                }
            } else if ((D.isMesh || D.isLine || D.isPoints) && (D.isSkinnedMesh && D.skeleton.frame !== xe.render.frame && (D.skeleton.update(), D.skeleton.frame = xe.render.frame), !D.frustumCulled || Q.intersectsObject(D))) {
                X && ee.setFromMatrixPosition(D.matrixWorld).applyMatrix4(se);
                const $e = je.update(D),
                    rt = D.material;
                if (Array.isArray(rt)) {
                    const Ze = $e.groups;
                    for (let Tt = 0, st = Ze.length; Tt < st; Tt++) {
                        const St = Ze[Tt],
                            Qe = rt[St.materialIndex];
                        Qe && Qe.visible && f.push(D, $e, Qe, j, ee.z, St)
                    }
                } else rt.visible && f.push(D, $e, rt, j, ee.z, null)
            }
        }
        const Oe = D.children;
        for (let $e = 0, rt = Oe.length; $e < rt; $e++) bt(Oe[$e], z, j, X)
    }

    function Kt(D, z, j, X) {
        const te = D.opaque,
            Oe = D.transmissive,
            $e = D.transparent;
        d.setupLightsView(j), F === !0 && K.setGlobalState(y.clippingPlanes, j), Oe.length > 0 && un(te, z, j), X && ve.viewport(A.copy(X)), te.length > 0 && zt(te, z, j), Oe.length > 0 && zt(Oe, z, j), $e.length > 0 && zt($e, z, j), ve.buffers.depth.setTest(!0), ve.buffers.depth.setMask(!0), ve.buffers.color.setMask(!0), ve.setPolygonOffset(!1)
    }

    function un(D, z, j) {
        const X = ue.isWebGL2;
        W === null && (W = new na(1024, 1024, {
            generateMipmaps: !0,
            type: fe.has("EXT_color_buffer_half_float") ? Qd : Du,
            minFilter: Dl,
            samples: X && s === !0 ? 4 : 0
        }));
        const te = y.getRenderTarget();
        y.setRenderTarget(W), y.clear();
        const Oe = y.toneMapping;
        y.toneMapping = Na, zt(D, z, j), y.toneMapping = Oe, he.updateMultisampleRenderTarget(W), he.updateRenderTargetMipmap(W), y.setRenderTarget(te)
    }

    function zt(D, z, j) {
        const X = z.isScene === !0 ? z.overrideMaterial : null;
        for (let te = 0, Oe = D.length; te < Oe; te++) {
            const $e = D[te],
                rt = $e.object,
                Ze = $e.geometry,
                Tt = X === null ? $e.material : X,
                st = $e.group;
            rt.layers.test(j.layers) && Ot(rt, z, j, Ze, Tt, st)
        }
    }

    function Ot(D, z, j, X, te, Oe) {
        D.onBeforeRender(y, z, j, X, te, Oe), D.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, D.matrixWorld), D.normalMatrix.getNormalMatrix(D.modelViewMatrix), te.onBeforeRender(y, z, j, X, D, Oe), te.transparent === !0 && te.side === Ra && te.forceSinglePass === !1 ? (te.side = Vs, te.needsUpdate = !0, y.renderBufferDirect(j, z, X, te, D, Oe), te.side = Ol, te.needsUpdate = !0, y.renderBufferDirect(j, z, X, te, D, Oe), te.side = Ra) : y.renderBufferDirect(j, z, X, te, D, Oe), D.onAfterRender(y, z, j, X, te, Oe)
    }

    function tn(D, z, j) {
        z.isScene !== !0 && (z = ae);
        const X = be.get(D),
            te = d.state.lights,
            Oe = d.state.shadowsArray,
            $e = te.state.version,
            rt = Ke.getParameters(D, te.state, Oe, z, j),
            Ze = Ke.getProgramCacheKey(rt);
        let Tt = X.programs;
        X.environment = D.isMeshStandardMaterial ? z.environment : null, X.fog = z.fog, X.envMap = (D.isMeshStandardMaterial ? Ce : me).get(D.envMap || X.environment), Tt === void 0 && (D.addEventListener("dispose", le), Tt = new Map, X.programs = Tt);
        let st = Tt.get(Ze);
        if (st !== void 0) {
            if (X.currentProgram === st && X.lightsStateVersion === $e) return Xt(D, rt), st
        } else rt.uniforms = Ke.getUniforms(D), D.onBuild(j, rt, y), D.onBeforeCompile(rt, y), st = Ke.acquireProgram(rt, Ze), Tt.set(Ze, st), X.uniforms = rt.uniforms;
        const St = X.uniforms;
        (!D.isShaderMaterial && !D.isRawShaderMaterial || D.clipping === !0) && (St.clippingPlanes = K.uniform), Xt(D, rt), X.needsLights = Gn(D), X.lightsStateVersion = $e, X.needsLights && (St.ambientLightColor.value = te.state.ambient, St.lightProbe.value = te.state.probe, St.directionalLights.value = te.state.directional, St.directionalLightShadows.value = te.state.directionalShadow, St.spotLights.value = te.state.spot, St.spotLightShadows.value = te.state.spotShadow, St.rectAreaLights.value = te.state.rectArea, St.ltc_1.value = te.state.rectAreaLTC1, St.ltc_2.value = te.state.rectAreaLTC2, St.pointLights.value = te.state.point, St.pointLightShadows.value = te.state.pointShadow, St.hemisphereLights.value = te.state.hemi, St.directionalShadowMap.value = te.state.directionalShadowMap, St.directionalShadowMatrix.value = te.state.directionalShadowMatrix, St.spotShadowMap.value = te.state.spotShadowMap, St.spotLightMatrix.value = te.state.spotLightMatrix, St.spotLightMap.value = te.state.spotLightMap, St.pointShadowMap.value = te.state.pointShadowMap, St.pointShadowMatrix.value = te.state.pointShadowMatrix);
        const Qe = st.getUniforms(),
            ft = AS.seqWithValue(Qe.seq, St);
        return X.currentProgram = st, X.uniformsList = ft, st
    }

    function Xt(D, z) {
        const j = be.get(D);
        j.outputEncoding = z.outputEncoding, j.instancing = z.instancing, j.skinning = z.skinning, j.morphTargets = z.morphTargets, j.morphNormals = z.morphNormals, j.morphColors = z.morphColors, j.morphTargetsCount = z.morphTargetsCount, j.numClippingPlanes = z.numClippingPlanes, j.numIntersection = z.numClipIntersection, j.vertexAlphas = z.vertexAlphas, j.vertexTangents = z.vertexTangents, j.toneMapping = z.toneMapping
    }

    function Hr(D, z, j, X, te) {
        z.isScene !== !0 && (z = ae), he.resetTextureUnits();
        const Oe = z.fog,
            $e = X.isMeshStandardMaterial ? z.environment : null,
            rt = x === null ? y.outputEncoding : x.isXRRenderTarget === !0 ? x.texture.encoding : Lu,
            Ze = (X.isMeshStandardMaterial ? Ce : me).get(X.envMap || $e),
            Tt = X.vertexColors === !0 && !!j.attributes.color && j.attributes.color.itemSize === 4,
            st = !!X.normalMap && !!j.attributes.tangent,
            St = !!j.morphAttributes.position,
            Qe = !!j.morphAttributes.normal,
            ft = !!j.morphAttributes.color,
            Vt = X.toneMapped ? y.toneMapping : Na,
            bn = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color,
            Ht = bn !== void 0 ? bn.length : 0,
            kt = be.get(X),
            nr = d.state.lights;
        if (F === !0 && (G === !0 || D !== E)) {
            const zn = D === E && X.id === S;
            K.setState(X, D, zn)
        }
        let vn = !1;
        X.version === kt.__version ? (kt.needsLights && kt.lightsStateVersion !== nr.state.version || kt.outputEncoding !== rt || te.isInstancedMesh && kt.instancing === !1 || !te.isInstancedMesh && kt.instancing === !0 || te.isSkinnedMesh && kt.skinning === !1 || !te.isSkinnedMesh && kt.skinning === !0 || kt.envMap !== Ze || X.fog === !0 && kt.fog !== Oe || kt.numClippingPlanes !== void 0 && (kt.numClippingPlanes !== K.numPlanes || kt.numIntersection !== K.numIntersection) || kt.vertexAlphas !== Tt || kt.vertexTangents !== st || kt.morphTargets !== St || kt.morphNormals !== Qe || kt.morphColors !== ft || kt.toneMapping !== Vt || ue.isWebGL2 === !0 && kt.morphTargetsCount !== Ht) && (vn = !0) : (vn = !0, kt.__version = X.version);
        let qn = kt.currentProgram;
        vn === !0 && (qn = tn(X, z, te));
        let Ii = !1,
            rr = !1,
            Pn = !1;
        const xn = qn.getUniforms(),
            $t = kt.uniforms;
        if (ve.useProgram(qn.program) && (Ii = !0, rr = !0, Pn = !0), X.id !== S && (S = X.id, rr = !0), Ii || E !== D) {
            if (xn.setValue(re, "projectionMatrix", D.projectionMatrix), ue.logarithmicDepthBuffer && xn.setValue(re, "logDepthBufFC", 2 / (Math.log(D.far + 1) / Math.LN2)), E !== D && (E = D, rr = !0, Pn = !0), X.isShaderMaterial || X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshStandardMaterial || X.envMap) {
                const zn = xn.map.cameraPosition;
                zn !== void 0 && zn.setValue(re, ee.setFromMatrixPosition(D.matrixWorld))
            }(X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshLambertMaterial || X.isMeshBasicMaterial || X.isMeshStandardMaterial || X.isShaderMaterial) && xn.setValue(re, "isOrthographic", D.isOrthographicCamera === !0), (X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshLambertMaterial || X.isMeshBasicMaterial || X.isMeshStandardMaterial || X.isShaderMaterial || X.isShadowMaterial || te.isSkinnedMesh) && xn.setValue(re, "viewMatrix", D.matrixWorldInverse)
        }
        if (te.isSkinnedMesh) {
            xn.setOptional(re, te, "bindMatrix"), xn.setOptional(re, te, "bindMatrixInverse");
            const zn = te.skeleton;
            zn && (ue.floatVertexTextures ? (zn.boneTexture === null && zn.computeBoneTexture(), xn.setValue(re, "boneTexture", zn.boneTexture, he), xn.setValue(re, "boneTextureSize", zn.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const cn = j.morphAttributes;
        if ((cn.position !== void 0 || cn.normal !== void 0 || cn.color !== void 0 && ue.isWebGL2 === !0) && Be.update(te, j, qn), (rr || kt.receiveShadow !== te.receiveShadow) && (kt.receiveShadow = te.receiveShadow, xn.setValue(re, "receiveShadow", te.receiveShadow)), X.isMeshGouraudMaterial && X.envMap !== null && ($t.envMap.value = Ze, $t.flipEnvMap.value = Ze.isCubeTexture && Ze.isRenderTargetTexture === !1 ? -1 : 1), rr && (xn.setValue(re, "toneMappingExposure", y.toneMappingExposure), kt.needsLights && cs($t, Pn), Oe && X.fog === !0 && He.refreshFogUniforms($t, Oe), He.refreshMaterialUniforms($t, X, k, O, W), AS.upload(re, kt.uniformsList, $t, he)), X.isShaderMaterial && X.uniformsNeedUpdate === !0 && (AS.upload(re, kt.uniformsList, $t, he), X.uniformsNeedUpdate = !1), X.isSpriteMaterial && xn.setValue(re, "center", te.center), xn.setValue(re, "modelViewMatrix", te.modelViewMatrix), xn.setValue(re, "normalMatrix", te.normalMatrix), xn.setValue(re, "modelMatrix", te.matrixWorld), X.isShaderMaterial || X.isRawShaderMaterial) {
            const zn = X.uniformsGroups;
            for (let Qn = 0, ar = zn.length; Qn < ar; Qn++)
                if (ue.isWebGL2) {
                    const Ir = zn[Qn];
                    we.update(Ir, qn), we.bind(Ir, qn)
                } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return qn
    }

    function cs(D, z) {
        D.ambientLightColor.needsUpdate = z, D.lightProbe.needsUpdate = z, D.directionalLights.needsUpdate = z, D.directionalLightShadows.needsUpdate = z, D.pointLights.needsUpdate = z, D.pointLightShadows.needsUpdate = z, D.spotLights.needsUpdate = z, D.spotLightShadows.needsUpdate = z, D.rectAreaLights.needsUpdate = z, D.hemisphereLights.needsUpdate = z
    }

    function Gn(D) {
        return D.isMeshLambertMaterial || D.isMeshToonMaterial || D.isMeshPhongMaterial || D.isMeshStandardMaterial || D.isShadowMaterial || D.isShaderMaterial && D.lights === !0
    }
    this.getActiveCubeFace = function() {
        return b
    }, this.getActiveMipmapLevel = function() {
        return _
    }, this.getRenderTarget = function() {
        return x
    }, this.setRenderTargetTextures = function(D, z, j) {
        be.get(D.texture).__webglTexture = z, be.get(D.depthTexture).__webglTexture = j;
        const X = be.get(D);
        X.__hasExternalTextures = !0, X.__hasExternalTextures && (X.__autoAllocateDepthBuffer = j === void 0, X.__autoAllocateDepthBuffer || fe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), X.__useRenderToTexture = !1))
    }, this.setRenderTargetFramebuffer = function(D, z) {
        const j = be.get(D);
        j.__webglFramebuffer = z, j.__useDefaultFramebuffer = z === void 0
    }, this.setRenderTarget = function(D, z = 0, j = 0) {
        x = D, b = z, _ = j;
        let X = !0,
            te = null,
            Oe = !1,
            $e = !1;
        if (D) {
            const Ze = be.get(D);
            Ze.__useDefaultFramebuffer !== void 0 ? (ve.bindFramebuffer(36160, null), X = !1) : Ze.__webglFramebuffer === void 0 ? he.setupRenderTarget(D) : Ze.__hasExternalTextures && he.rebindTextures(D, be.get(D.texture).__webglTexture, be.get(D.depthTexture).__webglTexture);
            const Tt = D.texture;
            (Tt.isData3DTexture || Tt.isDataArrayTexture || Tt.isCompressedArrayTexture) && ($e = !0);
            const st = be.get(D).__webglFramebuffer;
            D.isWebGLCubeRenderTarget ? (te = st[z], Oe = !0) : ue.isWebGL2 && D.samples > 0 && he.useMultisampledRTT(D) === !1 ? te = be.get(D).__webglMultisampledFramebuffer : te = st, A.copy(D.viewport), T.copy(D.scissor), M = D.scissorTest
        } else A.copy(B).multiplyScalar(k).floor(), T.copy(U).multiplyScalar(k).floor(), M = q;
        if (ve.bindFramebuffer(36160, te) && ue.drawBuffers && X && ve.drawBuffers(D, te), ve.viewport(A), ve.scissor(T), ve.setScissorTest(M), Oe) {
            const Ze = be.get(D.texture);
            re.framebufferTexture2D(36160, 36064, 34069 + z, Ze.__webglTexture, j)
        } else if ($e) {
            const Ze = be.get(D.texture),
                Tt = z || 0;
            re.framebufferTextureLayer(36160, 36064, Ze.__webglTexture, j || 0, Tt)
        }
        S = -1
    }, this.readRenderTargetPixels = function(D, z, j, X, te, Oe, $e) {
        if (!(D && D.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let rt = be.get(D).__webglFramebuffer;
        if (D.isWebGLCubeRenderTarget && $e !== void 0 && (rt = rt[$e]), rt) {
            ve.bindFramebuffer(36160, rt);
            try {
                const Ze = D.texture,
                    Tt = Ze.format,
                    st = Ze.type;
                if (Tt !== Ns && Ye.convert(Tt) !== re.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const St = st === Qd && (fe.has("EXT_color_buffer_half_float") || ue.isWebGL2 && fe.has("EXT_color_buffer_float"));
                if (st !== Du && Ye.convert(st) !== re.getParameter(35738) && !(st === xl && (ue.isWebGL2 || fe.has("OES_texture_float") || fe.has("WEBGL_color_buffer_float"))) && !St) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                z >= 0 && z <= D.width - X && j >= 0 && j <= D.height - te && re.readPixels(z, j, X, te, Ye.convert(Tt), Ye.convert(st), Oe)
            } finally {
                const Ze = x !== null ? be.get(x).__webglFramebuffer : null;
                ve.bindFramebuffer(36160, Ze)
            }
        }
    }, this.copyFramebufferToTexture = function(D, z, j = 0) {
        const X = Math.pow(2, -j),
            te = Math.floor(z.image.width * X),
            Oe = Math.floor(z.image.height * X);
        he.setTexture2D(z, 0), re.copyTexSubImage2D(3553, j, 0, 0, D.x, D.y, te, Oe), ve.unbindTexture()
    }, this.copyTextureToTexture = function(D, z, j, X = 0) {
        const te = z.image.width,
            Oe = z.image.height,
            $e = Ye.convert(j.format),
            rt = Ye.convert(j.type);
        he.setTexture2D(j, 0), re.pixelStorei(37440, j.flipY), re.pixelStorei(37441, j.premultiplyAlpha), re.pixelStorei(3317, j.unpackAlignment), z.isDataTexture ? re.texSubImage2D(3553, X, D.x, D.y, te, Oe, $e, rt, z.image.data) : z.isCompressedTexture ? re.compressedTexSubImage2D(3553, X, D.x, D.y, z.mipmaps[0].width, z.mipmaps[0].height, $e, z.mipmaps[0].data) : re.texSubImage2D(3553, X, D.x, D.y, $e, rt, z.image), X === 0 && j.generateMipmaps && re.generateMipmap(3553), ve.unbindTexture()
    }, this.copyTextureToTexture3D = function(D, z, j, X, te = 0) {
        if (y.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const Oe = D.max.x - D.min.x + 1,
            $e = D.max.y - D.min.y + 1,
            rt = D.max.z - D.min.z + 1,
            Ze = Ye.convert(X.format),
            Tt = Ye.convert(X.type);
        let st;
        if (X.isData3DTexture) he.setTexture3D(X, 0), st = 32879;
        else if (X.isDataArrayTexture) he.setTexture2DArray(X, 0), st = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        re.pixelStorei(37440, X.flipY), re.pixelStorei(37441, X.premultiplyAlpha), re.pixelStorei(3317, X.unpackAlignment);
        const St = re.getParameter(3314),
            Qe = re.getParameter(32878),
            ft = re.getParameter(3316),
            Vt = re.getParameter(3315),
            bn = re.getParameter(32877),
            Ht = j.isCompressedTexture ? j.mipmaps[0] : j.image;
        re.pixelStorei(3314, Ht.width), re.pixelStorei(32878, Ht.height), re.pixelStorei(3316, D.min.x), re.pixelStorei(3315, D.min.y), re.pixelStorei(32877, D.min.z), j.isDataTexture || j.isData3DTexture ? re.texSubImage3D(st, te, z.x, z.y, z.z, Oe, $e, rt, Ze, Tt, Ht.data) : j.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), re.compressedTexSubImage3D(st, te, z.x, z.y, z.z, Oe, $e, rt, Ze, Ht.data)) : re.texSubImage3D(st, te, z.x, z.y, z.z, Oe, $e, rt, Ze, Tt, Ht), re.pixelStorei(3314, St), re.pixelStorei(32878, Qe), re.pixelStorei(3316, ft), re.pixelStorei(3315, Vt), re.pixelStorei(32877, bn), te === 0 && X.generateMipmaps && re.generateMipmap(st), ve.unbindTexture()
    }, this.initTexture = function(D) {
        D.isCubeTexture ? he.setTextureCube(D, 0) : D.isData3DTexture ? he.setTexture3D(D, 0) : D.isDataArrayTexture || D.isCompressedArrayTexture ? he.setTexture2DArray(D, 0) : he.setTexture2D(D, 0), ve.unbindTexture()
    }, this.resetState = function() {
        b = 0, _ = 0, x = null, ve.reset(), Te.reset()
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
    }))
}
Object.defineProperties(zE.prototype, {
    physicallyCorrectLights: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !t
        }
    }
});
class xW extends zE {}
xW.prototype.isWebGL1Renderer = !0;
class HE {
    constructor(e, n = 25e-5) {
        this.isFogExp2 = !0, this.name = "", this.color = new dt(e), this.density = n
    }
    clone() {
        return new HE(this.color, this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class UE {
    constructor(e, n = 1, r = 1e3) {
        this.isFog = !0, this.name = "", this.color = new dt(e), this.near = n, this.far = r
    }
    clone() {
        return new UE(this.color, this.near, this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class _L extends Tn {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(e, n) {
        return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e
    }
}
class p1 {
    constructor(e, n) {
        this.isInterleavedBuffer = !0, this.array = e, this.stride = n, this.count = e !== void 0 ? e.length / n : 0, this.usage = u0, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = uo()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e, this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
    }
    copyAt(e, n, r) {
        e *= this.stride, r *= n.stride;
        for (let i = 0, s = this.stride; i < s; i++) this.array[e + i] = n.array[r + i];
        return this
    }
    set(e, n = 0) {
        return this.array.set(e, n), this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = uo()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const n = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            r = new this.constructor(n, this.stride);
        return r.setUsage(this.usage), r
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = uo()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const ys = new J;
class Hs {
    constructor(e, n, r, i = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = n, this.offset = r, this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let n = 0, r = this.data.count; n < r; n++) ys.fromBufferAttribute(this, n), ys.applyMatrix4(e), this.setXYZ(n, ys.x, ys.y, ys.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let n = 0, r = this.count; n < r; n++) ys.fromBufferAttribute(this, n), ys.applyNormalMatrix(e), this.setXYZ(n, ys.x, ys.y, ys.z);
        return this
    }
    transformDirection(e) {
        for (let n = 0, r = this.count; n < r; n++) ys.fromBufferAttribute(this, n), ys.transformDirection(e), this.setXYZ(n, ys.x, ys.y, ys.z);
        return this
    }
    setX(e, n) {
        return this.normalized && (n = er(n, this.array)), this.data.array[e * this.data.stride + this.offset] = n, this
    }
    setY(e, n) {
        return this.normalized && (n = er(n, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = n, this
    }
    setZ(e, n) {
        return this.normalized && (n = er(n, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = n, this
    }
    setW(e, n) {
        return this.normalized && (n = er(n, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = n, this
    }
    getX(e) {
        let n = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (n = _u(n, this.array)), n
    }
    getY(e) {
        let n = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (n = _u(n, this.array)), n
    }
    getZ(e) {
        let n = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (n = _u(n, this.array)), n
    }
    getW(e) {
        let n = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (n = _u(n, this.array)), n
    }
    setXY(e, n, r) {
        return e = e * this.data.stride + this.offset, this.normalized && (n = er(n, this.array), r = er(r, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this
    }
    setXYZ(e, n, r, i) {
        return e = e * this.data.stride + this.offset, this.normalized && (n = er(n, this.array), r = er(r, this.array), i = er(i, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this
    }
    setXYZW(e, n, r, i, s) {
        return e = e * this.data.stride + this.offset, this.normalized && (n = er(n, this.array), r = er(r, this.array), i = er(i, this.array), s = er(s, this.array)), this.data.array[e + 0] = n, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const n = [];
            for (let r = 0; r < this.count; r++) {
                const i = r * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[i + s])
            }
            return new Ln(new this.array.constructor(n), this.itemSize, this.normalized)
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Hs(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const n = [];
            for (let r = 0; r < this.count; r++) {
                const i = r * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) n.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: n,
                normalized: this.normalized
            }
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class SL extends li {
    constructor(e) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new dt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
let Jp;
const _y = new J,
    Yp = new J,
    Qp = new J,
    Zp = new ke,
    Sy = new ke,
    _W = new Gt,
    Rx = new J,
    wy = new J,
    Ox = new J,
    T6 = new ke,
    tT = new ke,
    P6 = new ke;
class SW extends Tn {
    constructor(e) {
        if (super(), this.isSprite = !0, this.type = "Sprite", Jp === void 0) {
            Jp = new on;
            const n = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                r = new p1(n, 5);
            Jp.setIndex([0, 1, 2, 0, 2, 3]), Jp.setAttribute("position", new Hs(r, 3, 0, !1)), Jp.setAttribute("uv", new Hs(r, 2, 3, !1))
        }
        this.geometry = Jp, this.material = e !== void 0 ? e : new SL, this.center = new ke(.5, .5)
    }
    raycast(e, n) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Yp.setFromMatrixScale(this.matrixWorld), _W.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Qp.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Yp.multiplyScalar(-Qp.z);
        const r = this.material.rotation;
        let i, s;
        r !== 0 && (s = Math.cos(r), i = Math.sin(r));
        const o = this.center;
        Dx(Rx.set(-.5, -.5, 0), Qp, o, Yp, i, s), Dx(wy.set(.5, -.5, 0), Qp, o, Yp, i, s), Dx(Ox.set(.5, .5, 0), Qp, o, Yp, i, s), T6.set(0, 0), tT.set(1, 0), P6.set(1, 1);
        let a = e.ray.intersectTriangle(Rx, wy, Ox, !1, _y);
        if (a === null && (Dx(wy.set(-.5, .5, 0), Qp, o, Yp, i, s), tT.set(0, 1), a = e.ray.intersectTriangle(Rx, Ox, wy, !1, _y), a === null)) return;
        const l = e.ray.origin.distanceTo(_y);
        l < e.near || l > e.far || n.push({
            distance: l,
            point: _y.clone(),
            uv: Go.getUV(_y, Rx, wy, Ox, T6, tT, P6, new ke),
            face: null,
            object: this
        })
    }
    copy(e, n) {
        return super.copy(e, n), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
    }
}

function Dx(t, e, n, r, i, s) {
    Zp.subVectors(t, n).addScalar(.5).multiply(r), i !== void 0 ? (Sy.x = s * Zp.x - i * Zp.y, Sy.y = i * Zp.x + s * Zp.y) : Sy.copy(Zp), t.copy(e), t.x += Sy.x, t.y += Sy.y, t.applyMatrix4(_W)
}
const Lx = new J,
    I6 = new J;
class wW extends Tn {
    constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }), this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const n = e.levels;
        for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate, this
    }
    addLevel(e, n = 0, r = 0) {
        n = Math.abs(n);
        const i = this.levels;
        let s;
        for (s = 0; s < i.length && !(n < i[s].distance); s++);
        return i.splice(s, 0, {
            distance: n,
            hysteresis: r,
            object: e
        }), this.add(e), this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const n = this.levels;
        if (n.length > 0) {
            let r, i;
            for (r = 1, i = n.length; r < i; r++) {
                let s = n[r].distance;
                if (n[r].object.visible && (s -= s * n[r].hysteresis), e < s) break
            }
            return n[r - 1].object
        }
        return null
    }
    raycast(e, n) {
        if (this.levels.length > 0) {
            Lx.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(Lx);
            this.getObjectForDistance(i).raycast(e, n)
        }
    }
    update(e) {
        const n = this.levels;
        if (n.length > 1) {
            Lx.setFromMatrixPosition(e.matrixWorld), I6.setFromMatrixPosition(this.matrixWorld);
            const r = Lx.distanceTo(I6) / e.zoom;
            n[0].object.visible = !0;
            let i, s;
            for (i = 1, s = n.length; i < s; i++) {
                let o = n[i].distance;
                if (n[i].object.visible && (o -= o * n[i].hysteresis), r >= o) n[i - 1].object.visible = !1, n[i].object.visible = !0;
                else break
            }
            for (this._currentLevel = i - 1; i < s; i++) n[i].object.visible = !1
        }
    }
    toJSON(e) {
        const n = super.toJSON(e);
        this.autoUpdate === !1 && (n.object.autoUpdate = !1), n.object.levels = [];
        const r = this.levels;
        for (let i = 0, s = r.length; i < s; i++) {
            const o = r[i];
            n.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return n
    }
}
const R6 = new J,
    O6 = new In,
    D6 = new In,
    Ahe = new J,
    L6 = new Gt;
class wL extends mi {
    constructor(e, n) {
        super(e, n), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Gt, this.bindMatrixInverse = new Gt
    }
    copy(e, n) {
        return super.copy(e, n), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
    }
    bind(e, n) {
        this.skeleton = e, n === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), n = this.matrixWorld), this.bindMatrix.copy(n), this.bindMatrixInverse.copy(n).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new In,
            n = this.geometry.attributes.skinWeight;
        for (let r = 0, i = n.count; r < i; r++) {
            e.fromBufferAttribute(n, r);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), n.setXYZW(r, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, n) {
        const r = this.skeleton,
            i = this.geometry;
        O6.fromBufferAttribute(i.attributes.skinIndex, e), D6.fromBufferAttribute(i.attributes.skinWeight, e), R6.copy(n).applyMatrix4(this.bindMatrix), n.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = D6.getComponent(s);
            if (o !== 0) {
                const a = O6.getComponent(s);
                L6.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]), n.addScaledVector(Ahe.copy(R6).applyMatrix4(L6), o)
            }
        }
        return n.applyMatrix4(this.bindMatrixInverse)
    }
}
class $E extends Tn {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class fm extends Sr {
    constructor(e = null, n = 1, r = 1, i, s, o, a, l, u = Br, c = Br, f, d) {
        super(null, o, a, l, u, c, i, s, f, d), this.isDataTexture = !0, this.image = {
            data: e,
            width: n,
            height: r
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const k6 = new Gt,
    Che = new Gt;
class h1 {
    constructor(e = [], n = []) {
        this.uuid = uo(), this.bones = e.slice(0), this.boneInverses = n, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
    }
    init() {
        const e = this.bones,
            n = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16), n.length === 0) this.calculateInverses();
        else if (e.length !== n.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let r = 0, i = this.bones.length; r < i; r++) this.boneInverses.push(new Gt)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, n = this.bones.length; e < n; e++) {
            const r = new Gt;
            this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r)
        }
    }
    pose() {
        for (let e = 0, n = this.bones.length; e < n; e++) {
            const r = this.bones[e];
            r && r.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, n = this.bones.length; e < n; e++) {
            const r = this.bones[e];
            r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale))
        }
    }
    update() {
        const e = this.bones,
            n = this.boneInverses,
            r = this.boneMatrices,
            i = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : Che;
            k6.multiplyMatrices(a, n[s]), k6.toArray(r, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new h1(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = oW(e), e = Math.max(e, 4);
        const n = new Float32Array(e * e * 4);
        n.set(this.boneMatrices);
        const r = new fm(n, e, e, Ns, xl);
        return r.needsUpdate = !0, this.boneMatrices = n, this.boneTexture = r, this.boneTextureSize = e, this
    }
    getBoneByName(e) {
        for (let n = 0, r = this.bones.length; n < r; n++) {
            const i = this.bones[n];
            if (i.name === e) return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(e, n) {
        this.uuid = e.uuid;
        for (let r = 0, i = e.bones.length; r < i; r++) {
            const s = e.bones[r];
            let o = n[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new $E), this.bones.push(o), this.boneInverses.push(new Gt().fromArray(e.boneInverses[r]))
        }
        return this.init(), this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const n = this.bones,
            r = this.boneInverses;
        for (let i = 0, s = n.length; i < s; i++) {
            const o = n[i];
            e.bones.push(o.uuid);
            const a = r[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class Nm extends Ln {
    constructor(e, n, r, i = 1) {
        super(e, n, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
    }
}
const B6 = new Gt,
    F6 = new Gt,
    kx = [],
    Mhe = new Gt,
    Ey = new mi;
class EL extends mi {
    constructor(e, n, r) {
        super(e, n), this.isInstancedMesh = !0, this.instanceMatrix = new Nm(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1;
        for (let i = 0; i < r; i++) this.setMatrixAt(i, Mhe)
    }
    copy(e, n) {
        return super.copy(e, n), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
    }
    getColorAt(e, n) {
        n.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, n) {
        n.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, n) {
        const r = this.matrixWorld,
            i = this.count;
        if (Ey.geometry = this.geometry, Ey.material = this.material, Ey.material !== void 0)
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, B6), F6.multiplyMatrices(r, B6), Ey.matrixWorld = F6, Ey.raycast(e, kx);
                for (let o = 0, a = kx.length; o < a; o++) {
                    const l = kx[o];
                    l.instanceId = s, l.object = this, n.push(l)
                }
                kx.length = 0
            }
    }
    setColorAt(e, n) {
        this.instanceColor === null && (this.instanceColor = new Nm(new Float32Array(this.instanceMatrix.count * 3), 3)), n.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, n) {
        n.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class us extends li {
    constructor(e) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new dt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
    }
}
const N6 = new J,
    z6 = new J,
    H6 = new Gt,
    nT = new yg,
    Bx = new Fl;
class ku extends Tn {
    constructor(e = new on, n = new us) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n), this.material = e.material, this.geometry = e.geometry, this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const n = e.attributes.position,
                r = [0];
            for (let i = 1, s = n.count; i < s; i++) N6.fromBufferAttribute(n, i - 1), z6.fromBufferAttribute(n, i), r[i] = r[i - 1], r[i] += N6.distanceTo(z6);
            e.setAttribute("lineDistance", new Mt(r, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, n) {
        const r = this.geometry,
            i = this.matrixWorld,
            s = e.params.Line.threshold,
            o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(), Bx.copy(r.boundingSphere), Bx.applyMatrix4(i), Bx.radius += s, e.ray.intersectsSphere(Bx) === !1) return;
        H6.copy(i).invert(), nT.copy(e.ray).applyMatrix4(H6);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            u = new J,
            c = new J,
            f = new J,
            d = new J,
            p = this.isLineSegments ? 2 : 1,
            m = r.index,
            v = r.attributes.position;
        if (m !== null) {
            const b = Math.max(0, o.start),
                _ = Math.min(m.count, o.start + o.count);
            for (let x = b, S = _ - 1; x < S; x += p) {
                const E = m.getX(x),
                    A = m.getX(x + 1);
                if (u.fromBufferAttribute(v, E), c.fromBufferAttribute(v, A), nT.distanceSqToSegment(u, c, d, f) > l) continue;
                d.applyMatrix4(this.matrixWorld);
                const M = e.ray.origin.distanceTo(d);
                M < e.near || M > e.far || n.push({
                    distance: M,
                    point: f.clone().applyMatrix4(this.matrixWorld),
                    index: x,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const b = Math.max(0, o.start),
                _ = Math.min(v.count, o.start + o.count);
            for (let x = b, S = _ - 1; x < S; x += p) {
                if (u.fromBufferAttribute(v, x), c.fromBufferAttribute(v, x + 1), nT.distanceSqToSegment(u, c, d, f) > l) continue;
                d.applyMatrix4(this.matrixWorld);
                const A = e.ray.origin.distanceTo(d);
                A < e.near || A > e.far || n.push({
                    distance: A,
                    point: f.clone().applyMatrix4(this.matrixWorld),
                    index: x,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes,
            r = Object.keys(n);
        if (r.length > 0) {
            const i = n[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const U6 = new J,
    $6 = new J;
class Ja extends ku {
    constructor(e, n) {
        super(e, n), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const n = e.attributes.position,
                r = [];
            for (let i = 0, s = n.count; i < s; i += 2) U6.fromBufferAttribute(n, i), $6.fromBufferAttribute(n, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + U6.distanceTo($6);
            e.setAttribute("lineDistance", new Mt(r, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class AL extends ku {
    constructor(e, n) {
        super(e, n), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class GE extends li {
    constructor(e) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new dt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
const G6 = new Gt,
    C3 = new yg,
    Fx = new Fl,
    Nx = new J;
class CL extends Tn {
    constructor(e = new on, n = new GE) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = n, this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n), this.material = e.material, this.geometry = e.geometry, this
    }
    raycast(e, n) {
        const r = this.geometry,
            i = this.matrixWorld,
            s = e.params.Points.threshold,
            o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(), Fx.copy(r.boundingSphere), Fx.applyMatrix4(i), Fx.radius += s, e.ray.intersectsSphere(Fx) === !1) return;
        G6.copy(i).invert(), C3.copy(e.ray).applyMatrix4(G6);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            u = r.index,
            f = r.attributes.position;
        if (u !== null) {
            const d = Math.max(0, o.start),
                p = Math.min(u.count, o.start + o.count);
            for (let m = d, y = p; m < y; m++) {
                const v = u.getX(m);
                Nx.fromBufferAttribute(f, v), V6(Nx, v, l, i, e, n, this)
            }
        } else {
            const d = Math.max(0, o.start),
                p = Math.min(f.count, o.start + o.count);
            for (let m = d, y = p; m < y; m++) Nx.fromBufferAttribute(f, m), V6(Nx, m, l, i, e, n, this)
        }
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes,
            r = Object.keys(n);
        if (r.length > 0) {
            const i = n[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}

function V6(t, e, n, r, i, s, o) {
    const a = C3.distanceSqToPoint(t);
    if (a < n) {
        const l = new J;
        C3.closestPointToPoint(t, l), l.applyMatrix4(r);
        const u = i.ray.origin.distanceTo(l);
        if (u < i.near || u > i.far) return;
        s.push({
            distance: u,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class The extends Sr {
    constructor(e, n, r, i, s, o, a, l, u) {
        super(e, n, r, i, s, o, a, l, u), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : fr, this.magFilter = s !== void 0 ? s : fr, this.generateMipmaps = !1;
        const c = this;

        function f() {
            c.needsUpdate = !0, e.requestVideoFrameCallback(f)
        }
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(f)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class Phe extends Sr {
    constructor(e, n, r) {
        super({
            width: e,
            height: n
        }), this.isFramebufferTexture = !0, this.format = r, this.magFilter = Br, this.minFilter = Br, this.generateMipmaps = !1, this.needsUpdate = !0
    }
}
class ML extends Sr {
    constructor(e, n, r, i, s, o, a, l, u, c, f, d) {
        super(null, o, a, l, u, c, i, s, f, d), this.isCompressedTexture = !0, this.image = {
            width: n,
            height: r
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }
}
class Ihe extends ML {
    constructor(e, n, r, i, s, o) {
        super(e, n, r, s, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = zi
    }
}
class Rhe extends Sr {
    constructor(e, n, r, i, s, o, a, l, u) {
        super(e, n, r, i, s, o, a, l, u), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class Ya {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(e, n) {
        const r = this.getUtoTmapping(e);
        return this.getPoint(r, n)
    }
    getPoints(e = 5) {
        const n = [];
        for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
        return n
    }
    getSpacedPoints(e = 5) {
        const n = [];
        for (let r = 0; r <= e; r++) n.push(this.getPointAt(r / e));
        return n
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const n = [];
        let r, i = this.getPoint(0),
            s = 0;
        n.push(0);
        for (let o = 1; o <= e; o++) r = this.getPoint(o / e), s += r.distanceTo(i), n.push(s), i = r;
        return this.cacheArcLengths = n, n
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(e, n) {
        const r = this.getLengths();
        let i = 0;
        const s = r.length;
        let o;
        n ? o = n : o = e * r[s - 1];
        let a = 0,
            l = s - 1,
            u;
        for (; a <= l;)
            if (i = Math.floor(a + (l - a) / 2), u = r[i] - o, u < 0) a = i + 1;
            else if (u > 0) l = i - 1;
        else {
            l = i;
            break
        }
        if (i = l, r[i] === o) return i / (s - 1);
        const c = r[i],
            d = r[i + 1] - c,
            p = (o - c) / d;
        return (i + p) / (s - 1)
    }
    getTangent(e, n) {
        let i = e - 1e-4,
            s = e + 1e-4;
        i < 0 && (i = 0), s > 1 && (s = 1);
        const o = this.getPoint(i),
            a = this.getPoint(s),
            l = n || (o.isVector2 ? new ke : new J);
        return l.copy(a).sub(o).normalize(), l
    }
    getTangentAt(e, n) {
        const r = this.getUtoTmapping(e);
        return this.getTangent(r, n)
    }
    computeFrenetFrames(e, n) {
        const r = new J,
            i = [],
            s = [],
            o = [],
            a = new J,
            l = new Gt;
        for (let p = 0; p <= e; p++) {
            const m = p / e;
            i[p] = this.getTangentAt(m, new J)
        }
        s[0] = new J, o[0] = new J;
        let u = Number.MAX_VALUE;
        const c = Math.abs(i[0].x),
            f = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
        c <= u && (u = c, r.set(1, 0, 0)), f <= u && (u = f, r.set(0, 1, 0)), d <= u && r.set(0, 0, 1), a.crossVectors(i[0], r).normalize(), s[0].crossVectors(i[0], a), o[0].crossVectors(i[0], s[0]);
        for (let p = 1; p <= e; p++) {
            if (s[p] = s[p - 1].clone(), o[p] = o[p - 1].clone(), a.crossVectors(i[p - 1], i[p]), a.length() > Number.EPSILON) {
                a.normalize();
                const m = Math.acos(Xr(i[p - 1].dot(i[p]), -1, 1));
                s[p].applyMatrix4(l.makeRotationAxis(a, m))
            }
            o[p].crossVectors(i[p], s[p])
        }
        if (n === !0) {
            let p = Math.acos(Xr(s[0].dot(s[e]), -1, 1));
            p /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (p = -p);
            for (let m = 1; m <= e; m++) s[m].applyMatrix4(l.makeRotationAxis(i[m], p * m)), o[m].crossVectors(i[m], s[m])
        }
        return {
            tangents: i,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
}
class VE extends Ya {
    constructor(e = 0, n = 0, r = 1, i = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = r, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
    }
    getPoint(e, n) {
        const r = n || new ke,
            i = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0;) s += i;
        for (; s > i;) s -= i;
        s < Number.EPSILON && (o ? s = 0 : s = i), this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a),
            u = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const c = Math.cos(this.aRotation),
                f = Math.sin(this.aRotation),
                d = l - this.aX,
                p = u - this.aY;
            l = d * c - p * f + this.aX, u = d * f + p * c + this.aY
        }
        return r.set(l, u)
    }
    copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
}
class EW extends VE {
    constructor(e, n, r, i, s, o) {
        super(e, n, r, r, i, s, o), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function TL() {
    let t = 0,
        e = 0,
        n = 0,
        r = 0;

    function i(s, o, a, l) {
        t = s, e = a, n = -3 * s + 3 * o - 2 * a - l, r = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, u) {
            i(o, a, u * (a - s), u * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, u, c, f) {
            let d = (o - s) / u - (a - s) / (u + c) + (a - o) / c,
                p = (a - o) / c - (l - o) / (c + f) + (l - a) / f;
            d *= c, p *= c, i(o, a, d, p)
        },
        calc: function(s) {
            const o = s * s,
                a = o * s;
            return t + e * s + n * o + r * a
        }
    }
}
const zx = new J,
    rT = new TL,
    iT = new TL,
    sT = new TL;
class AW extends Ya {
    constructor(e = [], n = !1, r = "centripetal", i = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = r, this.tension = i
    }
    getPoint(e, n = new J) {
        const r = n,
            i = this.points,
            s = i.length,
            o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o),
            l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
        let u, c;
        this.closed || a > 0 ? u = i[(a - 1) % s] : (zx.subVectors(i[0], i[1]).add(i[0]), u = zx);
        const f = i[a % s],
            d = i[(a + 1) % s];
        if (this.closed || a + 2 < s ? c = i[(a + 2) % s] : (zx.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), c = zx), this.curveType === "centripetal" || this.curveType === "chordal") {
            const p = this.curveType === "chordal" ? .5 : .25;
            let m = Math.pow(u.distanceToSquared(f), p),
                y = Math.pow(f.distanceToSquared(d), p),
                v = Math.pow(d.distanceToSquared(c), p);
            y < 1e-4 && (y = 1), m < 1e-4 && (m = y), v < 1e-4 && (v = y), rT.initNonuniformCatmullRom(u.x, f.x, d.x, c.x, m, y, v), iT.initNonuniformCatmullRom(u.y, f.y, d.y, c.y, m, y, v), sT.initNonuniformCatmullRom(u.z, f.z, d.z, c.z, m, y, v)
        } else this.curveType === "catmullrom" && (rT.initCatmullRom(u.x, f.x, d.x, c.x, this.tension), iT.initCatmullRom(u.y, f.y, d.y, c.y, this.tension), sT.initCatmullRom(u.z, f.z, d.z, c.z, this.tension));
        return r.set(rT.calc(l), iT.calc(l), sT.calc(l)), r
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(i.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let n = 0, r = this.points.length; n < r; n++) {
            const i = this.points[n];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(new J().fromArray(i))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
}

function j6(t, e, n, r, i) {
    const s = (r - e) * .5,
        o = (i - n) * .5,
        a = t * t,
        l = t * a;
    return (2 * n - 2 * r + s + o) * l + (-3 * n + 3 * r - 2 * s - o) * a + s * t + n
}

function Ohe(t, e) {
    const n = 1 - t;
    return n * n * e
}

function Dhe(t, e) {
    return 2 * (1 - t) * t * e
}

function Lhe(t, e) {
    return t * t * e
}

function mv(t, e, n, r) {
    return Ohe(t, e) + Dhe(t, n) + Lhe(t, r)
}

function khe(t, e) {
    const n = 1 - t;
    return n * n * n * e
}

function Bhe(t, e) {
    const n = 1 - t;
    return 3 * n * n * t * e
}

function Fhe(t, e) {
    return 3 * (1 - t) * t * t * e
}

function Nhe(t, e) {
    return t * t * t * e
}

function gv(t, e, n, r, i) {
    return khe(t, e) + Bhe(t, n) + Fhe(t, r) + Nhe(t, i)
}
class PL extends Ya {
    constructor(e = new ke, n = new ke, r = new ke, i = new ke) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = i
    }
    getPoint(e, n = new ke) {
        const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return r.set(gv(e, i.x, s.x, o.x, a.x), gv(e, i.y, s.y, o.y, a.y)), r
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class CW extends Ya {
    constructor(e = new J, n = new J, r = new J, i = new J) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r, this.v3 = i
    }
    getPoint(e, n = new J) {
        const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return r.set(gv(e, i.x, s.x, o.x, a.x), gv(e, i.y, s.y, o.y, a.y), gv(e, i.z, s.z, o.z, a.z)), r
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class jE extends Ya {
    constructor(e = new ke, n = new ke) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n
    }
    getPoint(e, n = new ke) {
        const r = n;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r
    }
    getPointAt(e, n) {
        return this.getPoint(e, n)
    }
    getTangent(e, n = new ke) {
        return n.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, n) {
        return this.getTangent(e, n)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class MW extends Ya {
    constructor(e = new J, n = new J) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n
    }
    getPoint(e, n = new J) {
        const r = n;
        return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r
    }
    getPointAt(e, n) {
        return this.getPoint(e, n)
    }
    getTangent(e, n = new J) {
        return n.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, n) {
        return this.getTangent(e, n)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class IL extends Ya {
    constructor(e = new ke, n = new ke, r = new ke) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = r
    }
    getPoint(e, n = new ke) {
        const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2;
        return r.set(mv(e, i.x, s.x, o.x), mv(e, i.y, s.y, o.y)), r
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class RL extends Ya {
    constructor(e = new J, n = new J, r = new J) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = r
    }
    getPoint(e, n = new J) {
        const r = n,
            i = this.v0,
            s = this.v1,
            o = this.v2;
        return r.set(mv(e, i.x, s.x, o.x), mv(e, i.y, s.y, o.y), mv(e, i.z, s.z, o.z)), r
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class OL extends Ya {
    constructor(e = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
    }
    getPoint(e, n = new ke) {
        const r = n,
            i = this.points,
            s = (i.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = i[o === 0 ? o : o - 1],
            u = i[o],
            c = i[o > i.length - 2 ? i.length - 1 : o + 1],
            f = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return r.set(j6(a, l.x, u.x, c.x, f.x), j6(a, l.y, u.y, c.y, f.y)), r
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let n = 0, r = this.points.length; n < r; n++) {
            const i = this.points[n];
            e.points.push(i.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let n = 0, r = e.points.length; n < r; n++) {
            const i = e.points[n];
            this.points.push(new ke().fromArray(i))
        }
        return this
    }
}
var DL = Object.freeze({
    __proto__: null,
    ArcCurve: EW,
    CatmullRomCurve3: AW,
    CubicBezierCurve: PL,
    CubicBezierCurve3: CW,
    EllipseCurve: VE,
    LineCurve: jE,
    LineCurve3: MW,
    QuadraticBezierCurve: IL,
    QuadraticBezierCurve3: RL,
    SplineCurve: OL
});
class TW extends Ya {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            n = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(n) || this.curves.push(new jE(n, e))
    }
    getPoint(e, n) {
        const r = e * this.getLength(),
            i = this.getCurveLengths();
        let s = 0;
        for (; s < i.length;) {
            if (i[s] >= r) {
                const o = i[s] - r,
                    a = this.curves[s],
                    l = a.getLength(),
                    u = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(u, n)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let n = 0;
        for (let r = 0, i = this.curves.length; r < i; r++) n += this.curves[r].getLength(), e.push(n);
        return this.cacheLengths = e, e
    }
    getSpacedPoints(e = 40) {
        const n = [];
        for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
        return this.autoClose && n.push(n[0]), n
    }
    getPoints(e = 12) {
        const n = [];
        let r;
        for (let i = 0, s = this.curves; i < s.length; i++) {
            const o = s[i],
                a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
                l = o.getPoints(a);
            for (let u = 0; u < l.length; u++) {
                const c = l[u];
                r && r.equals(c) || (n.push(c), r = c)
            }
        }
        return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
    }
    copy(e) {
        super.copy(e), this.curves = [];
        for (let n = 0, r = e.curves.length; n < r; n++) {
            const i = e.curves[n];
            this.curves.push(i.clone())
        }
        return this.autoClose = e.autoClose, this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for (let n = 0, r = this.curves.length; n < r; n++) {
            const i = this.curves[n];
            e.curves.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for (let n = 0, r = e.curves.length; n < r; n++) {
            const i = e.curves[n];
            this.curves.push(new DL[i.type]().fromJSON(i))
        }
        return this
    }
}
class d0 extends TW {
    constructor(e) {
        super(), this.type = "Path", this.currentPoint = new ke, e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let n = 1, r = e.length; n < r; n++) this.lineTo(e[n].x, e[n].y);
        return this
    }
    moveTo(e, n) {
        return this.currentPoint.set(e, n), this
    }
    lineTo(e, n) {
        const r = new jE(this.currentPoint.clone(), new ke(e, n));
        return this.curves.push(r), this.currentPoint.set(e, n), this
    }
    quadraticCurveTo(e, n, r, i) {
        const s = new IL(this.currentPoint.clone(), new ke(e, n), new ke(r, i));
        return this.curves.push(s), this.currentPoint.set(r, i), this
    }
    bezierCurveTo(e, n, r, i, s, o) {
        const a = new PL(this.currentPoint.clone(), new ke(e, n), new ke(r, i), new ke(s, o));
        return this.curves.push(a), this.currentPoint.set(s, o), this
    }
    splineThru(e) {
        const n = [this.currentPoint.clone()].concat(e),
            r = new OL(n);
        return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this
    }
    arc(e, n, r, i, s, o) {
        const a = this.currentPoint.x,
            l = this.currentPoint.y;
        return this.absarc(e + a, n + l, r, i, s, o), this
    }
    absarc(e, n, r, i, s, o) {
        return this.absellipse(e, n, r, r, i, s, o), this
    }
    ellipse(e, n, r, i, s, o, a, l) {
        const u = this.currentPoint.x,
            c = this.currentPoint.y;
        return this.absellipse(e + u, n + c, r, i, s, o, a, l), this
    }
    absellipse(e, n, r, i, s, o, a, l) {
        const u = new VE(e, n, r, i, s, o, a, l);
        if (this.curves.length > 0) {
            const f = u.getPoint(0);
            f.equals(this.currentPoint) || this.lineTo(f.x, f.y)
        }
        this.curves.push(u);
        const c = u.getPoint(1);
        return this.currentPoint.copy(c), this
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
    }
}
class xg extends on {
    constructor(e = [new ke(0, -.5), new ke(.5, 0), new ke(0, .5)], n = 12, r = 0, i = Math.PI * 2) {
        super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: n,
            phiStart: r,
            phiLength: i
        }, n = Math.floor(n), i = Xr(i, 0, Math.PI * 2);
        const s = [],
            o = [],
            a = [],
            l = [],
            u = [],
            c = 1 / n,
            f = new J,
            d = new ke,
            p = new J,
            m = new J,
            y = new J;
        let v = 0,
            b = 0;
        for (let _ = 0; _ <= e.length - 1; _++) switch (_) {
            case 0:
                v = e[_ + 1].x - e[_].x, b = e[_ + 1].y - e[_].y, p.x = b * 1, p.y = -v, p.z = b * 0, y.copy(p), p.normalize(), l.push(p.x, p.y, p.z);
                break;
            case e.length - 1:
                l.push(y.x, y.y, y.z);
                break;
            default:
                v = e[_ + 1].x - e[_].x, b = e[_ + 1].y - e[_].y, p.x = b * 1, p.y = -v, p.z = b * 0, m.copy(p), p.x += y.x, p.y += y.y, p.z += y.z, p.normalize(), l.push(p.x, p.y, p.z), y.copy(m)
        }
        for (let _ = 0; _ <= n; _++) {
            const x = r + _ * c * i,
                S = Math.sin(x),
                E = Math.cos(x);
            for (let A = 0; A <= e.length - 1; A++) {
                f.x = e[A].x * S, f.y = e[A].y, f.z = e[A].x * E, o.push(f.x, f.y, f.z), d.x = _ / n, d.y = A / (e.length - 1), a.push(d.x, d.y);
                const T = l[3 * A + 0] * S,
                    M = l[3 * A + 1],
                    I = l[3 * A + 0] * E;
                u.push(T, M, I)
            }
        }
        for (let _ = 0; _ < n; _++)
            for (let x = 0; x < e.length - 1; x++) {
                const S = x + _ * e.length,
                    E = S,
                    A = S + e.length,
                    T = S + e.length + 1,
                    M = S + 1;
                s.push(E, A, M), s.push(T, M, A)
            }
        this.setIndex(s), this.setAttribute("position", new Mt(o, 3)), this.setAttribute("uv", new Mt(a, 2)), this.setAttribute("normal", new Mt(u, 3))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new xg(e.points, e.segments, e.phiStart, e.phiLength)
    }
}
class m1 extends xg {
    constructor(e = 1, n = 1, r = 4, i = 8) {
        const s = new d0;
        s.absarc(0, -n / 2, e, Math.PI * 1.5, 0), s.absarc(0, n / 2, e, 0, Math.PI * .5), super(s.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            height: n,
            capSegments: r,
            radialSegments: i
        }
    }
    static fromJSON(e) {
        return new m1(e.radius, e.length, e.capSegments, e.radialSegments)
    }
}
class g1 extends on {
    constructor(e = 1, n = 32, r = 0, i = Math.PI * 2) {
        super(), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: n,
            thetaStart: r,
            thetaLength: i
        }, n = Math.max(3, n);
        const s = [],
            o = [],
            a = [],
            l = [],
            u = new J,
            c = new ke;
        o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5);
        for (let f = 0, d = 3; f <= n; f++, d += 3) {
            const p = r + f / n * i;
            u.x = e * Math.cos(p), u.y = e * Math.sin(p), o.push(u.x, u.y, u.z), a.push(0, 0, 1), c.x = (o[d] / e + 1) / 2, c.y = (o[d + 1] / e + 1) / 2, l.push(c.x, c.y)
        }
        for (let f = 1; f <= n; f++) s.push(f, f + 1, 0);
        this.setIndex(s), this.setAttribute("position", new Mt(o, 3)), this.setAttribute("normal", new Mt(a, 3)), this.setAttribute("uv", new Mt(l, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new g1(e.radius, e.segments, e.thetaStart, e.thetaLength)
    }
}
class wf extends on {
    constructor(e = 1, n = 1, r = 1, i = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: n,
            height: r,
            radialSegments: i,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const u = this;
        i = Math.floor(i), s = Math.floor(s);
        const c = [],
            f = [],
            d = [],
            p = [];
        let m = 0;
        const y = [],
            v = r / 2;
        let b = 0;
        _(), o === !1 && (e > 0 && x(!0), n > 0 && x(!1)), this.setIndex(c), this.setAttribute("position", new Mt(f, 3)), this.setAttribute("normal", new Mt(d, 3)), this.setAttribute("uv", new Mt(p, 2));

        function _() {
            const S = new J,
                E = new J;
            let A = 0;
            const T = (n - e) / r;
            for (let M = 0; M <= s; M++) {
                const I = [],
                    O = M / s,
                    k = O * (n - e) + e;
                for (let H = 0; H <= i; H++) {
                    const N = H / i,
                        B = N * l + a,
                        U = Math.sin(B),
                        q = Math.cos(B);
                    E.x = k * U, E.y = -O * r + v, E.z = k * q, f.push(E.x, E.y, E.z), S.set(U, T, q).normalize(), d.push(S.x, S.y, S.z), p.push(N, 1 - O), I.push(m++)
                }
                y.push(I)
            }
            for (let M = 0; M < i; M++)
                for (let I = 0; I < s; I++) {
                    const O = y[I][M],
                        k = y[I + 1][M],
                        H = y[I + 1][M + 1],
                        N = y[I][M + 1];
                    c.push(O, k, N), c.push(k, H, N), A += 6
                }
            u.addGroup(b, A, 0), b += A
        }

        function x(S) {
            const E = m,
                A = new ke,
                T = new J;
            let M = 0;
            const I = S === !0 ? e : n,
                O = S === !0 ? 1 : -1;
            for (let H = 1; H <= i; H++) f.push(0, v * O, 0), d.push(0, O, 0), p.push(.5, .5), m++;
            const k = m;
            for (let H = 0; H <= i; H++) {
                const B = H / i * l + a,
                    U = Math.cos(B),
                    q = Math.sin(B);
                T.x = I * q, T.y = v * O, T.z = I * U, f.push(T.x, T.y, T.z), d.push(0, O, 0), A.x = U * .5 + .5, A.y = q * .5 * O + .5, p.push(A.x, A.y), m++
            }
            for (let H = 0; H < i; H++) {
                const N = E + H,
                    B = k + H;
                S === !0 ? c.push(B, B + 1, N) : c.push(B + 1, B, N), M += 3
            }
            u.addGroup(b, M, S === !0 ? 1 : 2), b += M
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new wf(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class y1 extends wf {
    constructor(e = 1, n = 1, r = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
        super(0, e, n, r, i, s, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new y1(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class Vu extends on {
    constructor(e = [], n = [], r = 1, i = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: n,
            radius: r,
            detail: i
        };
        const s = [],
            o = [];
        a(i), u(r), c(), this.setAttribute("position", new Mt(s, 3)), this.setAttribute("normal", new Mt(s.slice(), 3)), this.setAttribute("uv", new Mt(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();

        function a(_) {
            const x = new J,
                S = new J,
                E = new J;
            for (let A = 0; A < n.length; A += 3) p(n[A + 0], x), p(n[A + 1], S), p(n[A + 2], E), l(x, S, E, _)
        }

        function l(_, x, S, E) {
            const A = E + 1,
                T = [];
            for (let M = 0; M <= A; M++) {
                T[M] = [];
                const I = _.clone().lerp(S, M / A),
                    O = x.clone().lerp(S, M / A),
                    k = A - M;
                for (let H = 0; H <= k; H++) H === 0 && M === A ? T[M][H] = I : T[M][H] = I.clone().lerp(O, H / k)
            }
            for (let M = 0; M < A; M++)
                for (let I = 0; I < 2 * (A - M) - 1; I++) {
                    const O = Math.floor(I / 2);
                    I % 2 === 0 ? (d(T[M][O + 1]), d(T[M + 1][O]), d(T[M][O])) : (d(T[M][O + 1]), d(T[M + 1][O + 1]), d(T[M + 1][O]))
                }
        }

        function u(_) {
            const x = new J;
            for (let S = 0; S < s.length; S += 3) x.x = s[S + 0], x.y = s[S + 1], x.z = s[S + 2], x.normalize().multiplyScalar(_), s[S + 0] = x.x, s[S + 1] = x.y, s[S + 2] = x.z
        }

        function c() {
            const _ = new J;
            for (let x = 0; x < s.length; x += 3) {
                _.x = s[x + 0], _.y = s[x + 1], _.z = s[x + 2];
                const S = v(_) / 2 / Math.PI + .5,
                    E = b(_) / Math.PI + .5;
                o.push(S, 1 - E)
            }
            m(), f()
        }

        function f() {
            for (let _ = 0; _ < o.length; _ += 6) {
                const x = o[_ + 0],
                    S = o[_ + 2],
                    E = o[_ + 4],
                    A = Math.max(x, S, E),
                    T = Math.min(x, S, E);
                A > .9 && T < .1 && (x < .2 && (o[_ + 0] += 1), S < .2 && (o[_ + 2] += 1), E < .2 && (o[_ + 4] += 1))
            }
        }

        function d(_) {
            s.push(_.x, _.y, _.z)
        }

        function p(_, x) {
            const S = _ * 3;
            x.x = e[S + 0], x.y = e[S + 1], x.z = e[S + 2]
        }

        function m() {
            const _ = new J,
                x = new J,
                S = new J,
                E = new J,
                A = new ke,
                T = new ke,
                M = new ke;
            for (let I = 0, O = 0; I < s.length; I += 9, O += 6) {
                _.set(s[I + 0], s[I + 1], s[I + 2]), x.set(s[I + 3], s[I + 4], s[I + 5]), S.set(s[I + 6], s[I + 7], s[I + 8]), A.set(o[O + 0], o[O + 1]), T.set(o[O + 2], o[O + 3]), M.set(o[O + 4], o[O + 5]), E.copy(_).add(x).add(S).divideScalar(3);
                const k = v(E);
                y(A, O + 0, _, k), y(T, O + 2, x, k), y(M, O + 4, S, k)
            }
        }

        function y(_, x, S, E) {
            E < 0 && _.x === 1 && (o[x] = _.x - 1), S.x === 0 && S.z === 0 && (o[x] = E / 2 / Math.PI + .5)
        }

        function v(_) {
            return Math.atan2(_.z, -_.x)
        }

        function b(_) {
            return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Vu(e.vertices, e.indices, e.radius, e.details)
    }
}
class v1 extends Vu {
    constructor(e = 1, n = 0) {
        const r = (1 + Math.sqrt(5)) / 2,
            i = 1 / r,
            s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, n), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: n
        }
    }
    static fromJSON(e) {
        return new v1(e.radius, e.detail)
    }
}
const Hx = new J,
    Ux = new J,
    oT = new J,
    $x = new Go;
class PW extends on {
    constructor(e = null, n = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
                geometry: e,
                thresholdAngle: n
            }, e !== null) {
            const i = Math.pow(10, 4),
                s = Math.cos(kd * n),
                o = e.getIndex(),
                a = e.getAttribute("position"),
                l = o ? o.count : a.count,
                u = [0, 0, 0],
                c = ["a", "b", "c"],
                f = new Array(3),
                d = {},
                p = [];
            for (let m = 0; m < l; m += 3) {
                o ? (u[0] = o.getX(m), u[1] = o.getX(m + 1), u[2] = o.getX(m + 2)) : (u[0] = m, u[1] = m + 1, u[2] = m + 2);
                const {
                    a: y,
                    b: v,
                    c: b
                } = $x;
                if (y.fromBufferAttribute(a, u[0]), v.fromBufferAttribute(a, u[1]), b.fromBufferAttribute(a, u[2]), $x.getNormal(oT), f[0] = `${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`, f[1] = `${Math.round(v.x*i)},${Math.round(v.y*i)},${Math.round(v.z*i)}`, f[2] = `${Math.round(b.x*i)},${Math.round(b.y*i)},${Math.round(b.z*i)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
                    for (let _ = 0; _ < 3; _++) {
                        const x = (_ + 1) % 3,
                            S = f[_],
                            E = f[x],
                            A = $x[c[_]],
                            T = $x[c[x]],
                            M = `${S}_${E}`,
                            I = `${E}_${S}`;
                        I in d && d[I] ? (oT.dot(d[I].normal) <= s && (p.push(A.x, A.y, A.z), p.push(T.x, T.y, T.z)), d[I] = null) : M in d || (d[M] = {
                            index0: u[_],
                            index1: u[x],
                            normal: oT.clone()
                        })
                    }
            }
            for (const m in d)
                if (d[m]) {
                    const {
                        index0: y,
                        index1: v
                    } = d[m];
                    Hx.fromBufferAttribute(a, y), Ux.fromBufferAttribute(a, v), p.push(Hx.x, Hx.y, Hx.z), p.push(Ux.x, Ux.y, Ux.z)
                }
            this.setAttribute("position", new Mt(p, 3))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
}
class Fd extends d0 {
    constructor(e) {
        super(e), this.uuid = uo(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(e) {
        const n = [];
        for (let r = 0, i = this.holes.length; r < i; r++) n[r] = this.holes[r].getPoints(e);
        return n
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e), this.holes = [];
        for (let n = 0, r = e.holes.length; n < r; n++) {
            const i = e.holes[n];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for (let n = 0, r = this.holes.length; n < r; n++) {
            const i = this.holes[n];
            e.holes.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for (let n = 0, r = e.holes.length; n < r; n++) {
            const i = e.holes[n];
            this.holes.push(new d0().fromJSON(i))
        }
        return this
    }
}
const zhe = {
    triangulate: function(t, e, n = 2) {
        const r = e && e.length,
            i = r ? e[0] * n : t.length;
        let s = IW(t, 0, i, n, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, u, c, f, d, p;
        if (r && (s = Vhe(t, e, s, n)), t.length > 80 * n) {
            a = u = t[0], l = c = t[1];
            for (let m = n; m < i; m += n) f = t[m], d = t[m + 1], f < a && (a = f), d < l && (l = d), f > u && (u = f), d > c && (c = d);
            p = Math.max(u - a, c - l), p = p !== 0 ? 32767 / p : 0
        }
        return p0(s, o, n, a, l, p, 0), o
    }
};

function IW(t, e, n, r, i) {
    let s, o;
    if (i === tme(t, e, n, r) > 0)
        for (s = e; s < n; s += r) o = W6(s, t[s], t[s + 1], o);
    else
        for (s = n - r; s >= e; s -= r) o = W6(s, t[s], t[s + 1], o);
    return o && WE(o, o.next) && (m0(o), o = o.next), o
}

function tp(t, e) {
    if (!t) return t;
    e || (e = t);
    let n = t,
        r;
    do
        if (r = !1, !n.steiner && (WE(n, n.next) || Cr(n.prev, n, n.next) === 0)) {
            if (m0(n), n = e = n.prev, n === n.next) break;
            r = !0
        } else n = n.next; while (r || n !== e);
    return e
}

function p0(t, e, n, r, i, s, o) {
    if (!t) return;
    !o && s && Xhe(t, r, i, s);
    let a = t,
        l, u;
    for (; t.prev !== t.next;) {
        if (l = t.prev, u = t.next, s ? Uhe(t, r, i, s) : Hhe(t)) {
            e.push(l.i / n | 0), e.push(t.i / n | 0), e.push(u.i / n | 0), m0(t), t = u.next, a = u.next;
            continue
        }
        if (t = u, t === a) {
            o ? o === 1 ? (t = $he(tp(t), e, n), p0(t, e, n, r, i, s, 2)) : o === 2 && Ghe(t, e, n, r, i, s) : p0(tp(t), e, n, r, i, s, 1);
            break
        }
    }
}

function Hhe(t) {
    const e = t.prev,
        n = t,
        r = t.next;
    if (Cr(e, n, r) >= 0) return !1;
    const i = e.x,
        s = n.x,
        o = r.x,
        a = e.y,
        l = n.y,
        u = r.y,
        c = i < s ? i < o ? i : o : s < o ? s : o,
        f = a < l ? a < u ? a : u : l < u ? l : u,
        d = i > s ? i > o ? i : o : s > o ? s : o,
        p = a > l ? a > u ? a : u : l > u ? l : u;
    let m = r.next;
    for (; m !== e;) {
        if (m.x >= c && m.x <= d && m.y >= f && m.y <= p && Hh(i, a, s, l, o, u, m.x, m.y) && Cr(m.prev, m, m.next) >= 0) return !1;
        m = m.next
    }
    return !0
}

function Uhe(t, e, n, r) {
    const i = t.prev,
        s = t,
        o = t.next;
    if (Cr(i, s, o) >= 0) return !1;
    const a = i.x,
        l = s.x,
        u = o.x,
        c = i.y,
        f = s.y,
        d = o.y,
        p = a < l ? a < u ? a : u : l < u ? l : u,
        m = c < f ? c < d ? c : d : f < d ? f : d,
        y = a > l ? a > u ? a : u : l > u ? l : u,
        v = c > f ? c > d ? c : d : f > d ? f : d,
        b = M3(p, m, e, n, r),
        _ = M3(y, v, e, n, r);
    let x = t.prevZ,
        S = t.nextZ;
    for (; x && x.z >= b && S && S.z <= _;) {
        if (x.x >= p && x.x <= y && x.y >= m && x.y <= v && x !== i && x !== o && Hh(a, c, l, f, u, d, x.x, x.y) && Cr(x.prev, x, x.next) >= 0 || (x = x.prevZ, S.x >= p && S.x <= y && S.y >= m && S.y <= v && S !== i && S !== o && Hh(a, c, l, f, u, d, S.x, S.y) && Cr(S.prev, S, S.next) >= 0)) return !1;
        S = S.nextZ
    }
    for (; x && x.z >= b;) {
        if (x.x >= p && x.x <= y && x.y >= m && x.y <= v && x !== i && x !== o && Hh(a, c, l, f, u, d, x.x, x.y) && Cr(x.prev, x, x.next) >= 0) return !1;
        x = x.prevZ
    }
    for (; S && S.z <= _;) {
        if (S.x >= p && S.x <= y && S.y >= m && S.y <= v && S !== i && S !== o && Hh(a, c, l, f, u, d, S.x, S.y) && Cr(S.prev, S, S.next) >= 0) return !1;
        S = S.nextZ
    }
    return !0
}

function $he(t, e, n) {
    let r = t;
    do {
        const i = r.prev,
            s = r.next.next;
        !WE(i, s) && RW(i, r, r.next, s) && h0(i, s) && h0(s, i) && (e.push(i.i / n | 0), e.push(r.i / n | 0), e.push(s.i / n | 0), m0(r), m0(r.next), r = t = s), r = r.next
    } while (r !== t);
    return tp(r)
}

function Ghe(t, e, n, r, i, s) {
    let o = t;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && Qhe(o, a)) {
                let l = OW(o, a);
                o = tp(o, o.next), l = tp(l, l.next), p0(o, e, n, r, i, s, 0), p0(l, e, n, r, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== t)
}

function Vhe(t, e, n, r) {
    const i = [];
    let s, o, a, l, u;
    for (s = 0, o = e.length; s < o; s++) a = e[s] * r, l = s < o - 1 ? e[s + 1] * r : t.length, u = IW(t, a, l, r, !1), u === u.next && (u.steiner = !0), i.push(Yhe(u));
    for (i.sort(jhe), s = 0; s < i.length; s++) n = Whe(i[s], n);
    return n
}

function jhe(t, e) {
    return t.x - e.x
}

function Whe(t, e) {
    const n = Khe(t, e);
    if (!n) return e;
    const r = OW(n, t);
    return tp(r, r.next), tp(n, n.next)
}

function Khe(t, e) {
    let n = e,
        r = -1 / 0,
        i;
    const s = t.x,
        o = t.y;
    do {
        if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
            const d = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (d <= s && d > r && (r = d, i = n.x < n.next.x ? n : n.next, d === s)) return i
        }
        n = n.next
    } while (n !== e);
    if (!i) return null;
    const a = i,
        l = i.x,
        u = i.y;
    let c = 1 / 0,
        f;
    n = i;
    do s >= n.x && n.x >= l && s !== n.x && Hh(o < u ? s : r, o, l, u, o < u ? r : s, o, n.x, n.y) && (f = Math.abs(o - n.y) / (s - n.x), h0(n, t) && (f < c || f === c && (n.x > i.x || n.x === i.x && qhe(i, n))) && (i = n, c = f)), n = n.next; while (n !== a);
    return i
}

function qhe(t, e) {
    return Cr(t.prev, t, e.prev) < 0 && Cr(e.next, t, t.next) < 0
}

function Xhe(t, e, n, r) {
    let i = t;
    do i.z === 0 && (i.z = M3(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== t);
    i.prevZ.nextZ = null, i.prevZ = null, Jhe(i)
}

function Jhe(t) {
    let e, n, r, i, s, o, a, l, u = 1;
    do {
        for (n = t, t = null, s = null, o = 0; n;) {
            for (o++, r = n, a = 0, e = 0; e < u && (a++, r = r.nextZ, !!r); e++);
            for (l = u; a > 0 || l > 0 && r;) a !== 0 && (l === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
            n = r
        }
        s.nextZ = null, u *= 2
    } while (o > 1);
    return t
}

function M3(t, e, n, r, i) {
    return t = (t - n) * i | 0, e = (e - r) * i | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1
}

function Yhe(t) {
    let e = t,
        n = t;
    do(e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next; while (e !== t);
    return n
}

function Hh(t, e, n, r, i, s, o, a) {
    return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (r - a) >= (n - o) * (e - a) && (n - o) * (s - a) >= (i - o) * (r - a)
}

function Qhe(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !Zhe(t, e) && (h0(t, e) && h0(e, t) && eme(t, e) && (Cr(t.prev, t, e.prev) || Cr(t, e.prev, e)) || WE(t, e) && Cr(t.prev, t, t.next) > 0 && Cr(e.prev, e, e.next) > 0)
}

function Cr(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}

function WE(t, e) {
    return t.x === e.x && t.y === e.y
}

function RW(t, e, n, r) {
    const i = Vx(Cr(t, e, n)),
        s = Vx(Cr(t, e, r)),
        o = Vx(Cr(n, r, t)),
        a = Vx(Cr(n, r, e));
    return !!(i !== s && o !== a || i === 0 && Gx(t, n, e) || s === 0 && Gx(t, r, e) || o === 0 && Gx(n, t, r) || a === 0 && Gx(n, e, r))
}

function Gx(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
}

function Vx(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}

function Zhe(t, e) {
    let n = t;
    do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && RW(n, n.next, t, e)) return !0;
        n = n.next
    } while (n !== t);
    return !1
}

function h0(t, e) {
    return Cr(t.prev, t, t.next) < 0 ? Cr(t, e, t.next) >= 0 && Cr(t, t.prev, e) >= 0 : Cr(t, e, t.prev) < 0 || Cr(t, t.next, e) < 0
}

function eme(t, e) {
    let n = t,
        r = !1;
    const i = (t.x + e.x) / 2,
        s = (t.y + e.y) / 2;
    do n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== t);
    return r
}

function OW(t, e) {
    const n = new T3(t.i, t.x, t.y),
        r = new T3(e.i, e.x, e.y),
        i = t.next,
        s = e.prev;
    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
}

function W6(t, e, n, r) {
    const i = new T3(t, e, n);
    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
}

function m0(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
}

function T3(t, e, n) {
    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function tme(t, e, n, r) {
    let i = 0;
    for (let s = e, o = n - r; s < n; s += r) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
    return i
}
class Ml {
    static area(e) {
        const n = e.length;
        let r = 0;
        for (let i = n - 1, s = 0; s < n; i = s++) r += e[i].x * e[s].y - e[s].x * e[i].y;
        return r * .5
    }
    static isClockWise(e) {
        return Ml.area(e) < 0
    }
    static triangulateShape(e, n) {
        const r = [],
            i = [],
            s = [];
        K6(e), q6(r, e);
        let o = e.length;
        n.forEach(K6);
        for (let l = 0; l < n.length; l++) i.push(o), o += n[l].length, q6(r, n[l]);
        const a = zhe.triangulate(r, i);
        for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
        return s
    }
}

function K6(t) {
    const e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop()
}

function q6(t, e) {
    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
}
class b1 extends on {
    constructor(e = new Fd([new ke(.5, .5), new ke(-.5, .5), new ke(-.5, -.5), new ke(.5, -.5)]), n = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: n
        }, e = Array.isArray(e) ? e : [e];
        const r = this,
            i = [],
            s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a];
            o(u)
        }
        this.setAttribute("position", new Mt(i, 3)), this.setAttribute("uv", new Mt(s, 2)), this.computeVertexNormals();

        function o(a) {
            const l = [],
                u = n.curveSegments !== void 0 ? n.curveSegments : 12,
                c = n.steps !== void 0 ? n.steps : 1,
                f = n.depth !== void 0 ? n.depth : 1;
            let d = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
                p = n.bevelThickness !== void 0 ? n.bevelThickness : .2,
                m = n.bevelSize !== void 0 ? n.bevelSize : p - .1,
                y = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
                v = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
            const b = n.extrudePath,
                _ = n.UVGenerator !== void 0 ? n.UVGenerator : nme;
            let x, S = !1,
                E, A, T, M;
            b && (x = b.getSpacedPoints(c), S = !0, d = !1, E = b.computeFrenetFrames(c, !1), A = new J, T = new J, M = new J), d || (v = 0, p = 0, m = 0, y = 0);
            const I = a.extractPoints(u);
            let O = I.shape;
            const k = I.holes;
            if (!Ml.isClockWise(O)) {
                O = O.reverse();
                for (let he = 0, me = k.length; he < me; he++) {
                    const Ce = k[he];
                    Ml.isClockWise(Ce) && (k[he] = Ce.reverse())
                }
            }
            const N = Ml.triangulateShape(O, k),
                B = O;
            for (let he = 0, me = k.length; he < me; he++) {
                const Ce = k[he];
                O = O.concat(Ce)
            }

            function U(he, me, Ce) {
                return me || console.error("THREE.ExtrudeGeometry: vec does not exist"), he.clone().addScaledVector(me, Ce)
            }
            const q = O.length,
                Q = N.length;

            function F(he, me, Ce) {
                let Ne, De, je;
                const Ke = he.x - me.x,
                    He = he.y - me.y,
                    qe = Ce.x - he.x,
                    Xe = Ce.y - he.y,
                    K = Ke * Ke + He * He,
                    V = Ke * Xe - He * qe;
                if (Math.abs(V) > Number.EPSILON) {
                    const ge = Math.sqrt(K),
                        Be = Math.sqrt(qe * qe + Xe * Xe),
                        ze = me.x - He / ge,
                        Ue = me.y + Ke / ge,
                        Ye = Ce.x - Xe / Be,
                        Te = Ce.y + qe / Be,
                        we = ((Ye - ze) * Xe - (Te - Ue) * qe) / (Ke * Xe - He * qe);
                    Ne = ze + Ke * we - he.x, De = Ue + He * we - he.y;
                    const lt = Ne * Ne + De * De;
                    if (lt <= 2) return new ke(Ne, De);
                    je = Math.sqrt(lt / 2)
                } else {
                    let ge = !1;
                    Ke > Number.EPSILON ? qe > Number.EPSILON && (ge = !0) : Ke < -Number.EPSILON ? qe < -Number.EPSILON && (ge = !0) : Math.sign(He) === Math.sign(Xe) && (ge = !0), ge ? (Ne = -He, De = Ke, je = Math.sqrt(K)) : (Ne = Ke, De = He, je = Math.sqrt(K / 2))
                }
                return new ke(Ne / je, De / je)
            }
            const G = [];
            for (let he = 0, me = B.length, Ce = me - 1, Ne = he + 1; he < me; he++, Ce++, Ne++) Ce === me && (Ce = 0), Ne === me && (Ne = 0), G[he] = F(B[he], B[Ce], B[Ne]);
            const W = [];
            let se, ee = G.concat();
            for (let he = 0, me = k.length; he < me; he++) {
                const Ce = k[he];
                se = [];
                for (let Ne = 0, De = Ce.length, je = De - 1, Ke = Ne + 1; Ne < De; Ne++, je++, Ke++) je === De && (je = 0), Ke === De && (Ke = 0), se[Ne] = F(Ce[Ne], Ce[je], Ce[Ke]);
                W.push(se), ee = ee.concat(se)
            }
            for (let he = 0; he < v; he++) {
                const me = he / v,
                    Ce = p * Math.cos(me * Math.PI / 2),
                    Ne = m * Math.sin(me * Math.PI / 2) + y;
                for (let De = 0, je = B.length; De < je; De++) {
                    const Ke = U(B[De], G[De], Ne);
                    fe(Ke.x, Ke.y, -Ce)
                }
                for (let De = 0, je = k.length; De < je; De++) {
                    const Ke = k[De];
                    se = W[De];
                    for (let He = 0, qe = Ke.length; He < qe; He++) {
                        const Xe = U(Ke[He], se[He], Ne);
                        fe(Xe.x, Xe.y, -Ce)
                    }
                }
            }
            const ae = m + y;
            for (let he = 0; he < q; he++) {
                const me = d ? U(O[he], ee[he], ae) : O[he];
                S ? (T.copy(E.normals[0]).multiplyScalar(me.x), A.copy(E.binormals[0]).multiplyScalar(me.y), M.copy(x[0]).add(T).add(A), fe(M.x, M.y, M.z)) : fe(me.x, me.y, 0)
            }
            for (let he = 1; he <= c; he++)
                for (let me = 0; me < q; me++) {
                    const Ce = d ? U(O[me], ee[me], ae) : O[me];
                    S ? (T.copy(E.normals[he]).multiplyScalar(Ce.x), A.copy(E.binormals[he]).multiplyScalar(Ce.y), M.copy(x[he]).add(T).add(A), fe(M.x, M.y, M.z)) : fe(Ce.x, Ce.y, f / c * he)
                }
            for (let he = v - 1; he >= 0; he--) {
                const me = he / v,
                    Ce = p * Math.cos(me * Math.PI / 2),
                    Ne = m * Math.sin(me * Math.PI / 2) + y;
                for (let De = 0, je = B.length; De < je; De++) {
                    const Ke = U(B[De], G[De], Ne);
                    fe(Ke.x, Ke.y, f + Ce)
                }
                for (let De = 0, je = k.length; De < je; De++) {
                    const Ke = k[De];
                    se = W[De];
                    for (let He = 0, qe = Ke.length; He < qe; He++) {
                        const Xe = U(Ke[He], se[He], Ne);
                        S ? fe(Xe.x, Xe.y + x[c - 1].y, x[c - 1].x + Ce) : fe(Xe.x, Xe.y, f + Ce)
                    }
                }
            }
            de(), re();

            function de() {
                const he = i.length / 3;
                if (d) {
                    let me = 0,
                        Ce = q * me;
                    for (let Ne = 0; Ne < Q; Ne++) {
                        const De = N[Ne];
                        ue(De[2] + Ce, De[1] + Ce, De[0] + Ce)
                    }
                    me = c + v * 2, Ce = q * me;
                    for (let Ne = 0; Ne < Q; Ne++) {
                        const De = N[Ne];
                        ue(De[0] + Ce, De[1] + Ce, De[2] + Ce)
                    }
                } else {
                    for (let me = 0; me < Q; me++) {
                        const Ce = N[me];
                        ue(Ce[2], Ce[1], Ce[0])
                    }
                    for (let me = 0; me < Q; me++) {
                        const Ce = N[me];
                        ue(Ce[0] + q * c, Ce[1] + q * c, Ce[2] + q * c)
                    }
                }
                r.addGroup(he, i.length / 3 - he, 0)
            }

            function re() {
                const he = i.length / 3;
                let me = 0;
                _e(B, me), me += B.length;
                for (let Ce = 0, Ne = k.length; Ce < Ne; Ce++) {
                    const De = k[Ce];
                    _e(De, me), me += De.length
                }
                r.addGroup(he, i.length / 3 - he, 1)
            }

            function _e(he, me) {
                let Ce = he.length;
                for (; --Ce >= 0;) {
                    const Ne = Ce;
                    let De = Ce - 1;
                    De < 0 && (De = he.length - 1);
                    for (let je = 0, Ke = c + v * 2; je < Ke; je++) {
                        const He = q * je,
                            qe = q * (je + 1),
                            Xe = me + Ne + He,
                            K = me + De + He,
                            V = me + De + qe,
                            ge = me + Ne + qe;
                        ve(Xe, K, V, ge)
                    }
                }
            }

            function fe(he, me, Ce) {
                l.push(he), l.push(me), l.push(Ce)
            }

            function ue(he, me, Ce) {
                xe(he), xe(me), xe(Ce);
                const Ne = i.length / 3,
                    De = _.generateTopUV(r, i, Ne - 3, Ne - 2, Ne - 1);
                be(De[0]), be(De[1]), be(De[2])
            }

            function ve(he, me, Ce, Ne) {
                xe(he), xe(me), xe(Ne), xe(me), xe(Ce), xe(Ne);
                const De = i.length / 3,
                    je = _.generateSideWallUV(r, i, De - 6, De - 3, De - 2, De - 1);
                be(je[0]), be(je[1]), be(je[3]), be(je[1]), be(je[2]), be(je[3])
            }

            function xe(he) {
                i.push(l[he * 3 + 0]), i.push(l[he * 3 + 1]), i.push(l[he * 3 + 2])
            }

            function be(he) {
                s.push(he.x), s.push(he.y)
            }
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON(),
            n = this.parameters.shapes,
            r = this.parameters.options;
        return rme(n, r, e)
    }
    static fromJSON(e, n) {
        const r = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = n[e.shapes[s]];
            r.push(a)
        }
        const i = e.options.extrudePath;
        return i !== void 0 && (e.options.extrudePath = new DL[i.type]().fromJSON(i)), new b1(r, e.options)
    }
}
const nme = {
    generateTopUV: function(t, e, n, r, i) {
        const s = e[n * 3],
            o = e[n * 3 + 1],
            a = e[r * 3],
            l = e[r * 3 + 1],
            u = e[i * 3],
            c = e[i * 3 + 1];
        return [new ke(s, o), new ke(a, l), new ke(u, c)]
    },
    generateSideWallUV: function(t, e, n, r, i, s) {
        const o = e[n * 3],
            a = e[n * 3 + 1],
            l = e[n * 3 + 2],
            u = e[r * 3],
            c = e[r * 3 + 1],
            f = e[r * 3 + 2],
            d = e[i * 3],
            p = e[i * 3 + 1],
            m = e[i * 3 + 2],
            y = e[s * 3],
            v = e[s * 3 + 1],
            b = e[s * 3 + 2];
        return Math.abs(a - c) < Math.abs(o - u) ? [new ke(o, 1 - l), new ke(u, 1 - f), new ke(d, 1 - m), new ke(y, 1 - b)] : [new ke(a, 1 - l), new ke(c, 1 - f), new ke(p, 1 - m), new ke(v, 1 - b)]
    }
};

function rme(t, e, n) {
    if (n.shapes = [], Array.isArray(t))
        for (let r = 0, i = t.length; r < i; r++) {
            const s = t[r];
            n.shapes.push(s.uuid)
        } else n.shapes.push(t.uuid);
    return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n
}
class x1 extends Vu {
    constructor(e = 1, n = 0) {
        const r = (1 + Math.sqrt(5)) / 2,
            i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1],
            s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(i, s, e, n), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: n
        }
    }
    static fromJSON(e) {
        return new x1(e.radius, e.detail)
    }
}
class _g extends Vu {
    constructor(e = 1, n = 0) {
        const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(r, i, e, n), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: n
        }
    }
    static fromJSON(e) {
        return new _g(e.radius, e.detail)
    }
}
class _1 extends on {
    constructor(e = .5, n = 1, r = 32, i = 1, s = 0, o = Math.PI * 2) {
        super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: n,
            thetaSegments: r,
            phiSegments: i,
            thetaStart: s,
            thetaLength: o
        }, r = Math.max(3, r), i = Math.max(1, i);
        const a = [],
            l = [],
            u = [],
            c = [];
        let f = e;
        const d = (n - e) / i,
            p = new J,
            m = new ke;
        for (let y = 0; y <= i; y++) {
            for (let v = 0; v <= r; v++) {
                const b = s + v / r * o;
                p.x = f * Math.cos(b), p.y = f * Math.sin(b), l.push(p.x, p.y, p.z), u.push(0, 0, 1), m.x = (p.x / n + 1) / 2, m.y = (p.y / n + 1) / 2, c.push(m.x, m.y)
            }
            f += d
        }
        for (let y = 0; y < i; y++) {
            const v = y * (r + 1);
            for (let b = 0; b < r; b++) {
                const _ = b + v,
                    x = _,
                    S = _ + r + 1,
                    E = _ + r + 2,
                    A = _ + 1;
                a.push(x, S, A), a.push(S, E, A)
            }
        }
        this.setIndex(a), this.setAttribute("position", new Mt(l, 3)), this.setAttribute("normal", new Mt(u, 3)), this.setAttribute("uv", new Mt(c, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new _1(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
    }
}
class S1 extends on {
    constructor(e = new Fd([new ke(0, .5), new ke(-.5, -.5), new ke(.5, -.5)]), n = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: n
        };
        const r = [],
            i = [],
            s = [],
            o = [];
        let a = 0,
            l = 0;
        if (Array.isArray(e) === !1) u(e);
        else
            for (let c = 0; c < e.length; c++) u(e[c]), this.addGroup(a, l, c), a += l, l = 0;
        this.setIndex(r), this.setAttribute("position", new Mt(i, 3)), this.setAttribute("normal", new Mt(s, 3)), this.setAttribute("uv", new Mt(o, 2));

        function u(c) {
            const f = i.length / 3,
                d = c.extractPoints(n);
            let p = d.shape;
            const m = d.holes;
            Ml.isClockWise(p) === !1 && (p = p.reverse());
            for (let v = 0, b = m.length; v < b; v++) {
                const _ = m[v];
                Ml.isClockWise(_) === !0 && (m[v] = _.reverse())
            }
            const y = Ml.triangulateShape(p, m);
            for (let v = 0, b = m.length; v < b; v++) {
                const _ = m[v];
                p = p.concat(_)
            }
            for (let v = 0, b = p.length; v < b; v++) {
                const _ = p[v];
                i.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y)
            }
            for (let v = 0, b = y.length; v < b; v++) {
                const _ = y[v],
                    x = _[0] + f,
                    S = _[1] + f,
                    E = _[2] + f;
                r.push(x, S, E), l += 3
            }
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON(),
            n = this.parameters.shapes;
        return ime(n, e)
    }
    static fromJSON(e, n) {
        const r = [];
        for (let i = 0, s = e.shapes.length; i < s; i++) {
            const o = n[e.shapes[i]];
            r.push(o)
        }
        return new S1(r, e.curveSegments)
    }
}

function ime(t, e) {
    if (e.shapes = [], Array.isArray(t))
        for (let n = 0, r = t.length; n < r; n++) {
            const i = t[n];
            e.shapes.push(i.uuid)
        } else e.shapes.push(t.uuid);
    return e
}
class Sg extends on {
    constructor(e = 1, n = 32, r = 16, i = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: n,
            heightSegments: r,
            phiStart: i,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        }, n = Math.max(3, Math.floor(n)), r = Math.max(2, Math.floor(r));
        const l = Math.min(o + a, Math.PI);
        let u = 0;
        const c = [],
            f = new J,
            d = new J,
            p = [],
            m = [],
            y = [],
            v = [];
        for (let b = 0; b <= r; b++) {
            const _ = [],
                x = b / r;
            let S = 0;
            b == 0 && o == 0 ? S = .5 / n : b == r && l == Math.PI && (S = -.5 / n);
            for (let E = 0; E <= n; E++) {
                const A = E / n;
                f.x = -e * Math.cos(i + A * s) * Math.sin(o + x * a), f.y = e * Math.cos(o + x * a), f.z = e * Math.sin(i + A * s) * Math.sin(o + x * a), m.push(f.x, f.y, f.z), d.copy(f).normalize(), y.push(d.x, d.y, d.z), v.push(A + S, 1 - x), _.push(u++)
            }
            c.push(_)
        }
        for (let b = 0; b < r; b++)
            for (let _ = 0; _ < n; _++) {
                const x = c[b][_ + 1],
                    S = c[b][_],
                    E = c[b + 1][_],
                    A = c[b + 1][_ + 1];
                (b !== 0 || o > 0) && p.push(x, S, A), (b !== r - 1 || l < Math.PI) && p.push(S, E, A)
            }
        this.setIndex(p), this.setAttribute("position", new Mt(m, 3)), this.setAttribute("normal", new Mt(y, 3)), this.setAttribute("uv", new Mt(v, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Sg(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
    }
}
class w1 extends Vu {
    constructor(e = 1, n = 0) {
        const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(r, i, e, n), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: n
        }
    }
    static fromJSON(e) {
        return new w1(e.radius, e.detail)
    }
}
class E1 extends on {
    constructor(e = 1, n = .4, r = 12, i = 48, s = Math.PI * 2) {
        super(), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: n,
            radialSegments: r,
            tubularSegments: i,
            arc: s
        }, r = Math.floor(r), i = Math.floor(i);
        const o = [],
            a = [],
            l = [],
            u = [],
            c = new J,
            f = new J,
            d = new J;
        for (let p = 0; p <= r; p++)
            for (let m = 0; m <= i; m++) {
                const y = m / i * s,
                    v = p / r * Math.PI * 2;
                f.x = (e + n * Math.cos(v)) * Math.cos(y), f.y = (e + n * Math.cos(v)) * Math.sin(y), f.z = n * Math.sin(v), a.push(f.x, f.y, f.z), c.x = e * Math.cos(y), c.y = e * Math.sin(y), d.subVectors(f, c).normalize(), l.push(d.x, d.y, d.z), u.push(m / i), u.push(p / r)
            }
        for (let p = 1; p <= r; p++)
            for (let m = 1; m <= i; m++) {
                const y = (i + 1) * p + m - 1,
                    v = (i + 1) * (p - 1) + m - 1,
                    b = (i + 1) * (p - 1) + m,
                    _ = (i + 1) * p + m;
                o.push(y, v, _), o.push(v, b, _)
            }
        this.setIndex(o), this.setAttribute("position", new Mt(a, 3)), this.setAttribute("normal", new Mt(l, 3)), this.setAttribute("uv", new Mt(u, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new E1(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
    }
}
class A1 extends on {
    constructor(e = 1, n = .4, r = 64, i = 8, s = 2, o = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: n,
            tubularSegments: r,
            radialSegments: i,
            p: s,
            q: o
        }, r = Math.floor(r), i = Math.floor(i);
        const a = [],
            l = [],
            u = [],
            c = [],
            f = new J,
            d = new J,
            p = new J,
            m = new J,
            y = new J,
            v = new J,
            b = new J;
        for (let x = 0; x <= r; ++x) {
            const S = x / r * s * Math.PI * 2;
            _(S, s, o, e, p), _(S + .01, s, o, e, m), v.subVectors(m, p), b.addVectors(m, p), y.crossVectors(v, b), b.crossVectors(y, v), y.normalize(), b.normalize();
            for (let E = 0; E <= i; ++E) {
                const A = E / i * Math.PI * 2,
                    T = -n * Math.cos(A),
                    M = n * Math.sin(A);
                f.x = p.x + (T * b.x + M * y.x), f.y = p.y + (T * b.y + M * y.y), f.z = p.z + (T * b.z + M * y.z), l.push(f.x, f.y, f.z), d.subVectors(f, p).normalize(), u.push(d.x, d.y, d.z), c.push(x / r), c.push(E / i)
            }
        }
        for (let x = 1; x <= r; x++)
            for (let S = 1; S <= i; S++) {
                const E = (i + 1) * (x - 1) + (S - 1),
                    A = (i + 1) * x + (S - 1),
                    T = (i + 1) * x + S,
                    M = (i + 1) * (x - 1) + S;
                a.push(E, A, M), a.push(A, T, M)
            }
        this.setIndex(a), this.setAttribute("position", new Mt(l, 3)), this.setAttribute("normal", new Mt(u, 3)), this.setAttribute("uv", new Mt(c, 2));

        function _(x, S, E, A, T) {
            const M = Math.cos(x),
                I = Math.sin(x),
                O = E / S * x,
                k = Math.cos(O);
            T.x = A * (2 + k) * .5 * M, T.y = A * (2 + k) * I * .5, T.z = A * Math.sin(O) * .5
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new A1(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
    }
}
class C1 extends on {
    constructor(e = new RL(new J(-1, -1, 0), new J(-1, 1, 0), new J(1, 1, 0)), n = 64, r = 1, i = 8, s = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: n,
            radius: r,
            radialSegments: i,
            closed: s
        };
        const o = e.computeFrenetFrames(n, s);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        const a = new J,
            l = new J,
            u = new ke;
        let c = new J;
        const f = [],
            d = [],
            p = [],
            m = [];
        y(), this.setIndex(m), this.setAttribute("position", new Mt(f, 3)), this.setAttribute("normal", new Mt(d, 3)), this.setAttribute("uv", new Mt(p, 2));

        function y() {
            for (let x = 0; x < n; x++) v(x);
            v(s === !1 ? n : 0), _(), b()
        }

        function v(x) {
            c = e.getPointAt(x / n, c);
            const S = o.normals[x],
                E = o.binormals[x];
            for (let A = 0; A <= i; A++) {
                const T = A / i * Math.PI * 2,
                    M = Math.sin(T),
                    I = -Math.cos(T);
                l.x = I * S.x + M * E.x, l.y = I * S.y + M * E.y, l.z = I * S.z + M * E.z, l.normalize(), d.push(l.x, l.y, l.z), a.x = c.x + r * l.x, a.y = c.y + r * l.y, a.z = c.z + r * l.z, f.push(a.x, a.y, a.z)
            }
        }

        function b() {
            for (let x = 1; x <= n; x++)
                for (let S = 1; S <= i; S++) {
                    const E = (i + 1) * (x - 1) + (S - 1),
                        A = (i + 1) * x + (S - 1),
                        T = (i + 1) * x + S,
                        M = (i + 1) * (x - 1) + S;
                    m.push(E, A, M), m.push(A, T, M)
                }
        }

        function _() {
            for (let x = 0; x <= n; x++)
                for (let S = 0; S <= i; S++) u.x = x / n, u.y = S / i, p.push(u.x, u.y)
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(), e
    }
    static fromJSON(e) {
        return new C1(new DL[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
    }
}
class LL extends on {
    constructor(e = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: e
            }, e !== null) {
            const n = [],
                r = new Set,
                i = new J,
                s = new J;
            if (e.index !== null) {
                const o = e.attributes.position,
                    a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let u = 0, c = l.length; u < c; ++u) {
                    const f = l[u],
                        d = f.start,
                        p = f.count;
                    for (let m = d, y = d + p; m < y; m += 3)
                        for (let v = 0; v < 3; v++) {
                            const b = a.getX(m + v),
                                _ = a.getX(m + (v + 1) % 3);
                            i.fromBufferAttribute(o, b), s.fromBufferAttribute(o, _), X6(i, s, r) === !0 && (n.push(i.x, i.y, i.z), n.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let u = 0; u < 3; u++) {
                        const c = 3 * a + u,
                            f = 3 * a + (u + 1) % 3;
                        i.fromBufferAttribute(o, c), s.fromBufferAttribute(o, f), X6(i, s, r) === !0 && (n.push(i.x, i.y, i.z), n.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new Mt(n, 3))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
}

function X6(t, e, n) {
    const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
        i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
    return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0)
}
var J6 = Object.freeze({
    __proto__: null,
    BoxGeometry: Sf,
    CapsuleGeometry: m1,
    CircleGeometry: g1,
    ConeGeometry: y1,
    CylinderGeometry: wf,
    DodecahedronGeometry: v1,
    EdgesGeometry: PW,
    ExtrudeGeometry: b1,
    IcosahedronGeometry: x1,
    LatheGeometry: xg,
    OctahedronGeometry: _g,
    PlaneGeometry: vg,
    PolyhedronGeometry: Vu,
    RingGeometry: _1,
    ShapeGeometry: S1,
    SphereGeometry: Sg,
    TetrahedronGeometry: w1,
    TorusGeometry: E1,
    TorusKnotGeometry: A1,
    TubeGeometry: C1,
    WireframeGeometry: LL
});
class DW extends li {
    constructor(e) {
        super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new dt(0), this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
    }
}
class LW extends ra {
    constructor(e) {
        super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
    }
}
class M1 extends li {
    constructor(e) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new dt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _f, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class Nl extends M1 {
    constructor(e) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ke(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return Xr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(n) {
                this.ior = (1 + .4 * n) / (1 - .4 * n)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new dt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new dt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new dt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
    }
}
class kW extends li {
    constructor(e) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new dt(16777215), this.specular = new dt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _f, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = u1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class BW extends li {
    constructor(e) {
        super(), this.isMeshToonMaterial = !0, this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new dt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _f, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
class FW extends li {
    constructor(e) {
        super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _f, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
    }
}
class NW extends li {
    constructor(e) {
        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new dt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _f, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = u1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class zW extends li {
    constructor(e) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new dt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _f, this.normalScale = new ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class HW extends us {
    constructor(e) {
        super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    }
}

function Oo(t, e, n) {
    return kL(t) ? new t.constructor(t.subarray(e, n !== void 0 ? n : t.length)) : t.slice(e, n)
}

function _d(t, e, n) {
    return !t || !n && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT == "number" ? new e(t) : Array.prototype.slice.call(t)
}

function kL(t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView)
}

function UW(t) {
    function e(i, s) {
        return t[i] - t[s]
    }
    const n = t.length,
        r = new Array(n);
    for (let i = 0; i !== n; ++i) r[i] = i;
    return r.sort(e), r
}

function P3(t, e, n) {
    const r = t.length,
        i = new t.constructor(r);
    for (let s = 0, o = 0; o !== r; ++s) {
        const a = n[s] * e;
        for (let l = 0; l !== e; ++l) i[o++] = t[a + l]
    }
    return i
}

function BL(t, e, n, r) {
    let i = 1,
        s = t[0];
    for (; s !== void 0 && s[r] === void 0;) s = t[i++];
    if (s === void 0) return;
    let o = s[r];
    if (o !== void 0)
        if (Array.isArray(o))
            do o = s[r], o !== void 0 && (e.push(s.time), n.push.apply(n, o)), s = t[i++]; while (s !== void 0);
        else if (o.toArray !== void 0)
        do o = s[r], o !== void 0 && (e.push(s.time), o.toArray(n, n.length)), s = t[i++]; while (s !== void 0);
    else
        do o = s[r], o !== void 0 && (e.push(s.time), n.push(o)), s = t[i++]; while (s !== void 0)
}

function sme(t, e, n, r, i = 30) {
    const s = t.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const u = s.tracks[l],
            c = u.getValueSize(),
            f = [],
            d = [];
        for (let p = 0; p < u.times.length; ++p) {
            const m = u.times[p] * i;
            if (!(m < n || m >= r)) {
                f.push(u.times[p]);
                for (let y = 0; y < c; ++y) d.push(u.values[p * c + y])
            }
        }
        f.length !== 0 && (u.times = _d(f, u.times.constructor), u.values = _d(d, u.values.constructor), o.push(u))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
    return s.resetDuration(), s
}

function ome(t, e = 0, n = t, r = 30) {
    r <= 0 && (r = 30);
    const i = n.tracks.length,
        s = e / r;
    for (let o = 0; o < i; ++o) {
        const a = n.tracks[o],
            l = a.ValueTypeName;
        if (l === "bool" || l === "string") continue;
        const u = t.tracks.find(function(b) {
            return b.name === a.name && b.ValueTypeName === l
        });
        if (u === void 0) continue;
        let c = 0;
        const f = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = f / 3);
        let d = 0;
        const p = u.getValueSize();
        u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
        const m = a.times.length - 1;
        let y;
        if (s <= a.times[0]) {
            const b = c,
                _ = f - c;
            y = Oo(a.values, b, _)
        } else if (s >= a.times[m]) {
            const b = m * f + c,
                _ = b + f - c;
            y = Oo(a.values, b, _)
        } else {
            const b = a.createInterpolant(),
                _ = c,
                x = f - c;
            b.evaluate(s), y = Oo(b.resultBuffer, _, x)
        }
        l === "quaternion" && new Ti().fromArray(y).normalize().conjugate().toArray(y);
        const v = u.times.length;
        for (let b = 0; b < v; ++b) {
            const _ = b * p + d;
            if (l === "quaternion") Ti.multiplyQuaternionsFlat(u.values, _, y, 0, u.values, _);
            else {
                const x = p - d * 2;
                for (let S = 0; S < x; ++S) u.values[_ + S] -= y[S]
            }
        }
    }
    return t.blendMode = uL, t
}
const ame = {
    arraySlice: Oo,
    convertArray: _d,
    isTypedArray: kL,
    getKeyframeOrder: UW,
    sortedArray: P3,
    flattenJSON: BL,
    subclip: sme,
    makeClipAdditive: ome
};
class wg {
    constructor(e, n, r, i) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new n.constructor(r), this.sampleValues = n, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const n = this.parameterPositions;
        let r = this._cachedIndex,
            i = n[r],
            s = n[r - 1];
        e: {
            t: {
                let o;n: {
                    r: if (!(e < i)) {
                        for (let a = r + 2;;) {
                            if (i === void 0) {
                                if (e < s) break r;
                                return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1)
                            }
                            if (r === a) break;
                            if (s = i, i = n[++r], e < i) break t
                        }
                        o = n.length;
                        break n
                    }if (!(e >= s)) {
                        const a = n[1];
                        e < a && (r = 2, s = a);
                        for (let l = r - 2;;) {
                            if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (r === l) break;
                            if (i = s, s = n[--r - 1], e >= s) break t
                        }
                        o = r, r = 0;
                        break n
                    }
                    break e
                }
                for (; r < o;) {
                    const a = r + o >>> 1;
                    e < n[a] ? o = a : r = a + 1
                }
                if (i = n[r], s = n[r - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (i === void 0) return r = n.length, this._cachedIndex = r, this.copySampleValue_(r - 1)
            }
            this._cachedIndex = r,
            this.intervalChanged_(r, s, i)
        }
        return this.interpolate_(r, s, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const n = this.resultBuffer,
            r = this.sampleValues,
            i = this.valueSize,
            s = e * i;
        for (let o = 0; o !== i; ++o) n[o] = r[s + o];
        return n
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class $W extends wg {
    constructor(e, n, r, i) {
        super(e, n, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: yd,
            endingEnd: yd
        }
    }
    intervalChanged_(e, n, r) {
        const i = this.parameterPositions;
        let s = e - 2,
            o = e + 1,
            a = i[s],
            l = i[o];
        if (a === void 0) switch (this.getSettings_().endingStart) {
            case vd:
                s = e, a = 2 * n - r;
                break;
            case l0:
                s = i.length - 2, a = n + i[s] - i[s + 1];
                break;
            default:
                s = e, a = r
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
            case vd:
                o = e, l = 2 * r - n;
                break;
            case l0:
                o = 1, l = r + i[1] - i[0];
                break;
            default:
                o = e - 1, l = n
        }
        const u = (r - n) * .5,
            c = this.valueSize;
        this._weightPrev = u / (n - a), this._weightNext = u / (l - r), this._offsetPrev = s * c, this._offsetNext = o * c
    }
    interpolate_(e, n, r, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            u = l - a,
            c = this._offsetPrev,
            f = this._offsetNext,
            d = this._weightPrev,
            p = this._weightNext,
            m = (r - n) / (i - n),
            y = m * m,
            v = y * m,
            b = -d * v + 2 * d * y - d * m,
            _ = (1 + d) * v + (-1.5 - 2 * d) * y + (-.5 + d) * m + 1,
            x = (-1 - p) * v + (1.5 + p) * y + .5 * m,
            S = p * v - p * y;
        for (let E = 0; E !== a; ++E) s[E] = b * o[c + E] + _ * o[u + E] + x * o[l + E] + S * o[f + E];
        return s
    }
}
class FL extends wg {
    constructor(e, n, r, i) {
        super(e, n, r, i)
    }
    interpolate_(e, n, r, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            u = l - a,
            c = (r - n) / (i - n),
            f = 1 - c;
        for (let d = 0; d !== a; ++d) s[d] = o[u + d] * f + o[l + d] * c;
        return s
    }
}
class GW extends wg {
    constructor(e, n, r, i) {
        super(e, n, r, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Qa {
    constructor(e, n, r, i) {
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (n === void 0 || n.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = _d(n, this.TimeBufferType), this.values = _d(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const n = e.constructor;
        let r;
        if (n.toJSON !== this.toJSON) r = n.toJSON(e);
        else {
            r = {
                name: e.name,
                times: _d(e.times, Array),
                values: _d(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (r.interpolation = i)
        }
        return r.type = e.ValueTypeName, r
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new GW(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new FL(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new $W(this.times, this.values, this.getValueSize(), e)
    }
    setInterpolation(e) {
        let n;
        switch (e) {
            case km:
                n = this.InterpolantFactoryMethodDiscrete;
                break;
            case ep:
                n = this.InterpolantFactoryMethodLinear;
                break;
            case wS:
                n = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (n === void 0) {
            const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(r);
            return console.warn("THREE.KeyframeTrack:", r), this
        }
        return this.createInterpolant = n, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return km;
            case this.InterpolantFactoryMethodLinear:
                return ep;
            case this.InterpolantFactoryMethodSmooth:
                return wS
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const n = this.times;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const n = this.times;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] *= e
        }
        return this
    }
    trim(e, n) {
        const r = this.times,
            i = r.length;
        let s = 0,
            o = i - 1;
        for (; s !== i && r[s] < e;) ++s;
        for (; o !== -1 && r[o] > n;) --o;
        if (++o, s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            const a = this.getValueSize();
            this.times = Oo(r, s, o), this.values = Oo(this.values, s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const n = this.getValueSize();
        n - Math.floor(n) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        const r = this.times,
            i = this.values,
            s = r.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = r[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
                break
            }
            o = l
        }
        if (i !== void 0 && kL(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const u = i[a];
                if (isNaN(u)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = Oo(this.times),
            n = Oo(this.values),
            r = this.getValueSize(),
            i = this.getInterpolation() === wS,
            s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const u = e[a],
                c = e[a + 1];
            if (u !== c && (a !== 1 || u !== e[0]))
                if (i) l = !0;
                else {
                    const f = a * r,
                        d = f - r,
                        p = f + r;
                    for (let m = 0; m !== r; ++m) {
                        const y = n[f + m];
                        if (y !== n[d + m] || y !== n[p + m]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const f = a * r,
                        d = o * r;
                    for (let p = 0; p !== r; ++p) n[d + p] = n[f + p]
                }++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * r, l = o * r, u = 0; u !== r; ++u) n[l + u] = n[a + u];
            ++o
        }
        return o !== e.length ? (this.times = Oo(e, 0, o), this.values = Oo(n, 0, o * r)) : (this.times = e, this.values = n), this
    }
    clone() {
        const e = Oo(this.times, 0),
            n = Oo(this.values, 0),
            r = this.constructor,
            i = new r(this.name, e, n);
        return i.createInterpolant = this.createInterpolant, i
    }
}
Qa.prototype.TimeBufferType = Float32Array;
Qa.prototype.ValueBufferType = Float32Array;
Qa.prototype.DefaultInterpolation = ep;
class bp extends Qa {}
bp.prototype.ValueTypeName = "bool";
bp.prototype.ValueBufferType = Array;
bp.prototype.DefaultInterpolation = km;
bp.prototype.InterpolantFactoryMethodLinear = void 0;
bp.prototype.InterpolantFactoryMethodSmooth = void 0;
class NL extends Qa {}
NL.prototype.ValueTypeName = "color";
class zm extends Qa {}
zm.prototype.ValueTypeName = "number";
class VW extends wg {
    constructor(e, n, r, i) {
        super(e, n, r, i)
    }
    interpolate_(e, n, r, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (r - n) / (i - n);
        let u = e * a;
        for (let c = u + a; u !== c; u += 4) Ti.slerpFlat(s, 0, o, u - a, o, u, l);
        return s
    }
}
class ff extends Qa {
    InterpolantFactoryMethodLinear(e) {
        return new VW(this.times, this.values, this.getValueSize(), e)
    }
}
ff.prototype.ValueTypeName = "quaternion";
ff.prototype.DefaultInterpolation = ep;
ff.prototype.InterpolantFactoryMethodSmooth = void 0;
class xp extends Qa {}
xp.prototype.ValueTypeName = "string";
xp.prototype.ValueBufferType = Array;
xp.prototype.DefaultInterpolation = km;
xp.prototype.InterpolantFactoryMethodLinear = void 0;
xp.prototype.InterpolantFactoryMethodSmooth = void 0;
class Hm extends Qa {}
Hm.prototype.ValueTypeName = "vector";
class Um {
    constructor(e, n = -1, r, i = kE) {
        this.name = e, this.tracks = r, this.duration = n, this.blendMode = i, this.uuid = uo(), this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const n = [],
            r = e.tracks,
            i = 1 / (e.fps || 1);
        for (let o = 0, a = r.length; o !== a; ++o) n.push(ume(r[o]).scale(i));
        const s = new this(e.name, e.duration, n, e.blendMode);
        return s.uuid = e.uuid, s
    }
    static toJSON(e) {
        const n = [],
            r = e.tracks,
            i = {
                name: e.name,
                duration: e.duration,
                tracks: n,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
        for (let s = 0, o = r.length; s !== o; ++s) n.push(Qa.toJSON(r[s]));
        return i
    }
    static CreateFromMorphTargetSequence(e, n, r, i) {
        const s = n.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let l = [],
                u = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0);
            const c = UW(l);
            l = P3(l, 1, c), u = P3(u, 1, c), !i && l[0] === 0 && (l.push(s), u.push(u[0])), o.push(new zm(".morphTargetInfluences[" + n[a].name + "]", l, u).scale(1 / r))
        }
        return new this(e, -1, o)
    }
    static findByName(e, n) {
        let r = e;
        if (!Array.isArray(e)) {
            const i = e;
            r = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < r.length; i++)
            if (r[i].name === n) return r[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, n, r) {
        const i = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a],
                c = u.name.match(s);
            if (c && c.length > 1) {
                const f = c[1];
                let d = i[f];
                d || (i[f] = d = []), d.push(u)
            }
        }
        const o = [];
        for (const a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], n, r));
        return o
    }
    static parseAnimation(e, n) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const r = function(f, d, p, m, y) {
                if (p.length !== 0) {
                    const v = [],
                        b = [];
                    BL(p, v, b, m), v.length !== 0 && y.push(new f(d, v, b))
                }
            },
            i = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
        let l = e.length || -1;
        const u = e.hierarchy || [];
        for (let f = 0; f < u.length; f++) {
            const d = u[f].keys;
            if (!(!d || d.length === 0))
                if (d[0].morphTargets) {
                    const p = {};
                    let m;
                    for (m = 0; m < d.length; m++)
                        if (d[m].morphTargets)
                            for (let y = 0; y < d[m].morphTargets.length; y++) p[d[m].morphTargets[y]] = -1;
                    for (const y in p) {
                        const v = [],
                            b = [];
                        for (let _ = 0; _ !== d[m].morphTargets.length; ++_) {
                            const x = d[m];
                            v.push(x.time), b.push(x.morphTarget === y ? 1 : 0)
                        }
                        i.push(new zm(".morphTargetInfluence[" + y + "]", v, b))
                    }
                    l = p.length * o
                } else {
                    const p = ".bones[" + n[f].name + "]";
                    r(Hm, p + ".position", d, "pos", i), r(ff, p + ".quaternion", d, "rot", i), r(Hm, p + ".scale", d, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s, l, i, a)
    }
    resetDuration() {
        const e = this.tracks;
        let n = 0;
        for (let r = 0, i = e.length; r !== i; ++r) {
            const s = this.tracks[r];
            n = Math.max(n, s.times[s.times.length - 1])
        }
        return this.duration = n, this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let n = 0; n < this.tracks.length; n++) e = e && this.tracks[n].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function lme(t) {
    switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return zm;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Hm;
        case "color":
            return NL;
        case "quaternion":
            return ff;
        case "bool":
        case "boolean":
            return bp;
        case "string":
            return xp
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
}

function ume(t) {
    if (t.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = lme(t.type);
    if (t.times === void 0) {
        const n = [],
            r = [];
        BL(t.keys, n, r, "value"), t.times = n, t.values = r
    }
    return e.parse !== void 0 ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
}
const np = {
    enabled: !1,
    files: {},
    add: function(t, e) {
        this.enabled !== !1 && (this.files[t] = e)
    },
    get: function(t) {
        if (this.enabled !== !1) return this.files[t]
    },
    remove: function(t) {
        delete this.files[t]
    },
    clear: function() {
        this.files = {}
    }
};
class zL {
    constructor(e, n, r) {
        const i = this;
        let s = !1,
            o = 0,
            a = 0,
            l;
        const u = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = r, this.itemStart = function(c) {
            a++, s === !1 && i.onStart !== void 0 && i.onStart(c, o, a), s = !0
        }, this.itemEnd = function(c) {
            o++, i.onProgress !== void 0 && i.onProgress(c, o, a), o === a && (s = !1, i.onLoad !== void 0 && i.onLoad())
        }, this.itemError = function(c) {
            i.onError !== void 0 && i.onError(c)
        }, this.resolveURL = function(c) {
            return l ? l(c) : c
        }, this.setURLModifier = function(c) {
            return l = c, this
        }, this.addHandler = function(c, f) {
            return u.push(c, f), this
        }, this.removeHandler = function(c) {
            const f = u.indexOf(c);
            return f !== -1 && u.splice(f, 2), this
        }, this.getHandler = function(c) {
            for (let f = 0, d = u.length; f < d; f += 2) {
                const p = u[f],
                    m = u[f + 1];
                if (p.global && (p.lastIndex = 0), p.test(c)) return m
            }
            return null
        }
    }
}
const Uh = new zL;
class As {
    constructor(e) {
        this.manager = e !== void 0 ? e : Uh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(e, n) {
        const r = this;
        return new Promise(function(i, s) {
            r.load(e, i, n, s)
        })
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e, this
    }
    setWithCredentials(e) {
        return this.withCredentials = e, this
    }
    setPath(e) {
        return this.path = e, this
    }
    setResourcePath(e) {
        return this.resourcePath = e, this
    }
    setRequestHeader(e) {
        return this.requestHeader = e, this
    }
}
const su = {};
class cme extends Error {
    constructor(e, n) {
        super(e), this.response = n
    }
}
class ho extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = np.get(e);
        if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            n && n(s), this.manager.itemEnd(e)
        }, 0), s;
        if (su[e] !== void 0) {
            su[e].push({
                onLoad: n,
                onProgress: r,
                onError: i
            });
            return
        }
        su[e] = [], su[e].push({
            onLoad: n,
            onProgress: r,
            onError: i
        });
        const o = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            a = this.mimeType,
            l = this.responseType;
        fetch(o).then(u => {
            if (u.status === 200 || u.status === 0) {
                if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u;
                const c = su[e],
                    f = u.body.getReader(),
                    d = u.headers.get("Content-Length") || u.headers.get("X-File-Size"),
                    p = d ? parseInt(d) : 0,
                    m = p !== 0;
                let y = 0;
                const v = new ReadableStream({
                    start(b) {
                        _();

                        function _() {
                            f.read().then(({
                                done: x,
                                value: S
                            }) => {
                                if (x) b.close();
                                else {
                                    y += S.byteLength;
                                    const E = new ProgressEvent("progress", {
                                        lengthComputable: m,
                                        loaded: y,
                                        total: p
                                    });
                                    for (let A = 0, T = c.length; A < T; A++) {
                                        const M = c[A];
                                        M.onProgress && M.onProgress(E)
                                    }
                                    b.enqueue(S), _()
                                }
                            })
                        }
                    }
                });
                return new Response(v)
            } else throw new cme(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u)
        }).then(u => {
            switch (l) {
                case "arraybuffer":
                    return u.arrayBuffer();
                case "blob":
                    return u.blob();
                case "document":
                    return u.text().then(c => new DOMParser().parseFromString(c, a));
                case "json":
                    return u.json();
                default:
                    if (a === void 0) return u.text(); {
                        const f = /charset="?([^;"\s]*)"?/i.exec(a),
                            d = f && f[1] ? f[1].toLowerCase() : void 0,
                            p = new TextDecoder(d);
                        return u.arrayBuffer().then(m => p.decode(m))
                    }
            }
        }).then(u => {
            np.add(e, u);
            const c = su[e];
            delete su[e];
            for (let f = 0, d = c.length; f < d; f++) {
                const p = c[f];
                p.onLoad && p.onLoad(u)
            }
        }).catch(u => {
            const c = su[e];
            if (c === void 0) throw this.manager.itemError(e), u;
            delete su[e];
            for (let f = 0, d = c.length; f < d; f++) {
                const p = c[f];
                p.onError && p.onError(u)
            }
            this.manager.itemError(e)
        }).finally(() => {
            this.manager.itemEnd(e)
        }), this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e, this
    }
    setMimeType(e) {
        return this.mimeType = e, this
    }
}
class fme extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = this,
            o = new ho(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
            try {
                n(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e) {
        const n = [];
        for (let r = 0; r < e.length; r++) {
            const i = Um.parse(e[r]);
            n.push(i)
        }
        return n
    }
}
class dme extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = this,
            o = [],
            a = new ML,
            l = new ho(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
        let u = 0;

        function c(f) {
            l.load(e[f], function(d) {
                const p = s.parse(d, !0);
                o[f] = {
                    width: p.width,
                    height: p.height,
                    format: p.format,
                    mipmaps: p.mipmaps
                }, u += 1, u === 6 && (p.mipmapCount === 1 && (a.minFilter = fr), a.image = o, a.format = p.format, a.needsUpdate = !0, n && n(a))
            }, r, i)
        }
        if (Array.isArray(e))
            for (let f = 0, d = e.length; f < d; ++f) c(f);
        else l.load(e, function(f) {
            const d = s.parse(f, !0);
            if (d.isCubemap) {
                const p = d.mipmaps.length / d.mipmapCount;
                for (let m = 0; m < p; m++) {
                    o[m] = {
                        mipmaps: []
                    };
                    for (let y = 0; y < d.mipmapCount; y++) o[m].mipmaps.push(d.mipmaps[m * d.mipmapCount + y]), o[m].format = d.format, o[m].width = d.width, o[m].height = d.height
                }
                a.image = o
            } else a.image.width = d.width, a.image.height = d.height, a.mipmaps = d.mipmaps;
            d.mipmapCount === 1 && (a.minFilter = fr), a.format = d.format, a.needsUpdate = !0, n && n(a)
        }, r, i);
        return a
    }
}
class g0 extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = np.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            n && n(o), s.manager.itemEnd(e)
        }, 0), o;
        const a = f0("img");

        function l() {
            c(), np.add(e, this), n && n(this), s.manager.itemEnd(e)
        }

        function u(f) {
            c(), i && i(f), s.manager.itemError(e), s.manager.itemEnd(e)
        }

        function c() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", u, !1)
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
    }
}
class pme extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = new d1,
            o = new g0(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;

        function l(u) {
            o.load(e[u], function(c) {
                s.images[u] = c, a++, a === 6 && (s.needsUpdate = !0, n && n(s))
            }, void 0, i)
        }
        for (let u = 0; u < e.length; ++u) l(u);
        return s
    }
}
class hme extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = this,
            o = new fm,
            a = new ho(this.manager);
        return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
            const u = s.parse(l);
            u && (u.image !== void 0 ? o.image = u.image : u.data !== void 0 && (o.image.width = u.width, o.image.height = u.height, o.image.data = u.data), o.wrapS = u.wrapS !== void 0 ? u.wrapS : zi, o.wrapT = u.wrapT !== void 0 ? u.wrapT : zi, o.magFilter = u.magFilter !== void 0 ? u.magFilter : fr, o.minFilter = u.minFilter !== void 0 ? u.minFilter : fr, o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.encoding !== void 0 && (o.encoding = u.encoding), u.flipY !== void 0 && (o.flipY = u.flipY), u.format !== void 0 && (o.format = u.format), u.type !== void 0 && (o.type = u.type), u.mipmaps !== void 0 && (o.mipmaps = u.mipmaps, o.minFilter = Dl), u.mipmapCount === 1 && (o.minFilter = fr), u.generateMipmaps !== void 0 && (o.generateMipmaps = u.generateMipmaps), o.needsUpdate = !0, n && n(o, u))
        }, r, i), o
    }
}
class jW extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = new Sr,
            o = new g0(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
            s.image = a, s.needsUpdate = !0, n !== void 0 && n(s)
        }, r, i), s
    }
}
class Ef extends Tn {
    constructor(e, n = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new dt(e), this.intensity = n
    }
    dispose() {}
    copy(e, n) {
        return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), n
    }
}
class WW extends Ef {
    constructor(e, n, r) {
        super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Tn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new dt(n)
    }
    copy(e, n) {
        return super.copy(e, n), this.groundColor.copy(e.groundColor), this
    }
}
const aT = new Gt,
    Y6 = new J,
    Q6 = new J;
class HL {
    constructor(e) {
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new Gt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new FE, this._frameExtents = new ke(1, 1), this._viewportCount = 1, this._viewports = [new In(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const n = this.camera,
            r = this.matrix;
        Y6.setFromMatrixPosition(e.matrixWorld), n.position.copy(Y6), Q6.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(Q6), n.updateMatrixWorld(), aT.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(aT), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(aT)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
    }
}
class mme extends HL {
    constructor() {
        super(new dr(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }
    updateMatrices(e) {
        const n = this.camera,
            r = c0 * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            s = e.distance || n.far;
        (r !== n.fov || i !== n.aspect || s !== n.far) && (n.fov = r, n.aspect = i, n.far = s, n.updateProjectionMatrix()), super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e), this.focus = e.focus, this
    }
}
let UL = class extends Ef {
    constructor(e, n, r = 0, i = Math.PI / 3, s = 0, o = 2) {
        super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Tn.DEFAULT_UP), this.updateMatrix(), this.target = new Tn, this.distance = r, this.angle = i, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new mme
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, n) {
        return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
};
const Z6 = new Gt,
    Ay = new J,
    lT = new J;
class gme extends HL {
    constructor() {
        super(new dr(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ke(4, 2), this._viewportCount = 6, this._viewports = [new In(2, 1, 1, 1), new In(0, 1, 1, 1), new In(3, 1, 1, 1), new In(1, 1, 1, 1), new In(3, 0, 1, 1), new In(1, 0, 1, 1)], this._cubeDirections = [new J(1, 0, 0), new J(-1, 0, 0), new J(0, 0, 1), new J(0, 0, -1), new J(0, 1, 0), new J(0, -1, 0)], this._cubeUps = [new J(0, 1, 0), new J(0, 1, 0), new J(0, 1, 0), new J(0, 1, 0), new J(0, 0, 1), new J(0, 0, -1)]
    }
    updateMatrices(e, n = 0) {
        const r = this.camera,
            i = this.matrix,
            s = e.distance || r.far;
        s !== r.far && (r.far = s, r.updateProjectionMatrix()), Ay.setFromMatrixPosition(e.matrixWorld), r.position.copy(Ay), lT.copy(r.position), lT.add(this._cubeDirections[n]), r.up.copy(this._cubeUps[n]), r.lookAt(lT), r.updateMatrixWorld(), i.makeTranslation(-Ay.x, -Ay.y, -Ay.z), Z6.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Z6)
    }
}
class $L extends Ef {
    constructor(e, n, r = 0, i = 2) {
        super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new gme
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, n) {
        return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
    }
}
class yme extends HL {
    constructor() {
        super(new Ko(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class GL extends Ef {
    constructor(e, n) {
        super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Tn.DEFAULT_UP), this.updateMatrix(), this.target = new Tn, this.shadow = new yme
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
class KW extends Ef {
    constructor(e, n) {
        super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}
class qW extends Ef {
    constructor(e, n, r = 10, i = 10) {
        super(e, n), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e), this.width = e.width, this.height = e.height, this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.width = this.width, n.object.height = this.height, n
    }
}
class XW {
    constructor() {
        this.isSphericalHarmonics3 = !0, this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new J)
    }
    set(e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].copy(e[n]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, n) {
        const r = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
        return n.copy(o[0]).multiplyScalar(.282095), n.addScaledVector(o[1], .488603 * i), n.addScaledVector(o[2], .488603 * s), n.addScaledVector(o[3], .488603 * r), n.addScaledVector(o[4], 1.092548 * (r * i)), n.addScaledVector(o[5], 1.092548 * (i * s)), n.addScaledVector(o[6], .315392 * (3 * s * s - 1)), n.addScaledVector(o[7], 1.092548 * (r * s)), n.addScaledVector(o[8], .546274 * (r * r - i * i)), n
    }
    getIrradianceAt(e, n) {
        const r = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
        return n.copy(o[0]).multiplyScalar(.886227), n.addScaledVector(o[1], 2 * .511664 * i), n.addScaledVector(o[2], 2 * .511664 * s), n.addScaledVector(o[3], 2 * .511664 * r), n.addScaledVector(o[4], 2 * .429043 * r * i), n.addScaledVector(o[5], 2 * .429043 * i * s), n.addScaledVector(o[6], .743125 * s * s - .247708), n.addScaledVector(o[7], 2 * .429043 * r * s), n.addScaledVector(o[8], .429043 * (r * r - i * i)), n
    }
    add(e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].add(e.coefficients[n]);
        return this
    }
    addScaledSH(e, n) {
        for (let r = 0; r < 9; r++) this.coefficients[r].addScaledVector(e.coefficients[r], n);
        return this
    }
    scale(e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].multiplyScalar(e);
        return this
    }
    lerp(e, n) {
        for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], n);
        return this
    }
    equals(e) {
        for (let n = 0; n < 9; n++)
            if (!this.coefficients[n].equals(e.coefficients[n])) return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, n = 0) {
        const r = this.coefficients;
        for (let i = 0; i < 9; i++) r[i].fromArray(e, n + i * 3);
        return this
    }
    toArray(e = [], n = 0) {
        const r = this.coefficients;
        for (let i = 0; i < 9; i++) r[i].toArray(e, n + i * 3);
        return e
    }
    static getBasisAt(e, n) {
        const r = e.x,
            i = e.y,
            s = e.z;
        n[0] = .282095, n[1] = .488603 * i, n[2] = .488603 * s, n[3] = .488603 * r, n[4] = 1.092548 * r * i, n[5] = 1.092548 * i * s, n[6] = .315392 * (3 * s * s - 1), n[7] = 1.092548 * r * s, n[8] = .546274 * (r * r - i * i)
    }
}
class KE extends Ef {
    constructor(e = new XW, n = 1) {
        super(void 0, n), this.isLightProbe = !0, this.sh = e
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this
    }
    fromJSON(e) {
        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.sh = this.sh.toArray(), n
    }
}
class qE extends As {
    constructor(e) {
        super(e), this.textures = {}
    }
    load(e, n, r, i) {
        const s = this,
            o = new ho(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                n(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e) {
        const n = this.textures;

        function r(s) {
            return n[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), n[s]
        }
        const i = qE.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new dt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (i.uniforms[s] = {}, o.type) {
                    case "t":
                        i.uniforms[s].value = r(o.value);
                        break;
                    case "c":
                        i.uniforms[s].value = new dt().setHex(o.value);
                        break;
                    case "v2":
                        i.uniforms[s].value = new ke().fromArray(o.value);
                        break;
                    case "v3":
                        i.uniforms[s].value = new J().fromArray(o.value);
                        break;
                    case "v4":
                        i.uniforms[s].value = new In().fromArray(o.value);
                        break;
                    case "m3":
                        i.uniforms[s].value = new Hi().fromArray(o.value);
                        break;
                    case "m4":
                        i.uniforms[s].value = new Gt().fromArray(o.value);
                        break;
                    default:
                        i.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
            for (const s in e.extensions) i.extensions[s] = e.extensions[s];
        if (e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]), i.normalScale = new ke().fromArray(s)
        }
        return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new ke().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i
    }
    setTextures(e) {
        return this.textures = e, this
    }
    static createMaterialFromType(e) {
        const n = {
            ShadowMaterial: DW,
            SpriteMaterial: SL,
            RawShaderMaterial: LW,
            ShaderMaterial: ra,
            PointsMaterial: GE,
            MeshPhysicalMaterial: Nl,
            MeshStandardMaterial: M1,
            MeshPhongMaterial: kW,
            MeshToonMaterial: BW,
            MeshNormalMaterial: FW,
            MeshLambertMaterial: NW,
            MeshDepthMaterial: vL,
            MeshDistanceMaterial: bL,
            MeshBasicMaterial: oo,
            MeshMatcapMaterial: zW,
            LineDashedMaterial: HW,
            LineBasicMaterial: us,
            Material: li
        };
        return new n[e]
    }
}
class Tl {
    static decodeText(e) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let n = "";
        for (let r = 0, i = e.length; r < i; r++) n += String.fromCharCode(e[r]);
        try {
            return decodeURIComponent(escape(n))
        } catch {
            return n
        }
    }
    static extractUrlBase(e) {
        const n = e.lastIndexOf("/");
        return n === -1 ? "./" : e.slice(0, n + 1)
    }
    static resolveURL(e, n) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(n) && /^\//.test(e) && (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : n + e)
    }
}
class VL extends on {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e), this.instanceCount = e.instanceCount, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
    }
}
class JW extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = this,
            o = new ho(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                n(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e) {
        const n = {},
            r = {};

        function i(p, m) {
            if (n[m] !== void 0) return n[m];
            const v = p.interleavedBuffers[m],
                b = s(p, v.buffer),
                _ = Nh(v.type, b),
                x = new p1(_, v.stride);
            return x.uuid = v.uuid, n[m] = x, x
        }

        function s(p, m) {
            if (r[m] !== void 0) return r[m];
            const v = p.arrayBuffers[m],
                b = new Uint32Array(v).buffer;
            return r[m] = b, b
        }
        const o = e.isInstancedBufferGeometry ? new VL : new on,
            a = e.data.index;
        if (a !== void 0) {
            const p = Nh(a.type, a.array);
            o.setIndex(new Ln(p, 1))
        }
        const l = e.data.attributes;
        for (const p in l) {
            const m = l[p];
            let y;
            if (m.isInterleavedBufferAttribute) {
                const v = i(e.data, m.data);
                y = new Hs(v, m.itemSize, m.offset, m.normalized)
            } else {
                const v = Nh(m.type, m.array),
                    b = m.isInstancedBufferAttribute ? Nm : Ln;
                y = new b(v, m.itemSize, m.normalized)
            }
            m.name !== void 0 && (y.name = m.name), m.usage !== void 0 && y.setUsage(m.usage), m.updateRange !== void 0 && (y.updateRange.offset = m.updateRange.offset, y.updateRange.count = m.updateRange.count), o.setAttribute(p, y)
        }
        const u = e.data.morphAttributes;
        if (u)
            for (const p in u) {
                const m = u[p],
                    y = [];
                for (let v = 0, b = m.length; v < b; v++) {
                    const _ = m[v];
                    let x;
                    if (_.isInterleavedBufferAttribute) {
                        const S = i(e.data, _.data);
                        x = new Hs(S, _.itemSize, _.offset, _.normalized)
                    } else {
                        const S = Nh(_.type, _.array);
                        x = new Ln(S, _.itemSize, _.normalized)
                    }
                    _.name !== void 0 && (x.name = _.name), y.push(x)
                }
                o.morphAttributes[p] = y
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const f = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (f !== void 0)
            for (let p = 0, m = f.length; p !== m; ++p) {
                const y = f[p];
                o.addGroup(y.start, y.count, y.materialIndex)
            }
        const d = e.data.boundingSphere;
        if (d !== void 0) {
            const p = new J;
            d.center !== void 0 && p.fromArray(d.center), o.boundingSphere = new Fl(p, d.radius)
        }
        return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    }
}
class vme extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = this,
            o = this.path === "" ? Tl.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new ho(this.manager);
        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
            let u = null;
            try {
                u = JSON.parse(l)
            } catch (f) {
                i !== void 0 && i(f), console.error("THREE:ObjectLoader: Can't parse " + e + ".", f.message);
                return
            }
            const c = u.metadata;
            if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") {
                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(u, n)
        }, r, i)
    }
    async loadAsync(e, n) {
        const r = this,
            i = this.path === "" ? Tl.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || i;
        const s = new ho(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, n),
            a = JSON.parse(o),
            l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await r.parseAsync(a)
    }
    parse(e, n) {
        const r = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, i),
            o = this.parseImages(e.images, function() {
                n !== void 0 && n(u)
            }),
            a = this.parseTextures(e.textures, o),
            l = this.parseMaterials(e.materials, a),
            u = this.parseObject(e.object, s, l, a, r),
            c = this.parseSkeletons(e.skeletons, u);
        if (this.bindSkeletons(u, c), n !== void 0) {
            let f = !1;
            for (const d in o)
                if (o[d].data instanceof HTMLImageElement) {
                    f = !0;
                    break
                }
            f === !1 && n(u)
        }
        return u
    }
    async parseAsync(e) {
        const n = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            i = this.parseGeometries(e.geometries, r),
            s = await this.parseImagesAsync(e.images),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            l = this.parseObject(e.object, i, a, o, n),
            u = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, u), l
    }
    parseShapes(e) {
        const n = {};
        if (e !== void 0)
            for (let r = 0, i = e.length; r < i; r++) {
                const s = new Fd().fromJSON(e[r]);
                n[s.uuid] = s
            }
        return n
    }
    parseSkeletons(e, n) {
        const r = {},
            i = {};
        if (n.traverse(function(s) {
                s.isBone && (i[s.uuid] = s)
            }), e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new h1().fromJSON(e[s], i);
                r[a.uuid] = a
            }
        return r
    }
    parseGeometries(e, n) {
        const r = {};
        if (e !== void 0) {
            const i = new JW;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        a = i.parse(l);
                        break;
                    default:
                        l.type in J6 ? a = J6[l.type].fromJSON(l, n) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), r[l.uuid] = a
            }
        }
        return r
    }
    parseMaterials(e, n) {
        const r = {},
            i = {};
        if (e !== void 0) {
            const s = new qE;
            s.setTextures(n);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)), i[l.uuid] = r[l.uuid]
            }
        }
        return i
    }
    parseAnimations(e) {
        const n = {};
        if (e !== void 0)
            for (let r = 0; r < e.length; r++) {
                const i = e[r],
                    s = Um.parse(i);
                n[s.uuid] = s
            }
        return n
    }
    parseImages(e, n) {
        const r = this,
            i = {};
        let s;

        function o(l) {
            return r.manager.itemStart(l), s.load(l, function() {
                r.manager.itemEnd(l)
            }, void 0, function() {
                r.manager.itemError(l), r.manager.itemEnd(l)
            })
        }

        function a(l) {
            if (typeof l == "string") {
                const u = l,
                    c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u;
                return o(c)
            } else return l.data ? {
                data: Nh(l.type, l.data),
                width: l.width,
                height: l.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new zL(n);
            s = new g0(l), s.setCrossOrigin(this.crossOrigin);
            for (let u = 0, c = e.length; u < c; u++) {
                const f = e[u],
                    d = f.url;
                if (Array.isArray(d)) {
                    const p = [];
                    for (let m = 0, y = d.length; m < y; m++) {
                        const v = d[m],
                            b = a(v);
                        b !== null && (b instanceof HTMLImageElement ? p.push(b) : p.push(new fm(b.data, b.width, b.height)))
                    }
                    i[f.uuid] = new xd(p)
                } else {
                    const p = a(f.url);
                    i[f.uuid] = new xd(p)
                }
            }
        }
        return i
    }
    async parseImagesAsync(e) {
        const n = this,
            r = {};
        let i;
        async function s(o) {
            if (typeof o == "string") {
                const a = o,
                    l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : n.resourcePath + a;
                return await i.loadAsync(l)
            } else return o.data ? {
                data: Nh(o.type, o.data),
                width: o.width,
                height: o.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            i = new g0(this.manager), i.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o],
                    u = l.url;
                if (Array.isArray(u)) {
                    const c = [];
                    for (let f = 0, d = u.length; f < d; f++) {
                        const p = u[f],
                            m = await s(p);
                        m !== null && (m instanceof HTMLImageElement ? c.push(m) : c.push(new fm(m.data, m.width, m.height)))
                    }
                    r[l.uuid] = new xd(c)
                } else {
                    const c = await s(l.url);
                    r[l.uuid] = new xd(c)
                }
            }
        }
        return r
    }
    parseTextures(e, n) {
        function r(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s])
        }
        const i = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), n[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = n[a.image],
                    u = l.data;
                let c;
                Array.isArray(u) ? (c = new d1, u.length === 6 && (c.needsUpdate = !0)) : (u && u.data ? c = new fm : c = new Sr, u && (c.needsUpdate = !0)), c.source = l, c.uuid = a.uuid, a.name !== void 0 && (c.name = a.name), a.mapping !== void 0 && (c.mapping = r(a.mapping, bme)), a.offset !== void 0 && c.offset.fromArray(a.offset), a.repeat !== void 0 && c.repeat.fromArray(a.repeat), a.center !== void 0 && c.center.fromArray(a.center), a.rotation !== void 0 && (c.rotation = a.rotation), a.wrap !== void 0 && (c.wrapS = r(a.wrap[0], e8), c.wrapT = r(a.wrap[1], e8)), a.format !== void 0 && (c.format = a.format), a.internalFormat !== void 0 && (c.internalFormat = a.internalFormat), a.type !== void 0 && (c.type = a.type), a.encoding !== void 0 && (c.encoding = a.encoding), a.minFilter !== void 0 && (c.minFilter = r(a.minFilter, t8)), a.magFilter !== void 0 && (c.magFilter = r(a.magFilter, t8)), a.anisotropy !== void 0 && (c.anisotropy = a.anisotropy), a.flipY !== void 0 && (c.flipY = a.flipY), a.generateMipmaps !== void 0 && (c.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (c.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (c.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (c.userData = a.userData), i[a.uuid] = c
            }
        return i
    }
    parseObject(e, n, r, i, s) {
        let o;

        function a(d) {
            return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), n[d]
        }

        function l(d) {
            if (d !== void 0) {
                if (Array.isArray(d)) {
                    const p = [];
                    for (let m = 0, y = d.length; m < y; m++) {
                        const v = d[m];
                        r[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), p.push(r[v])
                    }
                    return p
                }
                return r[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), r[d]
            }
        }

        function u(d) {
            return i[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), i[d]
        }
        let c, f;
        switch (e.type) {
            case "Scene":
                o = new _L, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new dt(e.background) : o.background = u(e.background)), e.environment !== void 0 && (o.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new UE(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new HE(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
                break;
            case "PerspectiveCamera":
                o = new dr(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                o = new Ko(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                o = new KW(e.color, e.intensity);
                break;
            case "DirectionalLight":
                o = new GL(e.color, e.intensity);
                break;
            case "PointLight":
                o = new $L(e.color, e.intensity, e.distance, e.decay);
                break;
            case "RectAreaLight":
                o = new qW(e.color, e.intensity, e.width, e.height);
                break;
            case "SpotLight":
                o = new UL(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                break;
            case "HemisphereLight":
                o = new WW(e.color, e.groundColor, e.intensity);
                break;
            case "LightProbe":
                o = new KE().fromJSON(e);
                break;
            case "SkinnedMesh":
                c = a(e.geometry), f = l(e.material), o = new wL(c, f), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
                break;
            case "Mesh":
                c = a(e.geometry), f = l(e.material), o = new mi(c, f);
                break;
            case "InstancedMesh":
                c = a(e.geometry), f = l(e.material);
                const d = e.count,
                    p = e.instanceMatrix,
                    m = e.instanceColor;
                o = new EL(c, f, d), o.instanceMatrix = new Nm(new Float32Array(p.array), 16), m !== void 0 && (o.instanceColor = new Nm(new Float32Array(m.array), m.itemSize));
                break;
            case "LOD":
                o = new wW;
                break;
            case "Line":
                o = new ku(a(e.geometry), l(e.material));
                break;
            case "LineLoop":
                o = new AL(a(e.geometry), l(e.material));
                break;
            case "LineSegments":
                o = new Ja(a(e.geometry), l(e.material));
                break;
            case "PointCloud":
            case "Points":
                o = new CL(a(e.geometry), l(e.material));
                break;
            case "Sprite":
                o = new SW(l(e.material));
                break;
            case "Group":
                o = new Su;
                break;
            case "Bone":
                o = new $E;
                break;
            default:
                o = new Tn
        }
        if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
            const d = e.children;
            for (let p = 0; p < d.length; p++) o.add(this.parseObject(d[p], n, r, i, s))
        }
        if (e.animations !== void 0) {
            const d = e.animations;
            for (let p = 0; p < d.length; p++) {
                const m = d[p];
                o.animations.push(s[m])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const d = e.levels;
            for (let p = 0; p < d.length; p++) {
                const m = d[p],
                    y = o.getObjectByProperty("uuid", m.object);
                y !== void 0 && o.addLevel(y, m.distance, m.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, n) {
        Object.keys(n).length !== 0 && e.traverse(function(r) {
            if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
                const i = n[r.skeleton];
                i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix)
            }
        })
    }
}
const bme = {
        UVMapping: DE,
        CubeReflectionMapping: lf,
        CubeRefractionMapping: uf,
        EquirectangularReflectionMapping: s0,
        EquirectangularRefractionMapping: o0,
        CubeUVReflectionMapping: gg
    },
    e8 = {
        RepeatWrapping: cf,
        ClampToEdgeWrapping: zi,
        MirroredRepeatWrapping: Lm
    },
    t8 = {
        NearestFilter: Br,
        NearestMipmapNearestFilter: a0,
        NearestMipmapLinearFilter: um,
        LinearFilter: fr,
        LinearMipmapNearestFilter: LE,
        LinearMipmapLinearFilter: Dl
    };
class YW extends As {
    constructor(e) {
        super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e, this
    }
    load(e, n, r, i) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = np.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            n && n(o), s.manager.itemEnd(e)
        }, 0), o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            np.add(e, l), n && n(l), s.manager.itemEnd(e)
        }).catch(function(l) {
            i && i(l), s.manager.itemError(e), s.manager.itemEnd(e)
        }), s.manager.itemStart(e)
    }
}
let jx;
class jL {
    static getContext() {
        return jx === void 0 && (jx = new(window.AudioContext || window.webkitAudioContext)), jx
    }
    static setContext(e) {
        jx = e
    }
}
class xme extends As {
    constructor(e) {
        super(e)
    }
    load(e, n, r, i) {
        const s = this,
            o = new ho(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
            try {
                const l = a.slice(0);
                jL.getContext().decodeAudioData(l, function(c) {
                    n(c)
                })
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, r, i)
    }
}
class _me extends KE {
    constructor(e, n, r = 1) {
        super(void 0, r), this.isHemisphereLightProbe = !0;
        const i = new dt().set(e),
            s = new dt().set(n),
            o = new J(i.r, i.g, i.b),
            a = new J(s.r, s.g, s.b),
            l = Math.sqrt(Math.PI),
            u = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(u)
    }
}
class Sme extends KE {
    constructor(e, n = 1) {
        super(void 0, n), this.isAmbientLightProbe = !0;
        const r = new dt().set(e);
        this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
const n8 = new Gt,
    r8 = new Gt,
    jf = new Gt;
class wme {
    constructor() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new dr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new dr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const n = this._cache;
        if (n.focus !== e.focus || n.fov !== e.fov || n.aspect !== e.aspect * this.aspect || n.near !== e.near || n.far !== e.far || n.zoom !== e.zoom || n.eyeSep !== this.eyeSep) {
            n.focus = e.focus, n.fov = e.fov, n.aspect = e.aspect * this.aspect, n.near = e.near, n.far = e.far, n.zoom = e.zoom, n.eyeSep = this.eyeSep, jf.copy(e.projectionMatrix);
            const i = n.eyeSep / 2,
                s = i * n.near / n.focus,
                o = n.near * Math.tan(kd * n.fov * .5) / n.zoom;
            let a, l;
            r8.elements[12] = -i, n8.elements[12] = i, a = -o * n.aspect + s, l = o * n.aspect + s, jf.elements[0] = 2 * n.near / (l - a), jf.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(jf), a = -o * n.aspect - s, l = o * n.aspect - s, jf.elements[0] = 2 * n.near / (l - a), jf.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(jf)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(r8), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(n8)
    }
}
class WL {
    constructor(e = !0) {
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    start() {
        this.startTime = i8(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }
    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const n = i8();
            e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e
        }
        return e
    }
}

function i8() {
    return (typeof performance > "u" ? Date : performance).now()
}
const Wf = new J,
    s8 = new Ti,
    Eme = new J,
    Kf = new J;
class Ame extends Tn {
    constructor() {
        super(), this.type = "AudioListener", this.context = jL.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new WL
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const n = this.context.listener,
            r = this.up;
        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Wf, s8, Eme), Kf.set(0, 0, -1).applyQuaternion(s8), n.positionX) {
            const i = this.context.currentTime + this.timeDelta;
            n.positionX.linearRampToValueAtTime(Wf.x, i), n.positionY.linearRampToValueAtTime(Wf.y, i), n.positionZ.linearRampToValueAtTime(Wf.z, i), n.forwardX.linearRampToValueAtTime(Kf.x, i), n.forwardY.linearRampToValueAtTime(Kf.y, i), n.forwardZ.linearRampToValueAtTime(Kf.z, i), n.upX.linearRampToValueAtTime(r.x, i), n.upY.linearRampToValueAtTime(r.y, i), n.upZ.linearRampToValueAtTime(r.z, i)
        } else n.setPosition(Wf.x, Wf.y, Wf.z), n.setOrientation(Kf.x, Kf.y, Kf.z, r.x, r.y, r.z)
    }
}
class QW extends Tn {
    constructor(e) {
        super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
    }
    setBuffer(e) {
        return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const n = this.context.createBufferSource();
        return n.buffer = this.buffer, n.loop = this.loop, n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.onended = this.onEnded.bind(this), n.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = n, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, n = this.filters.length; e < n; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, n = this.filters.length; e < n; e++) this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
    }
    setDetune(e) {
        if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
    }
    setLoopStart(e) {
        return this.loopStart = e, this
    }
    setLoopEnd(e) {
        return this.loopEnd = e, this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
}
const qf = new J,
    o8 = new Ti,
    Cme = new J,
    Xf = new J;
class Mme extends QW {
    constructor(e) {
        super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e, this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e, this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e, this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e, this
    }
    setDirectionalCone(e, n, r) {
        return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = n, this.panner.coneOuterGain = r, this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
        this.matrixWorld.decompose(qf, o8, Cme), Xf.set(0, 0, 1).applyQuaternion(o8);
        const n = this.panner;
        if (n.positionX) {
            const r = this.context.currentTime + this.listener.timeDelta;
            n.positionX.linearRampToValueAtTime(qf.x, r), n.positionY.linearRampToValueAtTime(qf.y, r), n.positionZ.linearRampToValueAtTime(qf.z, r), n.orientationX.linearRampToValueAtTime(Xf.x, r), n.orientationY.linearRampToValueAtTime(Xf.y, r), n.orientationZ.linearRampToValueAtTime(Xf.z, r)
        } else n.setPosition(qf.x, qf.y, qf.z), n.setOrientation(Xf.x, Xf.y, Xf.z)
    }
}
class Tme {
    constructor(e, n = 2048) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = n, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data
    }
    getAverageFrequency() {
        let e = 0;
        const n = this.getFrequencyData();
        for (let r = 0; r < n.length; r++) e += n[r];
        return e / n.length
    }
}
class ZW {
    constructor(e, n, r) {
        this.binding = e, this.valueSize = r;
        let i, s, o;
        switch (n) {
            case "quaternion":
                i = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                i = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
                break;
            default:
                i = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5)
        }
        this._mixBufferRegion = i, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    accumulate(e, n) {
        const r = this.buffer,
            i = this.valueSize,
            s = e * i + i;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== i; ++a) r[s + a] = r[a];
            o = n
        } else {
            o += n;
            const a = n / o;
            this._mixBufferRegion(r, s, 0, a, i)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const n = this.buffer,
            r = this.valueSize,
            i = r * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(n, i, 0, e, r), this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const n = this.valueSize,
            r = this.buffer,
            i = e * n + n,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
            const l = n * this._origIndex;
            this._mixBufferRegion(r, i, l, 1 - s, n)
        }
        o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n);
        for (let l = n, u = n + n; l !== u; ++l)
            if (r[l] !== r[l + n]) {
                a.setValue(r, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding,
            n = this.buffer,
            r = this.valueSize,
            i = r * this._origIndex;
        e.getValue(n, i);
        for (let s = r, o = i; s !== o; ++s) n[s] = n[i + s % r];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
            n = e + this.valueSize;
        for (let r = e; r < n; r++) this.buffer[r] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
            n = this._addIndex * this.valueSize;
        for (let r = 0; r < this.valueSize; r++) this.buffer[n + r] = this.buffer[e + r]
    }
    _select(e, n, r, i, s) {
        if (i >= .5)
            for (let o = 0; o !== s; ++o) e[n + o] = e[r + o]
    }
    _slerp(e, n, r, i) {
        Ti.slerpFlat(e, n, e, n, e, r, i)
    }
    _slerpAdditive(e, n, r, i, s) {
        const o = this._workIndex * s;
        Ti.multiplyQuaternionsFlat(e, o, e, n, e, r), Ti.slerpFlat(e, n, e, n, e, o, i)
    }
    _lerp(e, n, r, i, s) {
        const o = 1 - i;
        for (let a = 0; a !== s; ++a) {
            const l = n + a;
            e[l] = e[l] * o + e[r + a] * i
        }
    }
    _lerpAdditive(e, n, r, i, s) {
        for (let o = 0; o !== s; ++o) {
            const a = n + o;
            e[a] = e[a] + e[r + o] * i
        }
    }
}
const KL = "\\[\\]\\.:\\/",
    Pme = new RegExp("[" + KL + "]", "g"),
    qL = "[^" + KL + "]",
    Ime = "[^" + KL.replace("\\.", "") + "]",
    Rme = /((?:WC+[\/:])*)/.source.replace("WC", qL),
    Ome = /(WCOD+)?/.source.replace("WCOD", Ime),
    Dme = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", qL),
    Lme = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", qL),
    kme = new RegExp("^" + Rme + Ome + Dme + Lme + "$"),
    Bme = ["material", "materials", "bones", "map"];
class Fme {
    constructor(e, n, r) {
        const i = r || Mn.parseTrackName(n);
        this._targetGroup = e, this._bindings = e.subscribe_(n, i)
    }
    getValue(e, n) {
        this.bind();
        const r = this._targetGroup.nCachedObjects_,
            i = this._bindings[r];
        i !== void 0 && i.getValue(e, n)
    }
    setValue(e, n) {
        const r = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i) r[i].setValue(e, n)
    }
    bind() {
        const e = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n) e[n].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n) e[n].unbind()
    }
}
class Mn {
    constructor(e, n, r) {
        this.path = n, this.parsedPath = r || Mn.parseTrackName(n), this.node = Mn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(e, n, r) {
        return e && e.isAnimationObjectGroup ? new Mn.Composite(e, n, r) : new Mn(e, n, r)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(Pme, "")
    }
    static parseTrackName(e) {
        const n = kme.exec(e);
        if (n === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const r = {
                nodeName: n[2],
                objectName: n[3],
                objectIndex: n[4],
                propertyName: n[5],
                propertyIndex: n[6]
            },
            i = r.nodeName && r.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = r.nodeName.substring(i + 1);
            Bme.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = s)
        }
        if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return r
    }
    static findNode(e, n) {
        if (n === void 0 || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid) return e;
        if (e.skeleton) {
            const r = e.skeleton.getBoneByName(n);
            if (r !== void 0) return r
        }
        if (e.children) {
            const r = function(s) {
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (a.name === n || a.uuid === n) return a;
                        const l = r(a.children);
                        if (l) return l
                    }
                    return null
                },
                i = r(e.children);
            if (i) return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, n) {
        e[n] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, n) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i) e[n++] = r[i]
    }
    _getValue_arrayElement(e, n) {
        e[n] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, n) {
        this.resolvedProperty.toArray(e, n)
    }
    _setValue_direct(e, n) {
        this.targetObject[this.propertyName] = e[n]
    }
    _setValue_direct_setNeedsUpdate(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, n) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++]
    }
    _setValue_array_setNeedsUpdate(e, n) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[n++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n]
    }
    _setValue_arrayElement_setNeedsUpdate(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, n) {
        this.resolvedProperty.fromArray(e, n)
    }
    _setValue_fromArray_setNeedsUpdate(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, n) {
        this.bind(), this.getValue(e, n)
    }
    _setValue_unbound(e, n) {
        this.bind(), this.setValue(e, n)
    }
    bind() {
        let e = this.node;
        const n = this.parsedPath,
            r = n.objectName,
            i = n.propertyName;
        let s = n.propertyIndex;
        if (e || (e = Mn.findNode(this.rootNode, n.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (r) {
            let u = n.objectIndex;
            switch (r) {
                case "materials":
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    e = e.skeleton.bones;
                    for (let c = 0; c < e.length; c++)
                        if (e[c].name === u) {
                            u = c;
                            break
                        }
                    break;
                case "map":
                    if ("map" in e) {
                        e = e.map;
                        break
                    }
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[r] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    e = e[r]
            }
            if (u !== void 0) {
                if (e[u] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[u]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const u = n.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
Mn.Composite = Fme;
Mn.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Mn.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Mn.prototype.GetterByBindingType = [Mn.prototype._getValue_direct, Mn.prototype._getValue_array, Mn.prototype._getValue_arrayElement, Mn.prototype._getValue_toArray];
Mn.prototype.SetterByBindingTypeAndVersioning = [
    [Mn.prototype._setValue_direct, Mn.prototype._setValue_direct_setNeedsUpdate, Mn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [Mn.prototype._setValue_array, Mn.prototype._setValue_array_setNeedsUpdate, Mn.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [Mn.prototype._setValue_arrayElement, Mn.prototype._setValue_arrayElement_setNeedsUpdate, Mn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [Mn.prototype._setValue_fromArray, Mn.prototype._setValue_fromArray_setNeedsUpdate, Mn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class Nme {
    constructor() {
        this.isAnimationObjectGroup = !0, this.uuid = uo(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let r = 0, i = arguments.length; r !== i; ++r) e[arguments[r].uuid] = r;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }
    add() {
        const e = this._objects,
            n = this._indicesByUUID,
            r = this._paths,
            i = this._parsedPaths,
            s = this._bindings,
            o = s.length;
        let a, l = e.length,
            u = this.nCachedObjects_;
        for (let c = 0, f = arguments.length; c !== f; ++c) {
            const d = arguments[c],
                p = d.uuid;
            let m = n[p];
            if (m === void 0) {
                m = l++, n[p] = m, e.push(d);
                for (let y = 0, v = o; y !== v; ++y) s[y].push(new Mn(d, r[y], i[y]))
            } else if (m < u) {
                a = e[m];
                const y = --u,
                    v = e[y];
                n[v.uuid] = m, e[m] = v, n[p] = y, e[y] = d;
                for (let b = 0, _ = o; b !== _; ++b) {
                    const x = s[b],
                        S = x[y];
                    let E = x[m];
                    x[m] = S, E === void 0 && (E = new Mn(d, r[b], i[b])), x[y] = E
                }
            } else e[m] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = u
    }
    remove() {
        const e = this._objects,
            n = this._indicesByUUID,
            r = this._bindings,
            i = r.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o],
                u = l.uuid,
                c = n[u];
            if (c !== void 0 && c >= s) {
                const f = s++,
                    d = e[f];
                n[d.uuid] = c, e[c] = d, n[u] = f, e[f] = l;
                for (let p = 0, m = i; p !== m; ++p) {
                    const y = r[p],
                        v = y[f],
                        b = y[c];
                    y[c] = v, y[f] = b
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects,
            n = this._indicesByUUID,
            r = this._bindings,
            i = r.length;
        let s = this.nCachedObjects_,
            o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const u = arguments[a],
                c = u.uuid,
                f = n[c];
            if (f !== void 0)
                if (delete n[c], f < s) {
                    const d = --s,
                        p = e[d],
                        m = --o,
                        y = e[m];
                    n[p.uuid] = f, e[f] = p, n[y.uuid] = d, e[d] = y, e.pop();
                    for (let v = 0, b = i; v !== b; ++v) {
                        const _ = r[v],
                            x = _[d],
                            S = _[m];
                        _[f] = x, _[d] = S, _.pop()
                    }
                } else {
                    const d = --o,
                        p = e[d];
                    d > 0 && (n[p.uuid] = f), e[f] = p, e.pop();
                    for (let m = 0, y = i; m !== y; ++m) {
                        const v = r[m];
                        v[f] = v[d], v.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, n) {
        const r = this._bindingsIndicesByPath;
        let i = r[e];
        const s = this._bindings;
        if (i !== void 0) return s[i];
        const o = this._paths,
            a = this._parsedPaths,
            l = this._objects,
            u = l.length,
            c = this.nCachedObjects_,
            f = new Array(u);
        i = s.length, r[e] = i, o.push(e), a.push(n), s.push(f);
        for (let d = c, p = l.length; d !== p; ++d) {
            const m = l[d];
            f[d] = new Mn(m, e, n)
        }
        return f
    }
    unsubscribe_(e) {
        const n = this._bindingsIndicesByPath,
            r = n[e];
        if (r !== void 0) {
            const i = this._paths,
                s = this._parsedPaths,
                o = this._bindings,
                a = o.length - 1,
                l = o[a],
                u = e[a];
            n[u] = r, o[r] = l, o.pop(), s[r] = s[a], s.pop(), i[r] = i[a], i.pop()
        }
    }
}
class zme {
    constructor(e, n, r = null, i = n.blendMode) {
        this._mixer = e, this._clip = n, this._localRoot = r, this.blendMode = i;
        const s = n.tracks,
            o = s.length,
            a = new Array(o),
            l = {
                endingStart: yd,
                endingEnd: yd
            };
        for (let u = 0; u !== o; ++u) {
            const c = s[u].createInterpolant(null);
            a[u] = c, c.settings = l
        }
        this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Zj, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this), this
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset()
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e, this
    }
    setLoop(e, n) {
        return this.loop = e, this.repetitions = n, this
    }
    setEffectiveWeight(e) {
        return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, n, r) {
        if (e.fadeOut(n), this.fadeIn(n), r) {
            const i = this._clip.duration,
                s = e._clip.duration,
                o = s / i,
                a = i / s;
            e.warp(1, o, n), this.warp(a, 1, n)
        }
        return this
    }
    crossFadeTo(e, n, r) {
        return e.crossFadeFrom(this, n, r)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e, this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, n, r) {
        const i = this._mixer,
            s = i.time,
            o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
        const l = a.parameterPositions,
            u = a.sampleValues;
        return l[0] = s, l[1] = s + r, u[0] = e / o, u[1] = n / o, this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, n, r, i) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * r;
            l < 0 || r === 0 ? n = 0 : (this._startTime = null, n = r * l)
        }
        n *= this._updateTimeScale(e);
        const o = this._updateTime(n),
            a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants,
                u = this._propertyBindings;
            switch (this.blendMode) {
                case uL:
                    for (let c = 0, f = l.length; c !== f; ++c) l[c].evaluate(o), u[c].accumulateAdditive(a);
                    break;
                case kE:
                default:
                    for (let c = 0, f = l.length; c !== f; ++c) l[c].evaluate(o), u[c].accumulate(i, a)
            }
        }
    }
    _updateWeight(e) {
        let n = 0;
        if (this.enabled) {
            n = this.weight;
            const r = this._weightInterpolant;
            if (r !== null) {
                const i = r.evaluate(e)[0];
                n *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = n, n
    }
    _updateTimeScale(e) {
        let n = 0;
        if (!this.paused) {
            n = this.timeScale;
            const r = this._timeScaleInterpolant;
            if (r !== null) {
                const i = r.evaluate(e)[0];
                n *= i, e > r.parameterPositions[1] && (this.stopWarping(), n === 0 ? this.paused = !0 : this.timeScale = n)
            }
        }
        return this._effectiveTimeScale = n, n
    }
    _updateTime(e) {
        const n = this._clip.duration,
            r = this.loop;
        let i = this.time + e,
            s = this._loopCount;
        const o = r === eW;
        if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? n - i : i;
        if (r === Qj) {
            s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
                if (i >= n) i = n;
                else if (i < 0) i = 0;
                else {
                    this.time = i;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= n || i < 0) {
                const a = Math.floor(i / n);
                i -= n * a, s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? n : 0, this.time = i, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1
                });
                else {
                    if (l === 1) {
                        const u = e < 0;
                        this._setEndings(u, !u, o)
                    } else this._setEndings(!1, !1, o);
                    this._loopCount = s, this.time = i, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else this.time = i;
            if (o && (s & 1) === 1) return n - i
        }
        return i
    }
    _setEndings(e, n, r) {
        const i = this._interpolantSettings;
        r ? (i.endingStart = vd, i.endingEnd = vd) : (e ? i.endingStart = this.zeroSlopeAtStart ? vd : yd : i.endingStart = l0, n ? i.endingEnd = this.zeroSlopeAtEnd ? vd : yd : i.endingEnd = l0)
    }
    _scheduleFading(e, n, r) {
        const i = this._mixer,
            s = i.time;
        let o = this._weightInterpolant;
        o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
        const a = o.parameterPositions,
            l = o.sampleValues;
        return a[0] = s, l[0] = n, a[1] = s + e, l[1] = r, this
    }
}
const Hme = new Float32Array(1);
class Ume extends Bl {
    constructor(e) {
        super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }
    _bindAction(e, n) {
        const r = e._localRoot || this._root,
            i = e._clip.tracks,
            s = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = r.uuid,
            u = this._bindingsByRootAndName;
        let c = u[l];
        c === void 0 && (c = {}, u[l] = c);
        for (let f = 0; f !== s; ++f) {
            const d = i[f],
                p = d.name;
            let m = c[p];
            if (m !== void 0) ++m.referenceCount, o[f] = m;
            else {
                if (m = o[f], m !== void 0) {
                    m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, p));
                    continue
                }
                const y = n && n._propertyBindings[f].binding.parsedPath;
                m = new ZW(Mn.create(r, p, y), d.ValueTypeName, d.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, l, p), o[f] = m
            }
            a[f].resultBuffer = m.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const r = (e._localRoot || this._root).uuid,
                    i = e._clip.uuid,
                    s = this._actionsByClip[i];
                this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, i, r)
            }
            const n = e._propertyBindings;
            for (let r = 0, i = n.length; r !== i; ++r) {
                const s = n[r];
                s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const n = e._propertyBindings;
            for (let r = 0, i = n.length; r !== i; ++r) {
                const s = n[r];
                --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const n = e._cacheIndex;
        return n !== null && n < this._nActiveActions
    }
    _addInactiveAction(e, n, r) {
        const i = this._actions,
            s = this._actionsByClip;
        let o = s[n];
        if (o === void 0) o = {
            knownActions: [e],
            actionByRoot: {}
        }, e._byClipCacheIndex = 0, s[n] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length, a.push(e)
        }
        e._cacheIndex = i.length, i.push(e), o.actionByRoot[r] = e
    }
    _removeInactiveAction(e) {
        const n = this._actions,
            r = n[n.length - 1],
            i = e._cacheIndex;
        r._cacheIndex = i, n[i] = r, n.pop(), e._cacheIndex = null;
        const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            l = a.knownActions,
            u = l[l.length - 1],
            c = e._byClipCacheIndex;
        u._byClipCacheIndex = c, l[c] = u, l.pop(), e._byClipCacheIndex = null;
        const f = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
        delete f[d], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const n = e._propertyBindings;
        for (let r = 0, i = n.length; r !== i; ++r) {
            const s = n[r];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const n = this._actions,
            r = e._cacheIndex,
            i = this._nActiveActions++,
            s = n[i];
        e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
    }
    _takeBackAction(e) {
        const n = this._actions,
            r = e._cacheIndex,
            i = --this._nActiveActions,
            s = n[i];
        e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
    }
    _addInactiveBinding(e, n, r) {
        const i = this._bindingsByRootAndName,
            s = this._bindings;
        let o = i[n];
        o === void 0 && (o = {}, i[n] = o), o[r] = e, e._cacheIndex = s.length, s.push(e)
    }
    _removeInactiveBinding(e) {
        const n = this._bindings,
            r = e.binding,
            i = r.rootNode.uuid,
            s = r.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = n[n.length - 1],
            u = e._cacheIndex;
        l._cacheIndex = u, n[u] = l, n.pop(), delete a[s], Object.keys(a).length === 0 && delete o[i]
    }
    _lendBinding(e) {
        const n = this._bindings,
            r = e._cacheIndex,
            i = this._nActiveBindings++,
            s = n[i];
        e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
    }
    _takeBackBinding(e) {
        const n = this._bindings,
            r = e._cacheIndex,
            i = --this._nActiveBindings,
            s = n[i];
        e._cacheIndex = i, n[i] = e, s._cacheIndex = r, n[r] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants,
            n = this._nActiveControlInterpolants++;
        let r = e[n];
        return r === void 0 && (r = new FL(new Float32Array(2), new Float32Array(2), 1, Hme), r.__cacheIndex = n, e[n] = r), r
    }
    _takeBackControlInterpolant(e) {
        const n = this._controlInterpolants,
            r = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            s = n[i];
        e.__cacheIndex = i, n[i] = e, s.__cacheIndex = r, n[r] = s
    }
    clipAction(e, n, r) {
        const i = n || this._root,
            s = i.uuid;
        let o = typeof e == "string" ? Um.findByName(i, e) : e;
        const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
        let u = null;
        if (r === void 0 && (o !== null ? r = o.blendMode : r = kE), l !== void 0) {
            const f = l.actionByRoot[s];
            if (f !== void 0 && f.blendMode === r) return f;
            u = l.knownActions[0], o === null && (o = u._clip)
        }
        if (o === null) return null;
        const c = new zme(this, o, n, r);
        return this._bindAction(c, u), this._addInactiveAction(c, a, s), c
    }
    existingAction(e, n) {
        const r = n || this._root,
            i = r.uuid,
            s = typeof e == "string" ? Um.findByName(r, e) : e,
            o = s ? s.uuid : e,
            a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions,
            n = this._nActiveActions;
        for (let r = n - 1; r >= 0; --r) e[r].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const n = this._actions,
            r = this._nActiveActions,
            i = this.time += e,
            s = Math.sign(e),
            o = this._accuIndex ^= 1;
        for (let u = 0; u !== r; ++u) n[u]._update(i, e, s, o);
        const a = this._bindings,
            l = this._nActiveBindings;
        for (let u = 0; u !== l; ++u) a[u].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let n = 0; n < this._actions.length; n++) this._actions[n].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const n = this._actions,
            r = e.uuid,
            i = this._actionsByClip,
            s = i[r];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const u = o[a];
                this._deactivateAction(u);
                const c = u._cacheIndex,
                    f = n[n.length - 1];
                u._cacheIndex = null, u._byClipCacheIndex = null, f._cacheIndex = c, n[c] = f, n.pop(), this._removeInactiveBindingsForAction(u)
            }
            delete i[r]
        }
    }
    uncacheRoot(e) {
        const n = e.uuid,
            r = this._actionsByClip;
        for (const o in r) {
            const a = r[o].actionByRoot,
                l = a[n];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
        }
        const i = this._bindingsByRootAndName,
            s = i[n];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(), this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, n) {
        const r = this.existingAction(e, n);
        r !== null && (this._deactivateAction(r), this._removeInactiveAction(r))
    }
}
class XL {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new XL(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let $me = 0;
class Gme extends Bl {
    constructor() {
        super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
            value: $me++
        }), this.name = "", this.usage = u0, this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e), this
    }
    remove(e) {
        const n = this.uniforms.indexOf(e);
        return n !== -1 && this.uniforms.splice(n, 1), this
    }
    setName(e) {
        return this.name = e, this
    }
    setUsage(e) {
        return this.usage = e, this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }), this
    }
    copy(e) {
        this.name = e.name, this.usage = e.usage;
        const n = e.uniforms;
        this.uniforms.length = 0;
        for (let r = 0, i = n.length; r < i; r++) this.uniforms.push(n[r].clone());
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Bw extends p1 {
    constructor(e, n, r = 1) {
        super(e, n), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    clone(e) {
        const n = super.clone(e);
        return n.meshPerAttribute = this.meshPerAttribute, n
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.isInstancedInterleavedBuffer = !0, n.meshPerAttribute = this.meshPerAttribute, n
    }
}
class Vme {
    constructor(e, n, r, i, s) {
        this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = n, this.itemSize = r, this.elementSize = i, this.count = s, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e, this
    }
    setType(e, n) {
        return this.type = e, this.elementSize = n, this
    }
    setItemSize(e) {
        return this.itemSize = e, this
    }
    setCount(e) {
        return this.count = e, this
    }
}
class eK {
    constructor(e, n, r = 0, i = 1 / 0) {
        this.ray = new yg(e, n), this.near = r, this.far = i, this.camera = null, this.layers = new Bd, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, n) {
        this.ray.set(e, n)
    }
    setFromCamera(e, n) {
        n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type)
    }
    intersectObject(e, n = !0, r = []) {
        return I3(e, this, r, n), r.sort(a8), r
    }
    intersectObjects(e, n = !0, r = []) {
        for (let i = 0, s = e.length; i < s; i++) I3(e[i], this, r, n);
        return r.sort(a8), r
    }
}

function a8(t, e) {
    return t.distance - e.distance
}

function I3(t, e, n, r) {
    if (t.layers.test(e.layers) && t.raycast(e, n), r === !0) {
        const i = t.children;
        for (let s = 0, o = i.length; s < o; s++) I3(i[s], e, n, !0)
    }
}
class R3 {
    constructor(e = 1, n = 0, r = 0) {
        return this.radius = e, this.phi = n, this.theta = r, this
    }
    set(e, n, r) {
        return this.radius = e, this.phi = n, this.theta = r, this
    }
    copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, n, r) {
        return this.radius = Math.sqrt(e * e + n * n + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Xr(n / this.radius, -1, 1))), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class jme {
    constructor(e = 1, n = 0, r = 0) {
        return this.radius = e, this.theta = n, this.y = r, this
    }
    set(e, n, r) {
        return this.radius = e, this.theta = n, this.y = r, this
    }
    copy(e) {
        return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, n, r) {
        return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = n, this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const l8 = new ke;
class Wme {
    constructor(e = new ke(1 / 0, 1 / 0), n = new ke(-1 / 0, -1 / 0)) {
        this.isBox2 = !0, this.min = e, this.max = n
    }
    set(e, n) {
        return this.min.copy(e), this.max.copy(n), this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
        return this
    }
    setFromCenterAndSize(e, n) {
        const r = l8.copy(n).multiplyScalar(.5);
        return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, n) {
        return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, n) {
        return n.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, l8).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const u8 = new J,
    Wx = new J;
class tK {
    constructor(e = new J, n = new J) {
        this.start = e, this.end = n
    }
    set(e, n) {
        return this.start.copy(e), this.end.copy(n), this
    }
    copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, n) {
        return this.delta(n).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, n) {
        u8.subVectors(e, this.start), Wx.subVectors(this.end, this.start);
        const r = Wx.dot(Wx);
        let s = Wx.dot(u8) / r;
        return n && (s = Xr(s, 0, 1)), s
    }
    closestPointToPoint(e, n, r) {
        const i = this.closestPointToPointParameter(e, n);
        return this.delta(r).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const c8 = new J;
class Kme extends Tn {
    constructor(e, n) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
        const r = new on,
            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
            const u = o / l * Math.PI * 2,
                c = a / l * Math.PI * 2;
            i.push(Math.cos(u), Math.sin(u), 1, Math.cos(c), Math.sin(c), 1)
        }
        r.setAttribute("position", new Mt(i, 3));
        const s = new us({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Ja(r, s), this.add(this.cone), this.update()
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
        const e = this.light.distance ? this.light.distance : 1e3,
            n = e * Math.tan(this.light.angle);
        this.cone.scale.set(n, n, e), c8.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(c8), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const hc = new J,
    Kx = new Gt,
    uT = new Gt;
class qme extends Ja {
    constructor(e) {
        const n = nK(e),
            r = new on,
            i = [],
            s = [],
            o = new dt(0, 0, 1),
            a = new dt(0, 1, 0);
        for (let u = 0; u < n.length; u++) {
            const c = n[u];
            c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b))
        }
        r.setAttribute("position", new Mt(i, 3)), r.setAttribute("color", new Mt(s, 3));
        const l = new us({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(r, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = n, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const n = this.bones,
            r = this.geometry,
            i = r.getAttribute("position");
        uT.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < n.length; s++) {
            const a = n[s];
            a.parent && a.parent.isBone && (Kx.multiplyMatrices(uT, a.matrixWorld), hc.setFromMatrixPosition(Kx), i.setXYZ(o, hc.x, hc.y, hc.z), Kx.multiplyMatrices(uT, a.parent.matrixWorld), hc.setFromMatrixPosition(Kx), i.setXYZ(o + 1, hc.x, hc.y, hc.z), o += 2)
        }
        r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function nK(t) {
    const e = [];
    t.isBone === !0 && e.push(t);
    for (let n = 0; n < t.children.length; n++) e.push.apply(e, nK(t.children[n]));
    return e
}
class Xme extends mi {
    constructor(e, n, r) {
        const i = new Sg(n, 4, 2),
            s = new oo({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            });
        super(i, s), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const Jme = new J,
    f8 = new dt,
    d8 = new dt;
class Yme extends Tn {
    constructor(e, n, r) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper";
        const i = new _g(n);
        i.rotateY(Math.PI * .5), this.material = new oo({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }), this.color === void 0 && (this.material.vertexColors = !0);
        const s = i.getAttribute("position"),
            o = new Float32Array(s.count * 3);
        i.setAttribute("color", new Ln(o, 3)), this.add(new mi(i, this.material)), this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0) this.material.color.set(this.color);
        else {
            const n = e.geometry.getAttribute("color");
            f8.copy(this.light.color), d8.copy(this.light.groundColor);
            for (let r = 0, i = n.count; r < i; r++) {
                const s = r < i / 2 ? f8 : d8;
                n.setXYZ(r, s.r, s.g, s.b)
            }
            n.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1), e.lookAt(Jme.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class Qme extends Ja {
    constructor(e = 10, n = 10, r = 4473924, i = 8947848) {
        r = new dt(r), i = new dt(i);
        const s = n / 2,
            o = e / n,
            a = e / 2,
            l = [],
            u = [];
        for (let d = 0, p = 0, m = -a; d <= n; d++, m += o) {
            l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
            const y = d === s ? r : i;
            y.toArray(u, p), p += 3, y.toArray(u, p), p += 3, y.toArray(u, p), p += 3, y.toArray(u, p), p += 3
        }
        const c = new on;
        c.setAttribute("position", new Mt(l, 3)), c.setAttribute("color", new Mt(u, 3));
        const f = new us({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, f), this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class Zme extends Ja {
    constructor(e = 10, n = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
        s = new dt(s), o = new dt(o);
        const a = [],
            l = [];
        if (n > 1)
            for (let f = 0; f < n; f++) {
                const d = f / n * (Math.PI * 2),
                    p = Math.sin(d) * e,
                    m = Math.cos(d) * e;
                a.push(0, 0, 0), a.push(p, 0, m);
                const y = f & 1 ? s : o;
                l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b)
            }
        for (let f = 0; f < r; f++) {
            const d = f & 1 ? s : o,
                p = e - e / r * f;
            for (let m = 0; m < i; m++) {
                let y = m / i * (Math.PI * 2),
                    v = Math.sin(y) * p,
                    b = Math.cos(y) * p;
                a.push(v, 0, b), l.push(d.r, d.g, d.b), y = (m + 1) / i * (Math.PI * 2), v = Math.sin(y) * p, b = Math.cos(y) * p, a.push(v, 0, b), l.push(d.r, d.g, d.b)
            }
        }
        const u = new on;
        u.setAttribute("position", new Mt(a, 3)), u.setAttribute("color", new Mt(l, 3));
        const c = new us({
            vertexColors: !0,
            toneMapped: !1
        });
        super(u, c), this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
const p8 = new J,
    qx = new J,
    h8 = new J;
class ege extends Tn {
    constructor(e, n, r) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
        let i = new on;
        i.setAttribute("position", new Mt([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3));
        const s = new us({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new ku(i, s), this.add(this.lightPlane), i = new on, i.setAttribute("position", new Mt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ku(i, s), this.add(this.targetLine), this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), p8.setFromMatrixPosition(this.light.matrixWorld), qx.setFromMatrixPosition(this.light.target.matrixWorld), h8.subVectors(qx, p8), this.lightPlane.lookAt(qx), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(qx), this.targetLine.scale.z = h8.length()
    }
}
const Xx = new J,
    Or = new f1;
class tge extends Ja {
    constructor(e) {
        const n = new on,
            r = new us({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            }),
            i = [],
            s = [],
            o = {};
        a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");

        function a(m, y) {
            l(m), l(y)
        }

        function l(m) {
            i.push(0, 0, 0), s.push(0, 0, 0), o[m] === void 0 && (o[m] = []), o[m].push(i.length / 3 - 1)
        }
        n.setAttribute("position", new Mt(i, 3)), n.setAttribute("color", new Mt(s, 3)), super(n, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
        const u = new dt(16755200),
            c = new dt(16711680),
            f = new dt(43775),
            d = new dt(16777215),
            p = new dt(3355443);
        this.setColors(u, c, f, d, p)
    }
    setColors(e, n, r, i, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, n.r, n.g, n.b), a.setXYZ(25, n.r, n.g, n.b), a.setXYZ(26, n.r, n.g, n.b), a.setXYZ(27, n.r, n.g, n.b), a.setXYZ(28, n.r, n.g, n.b), a.setXYZ(29, n.r, n.g, n.b), a.setXYZ(30, n.r, n.g, n.b), a.setXYZ(31, n.r, n.g, n.b), a.setXYZ(32, r.r, r.g, r.b), a.setXYZ(33, r.r, r.g, r.b), a.setXYZ(34, r.r, r.g, r.b), a.setXYZ(35, r.r, r.g, r.b), a.setXYZ(36, r.r, r.g, r.b), a.setXYZ(37, r.r, r.g, r.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0
    }
    update() {
        const e = this.geometry,
            n = this.pointMap,
            r = 1,
            i = 1;
        Or.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Wr("c", n, e, Or, 0, 0, -1), Wr("t", n, e, Or, 0, 0, 1), Wr("n1", n, e, Or, -r, -i, -1), Wr("n2", n, e, Or, r, -i, -1), Wr("n3", n, e, Or, -r, i, -1), Wr("n4", n, e, Or, r, i, -1), Wr("f1", n, e, Or, -r, -i, 1), Wr("f2", n, e, Or, r, -i, 1), Wr("f3", n, e, Or, -r, i, 1), Wr("f4", n, e, Or, r, i, 1), Wr("u1", n, e, Or, r * .7, i * 1.1, -1), Wr("u2", n, e, Or, -r * .7, i * 1.1, -1), Wr("u3", n, e, Or, 0, i * 2, -1), Wr("cf1", n, e, Or, -r, 0, 1), Wr("cf2", n, e, Or, r, 0, 1), Wr("cf3", n, e, Or, 0, -i, 1), Wr("cf4", n, e, Or, 0, i, 1), Wr("cn1", n, e, Or, -r, 0, -1), Wr("cn2", n, e, Or, r, 0, -1), Wr("cn3", n, e, Or, 0, -i, -1), Wr("cn4", n, e, Or, 0, i, -1), e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function Wr(t, e, n, r, i, s, o) {
    Xx.set(i, s, o).unproject(r);
    const a = e[t];
    if (a !== void 0) {
        const l = n.getAttribute("position");
        for (let u = 0, c = a.length; u < c; u++) l.setXYZ(a[u], Xx.x, Xx.y, Xx.z)
    }
}
const Jx = new Xa;
class nge extends Ja {
    constructor(e, n = 16776960) {
        const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new Float32Array(8 * 3),
            s = new on;
        s.setIndex(new Ln(r, 1)), s.setAttribute("position", new Ln(i, 3)), super(s, new us({
            color: n,
            toneMapped: !1
        })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Jx.setFromObject(this.object), Jx.isEmpty()) return;
        const n = Jx.min,
            r = Jx.max,
            i = this.geometry.attributes.position,
            s = i.array;
        s[0] = r.x, s[1] = r.y, s[2] = r.z, s[3] = n.x, s[4] = r.y, s[5] = r.z, s[6] = n.x, s[7] = n.y, s[8] = r.z, s[9] = r.x, s[10] = n.y, s[11] = r.z, s[12] = r.x, s[13] = r.y, s[14] = n.z, s[15] = n.x, s[16] = r.y, s[17] = n.z, s[18] = n.x, s[19] = n.y, s[20] = n.z, s[21] = r.x, s[22] = n.y, s[23] = n.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e, this.update(), this
    }
    copy(e, n) {
        return super.copy(e, n), this.object = e.object, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class rge extends Ja {
    constructor(e, n = 16776960) {
        const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
            s = new on;
        s.setIndex(new Ln(r, 1)), s.setAttribute("position", new Mt(i, 3)), super(s, new us({
            color: n,
            toneMapped: !1
        })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const n = this.box;
        n.isEmpty() || (n.getCenter(this.position), n.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class ige extends ku {
    constructor(e, n = 1, r = 16776960) {
        const i = r,
            s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
            o = new on;
        o.setAttribute("position", new Mt(s, 3)), o.computeBoundingSphere(), super(o, new us({
            color: i,
            toneMapped: !1
        })), this.type = "PlaneHelper", this.plane = e, this.size = n;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            l = new on;
        l.setAttribute("position", new Mt(a, 3)), l.computeBoundingSphere(), this.add(new mi(l, new oo({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
}
const m8 = new J;
let Yx, cT;
class sge extends Tn {
    constructor(e = new J(0, 0, 1), n = new J(0, 0, 0), r = 1, i = 16776960, s = r * .2, o = s * .2) {
        super(), this.type = "ArrowHelper", Yx === void 0 && (Yx = new on, Yx.setAttribute("position", new Mt([0, 0, 0, 0, 1, 0], 3)), cT = new wf(0, .5, 1, 5, 1), cT.translate(0, -.5, 0)), this.position.copy(n), this.line = new ku(Yx, new us({
            color: i,
            toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new mi(cT, new oo({
            color: i,
            toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, s, o)
    }
    setDirection(e) {
        if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            m8.set(e.z, 0, -e.x).normalize();
            const n = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(m8, n)
        }
    }
    setLength(e, n = e * .2, r = n * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - n), 1), this.line.updateMatrix(), this.cone.scale.set(r, n, r), this.cone.position.y = e, this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }
    dispose() {
        this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
    }
}
class oge extends Ja {
    constructor(e = 1) {
        const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            i = new on;
        i.setAttribute("position", new Mt(n, 3)), i.setAttribute("color", new Mt(r, 3));
        const s = new us({
            vertexColors: !0,
            toneMapped: !1
        });
        super(i, s), this.type = "AxesHelper"
    }
    setColors(e, n, r) {
        const i = new dt,
            s = this.geometry.attributes.color.array;
        return i.set(e), i.toArray(s, 0), i.toArray(s, 3), i.set(n), i.toArray(s, 6), i.toArray(s, 9), i.set(r), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class age {
    constructor() {
        this.type = "ShapePath", this.color = new dt, this.subPaths = [], this.currentPath = null
    }
    moveTo(e, n) {
        return this.currentPath = new d0, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, n), this
    }
    lineTo(e, n) {
        return this.currentPath.lineTo(e, n), this
    }
    quadraticCurveTo(e, n, r, i) {
        return this.currentPath.quadraticCurveTo(e, n, r, i), this
    }
    bezierCurveTo(e, n, r, i, s, o) {
        return this.currentPath.bezierCurveTo(e, n, r, i, s, o), this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this
    }
    toShapes(e) {
        function n(b) {
            const _ = [];
            for (let x = 0, S = b.length; x < S; x++) {
                const E = b[x],
                    A = new Fd;
                A.curves = E.curves, _.push(A)
            }
            return _
        }

        function r(b, _) {
            const x = _.length;
            let S = !1;
            for (let E = x - 1, A = 0; A < x; E = A++) {
                let T = _[E],
                    M = _[A],
                    I = M.x - T.x,
                    O = M.y - T.y;
                if (Math.abs(O) > Number.EPSILON) {
                    if (O < 0 && (T = _[A], I = -I, M = _[E], O = -O), b.y < T.y || b.y > M.y) continue;
                    if (b.y === T.y) {
                        if (b.x === T.x) return !0
                    } else {
                        const k = O * (b.x - T.x) - I * (b.y - T.y);
                        if (k === 0) return !0;
                        if (k < 0) continue;
                        S = !S
                    }
                } else {
                    if (b.y !== T.y) continue;
                    if (M.x <= b.x && b.x <= T.x || T.x <= b.x && b.x <= M.x) return !0
                }
            }
            return S
        }
        const i = Ml.isClockWise,
            s = this.subPaths;
        if (s.length === 0) return [];
        let o, a, l;
        const u = [];
        if (s.length === 1) return a = s[0], l = new Fd, l.curves = a.curves, u.push(l), u;
        let c = !i(s[0].getPoints());
        c = e ? !c : c;
        const f = [],
            d = [];
        let p = [],
            m = 0,
            y;
        d[m] = void 0, p[m] = [];
        for (let b = 0, _ = s.length; b < _; b++) a = s[b], y = a.getPoints(), o = i(y), o = e ? !o : o, o ? (!c && d[m] && m++, d[m] = {
            s: new Fd,
            p: y
        }, d[m].s.curves = a.curves, c && m++, p[m] = []) : p[m].push({
            h: a,
            p: y[0]
        });
        if (!d[0]) return n(s);
        if (d.length > 1) {
            let b = !1,
                _ = 0;
            for (let x = 0, S = d.length; x < S; x++) f[x] = [];
            for (let x = 0, S = d.length; x < S; x++) {
                const E = p[x];
                for (let A = 0; A < E.length; A++) {
                    const T = E[A];
                    let M = !0;
                    for (let I = 0; I < d.length; I++) r(T.p, d[I].p) && (x !== I && _++, M ? (M = !1, f[I].push(T)) : b = !0);
                    M && f[x].push(T)
                }
            }
            _ > 0 && b === !1 && (p = f)
        }
        let v;
        for (let b = 0, _ = d.length; b < _; b++) {
            l = d[b].s, u.push(l), v = p[b];
            for (let x = 0, S = v.length; x < S; x++) l.holes.push(v[x].h)
        }
        return u
    }
}
const gu = lge();

function lge() {
    const t = new ArrayBuffer(4),
        e = new Float32Array(t),
        n = new Uint32Array(t),
        r = new Uint32Array(512),
        i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const u = l - 127;
        u < -27 ? (r[l] = 0, r[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : u < -14 ? (r[l] = 1024 >> -u - 14, r[l | 256] = 1024 >> -u - 14 | 32768, i[l] = -u - 1, i[l | 256] = -u - 1) : u <= 15 ? (r[l] = u + 15 << 10, r[l | 256] = u + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : u < 128 ? (r[l] = 31744, r[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (r[l] = 31744, r[l | 256] = 64512, i[l] = 13, i[l | 256] = 13)
    }
    const s = new Uint32Array(2048),
        o = new Uint32Array(64),
        a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let u = l << 13,
            c = 0;
        for (; !(u & 8388608);) u <<= 1, c -= 8388608;
        u &= -8388609, c += 947912704, s[l] = u | c
    }
    for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l) o[l] = l << 23;
    o[31] = 1199570944, o[32] = 2147483648;
    for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: n,
        baseTable: r,
        shiftTable: i,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}

function uge(t) {
    Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = Xr(t, -65504, 65504), gu.floatView[0] = t;
    const e = gu.uint32View[0],
        n = e >> 23 & 511;
    return gu.baseTable[n] + ((e & 8388607) >> gu.shiftTable[n])
}

function cge(t) {
    const e = t >> 10;
    return gu.uint32View[0] = gu.mantissaTable[gu.offsetTable[e] + (t & 1023)] + gu.exponentTable[e], gu.floatView[0]
}
const fge = {
    toHalfFloat: uge,
    fromHalfFloat: cge
};
class dge extends Sf {
    constructor(e, n, r, i, s, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, n, r, i, s, o)
    }
}
class pge extends m1 {
    constructor(e, n, r, i) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, n, r, i)
    }
}
class hge extends g1 {
    constructor(e, n, r, i) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, n, r, i)
    }
}
class mge extends y1 {
    constructor(e, n, r, i, s, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, n, r, i, s, o, a)
    }
}
class gge extends wf {
    constructor(e, n, r, i, s, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, n, r, i, s, o, a, l)
    }
}
class yge extends v1 {
    constructor(e, n) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, n)
    }
}
class vge extends b1 {
    constructor(e, n) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, n)
    }
}
class bge extends x1 {
    constructor(e, n) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, n)
    }
}
class xge extends xg {
    constructor(e, n, r, i) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, n, r, i)
    }
}
class _ge extends _g {
    constructor(e, n) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, n)
    }
}
class Sge extends vg {
    constructor(e, n, r, i) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, n, r, i)
    }
}
class wge extends Vu {
    constructor(e, n, r, i) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, n, r, i)
    }
}
class Ege extends _1 {
    constructor(e, n, r, i, s, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, n, r, i, s, o)
    }
}
class Age extends S1 {
    constructor(e, n) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, n)
    }
}
class Cge extends Sg {
    constructor(e, n, r, i, s, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, n, r, i, s, o, a)
    }
}
class Mge extends w1 {
    constructor(e, n) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, n)
    }
}
class Tge extends E1 {
    constructor(e, n, r, i, s) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, n, r, i, s)
    }
}
class Pge extends A1 {
    constructor(e, n, r, i, s, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, n, r, i, s, o)
    }
}
class Ige extends C1 {
    constructor(e, n, r, i, s) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, n, r, i, s)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: vp
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = vp);
const y0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: aL,
    AddEquation: ad,
    AddOperation: Oj,
    AdditiveAnimationBlendMode: uL,
    AdditiveBlending: qI,
    AlphaFormat: $j,
    AlwaysDepth: Aj,
    AlwaysStencilFunc: sW,
    AmbientLight: KW,
    AmbientLightProbe: Sme,
    AnimationClip: Um,
    AnimationLoader: fme,
    AnimationMixer: Ume,
    AnimationObjectGroup: Nme,
    AnimationUtils: ame,
    ArcCurve: EW,
    ArrayCamera: bW,
    ArrowHelper: sge,
    Audio: QW,
    AudioAnalyser: Tme,
    AudioContext: jL,
    AudioListener: Ame,
    AudioLoader: xme,
    AxesHelper: oge,
    BackSide: Vs,
    BasicDepthPacking: nW,
    BasicShadowMap: fj,
    Bone: $E,
    BooleanKeyframeTrack: bp,
    Box2: Wme,
    Box3: Xa,
    Box3Helper: rge,
    BoxBufferGeometry: dge,
    BoxGeometry: Sf,
    BoxHelper: nge,
    BufferAttribute: Ln,
    BufferGeometry: on,
    BufferGeometryLoader: JW,
    ByteType: Fj,
    Cache: np,
    Camera: f1,
    CameraHelper: tge,
    CanvasTexture: Rhe,
    CapsuleBufferGeometry: pge,
    CapsuleGeometry: m1,
    CatmullRomCurve3: AW,
    CineonToneMapping: kj,
    CircleBufferGeometry: hge,
    CircleGeometry: g1,
    ClampToEdgeWrapping: zi,
    Clock: WL,
    Color: dt,
    ColorKeyframeTrack: NL,
    ColorManagement: ts,
    CompressedArrayTexture: Ihe,
    CompressedTexture: ML,
    CompressedTextureLoader: dme,
    ConeBufferGeometry: mge,
    ConeGeometry: y1,
    CubeCamera: fW,
    CubeReflectionMapping: lf,
    CubeRefractionMapping: uf,
    CubeTexture: d1,
    CubeTextureLoader: pme,
    CubeUVReflectionMapping: gg,
    CubicBezierCurve: PL,
    CubicBezierCurve3: CW,
    CubicInterpolant: $W,
    CullFaceBack: KI,
    CullFaceFront: cj,
    CullFaceFrontBack: Ile,
    CullFaceNone: uj,
    Curve: Ya,
    CurvePath: TW,
    CustomBlending: dj,
    CustomToneMapping: Bj,
    CylinderBufferGeometry: gge,
    CylinderGeometry: wf,
    Cylindrical: jme,
    Data3DTexture: hL,
    DataArrayTexture: BE,
    DataTexture: fm,
    DataTextureLoader: hme,
    DataUtils: fge,
    DecrementStencilOp: Hle,
    DecrementWrapStencilOp: $le,
    DefaultLoadingManager: Uh,
    DepthFormat: Qc,
    DepthStencilFormat: Zd,
    DepthTexture: xL,
    DirectionalLight: GL,
    DirectionalLightHelper: ege,
    DiscreteInterpolant: GW,
    DisplayP3ColorSpace: fL,
    DodecahedronBufferGeometry: yge,
    DodecahedronGeometry: v1,
    DoubleSide: Ra,
    DstAlphaFactor: bj,
    DstColorFactor: _j,
    DynamicCopyUsage: rue,
    DynamicDrawUsage: Yle,
    DynamicReadUsage: eue,
    EdgesGeometry: PW,
    EllipseCurve: VE,
    EqualDepth: Mj,
    EqualStencilFunc: Wle,
    EquirectangularReflectionMapping: s0,
    EquirectangularRefractionMapping: o0,
    Euler: c1,
    EventDispatcher: Bl,
    ExtrudeBufferGeometry: vge,
    ExtrudeGeometry: b1,
    FileLoader: ho,
    Float16BufferAttribute: Gue,
    Float32BufferAttribute: Mt,
    Float64BufferAttribute: Vue,
    FloatType: xl,
    Fog: UE,
    FogExp2: HE,
    FramebufferTexture: Phe,
    FrontSide: Ol,
    Frustum: FE,
    GLBufferAttribute: Vme,
    GLSL1: sue,
    GLSL3: S3,
    GreaterDepth: Pj,
    GreaterEqualDepth: Tj,
    GreaterEqualStencilFunc: Jle,
    GreaterStencilFunc: qle,
    GridHelper: Qme,
    Group: Su,
    HalfFloatType: Qd,
    HemisphereLight: WW,
    HemisphereLightHelper: Yme,
    HemisphereLightProbe: _me,
    IcosahedronBufferGeometry: bge,
    IcosahedronGeometry: x1,
    ImageBitmapLoader: YW,
    ImageLoader: g0,
    ImageUtils: pL,
    IncrementStencilOp: zle,
    IncrementWrapStencilOp: Ule,
    InstancedBufferAttribute: Nm,
    InstancedBufferGeometry: VL,
    InstancedInterleavedBuffer: Bw,
    InstancedMesh: EL,
    Int16BufferAttribute: Uue,
    Int32BufferAttribute: $ue,
    Int8BufferAttribute: Nue,
    IntType: zj,
    InterleavedBuffer: p1,
    InterleavedBufferAttribute: Hs,
    Interpolant: wg,
    InterpolateDiscrete: km,
    InterpolateLinear: ep,
    InterpolateSmooth: wS,
    InvertStencilOp: Gle,
    KeepStencilOp: ES,
    KeyframeTrack: Qa,
    LOD: wW,
    LatheBufferGeometry: xge,
    LatheGeometry: xg,
    Layers: Bd,
    LessDepth: Cj,
    LessEqualDepth: Ow,
    LessEqualStencilFunc: Kle,
    LessStencilFunc: jle,
    Light: Ef,
    LightProbe: KE,
    Line: ku,
    Line3: tK,
    LineBasicMaterial: us,
    LineCurve: jE,
    LineCurve3: MW,
    LineDashedMaterial: HW,
    LineLoop: AL,
    LineSegments: Ja,
    LinearEncoding: Lu,
    LinearFilter: fr,
    LinearInterpolant: FL,
    LinearMipMapLinearFilter: kle,
    LinearMipMapNearestFilter: Lle,
    LinearMipmapLinearFilter: Dl,
    LinearMipmapNearestFilter: LE,
    LinearSRGBColorSpace: Bm,
    LinearToneMapping: Dj,
    Loader: As,
    LoaderUtils: Tl,
    LoadingManager: zL,
    LoopOnce: Qj,
    LoopPingPong: eW,
    LoopRepeat: Zj,
    LuminanceAlphaFormat: Vj,
    LuminanceFormat: Gj,
    MOUSE: td,
    Material: li,
    MaterialLoader: qE,
    MathUtils: bd,
    Matrix3: Hi,
    Matrix4: Gt,
    MaxEquation: QI,
    Mesh: mi,
    MeshBasicMaterial: oo,
    MeshDepthMaterial: vL,
    MeshDistanceMaterial: bL,
    MeshLambertMaterial: NW,
    MeshMatcapMaterial: zW,
    MeshNormalMaterial: FW,
    MeshPhongMaterial: kW,
    MeshPhysicalMaterial: Nl,
    MeshStandardMaterial: M1,
    MeshToonMaterial: BW,
    MinEquation: YI,
    MirroredRepeatWrapping: Lm,
    MixOperation: Rj,
    MultiplyBlending: JI,
    MultiplyOperation: u1,
    NearestFilter: Br,
    NearestMipMapLinearFilter: Dle,
    NearestMipMapNearestFilter: Ole,
    NearestMipmapLinearFilter: um,
    NearestMipmapNearestFilter: a0,
    NeverDepth: Ej,
    NeverStencilFunc: Vle,
    NoBlending: Mu,
    NoColorSpace: Ble,
    NoToneMapping: Na,
    NormalAnimationBlendMode: kE,
    NormalBlending: Dd,
    NotEqualDepth: Ij,
    NotEqualStencilFunc: Xle,
    NumberKeyframeTrack: zm,
    Object3D: Tn,
    ObjectLoader: vme,
    ObjectSpaceNormalMap: iW,
    OctahedronBufferGeometry: _ge,
    OctahedronGeometry: _g,
    OneFactor: gj,
    OneMinusDstAlphaFactor: xj,
    OneMinusDstColorFactor: Sj,
    OneMinusSrcAlphaFactor: oL,
    OneMinusSrcColorFactor: vj,
    OrthographicCamera: Ko,
    PCFShadowMap: OE,
    PCFSoftShadowMap: pv,
    PMREMGenerator: E3,
    Path: d0,
    PerspectiveCamera: dr,
    Plane: mu,
    PlaneBufferGeometry: Sge,
    PlaneGeometry: vg,
    PlaneHelper: ige,
    PointLight: $L,
    PointLightHelper: Xme,
    Points: CL,
    PointsMaterial: GE,
    PolarGridHelper: Zme,
    PolyhedronBufferGeometry: wge,
    PolyhedronGeometry: Vu,
    PositionalAudio: Mme,
    PropertyBinding: Mn,
    PropertyMixer: ZW,
    QuadraticBezierCurve: IL,
    QuadraticBezierCurve3: RL,
    Quaternion: Ti,
    QuaternionKeyframeTrack: ff,
    QuaternionLinearInterpolant: VW,
    RED_GREEN_RGTC2_Format: x3,
    RED_RGTC1_Format: Yj,
    REVISION: vp,
    RGBADepthPacking: rW,
    RGBAFormat: Ns,
    RGBAIntegerFormat: Xj,
    RGBA_ASTC_10x10_Format: g3,
    RGBA_ASTC_10x5_Format: p3,
    RGBA_ASTC_10x6_Format: h3,
    RGBA_ASTC_10x8_Format: m3,
    RGBA_ASTC_12x10_Format: y3,
    RGBA_ASTC_12x12_Format: v3,
    RGBA_ASTC_4x4_Format: s3,
    RGBA_ASTC_5x4_Format: o3,
    RGBA_ASTC_5x5_Format: a3,
    RGBA_ASTC_6x5_Format: l3,
    RGBA_ASTC_6x6_Format: u3,
    RGBA_ASTC_8x5_Format: c3,
    RGBA_ASTC_8x6_Format: f3,
    RGBA_ASTC_8x8_Format: d3,
    RGBA_BPTC_Format: SS,
    RGBA_ETC2_EAC_Format: i3,
    RGBA_PVRTC_2BPPV1_Format: n3,
    RGBA_PVRTC_4BPPV1_Format: t3,
    RGBA_S3TC_DXT1_Format: bS,
    RGBA_S3TC_DXT3_Format: xS,
    RGBA_S3TC_DXT5_Format: _S,
    RGB_ETC1_Format: Jj,
    RGB_ETC2_Format: r3,
    RGB_PVRTC_2BPPV1_Format: e3,
    RGB_PVRTC_4BPPV1_Format: ZI,
    RGB_S3TC_DXT1_Format: vS,
    RGFormat: Kj,
    RGIntegerFormat: qj,
    RawShaderMaterial: LW,
    Ray: yg,
    Raycaster: eK,
    RectAreaLight: qW,
    RedFormat: jj,
    RedIntegerFormat: Wj,
    ReinhardToneMapping: Lj,
    RepeatWrapping: cf,
    ReplaceStencilOp: Nle,
    ReverseSubtractEquation: hj,
    RingBufferGeometry: Ege,
    RingGeometry: _1,
    SIGNED_RED_GREEN_RGTC2_Format: _3,
    SIGNED_RED_RGTC1_Format: b3,
    SRGBColorSpace: Ea,
    Scene: _L,
    ShaderChunk: pn,
    ShaderLib: Ma,
    ShaderMaterial: ra,
    ShadowMaterial: DW,
    Shape: Fd,
    ShapeBufferGeometry: Age,
    ShapeGeometry: S1,
    ShapePath: age,
    ShapeUtils: Ml,
    ShortType: Nj,
    Skeleton: h1,
    SkeletonHelper: qme,
    SkinnedMesh: wL,
    Source: xd,
    Sphere: Fl,
    SphereBufferGeometry: Cge,
    SphereGeometry: Sg,
    Spherical: R3,
    SphericalHarmonics3: XW,
    SplineCurve: OL,
    SpotLight: UL,
    SpotLightHelper: Kme,
    Sprite: SW,
    SpriteMaterial: SL,
    SrcAlphaFactor: sL,
    SrcAlphaSaturateFactor: wj,
    SrcColorFactor: yj,
    StaticCopyUsage: nue,
    StaticDrawUsage: u0,
    StaticReadUsage: Zle,
    StereoCamera: wme,
    StreamCopyUsage: iue,
    StreamDrawUsage: Qle,
    StreamReadUsage: tue,
    StringKeyframeTrack: xp,
    SubtractEquation: pj,
    SubtractiveBlending: XI,
    TOUCH: nd,
    TangentSpaceNormalMap: _f,
    TetrahedronBufferGeometry: Mge,
    TetrahedronGeometry: w1,
    Texture: Sr,
    TextureLoader: jW,
    TorusBufferGeometry: Tge,
    TorusGeometry: E1,
    TorusKnotBufferGeometry: Pge,
    TorusKnotGeometry: A1,
    Triangle: Go,
    TriangleFanDrawMode: Dw,
    TriangleStripDrawMode: cL,
    TrianglesDrawMode: tW,
    TubeBufferGeometry: Ige,
    TubeGeometry: C1,
    TwoPassDoubleSide: Rle,
    UVMapping: DE,
    Uint16BufferAttribute: mL,
    Uint32BufferAttribute: gL,
    Uint8BufferAttribute: zue,
    Uint8ClampedBufferAttribute: Hue,
    Uniform: XL,
    UniformsGroup: Gme,
    UniformsLib: ot,
    UniformsUtils: kw,
    UnsignedByteType: Du,
    UnsignedInt248Type: Ld,
    UnsignedIntType: Oc,
    UnsignedShort4444Type: Hj,
    UnsignedShort5551Type: Uj,
    UnsignedShortType: lL,
    VSMShadowMap: gd,
    Vector2: ke,
    Vector3: J,
    Vector4: In,
    VectorKeyframeTrack: Hm,
    VideoTexture: The,
    WebGL1Renderer: xW,
    WebGL3DRenderTarget: Tue,
    WebGLArrayRenderTarget: Mue,
    WebGLCubeRenderTarget: dW,
    WebGLMultipleRenderTargets: Pue,
    WebGLRenderTarget: na,
    WebGLRenderer: zE,
    WebGLUtils: vW,
    WireframeGeometry: LL,
    WrapAroundEnding: l0,
    ZeroCurvatureEnding: yd,
    ZeroFactor: mj,
    ZeroSlopeEnding: vd,
    ZeroStencilOp: Fle,
    _SRGBAFormat: Lw,
    sRGBEncoding: Xn
}, Symbol.toStringTag, {
    value: "Module"
}));

function rp(t) {
    return new Promise((e, n) => {
        t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => n(t.error)
    })
}

function Rge(t, e) {
    const n = indexedDB.open(t);
    n.onupgradeneeded = () => n.result.createObjectStore(e);
    const r = rp(n);
    return (i, s) => r.then(o => s(o.transaction(e, i).objectStore(e)))
}
let fT;

function XE() {
    return fT || (fT = Rge("keyval-store", "keyval")), fT
}

function uHe(t, e = XE()) {
    return e("readwrite", n => (t.forEach(r => n.put(r[1], r[0])), rp(n.transaction)))
}

function cHe(t, e, n = XE()) {
    return n("readwrite", r => new Promise((i, s) => {
        r.get(t).onsuccess = function() {
            try {
                r.put(e(this.result), t), i(rp(r.transaction))
            } catch (o) {
                s(o)
            }
        }
    }))
}

function fHe(t, e = XE()) {
    return e("readwrite", n => (n.delete(t), rp(n.transaction)))
}

function Oge(t, e) {
    return t.openCursor().onsuccess = function() {
        this.result && (e(this.result), this.result.continue())
    }, rp(t.transaction)
}

function dHe(t = XE()) {
    return t("readonly", e => {
        if (e.getAll && e.getAllKeys) return Promise.all([rp(e.getAllKeys()), rp(e.getAll())]).then(([r, i]) => r.map((s, o) => [s, i[o]]));
        const n = [];
        return t("readonly", r => Oge(r, i => n.push([i.key, i.value])).then(() => n))
    })
}

function g8(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function wt(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? g8(Object(n), !0).forEach(function(r) {
            xi(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : g8(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}

function Fw(t) {
    "@babel/helpers - typeof";
    return Fw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, Fw(t)
}

function Dge(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function y8(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
}

function Lge(t, e, n) {
    return e && y8(t.prototype, e), n && y8(t, n), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}

function xi(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function JL(t, e) {
    return Bge(t) || Nge(t, e) || rK(t, e) || Hge()
}

function T1(t) {
    return kge(t) || Fge(t) || rK(t) || zge()
}

function kge(t) {
    if (Array.isArray(t)) return O3(t)
}

function Bge(t) {
    if (Array.isArray(t)) return t
}

function Fge(t) {
    if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
}

function Nge(t, e) {
    var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (n != null) {
        var r = [],
            i = !0,
            s = !1,
            o, a;
        try {
            for (n = n.call(t); !(i = (o = n.next()).done) && (r.push(o.value), !(e && r.length === e)); i = !0);
        } catch (l) {
            s = !0, a = l
        } finally {
            try {
                !i && n.return != null && n.return()
            } finally {
                if (s) throw a
            }
        }
        return r
    }
}

function rK(t, e) {
    if (t) {
        if (typeof t == "string") return O3(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return O3(t, e)
    }
}

function O3(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
}

function zge() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function Hge() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var v8 = function() {},
    YL = {},
    iK = {},
    sK = null,
    oK = {
        mark: v8,
        measure: v8
    };
try {
    typeof window < "u" && (YL = window), typeof document < "u" && (iK = document), typeof MutationObserver < "u" && (sK = MutationObserver), typeof performance < "u" && (oK = performance)
} catch {}
var Uge = YL.navigator || {},
    b8 = Uge.userAgent,
    x8 = b8 === void 0 ? "" : b8,
    df = YL,
    hr = iK,
    _8 = sK,
    Qx = oK;
df.document;
var ju = !!hr.documentElement && !!hr.head && typeof hr.addEventListener == "function" && typeof hr.createElement == "function",
    aK = ~x8.indexOf("MSIE") || ~x8.indexOf("Trident/"),
    Zx, e_, t_, n_, r_, Bu = "___FONT_AWESOME___",
    D3 = 16,
    lK = "fa",
    uK = "svg-inline--fa",
    ip = "data-fa-i2svg",
    L3 = "data-fa-pseudo-element",
    $ge = "data-fa-pseudo-element-pending",
    QL = "data-prefix",
    ZL = "data-icon",
    S8 = "fontawesome-i2svg",
    Gge = "async",
    Vge = ["HTML", "HEAD", "STYLE", "SCRIPT"],
    cK = function() {
        try {
            return !0
        } catch {
            return !1
        }
    }(),
    cr = "classic",
    Fr = "sharp",
    e4 = [cr, Fr];

function P1(t) {
    return new Proxy(t, {
        get: function(n, r) {
            return r in n ? n[r] : n[cr]
        }
    })
}
var v0 = P1((Zx = {}, xi(Zx, cr, {
        fa: "solid",
        fas: "solid",
        "fa-solid": "solid",
        far: "regular",
        "fa-regular": "regular",
        fal: "light",
        "fa-light": "light",
        fat: "thin",
        "fa-thin": "thin",
        fad: "duotone",
        "fa-duotone": "duotone",
        fab: "brands",
        "fa-brands": "brands",
        fak: "kit",
        "fa-kit": "kit"
    }), xi(Zx, Fr, {
        fa: "solid",
        fass: "solid",
        "fa-solid": "solid",
        fasr: "regular",
        "fa-regular": "regular"
    }), Zx)),
    b0 = P1((e_ = {}, xi(e_, cr, {
        solid: "fas",
        regular: "far",
        light: "fal",
        thin: "fat",
        duotone: "fad",
        brands: "fab",
        kit: "fak"
    }), xi(e_, Fr, {
        solid: "fass",
        regular: "fasr"
    }), e_)),
    x0 = P1((t_ = {}, xi(t_, cr, {
        fab: "fa-brands",
        fad: "fa-duotone",
        fak: "fa-kit",
        fal: "fa-light",
        far: "fa-regular",
        fas: "fa-solid",
        fat: "fa-thin"
    }), xi(t_, Fr, {
        fass: "fa-solid",
        fasr: "fa-regular"
    }), t_)),
    jge = P1((n_ = {}, xi(n_, cr, {
        "fa-brands": "fab",
        "fa-duotone": "fad",
        "fa-kit": "fak",
        "fa-light": "fal",
        "fa-regular": "far",
        "fa-solid": "fas",
        "fa-thin": "fat"
    }), xi(n_, Fr, {
        "fa-solid": "fass",
        "fa-regular": "fasr"
    }), n_)),
    Wge = /fa(s|r|l|t|d|b|k|ss|sr)?[\-\ ]/,
    fK = "fa-layers-text",
    Kge = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i,
    qge = P1((r_ = {}, xi(r_, cr, {
        900: "fas",
        400: "far",
        normal: "far",
        300: "fal",
        100: "fat"
    }), xi(r_, Fr, {
        900: "fass",
        400: "fasr"
    }), r_)),
    dK = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    Xge = dK.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
    Jge = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"],
    Sd = {
        GROUP: "duotone-group",
        SWAP_OPACITY: "swap-opacity",
        PRIMARY: "primary",
        SECONDARY: "secondary"
    },
    _0 = new Set;
Object.keys(b0[cr]).map(_0.add.bind(_0));
Object.keys(b0[Fr]).map(_0.add.bind(_0));
var Yge = [].concat(e4, T1(_0), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Sd.GROUP, Sd.SWAP_OPACITY, Sd.PRIMARY, Sd.SECONDARY]).concat(dK.map(function(t) {
        return "".concat(t, "x")
    })).concat(Xge.map(function(t) {
        return "w-".concat(t)
    })),
    yv = df.FontAwesomeConfig || {};

function Qge(t) {
    var e = hr.querySelector("script[" + t + "]");
    if (e) return e.getAttribute(t)
}

function Zge(t) {
    return t === "" ? !0 : t === "false" ? !1 : t === "true" ? !0 : t
}
if (hr && typeof hr.querySelector == "function") {
    var eye = [
        ["data-family-prefix", "familyPrefix"],
        ["data-css-prefix", "cssPrefix"],
        ["data-family-default", "familyDefault"],
        ["data-style-default", "styleDefault"],
        ["data-replacement-class", "replacementClass"],
        ["data-auto-replace-svg", "autoReplaceSvg"],
        ["data-auto-add-css", "autoAddCss"],
        ["data-auto-a11y", "autoA11y"],
        ["data-search-pseudo-elements", "searchPseudoElements"],
        ["data-observe-mutations", "observeMutations"],
        ["data-mutate-approach", "mutateApproach"],
        ["data-keep-original-source", "keepOriginalSource"],
        ["data-measure-performance", "measurePerformance"],
        ["data-show-missing-icons", "showMissingIcons"]
    ];
    eye.forEach(function(t) {
        var e = JL(t, 2),
            n = e[0],
            r = e[1],
            i = Zge(Qge(n));
        i != null && (yv[r] = i)
    })
}
var pK = {
    styleDefault: "solid",
    familyDefault: "classic",
    cssPrefix: lK,
    replacementClass: uK,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    autoA11y: !0,
    searchPseudoElements: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
};
yv.familyPrefix && (yv.cssPrefix = yv.familyPrefix);
var $m = wt(wt({}, pK), yv);
$m.autoReplaceSvg || ($m.observeMutations = !1);
var It = {};
Object.keys(pK).forEach(function(t) {
    Object.defineProperty(It, t, {
        enumerable: !0,
        set: function(n) {
            $m[t] = n, vv.forEach(function(r) {
                return r(It)
            })
        },
        get: function() {
            return $m[t]
        }
    })
});
Object.defineProperty(It, "familyPrefix", {
    enumerable: !0,
    set: function(e) {
        $m.cssPrefix = e, vv.forEach(function(n) {
            return n(It)
        })
    },
    get: function() {
        return $m.cssPrefix
    }
});
df.FontAwesomeConfig = It;
var vv = [];

function tye(t) {
    return vv.push(t),
        function() {
            vv.splice(vv.indexOf(t), 1)
        }
}
var mc = D3,
    _l = {
        size: 16,
        x: 0,
        y: 0,
        rotate: 0,
        flipX: !1,
        flipY: !1
    };

function nye(t) {
    if (!(!t || !ju)) {
        var e = hr.createElement("style");
        e.setAttribute("type", "text/css"), e.innerHTML = t;
        for (var n = hr.head.childNodes, r = null, i = n.length - 1; i > -1; i--) {
            var s = n[i],
                o = (s.tagName || "").toUpperCase();
            ["STYLE", "LINK"].indexOf(o) > -1 && (r = s)
        }
        return hr.head.insertBefore(e, r), t
    }
}
var rye = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

function S0() {
    for (var t = 12, e = ""; t-- > 0;) e += rye[Math.random() * 62 | 0];
    return e
}

function Eg(t) {
    for (var e = [], n = (t || []).length >>> 0; n--;) e[n] = t[n];
    return e
}

function t4(t) {
    return t.classList ? Eg(t.classList) : (t.getAttribute("class") || "").split(" ").filter(function(e) {
        return e
    })
}

function hK(t) {
    return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}

function iye(t) {
    return Object.keys(t || {}).reduce(function(e, n) {
        return e + "".concat(n, '="').concat(hK(t[n]), '" ')
    }, "").trim()
}

function JE(t) {
    return Object.keys(t || {}).reduce(function(e, n) {
        return e + "".concat(n, ": ").concat(t[n].trim(), ";")
    }, "")
}

function n4(t) {
    return t.size !== _l.size || t.x !== _l.x || t.y !== _l.y || t.rotate !== _l.rotate || t.flipX || t.flipY
}

function sye(t) {
    var e = t.transform,
        n = t.containerWidth,
        r = t.iconWidth,
        i = {
            transform: "translate(".concat(n / 2, " 256)")
        },
        s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "),
        o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "),
        a = "rotate(".concat(e.rotate, " 0 0)"),
        l = {
            transform: "".concat(s, " ").concat(o, " ").concat(a)
        },
        u = {
            transform: "translate(".concat(r / 2 * -1, " -256)")
        };
    return {
        outer: i,
        inner: l,
        path: u
    }
}

function oye(t) {
    var e = t.transform,
        n = t.width,
        r = n === void 0 ? D3 : n,
        i = t.height,
        s = i === void 0 ? D3 : i,
        o = t.startCentered,
        a = o === void 0 ? !1 : o,
        l = "";
    return a && aK ? l += "translate(".concat(e.x / mc - r / 2, "em, ").concat(e.y / mc - s / 2, "em) ") : a ? l += "translate(calc(-50% + ".concat(e.x / mc, "em), calc(-50% + ").concat(e.y / mc, "em)) ") : l += "translate(".concat(e.x / mc, "em, ").concat(e.y / mc, "em) "), l += "scale(".concat(e.size / mc * (e.flipX ? -1 : 1), ", ").concat(e.size / mc * (e.flipY ? -1 : 1), ") "), l += "rotate(".concat(e.rotate, "deg) "), l
}
var aye = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;

function mK() {
    var t = lK,
        e = uK,
        n = It.cssPrefix,
        r = It.replacementClass,
        i = aye;
    if (n !== t || r !== e) {
        var s = new RegExp("\\.".concat(t, "\\-"), "g"),
            o = new RegExp("\\--".concat(t, "\\-"), "g"),
            a = new RegExp("\\.".concat(e), "g");
        i = i.replace(s, ".".concat(n, "-")).replace(o, "--".concat(n, "-")).replace(a, ".".concat(r))
    }
    return i
}
var w8 = !1;

function dT() {
    It.autoAddCss && !w8 && (nye(mK()), w8 = !0)
}
var lye = {
        mixout: function() {
            return {
                dom: {
                    css: mK,
                    insertCss: dT
                }
            }
        },
        hooks: function() {
            return {
                beforeDOMElementCreation: function() {
                    dT()
                },
                beforeI2svg: function() {
                    dT()
                }
            }
        }
    },
    Fu = df || {};
Fu[Bu] || (Fu[Bu] = {});
Fu[Bu].styles || (Fu[Bu].styles = {});
Fu[Bu].hooks || (Fu[Bu].hooks = {});
Fu[Bu].shims || (Fu[Bu].shims = []);
var Oa = Fu[Bu],
    gK = [],
    uye = function t() {
        hr.removeEventListener("DOMContentLoaded", t), Nw = 1, gK.map(function(e) {
            return e()
        })
    },
    Nw = !1;
ju && (Nw = (hr.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(hr.readyState), Nw || hr.addEventListener("DOMContentLoaded", uye));

function cye(t) {
    ju && (Nw ? setTimeout(t, 0) : gK.push(t))
}

function I1(t) {
    var e = t.tag,
        n = t.attributes,
        r = n === void 0 ? {} : n,
        i = t.children,
        s = i === void 0 ? [] : i;
    return typeof t == "string" ? hK(t) : "<".concat(e, " ").concat(iye(r), ">").concat(s.map(I1).join(""), "</").concat(e, ">")
}

function E8(t, e, n) {
    if (t && t[e] && t[e][n]) return {
        prefix: e,
        iconName: n,
        icon: t[e][n]
    }
}
var fye = function(e, n) {
        return function(r, i, s, o) {
            return e.call(n, r, i, s, o)
        }
    },
    pT = function(e, n, r, i) {
        var s = Object.keys(e),
            o = s.length,
            a = i !== void 0 ? fye(n, i) : n,
            l, u, c;
        for (r === void 0 ? (l = 1, c = e[s[0]]) : (l = 0, c = r); l < o; l++) u = s[l], c = a(c, e[u], u, e);
        return c
    };

function dye(t) {
    for (var e = [], n = 0, r = t.length; n < r;) {
        var i = t.charCodeAt(n++);
        if (i >= 55296 && i <= 56319 && n < r) {
            var s = t.charCodeAt(n++);
            (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--)
        } else e.push(i)
    }
    return e
}

function k3(t) {
    var e = dye(t);
    return e.length === 1 ? e[0].toString(16) : null
}

function pye(t, e) {
    var n = t.length,
        r = t.charCodeAt(e),
        i;
    return r >= 55296 && r <= 56319 && n > e + 1 && (i = t.charCodeAt(e + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r
}

function A8(t) {
    return Object.keys(t).reduce(function(e, n) {
        var r = t[n],
            i = !!r.icon;
        return i ? e[r.iconName] = r.icon : e[n] = r, e
    }, {})
}

function B3(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        r = n.skipHooks,
        i = r === void 0 ? !1 : r,
        s = A8(e);
    typeof Oa.hooks.addPack == "function" && !i ? Oa.hooks.addPack(t, A8(e)) : Oa.styles[t] = wt(wt({}, Oa.styles[t] || {}), s), t === "fas" && B3("fa", e)
}
var i_, s_, o_, $h = Oa.styles,
    hye = Oa.shims,
    mye = (i_ = {}, xi(i_, cr, Object.values(x0[cr])), xi(i_, Fr, Object.values(x0[Fr])), i_),
    r4 = null,
    yK = {},
    vK = {},
    bK = {},
    xK = {},
    _K = {},
    gye = (s_ = {}, xi(s_, cr, Object.keys(v0[cr])), xi(s_, Fr, Object.keys(v0[Fr])), s_);

function yye(t) {
    return ~Yge.indexOf(t)
}

function vye(t, e) {
    var n = e.split("-"),
        r = n[0],
        i = n.slice(1).join("-");
    return r === t && i !== "" && !yye(i) ? i : null
}
var SK = function() {
    var e = function(s) {
        return pT($h, function(o, a, l) {
            return o[l] = pT(a, s, {}), o
        }, {})
    };
    yK = e(function(i, s, o) {
        if (s[3] && (i[s[3]] = o), s[2]) {
            var a = s[2].filter(function(l) {
                return typeof l == "number"
            });
            a.forEach(function(l) {
                i[l.toString(16)] = o
            })
        }
        return i
    }), vK = e(function(i, s, o) {
        if (i[o] = o, s[2]) {
            var a = s[2].filter(function(l) {
                return typeof l == "string"
            });
            a.forEach(function(l) {
                i[l] = o
            })
        }
        return i
    }), _K = e(function(i, s, o) {
        var a = s[2];
        return i[o] = o, a.forEach(function(l) {
            i[l] = o
        }), i
    });
    var n = "far" in $h || It.autoFetchSvg,
        r = pT(hye, function(i, s) {
            var o = s[0],
                a = s[1],
                l = s[2];
            return a === "far" && !n && (a = "fas"), typeof o == "string" && (i.names[o] = {
                prefix: a,
                iconName: l
            }), typeof o == "number" && (i.unicodes[o.toString(16)] = {
                prefix: a,
                iconName: l
            }), i
        }, {
            names: {},
            unicodes: {}
        });
    bK = r.names, xK = r.unicodes, r4 = YE(It.styleDefault, {
        family: It.familyDefault
    })
};
tye(function(t) {
    r4 = YE(t.styleDefault, {
        family: It.familyDefault
    })
});
SK();

function i4(t, e) {
    return (yK[t] || {})[e]
}

function bye(t, e) {
    return (vK[t] || {})[e]
}

function wd(t, e) {
    return (_K[t] || {})[e]
}

function wK(t) {
    return bK[t] || {
        prefix: null,
        iconName: null
    }
}

function xye(t) {
    var e = xK[t],
        n = i4("fas", t);
    return e || (n ? {
        prefix: "fas",
        iconName: n
    } : null) || {
        prefix: null,
        iconName: null
    }
}

function pf() {
    return r4
}
var s4 = function() {
    return {
        prefix: null,
        iconName: null,
        rest: []
    }
};

function YE(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = e.family,
        r = n === void 0 ? cr : n,
        i = v0[r][t],
        s = b0[r][t] || b0[r][i],
        o = t in Oa.styles ? t : null;
    return s || o || null
}
var C8 = (o_ = {}, xi(o_, cr, Object.keys(x0[cr])), xi(o_, Fr, Object.keys(x0[Fr])), o_);

function QE(t) {
    var e, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        r = n.skipLookups,
        i = r === void 0 ? !1 : r,
        s = (e = {}, xi(e, cr, "".concat(It.cssPrefix, "-").concat(cr)), xi(e, Fr, "".concat(It.cssPrefix, "-").concat(Fr)), e),
        o = null,
        a = cr;
    (t.includes(s[cr]) || t.some(function(u) {
        return C8[cr].includes(u)
    })) && (a = cr), (t.includes(s[Fr]) || t.some(function(u) {
        return C8[Fr].includes(u)
    })) && (a = Fr);
    var l = t.reduce(function(u, c) {
        var f = vye(It.cssPrefix, c);
        if ($h[c] ? (c = mye[a].includes(c) ? jge[a][c] : c, o = c, u.prefix = c) : gye[a].indexOf(c) > -1 ? (o = c, u.prefix = YE(c, {
                family: a
            })) : f ? u.iconName = f : c !== It.replacementClass && c !== s[cr] && c !== s[Fr] && u.rest.push(c), !i && u.prefix && u.iconName) {
            var d = o === "fa" ? wK(u.iconName) : {},
                p = wd(u.prefix, u.iconName);
            d.prefix && (o = null), u.iconName = d.iconName || p || u.iconName, u.prefix = d.prefix || u.prefix, u.prefix === "far" && !$h.far && $h.fas && !It.autoFetchSvg && (u.prefix = "fas")
        }
        return u
    }, s4());
    return (t.includes("fa-brands") || t.includes("fab")) && (l.prefix = "fab"), (t.includes("fa-duotone") || t.includes("fad")) && (l.prefix = "fad"), !l.prefix && a === Fr && ($h.fass || It.autoFetchSvg) && (l.prefix = "fass", l.iconName = wd(l.prefix, l.iconName) || l.iconName), (l.prefix === "fa" || o === "fa") && (l.prefix = pf() || "fas"), l
}
var _ye = function() {
        function t() {
            Dge(this, t), this.definitions = {}
        }
        return Lge(t, [{
            key: "add",
            value: function() {
                for (var n = this, r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
                var o = i.reduce(this._pullDefinitions, {});
                Object.keys(o).forEach(function(a) {
                    n.definitions[a] = wt(wt({}, n.definitions[a] || {}), o[a]), B3(a, o[a]);
                    var l = x0[cr][a];
                    l && B3(l, o[a]), SK()
                })
            }
        }, {
            key: "reset",
            value: function() {
                this.definitions = {}
            }
        }, {
            key: "_pullDefinitions",
            value: function(n, r) {
                var i = r.prefix && r.iconName && r.icon ? {
                    0: r
                } : r;
                return Object.keys(i).map(function(s) {
                    var o = i[s],
                        a = o.prefix,
                        l = o.iconName,
                        u = o.icon,
                        c = u[2];
                    n[a] || (n[a] = {}), c.length > 0 && c.forEach(function(f) {
                        typeof f == "string" && (n[a][f] = u)
                    }), n[a][l] = u
                }), n
            }
        }]), t
    }(),
    M8 = [],
    Gh = {},
    dm = {},
    Sye = Object.keys(dm);

function wye(t, e) {
    var n = e.mixoutsTo;
    return M8 = t, Gh = {}, Object.keys(dm).forEach(function(r) {
        Sye.indexOf(r) === -1 && delete dm[r]
    }), M8.forEach(function(r) {
        var i = r.mixout ? r.mixout() : {};
        if (Object.keys(i).forEach(function(o) {
                typeof i[o] == "function" && (n[o] = i[o]), Fw(i[o]) === "object" && Object.keys(i[o]).forEach(function(a) {
                    n[o] || (n[o] = {}), n[o][a] = i[o][a]
                })
            }), r.hooks) {
            var s = r.hooks();
            Object.keys(s).forEach(function(o) {
                Gh[o] || (Gh[o] = []), Gh[o].push(s[o])
            })
        }
        r.provides && r.provides(dm)
    }), n
}

function F3(t, e) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++) r[i - 2] = arguments[i];
    var s = Gh[t] || [];
    return s.forEach(function(o) {
        e = o.apply(null, [e].concat(r))
    }), e
}

function sp(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    var i = Gh[t] || [];
    i.forEach(function(s) {
        s.apply(null, n)
    })
}

function Nu() {
    var t = arguments[0],
        e = Array.prototype.slice.call(arguments, 1);
    return dm[t] ? dm[t].apply(null, e) : void 0
}

function N3(t) {
    t.prefix === "fa" && (t.prefix = "fas");
    var e = t.iconName,
        n = t.prefix || pf();
    if (e) return e = wd(n, e) || e, E8(EK.definitions, n, e) || E8(Oa.styles, n, e)
}
var EK = new _ye,
    Eye = function() {
        It.autoReplaceSvg = !1, It.observeMutations = !1, sp("noAuto")
    },
    Aye = {
        i2svg: function() {
            var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return ju ? (sp("beforeI2svg", e), Nu("pseudoElements2svg", e), Nu("i2svg", e)) : Promise.reject("Operation requires a DOM of some kind.")
        },
        watch: function() {
            var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                n = e.autoReplaceSvgRoot;
            It.autoReplaceSvg === !1 && (It.autoReplaceSvg = !0), It.observeMutations = !0, cye(function() {
                Mye({
                    autoReplaceSvgRoot: n
                }), sp("watch", e)
            })
        }
    },
    Cye = {
        icon: function(e) {
            if (e === null) return null;
            if (Fw(e) === "object" && e.prefix && e.iconName) return {
                prefix: e.prefix,
                iconName: wd(e.prefix, e.iconName) || e.iconName
            };
            if (Array.isArray(e) && e.length === 2) {
                var n = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1],
                    r = YE(e[0]);
                return {
                    prefix: r,
                    iconName: wd(r, n) || n
                }
            }
            if (typeof e == "string" && (e.indexOf("".concat(It.cssPrefix, "-")) > -1 || e.match(Wge))) {
                var i = QE(e.split(" "), {
                    skipLookups: !0
                });
                return {
                    prefix: i.prefix || pf(),
                    iconName: wd(i.prefix, i.iconName) || i.iconName
                }
            }
            if (typeof e == "string") {
                var s = pf();
                return {
                    prefix: s,
                    iconName: wd(s, e) || e
                }
            }
        }
    },
    bo = {
        noAuto: Eye,
        config: It,
        dom: Aye,
        parse: Cye,
        library: EK,
        findIconDefinition: N3,
        toHtml: I1
    },
    Mye = function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            n = e.autoReplaceSvgRoot,
            r = n === void 0 ? hr : n;
        (Object.keys(Oa.styles).length > 0 || It.autoFetchSvg) && ju && It.autoReplaceSvg && bo.dom.i2svg({
            node: r
        })
    };

function ZE(t, e) {
    return Object.defineProperty(t, "abstract", {
        get: e
    }), Object.defineProperty(t, "html", {
        get: function() {
            return t.abstract.map(function(r) {
                return I1(r)
            })
        }
    }), Object.defineProperty(t, "node", {
        get: function() {
            if (ju) {
                var r = hr.createElement("div");
                return r.innerHTML = t.html, r.children
            }
        }
    }), t
}

function Tye(t) {
    var e = t.children,
        n = t.main,
        r = t.mask,
        i = t.attributes,
        s = t.styles,
        o = t.transform;
    if (n4(o) && n.found && !r.found) {
        var a = n.width,
            l = n.height,
            u = {
                x: a / l / 2,
                y: .5
            };
        i.style = JE(wt(wt({}, s), {}, {
            "transform-origin": "".concat(u.x + o.x / 16, "em ").concat(u.y + o.y / 16, "em")
        }))
    }
    return [{
        tag: "svg",
        attributes: i,
        children: e
    }]
}

function Pye(t) {
    var e = t.prefix,
        n = t.iconName,
        r = t.children,
        i = t.attributes,
        s = t.symbol,
        o = s === !0 ? "".concat(e, "-").concat(It.cssPrefix, "-").concat(n) : s;
    return [{
        tag: "svg",
        attributes: {
            style: "display: none;"
        },
        children: [{
            tag: "symbol",
            attributes: wt(wt({}, i), {}, {
                id: o
            }),
            children: r
        }]
    }]
}

function o4(t) {
    var e = t.icons,
        n = e.main,
        r = e.mask,
        i = t.prefix,
        s = t.iconName,
        o = t.transform,
        a = t.symbol,
        l = t.title,
        u = t.maskId,
        c = t.titleId,
        f = t.extra,
        d = t.watchable,
        p = d === void 0 ? !1 : d,
        m = r.found ? r : n,
        y = m.width,
        v = m.height,
        b = i === "fak",
        _ = [It.replacementClass, s ? "".concat(It.cssPrefix, "-").concat(s) : ""].filter(function(I) {
            return f.classes.indexOf(I) === -1
        }).filter(function(I) {
            return I !== "" || !!I
        }).concat(f.classes).join(" "),
        x = {
            children: [],
            attributes: wt(wt({}, f.attributes), {}, {
                "data-prefix": i,
                "data-icon": s,
                class: _,
                role: f.attributes.role || "img",
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 ".concat(y, " ").concat(v)
            })
        },
        S = b && !~f.classes.indexOf("fa-fw") ? {
            width: "".concat(y / v * 16 * .0625, "em")
        } : {};
    p && (x.attributes[ip] = ""), l && (x.children.push({
        tag: "title",
        attributes: {
            id: x.attributes["aria-labelledby"] || "title-".concat(c || S0())
        },
        children: [l]
    }), delete x.attributes.title);
    var E = wt(wt({}, x), {}, {
            prefix: i,
            iconName: s,
            main: n,
            mask: r,
            maskId: u,
            transform: o,
            symbol: a,
            styles: wt(wt({}, S), f.styles)
        }),
        A = r.found && n.found ? Nu("generateAbstractMask", E) || {
            children: [],
            attributes: {}
        } : Nu("generateAbstractIcon", E) || {
            children: [],
            attributes: {}
        },
        T = A.children,
        M = A.attributes;
    return E.children = T, E.attributes = M, a ? Pye(E) : Tye(E)
}

function T8(t) {
    var e = t.content,
        n = t.width,
        r = t.height,
        i = t.transform,
        s = t.title,
        o = t.extra,
        a = t.watchable,
        l = a === void 0 ? !1 : a,
        u = wt(wt(wt({}, o.attributes), s ? {
            title: s
        } : {}), {}, {
            class: o.classes.join(" ")
        });
    l && (u[ip] = "");
    var c = wt({}, o.styles);
    n4(i) && (c.transform = oye({
        transform: i,
        startCentered: !0,
        width: n,
        height: r
    }), c["-webkit-transform"] = c.transform);
    var f = JE(c);
    f.length > 0 && (u.style = f);
    var d = [];
    return d.push({
        tag: "span",
        attributes: u,
        children: [e]
    }), s && d.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [s]
    }), d
}

function Iye(t) {
    var e = t.content,
        n = t.title,
        r = t.extra,
        i = wt(wt(wt({}, r.attributes), n ? {
            title: n
        } : {}), {}, {
            class: r.classes.join(" ")
        }),
        s = JE(r.styles);
    s.length > 0 && (i.style = s);
    var o = [];
    return o.push({
        tag: "span",
        attributes: i,
        children: [e]
    }), n && o.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [n]
    }), o
}
var hT = Oa.styles;

function z3(t) {
    var e = t[0],
        n = t[1],
        r = t.slice(4),
        i = JL(r, 1),
        s = i[0],
        o = null;
    return Array.isArray(s) ? o = {
        tag: "g",
        attributes: {
            class: "".concat(It.cssPrefix, "-").concat(Sd.GROUP)
        },
        children: [{
            tag: "path",
            attributes: {
                class: "".concat(It.cssPrefix, "-").concat(Sd.SECONDARY),
                fill: "currentColor",
                d: s[0]
            }
        }, {
            tag: "path",
            attributes: {
                class: "".concat(It.cssPrefix, "-").concat(Sd.PRIMARY),
                fill: "currentColor",
                d: s[1]
            }
        }]
    } : o = {
        tag: "path",
        attributes: {
            fill: "currentColor",
            d: s
        }
    }, {
        found: !0,
        width: e,
        height: n,
        icon: o
    }
}
var Rye = {
    found: !1,
    width: 512,
    height: 512
};

function Oye(t, e) {
    !cK && !It.showMissingIcons && t && console.error('Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.'))
}

function H3(t, e) {
    var n = e;
    return e === "fa" && It.styleDefault !== null && (e = pf()), new Promise(function(r, i) {
        if (Nu("missingIconAbstract"), n === "fa") {
            var s = wK(t) || {};
            t = s.iconName || t, e = s.prefix || e
        }
        if (t && e && hT[e] && hT[e][t]) {
            var o = hT[e][t];
            return r(z3(o))
        }
        Oye(t, e), r(wt(wt({}, Rye), {}, {
            icon: It.showMissingIcons && t ? Nu("missingIconAbstract") || {} : {}
        }))
    })
}
var P8 = function() {},
    U3 = It.measurePerformance && Qx && Qx.mark && Qx.measure ? Qx : {
        mark: P8,
        measure: P8
    },
    Jy = 'FA "6.3.0"',
    Dye = function(e) {
        return U3.mark("".concat(Jy, " ").concat(e, " begins")),
            function() {
                return AK(e)
            }
    },
    AK = function(e) {
        U3.mark("".concat(Jy, " ").concat(e, " ends")), U3.measure("".concat(Jy, " ").concat(e), "".concat(Jy, " ").concat(e, " begins"), "".concat(Jy, " ").concat(e, " ends"))
    },
    a4 = {
        begin: Dye,
        end: AK
    },
    CS = function() {};

function I8(t) {
    var e = t.getAttribute ? t.getAttribute(ip) : null;
    return typeof e == "string"
}

function Lye(t) {
    var e = t.getAttribute ? t.getAttribute(QL) : null,
        n = t.getAttribute ? t.getAttribute(ZL) : null;
    return e && n
}

function kye(t) {
    return t && t.classList && t.classList.contains && t.classList.contains(It.replacementClass)
}

function Bye() {
    if (It.autoReplaceSvg === !0) return MS.replace;
    var t = MS[It.autoReplaceSvg];
    return t || MS.replace
}

function Fye(t) {
    return hr.createElementNS("http://www.w3.org/2000/svg", t)
}

function Nye(t) {
    return hr.createElement(t)
}

function CK(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = e.ceFn,
        r = n === void 0 ? t.tag === "svg" ? Fye : Nye : n;
    if (typeof t == "string") return hr.createTextNode(t);
    var i = r(t.tag);
    Object.keys(t.attributes || []).forEach(function(o) {
        i.setAttribute(o, t.attributes[o])
    });
    var s = t.children || [];
    return s.forEach(function(o) {
        i.appendChild(CK(o, {
            ceFn: r
        }))
    }), i
}

function zye(t) {
    var e = " ".concat(t.outerHTML, " ");
    return e = "".concat(e, "Font Awesome fontawesome.com "), e
}
var MS = {
    replace: function(e) {
        var n = e[0];
        if (n.parentNode)
            if (e[1].forEach(function(i) {
                    n.parentNode.insertBefore(CK(i), n)
                }), n.getAttribute(ip) === null && It.keepOriginalSource) {
                var r = hr.createComment(zye(n));
                n.parentNode.replaceChild(r, n)
            } else n.remove()
    },
    nest: function(e) {
        var n = e[0],
            r = e[1];
        if (~t4(n).indexOf(It.replacementClass)) return MS.replace(e);
        var i = new RegExp("".concat(It.cssPrefix, "-.*"));
        if (delete r[0].attributes.id, r[0].attributes.class) {
            var s = r[0].attributes.class.split(" ").reduce(function(a, l) {
                return l === It.replacementClass || l.match(i) ? a.toSvg.push(l) : a.toNode.push(l), a
            }, {
                toNode: [],
                toSvg: []
            });
            r[0].attributes.class = s.toSvg.join(" "), s.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", s.toNode.join(" "))
        }
        var o = r.map(function(a) {
            return I1(a)
        }).join(`
`);
        n.setAttribute(ip, ""), n.innerHTML = o
    }
};

function R8(t) {
    t()
}

function MK(t, e) {
    var n = typeof e == "function" ? e : CS;
    if (t.length === 0) n();
    else {
        var r = R8;
        It.mutateApproach === Gge && (r = df.requestAnimationFrame || R8), r(function() {
            var i = Bye(),
                s = a4.begin("mutate");
            t.map(i), s(), n()
        })
    }
}
var l4 = !1;

function TK() {
    l4 = !0
}

function $3() {
    l4 = !1
}
var zw = null;

function O8(t) {
    if (_8 && It.observeMutations) {
        var e = t.treeCallback,
            n = e === void 0 ? CS : e,
            r = t.nodeCallback,
            i = r === void 0 ? CS : r,
            s = t.pseudoElementsCallback,
            o = s === void 0 ? CS : s,
            a = t.observeMutationsRoot,
            l = a === void 0 ? hr : a;
        zw = new _8(function(u) {
            if (!l4) {
                var c = pf();
                Eg(u).forEach(function(f) {
                    if (f.type === "childList" && f.addedNodes.length > 0 && !I8(f.addedNodes[0]) && (It.searchPseudoElements && o(f.target), n(f.target)), f.type === "attributes" && f.target.parentNode && It.searchPseudoElements && o(f.target.parentNode), f.type === "attributes" && I8(f.target) && ~Jge.indexOf(f.attributeName))
                        if (f.attributeName === "class" && Lye(f.target)) {
                            var d = QE(t4(f.target)),
                                p = d.prefix,
                                m = d.iconName;
                            f.target.setAttribute(QL, p || c), m && f.target.setAttribute(ZL, m)
                        } else kye(f.target) && i(f.target)
                })
            }
        }), ju && zw.observe(l, {
            childList: !0,
            attributes: !0,
            characterData: !0,
            subtree: !0
        })
    }
}

function Hye() {
    zw && zw.disconnect()
}

function Uye(t) {
    var e = t.getAttribute("style"),
        n = [];
    return e && (n = e.split(";").reduce(function(r, i) {
        var s = i.split(":"),
            o = s[0],
            a = s.slice(1);
        return o && a.length > 0 && (r[o] = a.join(":").trim()), r
    }, {})), n
}

function $ye(t) {
    var e = t.getAttribute("data-prefix"),
        n = t.getAttribute("data-icon"),
        r = t.innerText !== void 0 ? t.innerText.trim() : "",
        i = QE(t4(t));
    return i.prefix || (i.prefix = pf()), e && n && (i.prefix = e, i.iconName = n), i.iconName && i.prefix || (i.prefix && r.length > 0 && (i.iconName = bye(i.prefix, t.innerText) || i4(i.prefix, k3(t.innerText))), !i.iconName && It.autoFetchSvg && t.firstChild && t.firstChild.nodeType === Node.TEXT_NODE && (i.iconName = t.firstChild.data)), i
}

function Gye(t) {
    var e = Eg(t.attributes).reduce(function(i, s) {
            return i.name !== "class" && i.name !== "style" && (i[s.name] = s.value), i
        }, {}),
        n = t.getAttribute("title"),
        r = t.getAttribute("data-fa-title-id");
    return It.autoA11y && (n ? e["aria-labelledby"] = "".concat(It.replacementClass, "-title-").concat(r || S0()) : (e["aria-hidden"] = "true", e.focusable = "false")), e
}

function Vye() {
    return {
        iconName: null,
        title: null,
        titleId: null,
        prefix: null,
        transform: _l,
        symbol: !1,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        extra: {
            classes: [],
            styles: {},
            attributes: {}
        }
    }
}

function D8(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            styleParser: !0
        },
        n = $ye(t),
        r = n.iconName,
        i = n.prefix,
        s = n.rest,
        o = Gye(t),
        a = F3("parseNodeAttributes", {}, t),
        l = e.styleParser ? Uye(t) : [];
    return wt({
        iconName: r,
        title: t.getAttribute("title"),
        titleId: t.getAttribute("data-fa-title-id"),
        prefix: i,
        transform: _l,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        symbol: !1,
        extra: {
            classes: s,
            styles: l,
            attributes: o
        }
    }, a)
}
var jye = Oa.styles;

function PK(t) {
    var e = It.autoReplaceSvg === "nest" ? D8(t, {
        styleParser: !1
    }) : D8(t);
    return ~e.extra.classes.indexOf(fK) ? Nu("generateLayersText", t, e) : Nu("generateSvgReplacementMutation", t, e)
}
var hf = new Set;
e4.map(function(t) {
    hf.add("fa-".concat(t))
});
Object.keys(v0[cr]).map(hf.add.bind(hf));
Object.keys(v0[Fr]).map(hf.add.bind(hf));
hf = T1(hf);

function L8(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!ju) return Promise.resolve();
    var n = hr.documentElement.classList,
        r = function(f) {
            return n.add("".concat(S8, "-").concat(f))
        },
        i = function(f) {
            return n.remove("".concat(S8, "-").concat(f))
        },
        s = It.autoFetchSvg ? hf : e4.map(function(c) {
            return "fa-".concat(c)
        }).concat(Object.keys(jye));
    s.includes("fa") || s.push("fa");
    var o = [".".concat(fK, ":not([").concat(ip, "])")].concat(s.map(function(c) {
        return ".".concat(c, ":not([").concat(ip, "])")
    })).join(", ");
    if (o.length === 0) return Promise.resolve();
    var a = [];
    try {
        a = Eg(t.querySelectorAll(o))
    } catch {}
    if (a.length > 0) r("pending"), i("complete");
    else return Promise.resolve();
    var l = a4.begin("onTree"),
        u = a.reduce(function(c, f) {
            try {
                var d = PK(f);
                d && c.push(d)
            } catch (p) {
                cK || p.name === "MissingIcon" && console.error(p)
            }
            return c
        }, []);
    return new Promise(function(c, f) {
        Promise.all(u).then(function(d) {
            MK(d, function() {
                r("active"), r("complete"), i("pending"), typeof e == "function" && e(), l(), c()
            })
        }).catch(function(d) {
            l(), f(d)
        })
    })
}

function Wye(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    PK(t).then(function(n) {
        n && MK([n], e)
    })
}

function Kye(t) {
    return function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            r = (e || {}).icon ? e : N3(e || {}),
            i = n.mask;
        return i && (i = (i || {}).icon ? i : N3(i || {})), t(r, wt(wt({}, n), {}, {
            mask: i
        }))
    }
}
var qye = function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            r = n.transform,
            i = r === void 0 ? _l : r,
            s = n.symbol,
            o = s === void 0 ? !1 : s,
            a = n.mask,
            l = a === void 0 ? null : a,
            u = n.maskId,
            c = u === void 0 ? null : u,
            f = n.title,
            d = f === void 0 ? null : f,
            p = n.titleId,
            m = p === void 0 ? null : p,
            y = n.classes,
            v = y === void 0 ? [] : y,
            b = n.attributes,
            _ = b === void 0 ? {} : b,
            x = n.styles,
            S = x === void 0 ? {} : x;
        if (e) {
            var E = e.prefix,
                A = e.iconName,
                T = e.icon;
            return ZE(wt({
                type: "icon"
            }, e), function() {
                return sp("beforeDOMElementCreation", {
                    iconDefinition: e,
                    params: n
                }), It.autoA11y && (d ? _["aria-labelledby"] = "".concat(It.replacementClass, "-title-").concat(m || S0()) : (_["aria-hidden"] = "true", _.focusable = "false")), o4({
                    icons: {
                        main: z3(T),
                        mask: l ? z3(l.icon) : {
                            found: !1,
                            width: null,
                            height: null,
                            icon: {}
                        }
                    },
                    prefix: E,
                    iconName: A,
                    transform: wt(wt({}, _l), i),
                    symbol: o,
                    title: d,
                    maskId: c,
                    titleId: m,
                    extra: {
                        attributes: _,
                        styles: S,
                        classes: v
                    }
                })
            })
        }
    },
    Xye = {
        mixout: function() {
            return {
                icon: Kye(qye)
            }
        },
        hooks: function() {
            return {
                mutationObserverCallbacks: function(n) {
                    return n.treeCallback = L8, n.nodeCallback = Wye, n
                }
            }
        },
        provides: function(e) {
            e.i2svg = function(n) {
                var r = n.node,
                    i = r === void 0 ? hr : r,
                    s = n.callback,
                    o = s === void 0 ? function() {} : s;
                return L8(i, o)
            }, e.generateSvgReplacementMutation = function(n, r) {
                var i = r.iconName,
                    s = r.title,
                    o = r.titleId,
                    a = r.prefix,
                    l = r.transform,
                    u = r.symbol,
                    c = r.mask,
                    f = r.maskId,
                    d = r.extra;
                return new Promise(function(p, m) {
                    Promise.all([H3(i, a), c.iconName ? H3(c.iconName, c.prefix) : Promise.resolve({
                        found: !1,
                        width: 512,
                        height: 512,
                        icon: {}
                    })]).then(function(y) {
                        var v = JL(y, 2),
                            b = v[0],
                            _ = v[1];
                        p([n, o4({
                            icons: {
                                main: b,
                                mask: _
                            },
                            prefix: a,
                            iconName: i,
                            transform: l,
                            symbol: u,
                            maskId: f,
                            title: s,
                            titleId: o,
                            extra: d,
                            watchable: !0
                        })])
                    }).catch(m)
                })
            }, e.generateAbstractIcon = function(n) {
                var r = n.children,
                    i = n.attributes,
                    s = n.main,
                    o = n.transform,
                    a = n.styles,
                    l = JE(a);
                l.length > 0 && (i.style = l);
                var u;
                return n4(o) && (u = Nu("generateAbstractTransformGrouping", {
                    main: s,
                    transform: o,
                    containerWidth: s.width,
                    iconWidth: s.width
                })), r.push(u || s.icon), {
                    children: r,
                    attributes: i
                }
            }
        }
    },
    Jye = {
        mixout: function() {
            return {
                layer: function(n) {
                    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                        i = r.classes,
                        s = i === void 0 ? [] : i;
                    return ZE({
                        type: "layer"
                    }, function() {
                        sp("beforeDOMElementCreation", {
                            assembler: n,
                            params: r
                        });
                        var o = [];
                        return n(function(a) {
                            Array.isArray(a) ? a.map(function(l) {
                                o = o.concat(l.abstract)
                            }) : o = o.concat(a.abstract)
                        }), [{
                            tag: "span",
                            attributes: {
                                class: ["".concat(It.cssPrefix, "-layers")].concat(T1(s)).join(" ")
                            },
                            children: o
                        }]
                    })
                }
            }
        }
    },
    Yye = {
        mixout: function() {
            return {
                counter: function(n) {
                    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                        i = r.title,
                        s = i === void 0 ? null : i,
                        o = r.classes,
                        a = o === void 0 ? [] : o,
                        l = r.attributes,
                        u = l === void 0 ? {} : l,
                        c = r.styles,
                        f = c === void 0 ? {} : c;
                    return ZE({
                        type: "counter",
                        content: n
                    }, function() {
                        return sp("beforeDOMElementCreation", {
                            content: n,
                            params: r
                        }), Iye({
                            content: n.toString(),
                            title: s,
                            extra: {
                                attributes: u,
                                styles: f,
                                classes: ["".concat(It.cssPrefix, "-layers-counter")].concat(T1(a))
                            }
                        })
                    })
                }
            }
        }
    },
    Qye = {
        mixout: function() {
            return {
                text: function(n) {
                    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                        i = r.transform,
                        s = i === void 0 ? _l : i,
                        o = r.title,
                        a = o === void 0 ? null : o,
                        l = r.classes,
                        u = l === void 0 ? [] : l,
                        c = r.attributes,
                        f = c === void 0 ? {} : c,
                        d = r.styles,
                        p = d === void 0 ? {} : d;
                    return ZE({
                        type: "text",
                        content: n
                    }, function() {
                        return sp("beforeDOMElementCreation", {
                            content: n,
                            params: r
                        }), T8({
                            content: n,
                            transform: wt(wt({}, _l), s),
                            title: a,
                            extra: {
                                attributes: f,
                                styles: p,
                                classes: ["".concat(It.cssPrefix, "-layers-text")].concat(T1(u))
                            }
                        })
                    })
                }
            }
        },
        provides: function(e) {
            e.generateLayersText = function(n, r) {
                var i = r.title,
                    s = r.transform,
                    o = r.extra,
                    a = null,
                    l = null;
                if (aK) {
                    var u = parseInt(getComputedStyle(n).fontSize, 10),
                        c = n.getBoundingClientRect();
                    a = c.width / u, l = c.height / u
                }
                return It.autoA11y && !i && (o.attributes["aria-hidden"] = "true"), Promise.resolve([n, T8({
                    content: n.innerHTML,
                    width: a,
                    height: l,
                    transform: s,
                    title: i,
                    extra: o,
                    watchable: !0
                })])
            }
        }
    },
    Zye = new RegExp('"', "ug"),
    k8 = [1105920, 1112319];

function eve(t) {
    var e = t.replace(Zye, ""),
        n = pye(e, 0),
        r = n >= k8[0] && n <= k8[1],
        i = e.length === 2 ? e[0] === e[1] : !1;
    return {
        value: k3(i ? e[0] : e),
        isSecondary: r || i
    }
}

function B8(t, e) {
    var n = "".concat($ge).concat(e.replace(":", "-"));
    return new Promise(function(r, i) {
        if (t.getAttribute(n) !== null) return r();
        var s = Eg(t.children),
            o = s.filter(function(T) {
                return T.getAttribute(L3) === e
            })[0],
            a = df.getComputedStyle(t, e),
            l = a.getPropertyValue("font-family").match(Kge),
            u = a.getPropertyValue("font-weight"),
            c = a.getPropertyValue("content");
        if (o && !l) return t.removeChild(o), r();
        if (l && c !== "none" && c !== "") {
            var f = a.getPropertyValue("content"),
                d = ~["Sharp"].indexOf(l[2]) ? Fr : cr,
                p = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(l[2]) ? b0[d][l[2].toLowerCase()] : qge[d][u],
                m = eve(f),
                y = m.value,
                v = m.isSecondary,
                b = l[0].startsWith("FontAwesome"),
                _ = i4(p, y),
                x = _;
            if (b) {
                var S = xye(y);
                S.iconName && S.prefix && (_ = S.iconName, p = S.prefix)
            }
            if (_ && !v && (!o || o.getAttribute(QL) !== p || o.getAttribute(ZL) !== x)) {
                t.setAttribute(n, x), o && t.removeChild(o);
                var E = Vye(),
                    A = E.extra;
                A.attributes[L3] = e, H3(_, p).then(function(T) {
                    var M = o4(wt(wt({}, E), {}, {
                            icons: {
                                main: T,
                                mask: s4()
                            },
                            prefix: p,
                            iconName: x,
                            extra: A,
                            watchable: !0
                        })),
                        I = hr.createElement("svg");
                    e === "::before" ? t.insertBefore(I, t.firstChild) : t.appendChild(I), I.outerHTML = M.map(function(O) {
                        return I1(O)
                    }).join(`
`), t.removeAttribute(n), r()
                }).catch(i)
            } else r()
        } else r()
    })
}

function tve(t) {
    return Promise.all([B8(t, "::before"), B8(t, "::after")])
}

function nve(t) {
    return t.parentNode !== document.head && !~Vge.indexOf(t.tagName.toUpperCase()) && !t.getAttribute(L3) && (!t.parentNode || t.parentNode.tagName !== "svg")
}

function F8(t) {
    if (ju) return new Promise(function(e, n) {
        var r = Eg(t.querySelectorAll("*")).filter(nve).map(tve),
            i = a4.begin("searchPseudoElements");
        TK(), Promise.all(r).then(function() {
            i(), $3(), e()
        }).catch(function() {
            i(), $3(), n()
        })
    })
}
var rve = {
        hooks: function() {
            return {
                mutationObserverCallbacks: function(n) {
                    return n.pseudoElementsCallback = F8, n
                }
            }
        },
        provides: function(e) {
            e.pseudoElements2svg = function(n) {
                var r = n.node,
                    i = r === void 0 ? hr : r;
                It.searchPseudoElements && F8(i)
            }
        }
    },
    N8 = !1,
    ive = {
        mixout: function() {
            return {
                dom: {
                    unwatch: function() {
                        TK(), N8 = !0
                    }
                }
            }
        },
        hooks: function() {
            return {
                bootstrap: function() {
                    O8(F3("mutationObserverCallbacks", {}))
                },
                noAuto: function() {
                    Hye()
                },
                watch: function(n) {
                    var r = n.observeMutationsRoot;
                    N8 ? $3() : O8(F3("mutationObserverCallbacks", {
                        observeMutationsRoot: r
                    }))
                }
            }
        }
    },
    z8 = function(e) {
        var n = {
            size: 16,
            x: 0,
            y: 0,
            flipX: !1,
            flipY: !1,
            rotate: 0
        };
        return e.toLowerCase().split(" ").reduce(function(r, i) {
            var s = i.toLowerCase().split("-"),
                o = s[0],
                a = s.slice(1).join("-");
            if (o && a === "h") return r.flipX = !0, r;
            if (o && a === "v") return r.flipY = !0, r;
            if (a = parseFloat(a), isNaN(a)) return r;
            switch (o) {
                case "grow":
                    r.size = r.size + a;
                    break;
                case "shrink":
                    r.size = r.size - a;
                    break;
                case "left":
                    r.x = r.x - a;
                    break;
                case "right":
                    r.x = r.x + a;
                    break;
                case "up":
                    r.y = r.y - a;
                    break;
                case "down":
                    r.y = r.y + a;
                    break;
                case "rotate":
                    r.rotate = r.rotate + a;
                    break
            }
            return r
        }, n)
    },
    sve = {
        mixout: function() {
            return {
                parse: {
                    transform: function(n) {
                        return z8(n)
                    }
                }
            }
        },
        hooks: function() {
            return {
                parseNodeAttributes: function(n, r) {
                    var i = r.getAttribute("data-fa-transform");
                    return i && (n.transform = z8(i)), n
                }
            }
        },
        provides: function(e) {
            e.generateAbstractTransformGrouping = function(n) {
                var r = n.main,
                    i = n.transform,
                    s = n.containerWidth,
                    o = n.iconWidth,
                    a = {
                        transform: "translate(".concat(s / 2, " 256)")
                    },
                    l = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "),
                    u = "scale(".concat(i.size / 16 * (i.flipX ? -1 : 1), ", ").concat(i.size / 16 * (i.flipY ? -1 : 1), ") "),
                    c = "rotate(".concat(i.rotate, " 0 0)"),
                    f = {
                        transform: "".concat(l, " ").concat(u, " ").concat(c)
                    },
                    d = {
                        transform: "translate(".concat(o / 2 * -1, " -256)")
                    },
                    p = {
                        outer: a,
                        inner: f,
                        path: d
                    };
                return {
                    tag: "g",
                    attributes: wt({}, p.outer),
                    children: [{
                        tag: "g",
                        attributes: wt({}, p.inner),
                        children: [{
                            tag: r.icon.tag,
                            children: r.icon.children,
                            attributes: wt(wt({}, r.icon.attributes), p.path)
                        }]
                    }]
                }
            }
        }
    },
    mT = {
        x: 0,
        y: 0,
        width: "100%",
        height: "100%"
    };

function H8(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t
}

function ove(t) {
    return t.tag === "g" ? t.children : [t]
}
var ave = {
        hooks: function() {
            return {
                parseNodeAttributes: function(n, r) {
                    var i = r.getAttribute("data-fa-mask"),
                        s = i ? QE(i.split(" ").map(function(o) {
                            return o.trim()
                        })) : s4();
                    return s.prefix || (s.prefix = pf()), n.mask = s, n.maskId = r.getAttribute("data-fa-mask-id"), n
                }
            }
        },
        provides: function(e) {
            e.generateAbstractMask = function(n) {
                var r = n.children,
                    i = n.attributes,
                    s = n.main,
                    o = n.mask,
                    a = n.maskId,
                    l = n.transform,
                    u = s.width,
                    c = s.icon,
                    f = o.width,
                    d = o.icon,
                    p = sye({
                        transform: l,
                        containerWidth: f,
                        iconWidth: u
                    }),
                    m = {
                        tag: "rect",
                        attributes: wt(wt({}, mT), {}, {
                            fill: "white"
                        })
                    },
                    y = c.children ? {
                        children: c.children.map(H8)
                    } : {},
                    v = {
                        tag: "g",
                        attributes: wt({}, p.inner),
                        children: [H8(wt({
                            tag: c.tag,
                            attributes: wt(wt({}, c.attributes), p.path)
                        }, y))]
                    },
                    b = {
                        tag: "g",
                        attributes: wt({}, p.outer),
                        children: [v]
                    },
                    _ = "mask-".concat(a || S0()),
                    x = "clip-".concat(a || S0()),
                    S = {
                        tag: "mask",
                        attributes: wt(wt({}, mT), {}, {
                            id: _,
                            maskUnits: "userSpaceOnUse",
                            maskContentUnits: "userSpaceOnUse"
                        }),
                        children: [m, b]
                    },
                    E = {
                        tag: "defs",
                        children: [{
                            tag: "clipPath",
                            attributes: {
                                id: x
                            },
                            children: ove(d)
                        }, S]
                    };
                return r.push(E, {
                    tag: "rect",
                    attributes: wt({
                        fill: "currentColor",
                        "clip-path": "url(#".concat(x, ")"),
                        mask: "url(#".concat(_, ")")
                    }, mT)
                }), {
                    children: r,
                    attributes: i
                }
            }
        }
    },
    lve = {
        provides: function(e) {
            var n = !1;
            df.matchMedia && (n = df.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
                var r = [],
                    i = {
                        fill: "currentColor"
                    },
                    s = {
                        attributeType: "XML",
                        repeatCount: "indefinite",
                        dur: "2s"
                    };
                r.push({
                    tag: "path",
                    attributes: wt(wt({}, i), {}, {
                        d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
                    })
                });
                var o = wt(wt({}, s), {}, {
                        attributeName: "opacity"
                    }),
                    a = {
                        tag: "circle",
                        attributes: wt(wt({}, i), {}, {
                            cx: "256",
                            cy: "364",
                            r: "28"
                        }),
                        children: []
                    };
                return n || a.children.push({
                    tag: "animate",
                    attributes: wt(wt({}, s), {}, {
                        attributeName: "r",
                        values: "28;14;28;28;14;28;"
                    })
                }, {
                    tag: "animate",
                    attributes: wt(wt({}, o), {}, {
                        values: "1;0;1;1;0;1;"
                    })
                }), r.push(a), r.push({
                    tag: "path",
                    attributes: wt(wt({}, i), {}, {
                        opacity: "1",
                        d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
                    }),
                    children: n ? [] : [{
                        tag: "animate",
                        attributes: wt(wt({}, o), {}, {
                            values: "1;0;0;0;0;1;"
                        })
                    }]
                }), n || r.push({
                    tag: "path",
                    attributes: wt(wt({}, i), {}, {
                        opacity: "0",
                        d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
                    }),
                    children: [{
                        tag: "animate",
                        attributes: wt(wt({}, o), {}, {
                            values: "0;0;1;1;0;0;"
                        })
                    }]
                }), {
                    tag: "g",
                    attributes: {
                        class: "missing"
                    },
                    children: r
                }
            }
        }
    },
    uve = {
        hooks: function() {
            return {
                parseNodeAttributes: function(n, r) {
                    var i = r.getAttribute("data-fa-symbol"),
                        s = i === null ? !1 : i === "" ? !0 : i;
                    return n.symbol = s, n
                }
            }
        }
    },
    cve = [lye, Xye, Jye, Yye, Qye, rve, ive, sve, ave, lve, uve];
wye(cve, {
    mixoutsTo: bo
});
bo.noAuto;
bo.config;
bo.library;
bo.dom;
var G3 = bo.parse;
bo.findIconDefinition;
bo.toHtml;
var fve = bo.icon;
bo.layer;
bo.text;
bo.counter;
var IK = {
        exports: {}
    },
    dve = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
    pve = dve,
    hve = pve;

function RK() {}

function OK() {}
OK.resetWarningCache = RK;
var mve = function() {
    function t(r, i, s, o, a, l) {
        if (l !== hve) {
            var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw u.name = "Invariant Violation", u
        }
    }
    t.isRequired = t;

    function e() {
        return t
    }
    var n = {
        array: t,
        bigint: t,
        bool: t,
        func: t,
        number: t,
        object: t,
        string: t,
        symbol: t,
        any: t,
        arrayOf: e,
        element: t,
        elementType: t,
        instanceOf: e,
        node: t,
        objectOf: e,
        oneOf: e,
        oneOfType: e,
        shape: e,
        exact: e,
        checkPropTypes: OK,
        resetWarningCache: RK
    };
    return n.PropTypes = n, n
};
IK.exports = mve();
var gve = IK.exports;
const Le = la(gve);

function U8(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Lc(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? U8(Object(n), !0).forEach(function(r) {
            Vh(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : U8(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}

function Hw(t) {
    "@babel/helpers - typeof";
    return Hw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, Hw(t)
}

function Vh(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function yve(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}

function vve(t, e) {
    if (t == null) return {};
    var n = yve(t, e),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (i = 0; i < s.length; i++) r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
    }
    return n
}

function V3(t) {
    return bve(t) || xve(t) || _ve(t) || Sve()
}

function bve(t) {
    if (Array.isArray(t)) return j3(t)
}

function xve(t) {
    if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
}

function _ve(t, e) {
    if (t) {
        if (typeof t == "string") return j3(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return j3(t, e)
    }
}

function j3(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
}

function Sve() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function wve(t) {
    var e, n = t.beat,
        r = t.fade,
        i = t.beatFade,
        s = t.bounce,
        o = t.shake,
        a = t.flash,
        l = t.spin,
        u = t.spinPulse,
        c = t.spinReverse,
        f = t.pulse,
        d = t.fixedWidth,
        p = t.inverse,
        m = t.border,
        y = t.listItem,
        v = t.flip,
        b = t.size,
        _ = t.rotation,
        x = t.pull,
        S = (e = {
            "fa-beat": n,
            "fa-fade": r,
            "fa-beat-fade": i,
            "fa-bounce": s,
            "fa-shake": o,
            "fa-flash": a,
            "fa-spin": l,
            "fa-spin-reverse": c,
            "fa-spin-pulse": u,
            "fa-pulse": f,
            "fa-fw": d,
            "fa-inverse": p,
            "fa-border": m,
            "fa-li": y,
            "fa-flip": v === !0,
            "fa-flip-horizontal": v === "horizontal" || v === "both",
            "fa-flip-vertical": v === "vertical" || v === "both"
        }, Vh(e, "fa-".concat(b), typeof b < "u" && b !== null), Vh(e, "fa-rotate-".concat(_), typeof _ < "u" && _ !== null && _ !== 0), Vh(e, "fa-pull-".concat(x), typeof x < "u" && x !== null), Vh(e, "fa-swap-opacity", t.swapOpacity), e);
    return Object.keys(S).map(function(E) {
        return S[E] ? E : null
    }).filter(function(E) {
        return E
    })
}

function Eve(t) {
    return t = t - 0, t === t
}

function DK(t) {
    return Eve(t) ? t : (t = t.replace(/[\-_\s]+(.)?/g, function(e, n) {
        return n ? n.toUpperCase() : ""
    }), t.substr(0, 1).toLowerCase() + t.substr(1))
}
var Ave = ["style"];

function Cve(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}

function Mve(t) {
    return t.split(";").map(function(e) {
        return e.trim()
    }).filter(function(e) {
        return e
    }).reduce(function(e, n) {
        var r = n.indexOf(":"),
            i = DK(n.slice(0, r)),
            s = n.slice(r + 1).trim();
        return i.startsWith("webkit") ? e[Cve(i)] = s : e[i] = s, e
    }, {})
}

function LK(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof e == "string") return e;
    var r = (e.children || []).map(function(l) {
            return LK(t, l)
        }),
        i = Object.keys(e.attributes || {}).reduce(function(l, u) {
            var c = e.attributes[u];
            switch (u) {
                case "class":
                    l.attrs.className = c, delete e.attributes.class;
                    break;
                case "style":
                    l.attrs.style = Mve(c);
                    break;
                default:
                    u.indexOf("aria-") === 0 || u.indexOf("data-") === 0 ? l.attrs[u.toLowerCase()] = c : l.attrs[DK(u)] = c
            }
            return l
        }, {
            attrs: {}
        }),
        s = n.style,
        o = s === void 0 ? {} : s,
        a = vve(n, Ave);
    return i.attrs.style = Lc(Lc({}, i.attrs.style), o), t.apply(void 0, [e.tag, Lc(Lc({}, i.attrs), a)].concat(V3(r)))
}
var kK = !1;
try {
    kK = !0
} catch {}

function Tve() {
    if (!kK && console && typeof console.error == "function") {
        var t;
        (t = console).error.apply(t, arguments)
    }
}

function $8(t) {
    if (t && Hw(t) === "object" && t.prefix && t.iconName && t.icon) return t;
    if (G3.icon) return G3.icon(t);
    if (t === null) return null;
    if (t && Hw(t) === "object" && t.prefix && t.iconName) return t;
    if (Array.isArray(t) && t.length === 2) return {
        prefix: t[0],
        iconName: t[1]
    };
    if (typeof t == "string") return {
        prefix: "fas",
        iconName: t
    }
}

function gT(t, e) {
    return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? Vh({}, t, e) : {}
}
var eA = Bt.forwardRef(function(t, e) {
    var n = t.icon,
        r = t.mask,
        i = t.symbol,
        s = t.className,
        o = t.title,
        a = t.titleId,
        l = t.maskId,
        u = $8(n),
        c = gT("classes", [].concat(V3(wve(t)), V3(s.split(" ")))),
        f = gT("transform", typeof t.transform == "string" ? G3.transform(t.transform) : t.transform),
        d = gT("mask", $8(r)),
        p = fve(u, Lc(Lc(Lc(Lc({}, c), f), d), {}, {
            symbol: i,
            title: o,
            titleId: a,
            maskId: l
        }));
    if (!p) return Tve("Could not find icon", u), null;
    var m = p.abstract,
        y = {
            ref: e
        };
    return Object.keys(t).forEach(function(v) {
        eA.defaultProps.hasOwnProperty(v) || (y[v] = t[v])
    }), Pve(m[0], y)
});
eA.displayName = "FontAwesomeIcon";
eA.propTypes = {
    beat: Le.bool,
    border: Le.bool,
    beatFade: Le.bool,
    bounce: Le.bool,
    className: Le.string,
    fade: Le.bool,
    flash: Le.bool,
    mask: Le.oneOfType([Le.object, Le.array, Le.string]),
    maskId: Le.string,
    fixedWidth: Le.bool,
    inverse: Le.bool,
    flip: Le.oneOf([!0, !1, "horizontal", "vertical", "both"]),
    icon: Le.oneOfType([Le.object, Le.array, Le.string]),
    listItem: Le.bool,
    pull: Le.oneOf(["right", "left"]),
    pulse: Le.bool,
    rotation: Le.oneOf([0, 90, 180, 270]),
    shake: Le.bool,
    size: Le.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
    spin: Le.bool,
    spinPulse: Le.bool,
    spinReverse: Le.bool,
    symbol: Le.oneOfType([Le.bool, Le.string]),
    title: Le.string,
    titleId: Le.string,
    transform: Le.oneOfType([Le.string, Le.object]),
    swapOpacity: Le.bool
};
eA.defaultProps = {
    border: !1,
    className: "",
    mask: null,
    maskId: null,
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: null,
    listItem: !1,
    pull: null,
    pulse: !1,
    rotation: null,
    size: null,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: null,
    transform: null,
    swapOpacity: !1
};
var Pve = LK.bind(null, Bt.createElement),
    pHe = {
        prefix: "fas",
        iconName: "stethoscope",
        icon: [576, 512, [129658], "f0f1", "M126.4 21.9c5.6 16.8-3.5 34.9-20.2 40.5L80 71.1V192c0 53 43 96 96 96s96-43 96-96V71.1l-26.1-8.7c-16.8-5.6-25.8-23.7-20.2-40.5s23.7-25.8 40.5-20.2l26.1 8.7C318.4 19.1 336 43.5 336 71.1V192c0 77.2-54.6 141.6-127.3 156.7C215 404.6 262.4 448 320 448c61.9 0 112-50.1 112-112V265.3c-28.3-12.3-48-40.5-48-73.3c0-44.2 35.8-80 80-80s80 35.8 80 80c0 32.8-19.7 61-48 73.3V336c0 97.2-78.8 176-176 176c-92.9 0-168.9-71.9-175.5-163.1C71.2 334.2 16 269.6 16 192V71.1c0-27.5 17.6-52 43.8-60.7L85.9 1.6c16.8-5.6 34.9 3.5 40.5 20.2zM464 224a32 32 0 1 0 0-64 32 32 0 1 0 0 64z"]
    },
    hHe = {
        prefix: "fas",
        iconName: "bars",
        icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"]
    },
    mHe = {
        prefix: "fas",
        iconName: "lightbulb",
        icon: [384, 512, [128161], "f0eb", "M256 384c9.6-31.9 29.5-59.1 49.2-86.2l0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C352 78.8 273.2 0 176 0S0 78.8 0 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4l0 0C66.5 324.9 86.4 352.1 96 384H256zM176 512c44.2 0 80-35.8 80-80V416H96v16c0 44.2 35.8 80 80 80zM96 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"]
    },
    gHe = {
        prefix: "fas",
        iconName: "compress",
        icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V64zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32H96v64c0 17.7 14.3 32 32 32s32-14.3 32-32V352c0-17.7-14.3-32-32-32H32zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H352V64zM320 320c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32s32-14.3 32-32V384h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H320z"]
    },
    yHe = {
        prefix: "fas",
        iconName: "gamepad",
        icon: [640, 512, [], "f11b", "M192 64C86 64 0 150 0 256S86 448 192 448H448c106 0 192-86 192-192s-86-192-192-192H192zM496 248c-22.1 0-40-17.9-40-40s17.9-40 40-40s40 17.9 40 40s-17.9 40-40 40zm-24 56c0 22.1-17.9 40-40 40s-40-17.9-40-40s17.9-40 40-40s40 17.9 40 40zM168 200c0-13.3 10.7-24 24-24s24 10.7 24 24v32h32c13.3 0 24 10.7 24 24s-10.7 24-24 24H216v32c0 13.3-10.7 24-24 24s-24-10.7-24-24V280H136c-13.3 0-24-10.7-24-24s10.7-24 24-24h32V200z"]
    },
    vHe = {
        prefix: "fas",
        iconName: "stopwatch",
        icon: [448, 512, [9201], "f2f2", "M160 0c-17.7 0-32 14.3-32 32s14.3 32 32 32h16V98.4C76.3 113.8 0 200 0 304C0 418.9 93.1 512 208 512s208-93.1 208-208c0-41.8-12.3-80.7-33.5-113.2l24.1-24.1c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L339.7 143c-28.1-23-62.2-38.8-99.7-44.6V64h16c17.7 0 32-14.3 32-32s-14.3-32-32-32H208 160zm72 192V320c0 13.3-10.7 24-24 24s-24-10.7-24-24V192c0-13.3 10.7-24 24-24s24 10.7 24 24z"]
    },
    bHe = {
        prefix: "fas",
        iconName: "stairs",
        icon: [576, 512, [], "e289", "M384 64c0-17.7 14.3-32 32-32H544c17.7 0 32 14.3 32 32s-14.3 32-32 32H448v96c0 17.7-14.3 32-32 32H320v96c0 17.7-14.3 32-32 32H192v96c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h96V320c0-17.7 14.3-32 32-32h96V192c0-17.7 14.3-32 32-32h96V64z"]
    },
    Ive = {
        prefix: "fas",
        iconName: "wand-magic-sparkles",
        icon: [576, 512, ["magic-wand-sparkles"], "e2ca", "M234.7 42.7L197 56.8c-3 1.1-5 4-5 7.2s2 6.1 5 7.2l37.7 14.1L248.8 123c1.1 3 4 5 7.2 5s6.1-2 7.2-5l14.1-37.7L315 71.2c3-1.1 5-4 5-7.2s-2-6.1-5-7.2L277.3 42.7 263.2 5c-1.1-3-4-5-7.2-5s-6.1 2-7.2 5L234.7 42.7zM46.1 395.4c-18.7 18.7-18.7 49.1 0 67.9l34.6 34.6c18.7 18.7 49.1 18.7 67.9 0L529.9 116.5c18.7-18.7 18.7-49.1 0-67.9L495.3 14.1c-18.7-18.7-49.1-18.7-67.9 0L46.1 395.4zM484.6 82.6l-105 105-23.3-23.3 105-105 23.3 23.3zM7.5 117.2C3 118.9 0 123.2 0 128s3 9.1 7.5 10.8L64 160l21.2 56.5c1.7 4.5 6 7.5 10.8 7.5s9.1-3 10.8-7.5L128 160l56.5-21.2c4.5-1.7 7.5-6 7.5-10.8s-3-9.1-7.5-10.8L128 96 106.8 39.5C105.1 35 100.8 32 96 32s-9.1 3-10.8 7.5L64 96 7.5 117.2zm352 256c-4.5 1.7-7.5 6-7.5 10.8s3 9.1 7.5 10.8L416 416l21.2 56.5c1.7 4.5 6 7.5 10.8 7.5s9.1-3 10.8-7.5L480 416l56.5-21.2c4.5-1.7 7.5-6 7.5-10.8s-3-9.1-7.5-10.8L480 352l-21.2-56.5c-1.7-4.5-6-7.5-10.8-7.5s-9.1 3-10.8 7.5L416 352l-56.5 21.2z"]
    },
    xHe = Ive,
    Rve = {
        prefix: "fas",
        iconName: "ban",
        icon: [512, 512, [128683, "cancel"], "f05e", "M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z"]
    },
    _He = Rve,
    SHe = {
        prefix: "fas",
        iconName: "microchip",
        icon: [512, 512, [], "f2db", "M176 24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64c-35.3 0-64 28.7-64 64H24c-13.3 0-24 10.7-24 24s10.7 24 24 24H64v56H24c-13.3 0-24 10.7-24 24s10.7 24 24 24H64v56H24c-13.3 0-24 10.7-24 24s10.7 24 24 24H64c0 35.3 28.7 64 64 64v40c0 13.3 10.7 24 24 24s24-10.7 24-24V448h56v40c0 13.3 10.7 24 24 24s24-10.7 24-24V448h56v40c0 13.3 10.7 24 24 24s24-10.7 24-24V448c35.3 0 64-28.7 64-64h40c13.3 0 24-10.7 24-24s-10.7-24-24-24H448V280h40c13.3 0 24-10.7 24-24s-10.7-24-24-24H448V176h40c13.3 0 24-10.7 24-24s-10.7-24-24-24H448c0-35.3-28.7-64-64-64V24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64H280V24c0-13.3-10.7-24-24-24s-24 10.7-24 24V64H176V24zM160 128H352c17.7 0 32 14.3 32 32V352c0 17.7-14.3 32-32 32H160c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32zm192 32H160V352H352V160z"]
    },
    wHe = {
        prefix: "fas",
        iconName: "circle-arrow-up",
        icon: [512, 512, ["arrow-circle-up"], "f0aa", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM385 231c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-71-71V376c0 13.3-10.7 24-24 24s-24-10.7-24-24V193.9l-71 71c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9L239 119c9.4-9.4 24.6-9.4 33.9 0L385 231z"]
    },
    EHe = {
        prefix: "fas",
        iconName: "unlock",
        icon: [448, 512, [128275], "f09c", "M144 144c0-44.2 35.8-80 80-80c31.9 0 59.4 18.6 72.3 45.7c7.6 16 26.7 22.8 42.6 15.2s22.8-26.7 15.2-42.6C331 33.7 281.5 0 224 0C144.5 0 80 64.5 80 144v48H64c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V256c0-35.3-28.7-64-64-64H144V144z"]
    },
    AHe = {
        prefix: "fas",
        iconName: "arrow-down-wide-short",
        icon: [576, 512, ["sort-amount-asc", "sort-amount-down"], "f160", "M151.6 469.6C145.5 476.2 137 480 128 480s-17.5-3.8-23.6-10.4l-88-96c-11.9-13-11.1-33.3 2-45.2s33.3-11.1 45.2 2L96 365.7V64c0-17.7 14.3-32 32-32s32 14.3 32 32V365.7l32.4-35.4c11.9-13 32.2-13.9 45.2-2s13.9 32.2 2 45.2l-88 96zM320 480c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H320zm0-128c-17.7 0-32-14.3-32-32s14.3-32 32-32h96c17.7 0 32 14.3 32 32s-14.3 32-32 32H320zm0-128c-17.7 0-32-14.3-32-32s14.3-32 32-32H480c17.7 0 32 14.3 32 32s-14.3 32-32 32H320zm0-128c-17.7 0-32-14.3-32-32s14.3-32 32-32H544c17.7 0 32 14.3 32 32s-14.3 32-32 32H320z"]
    },
    Ove = {
        prefix: "fas",
        iconName: "arrows-left-right",
        icon: [512, 512, ["arrows-h"], "f07e", "M406.6 374.6l96-96c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224l-293.5 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288l293.5 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"]
    },
    CHe = Ove,
    MHe = {
        prefix: "fas",
        iconName: "square",
        icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M0 96C0 60.7 28.7 32 64 32H384c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96z"]
    },
    THe = {
        prefix: "fas",
        iconName: "code",
        icon: [640, 512, [], "f121", "M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3L562.7 256l-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"]
    },
    PHe = {
        prefix: "fas",
        iconName: "circle",
        icon: [512, 512, [128308, 128309, 128992, 128993, 128994, 128995, 128996, 9679, 9898, 9899, 11044, 61708, 61915], "f111", "M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512z"]
    },
    IHe = {
        prefix: "fas",
        iconName: "circle-question",
        icon: [512, 512, [62108, "question-circle"], "f059", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM169.8 165.3c7.9-22.3 29.1-37.3 52.8-37.3h58.3c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24V250.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1H222.6c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
    },
    Dve = {
        prefix: "fas",
        iconName: "floppy-disk",
        icon: [448, 512, [128190, 128426, "save"], "f0c7", "M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V173.3c0-17-6.7-33.3-18.7-45.3L352 50.7C340 38.7 323.7 32 306.7 32H64zm0 96c0-17.7 14.3-32 32-32H288c17.7 0 32 14.3 32 32v64c0 17.7-14.3 32-32 32H96c-17.7 0-32-14.3-32-32V128zM224 288a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"]
    },
    RHe = Dve,
    OHe = {
        prefix: "fas",
        iconName: "trash",
        icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"]
    },
    DHe = {
        prefix: "fas",
        iconName: "headphones",
        icon: [512, 512, [127911], "f025", "M256 80C149.9 80 62.4 159.4 49.6 262c9.4-3.8 19.6-6 30.4-6c26.5 0 48 21.5 48 48V432c0 26.5-21.5 48-48 48c-44.2 0-80-35.8-80-80V384 336 288C0 146.6 114.6 32 256 32s256 114.6 256 256v48 48 16c0 44.2-35.8 80-80 80c-26.5 0-48-21.5-48-48V304c0-26.5 21.5-48 48-48c10.8 0 21 2.1 30.4 6C449.6 159.4 362.1 80 256 80z"]
    },
    Lve = {
        prefix: "fas",
        iconName: "arrow-rotate-left",
        icon: [512, 512, [8634, "arrow-left-rotate", "arrow-rotate-back", "arrow-rotate-backward", "undo"], "f0e2", "M109.7 160H160c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32V64C0 46.3 14.3 32 32 32s32 14.3 32 32v51.2L81.6 97.6c87.5-87.5 229.3-87.5 316.8 0s87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3s-163.8-62.5-226.3 0L109.7 160z"]
    },
    LHe = Lve,
    kHe = {
        prefix: "fas",
        iconName: "gear",
        icon: [512, 512, [9881, "cog"], "f013", "M481.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-30.9 28.1c-7.7 7.1-11.4 17.5-10.9 27.9c.1 2.9 .2 5.8 .2 8.8s-.1 5.9-.2 8.8c-.5 10.5 3.1 20.9 10.9 27.9l30.9 28.1c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-39.7-12.6c-10-3.2-20.8-1.1-29.7 4.6c-4.9 3.1-9.9 6.1-15.1 8.7c-9.3 4.8-16.5 13.2-18.8 23.4l-8.9 40.7c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-8.9-40.7c-2.2-10.2-9.5-18.6-18.8-23.4c-5.2-2.7-10.2-5.6-15.1-8.7c-8.8-5.7-19.7-7.8-29.7-4.6L69.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l30.9-28.1c7.7-7.1 11.4-17.5 10.9-27.9c-.1-2.9-.2-5.8-.2-8.8s.1-5.9 .2-8.8c.5-10.5-3.1-20.9-10.9-27.9L8.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l39.7 12.6c10 3.2 20.8 1.1 29.7-4.6c4.9-3.1 9.9-6.1 15.1-8.7c9.3-4.8 16.5-13.2 18.8-23.4l8.9-40.7c2-9.1 9-16.3 18.2-17.8C213.3 1.2 227.5 0 242 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l8.9 40.7c2.2 10.2 9.4 18.6 18.8 23.4c5.2 2.7 10.2 5.6 15.1 8.7c8.8 5.7 19.7 7.7 29.7 4.6l39.7-12.6c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM242 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
    },
    BHe = {
        prefix: "fas",
        iconName: "keyboard",
        icon: [576, 512, [9e3], "f11c", "M64 64C28.7 64 0 92.7 0 128V384c0 35.3 28.7 64 64 64H512c35.3 0 64-28.7 64-64V128c0-35.3-28.7-64-64-64H64zm16 64h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16zM64 240c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V240zm16 80h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V336c0-8.8 7.2-16 16-16zm80-176c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V144zm16 80h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V240c0-8.8 7.2-16 16-16zM160 336c0-8.8 7.2-16 16-16H400c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V336zM272 128h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H272c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16zM256 240c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H272c-8.8 0-16-7.2-16-16V240zM368 128h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H368c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16zM352 240c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H368c-8.8 0-16-7.2-16-16V240zM464 128h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H464c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16zM448 240c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H464c-8.8 0-16-7.2-16-16V240zm16 80h32c8.8 0 16 7.2 16 16v32c0 8.8-7.2 16-16 16H464c-8.8 0-16-7.2-16-16V336c0-8.8 7.2-16 16-16z"]
    },
    FHe = {
        prefix: "fas",
        iconName: "download",
        icon: [512, 512, [], "f019", "M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 56a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"]
    },
    NHe = {
        prefix: "fas",
        iconName: "upload",
        icon: [512, 512, [], "f093", "M288 109.3V352c0 17.7-14.3 32-32 32s-32-14.3-32-32V109.3l-73.4 73.4c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l128-128c12.5-12.5 32.8-12.5 45.3 0l128 128c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L288 109.3zM64 352H192c0 35.3 28.7 64 64 64s64-28.7 64-64H448c35.3 0 64 28.7 64 64v32c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V416c0-35.3 28.7-64 64-64zM432 456a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"]
    },
    zHe = {
        prefix: "fas",
        iconName: "angle-down",
        icon: [384, 512, [8964], "f107", "M169.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 274.7 54.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
    },
    HHe = {
        prefix: "fas",
        iconName: "toolbox",
        icon: [512, 512, [129520], "f552", "M176 88v40H336V88c0-4.4-3.6-8-8-8H184c-4.4 0-8 3.6-8 8zm-48 40V88c0-30.9 25.1-56 56-56H328c30.9 0 56 25.1 56 56v40h28.1c12.7 0 24.9 5.1 33.9 14.1l51.9 51.9c9 9 14.1 21.2 14.1 33.9V304H384V288c0-17.7-14.3-32-32-32s-32 14.3-32 32v16H192V288c0-17.7-14.3-32-32-32s-32 14.3-32 32v16H0V227.9c0-12.7 5.1-24.9 14.1-33.9l51.9-51.9c9-9 21.2-14.1 33.9-14.1H128zM0 416V336H128v16c0 17.7 14.3 32 32 32s32-14.3 32-32V336H320v16c0 17.7 14.3 32 32 32s32-14.3 32-32V336H512v80c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64z"]
    },
    UHe = {
        prefix: "fas",
        iconName: "clapperboard",
        icon: [512, 512, [], "e131", "M448 32H361.9l-1 1-127 127h92.1l1-1L453.8 32.3c-1.9-.2-3.8-.3-5.8-.3zm64 128V96c0-15.1-5.3-29.1-14-40l-104 104H512zM294.1 32H201.9l-1 1L73.9 160h92.1l1-1 127-127zM64 32C28.7 32 0 60.7 0 96v64H6.1l1-1 127-127H64zM512 192H0V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V192z"]
    },
    $He = {
        prefix: "fas",
        iconName: "plus",
        icon: [448, 512, [10133, 61543, "add"], "2b", "M240 80c0-17.7-14.3-32-32-32s-32 14.3-32 32V224H32c-17.7 0-32 14.3-32 32s14.3 32 32 32H176V432c0 17.7 14.3 32 32 32s32-14.3 32-32V288H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H240V80z"]
    },
    GHe = {
        prefix: "fas",
        iconName: "expand",
        icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64v96c0 17.7 14.3 32 32 32s32-14.3 32-32V96h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H64V352zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V64c0-17.7-14.3-32-32-32H320zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H320c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V352z"]
    },
    VHe = {
        prefix: "fas",
        iconName: "computer",
        icon: [640, 512, [], "e4e5", "M384 96V320H64L64 96H384zM64 32C28.7 32 0 60.7 0 96V320c0 35.3 28.7 64 64 64H181.3l-10.7 32H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H352c17.7 0 32-14.3 32-32s-14.3-32-32-32H277.3l-10.7-32H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zm464 0c-26.5 0-48 21.5-48 48V432c0 26.5 21.5 48 48 48h64c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48H528zm16 64h32c8.8 0 16 7.2 16 16s-7.2 16-16 16H544c-8.8 0-16-7.2-16-16s7.2-16 16-16zm-16 80c0-8.8 7.2-16 16-16h32c8.8 0 16 7.2 16 16s-7.2 16-16 16H544c-8.8 0-16-7.2-16-16zm32 160a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"]
    },
    jHe = {
        prefix: "fas",
        iconName: "xmark",
        icon: [320, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M310.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L160 210.7 54.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L114.7 256 9.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 301.3 265.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L205.3 256 310.6 150.6z"]
    },
    WHe = {
        prefix: "fas",
        iconName: "display",
        icon: [576, 512, [], "e163", "M64 0C28.7 0 0 28.7 0 64V352c0 35.3 28.7 64 64 64H240l-10.7 32H160c-17.7 0-32 14.3-32 32s14.3 32 32 32H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H346.7L336 416H512c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64H64zM512 64V352H64V64H512z"]
    },
    KHe = {
        prefix: "fas",
        iconName: "spinner",
        icon: [512, 512, [], "f110", "M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"]
    },
    qHe = {
        prefix: "fas",
        iconName: "sd-card",
        icon: [384, 512, [], "f7c2", "M320 0H141.3C124.3 0 108 6.7 96 18.7L18.7 96C6.7 108 0 124.3 0 141.3V448c0 35.3 28.7 64 64 64H320c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64zM160 88v48c0 13.3-10.7 24-24 24s-24-10.7-24-24V88c0-13.3 10.7-24 24-24s24 10.7 24 24zm80 0v48c0 13.3-10.7 24-24 24s-24-10.7-24-24V88c0-13.3 10.7-24 24-24s24 10.7 24 24zm80 0v48c0 13.3-10.7 24-24 24s-24-10.7-24-24V88c0-13.3 10.7-24 24-24s24 10.7 24 24z"]
    },
    XHe = {
        prefix: "fas",
        iconName: "book",
        icon: [448, 512, [128212], "f02d", "M96 0C43 0 0 43 0 96V416c0 53 43 96 96 96H384h32c17.7 0 32-14.3 32-32s-14.3-32-32-32V384c17.7 0 32-14.3 32-32V32c0-17.7-14.3-32-32-32H384 96zm0 384H352v64H96c-17.7 0-32-14.3-32-32s14.3-32 32-32zm32-240c0-8.8 7.2-16 16-16H336c8.8 0 16 7.2 16 16s-7.2 16-16 16H144c-8.8 0-16-7.2-16-16zm16 48H336c8.8 0 16 7.2 16 16s-7.2 16-16 16H144c-8.8 0-16-7.2-16-16s7.2-16 16-16z"]
    },
    kve = {
        prefix: "fas",
        iconName: "triangle-exclamation",
        icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"]
    },
    JHe = kve,
    Bve = {
        prefix: "fas",
        iconName: "circle-xmark",
        icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"]
    },
    YHe = Bve,
    QHe = {
        prefix: "fas",
        iconName: "brush",
        icon: [384, 512, [], "f55d", "M192 64L160 0H128L96 64 64 0H48C21.5 0 0 21.5 0 48V256H384V48c0-26.5-21.5-48-48-48H224L192 64zM0 288v32c0 35.3 28.7 64 64 64h64v64c0 35.3 28.7 64 64 64s64-28.7 64-64V384h64c35.3 0 64-28.7 64-64V288H0zM192 432a16 16 0 1 1 0 32 16 16 0 1 1 0-32z"]
    },
    ai = function() {
        return ai = Object.assign || function(e) {
            for (var n, r = 1, i = arguments.length; r < i; r++) {
                n = arguments[r];
                for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
            }
            return e
        }, ai.apply(this, arguments)
    };

function w0(t, e, n) {
    if (n || arguments.length === 2)
        for (var r = 0, i = e.length, s; r < i; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
    return t.concat(s || Array.prototype.slice.call(e))
}

function BK(t) {
    var e = Object.create(null);
    return function(n) {
        return e[n] === void 0 && (e[n] = t(n)), e[n]
    }
}
var Fve = function(e, n, r, i) {
    var s = r ? r.call(i, e, n) : void 0;
    if (s !== void 0) return !!s;
    if (e === n) return !0;
    if (typeof e != "object" || !e || typeof n != "object" || !n) return !1;
    var o = Object.keys(e),
        a = Object.keys(n);
    if (o.length !== a.length) return !1;
    for (var l = Object.prototype.hasOwnProperty.bind(n), u = 0; u < o.length; u++) {
        var c = o[u];
        if (!l(c)) return !1;
        var f = e[c],
            d = n[c];
        if (s = r ? r.call(i, f, d, c) : void 0, s === !1 || s === void 0 && f !== d) return !1
    }
    return !0
};
const Nve = la(Fve);
var ur = "-ms-",
    bv = "-moz-",
    Hn = "-webkit-",
    FK = "comm",
    tA = "rule",
    u4 = "decl",
    zve = "@import",
    NK = "@keyframes",
    Hve = "@layer",
    zK = Math.abs,
    c4 = String.fromCharCode,
    W3 = Object.assign;

function Uve(t, e) {
    return Ai(t, 0) ^ 45 ? (((e << 2 ^ Ai(t, 0)) << 2 ^ Ai(t, 1)) << 2 ^ Ai(t, 2)) << 2 ^ Ai(t, 3) : 0
}

function HK(t) {
    return t.trim()
}

function cu(t, e) {
    return (t = e.exec(t)) ? t[0] : t
}

function hn(t, e, n) {
    return t.replace(e, n)
}

function TS(t, e, n) {
    return t.indexOf(e, n)
}

function Ai(t, e) {
    return t.charCodeAt(e) | 0
}

function Gm(t, e, n) {
    return t.slice(e, n)
}

function pl(t) {
    return t.length
}

function UK(t) {
    return t.length
}

function Yy(t, e) {
    return e.push(t), t
}

function $ve(t, e) {
    return t.map(e).join("")
}

function G8(t, e) {
    return t.filter(function(n) {
        return !cu(n, e)
    })
}
var nA = 1,
    Vm = 1,
    $K = 0,
    ia = 0,
    ii = 0,
    Ag = "";

function rA(t, e, n, r, i, s, o, a) {
    return {
        value: t,
        root: e,
        parent: n,
        type: r,
        props: i,
        children: s,
        line: nA,
        column: Vm,
        length: o,
        return: "",
        siblings: a
    }
}

function xc(t, e) {
    return W3(rA("", null, null, "", null, null, 0, t.siblings), t, {
        length: -t.length
    }, e)
}

function eh(t) {
    for (; t.root;) t = xc(t.root, {
        children: [t]
    });
    Yy(t, t.siblings)
}

function Gve() {
    return ii
}

function Vve() {
    return ii = ia > 0 ? Ai(Ag, --ia) : 0, Vm--, ii === 10 && (Vm = 1, nA--), ii
}

function za() {
    return ii = ia < $K ? Ai(Ag, ia++) : 0, Vm++, ii === 10 && (Vm = 1, nA++), ii
}

function Nd() {
    return Ai(Ag, ia)
}

function PS() {
    return ia
}

function iA(t, e) {
    return Gm(Ag, t, e)
}

function K3(t) {
    switch (t) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1
    }
    return 0
}

function jve(t) {
    return nA = Vm = 1, $K = pl(Ag = t), ia = 0, []
}

function Wve(t) {
    return Ag = "", t
}

function yT(t) {
    return HK(iA(ia - 1, q3(t === 91 ? t + 2 : t === 40 ? t + 1 : t)))
}

function Kve(t) {
    for (;
        (ii = Nd()) && ii < 33;) za();
    return K3(t) > 2 || K3(ii) > 3 ? "" : " "
}

function qve(t, e) {
    for (; --e && za() && !(ii < 48 || ii > 102 || ii > 57 && ii < 65 || ii > 70 && ii < 97););
    return iA(t, PS() + (e < 6 && Nd() == 32 && za() == 32))
}

function q3(t) {
    for (; za();) switch (ii) {
        case t:
            return ia;
        case 34:
        case 39:
            t !== 34 && t !== 39 && q3(ii);
            break;
        case 40:
            t === 41 && q3(t);
            break;
        case 92:
            za();
            break
    }
    return ia
}

function Xve(t, e) {
    for (; za() && t + ii !== 47 + 10;)
        if (t + ii === 42 + 42 && Nd() === 47) break;
    return "/*" + iA(e, ia - 1) + "*" + c4(t === 47 ? t : za())
}

function Jve(t) {
    for (; !K3(Nd());) za();
    return iA(t, ia)
}

function Yve(t) {
    return Wve(IS("", null, null, null, [""], t = jve(t), 0, [0], t))
}

function IS(t, e, n, r, i, s, o, a, l) {
    for (var u = 0, c = 0, f = o, d = 0, p = 0, m = 0, y = 1, v = 1, b = 1, _ = 0, x = "", S = i, E = s, A = r, T = x; v;) switch (m = _, _ = za()) {
        case 40:
            if (m != 108 && Ai(T, f - 1) == 58) {
                TS(T += hn(yT(_), "&", "&\f"), "&\f", zK(u ? a[u - 1] : 0)) != -1 && (b = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            T += yT(_);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            T += Kve(m);
            break;
        case 92:
            T += qve(PS() - 1, 7);
            continue;
        case 47:
            switch (Nd()) {
                case 42:
                case 47:
                    Yy(Qve(Xve(za(), PS()), e, n, l), l);
                    break;
                default:
                    T += "/"
            }
            break;
        case 123 * y:
            a[u++] = pl(T) * b;
        case 125 * y:
        case 59:
        case 0:
            switch (_) {
                case 0:
                case 125:
                    v = 0;
                case 59 + c:
                    b == -1 && (T = hn(T, /\f/g, "")), p > 0 && pl(T) - f && Yy(p > 32 ? j8(T + ";", r, n, f - 1, l) : j8(hn(T, " ", "") + ";", r, n, f - 2, l), l);
                    break;
                case 59:
                    T += ";";
                default:
                    if (Yy(A = V8(T, e, n, u, c, i, a, x, S = [], E = [], f, s), s), _ === 123)
                        if (c === 0) IS(T, e, A, A, S, s, f, a, E);
                        else switch (d === 99 && Ai(T, 3) === 110 ? 100 : d) {
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                                IS(t, A, A, r && Yy(V8(t, A, A, 0, 0, i, a, x, i, S = [], f, E), E), i, E, f, a, r ? S : E);
                                break;
                            default:
                                IS(T, A, A, A, [""], E, 0, a, E)
                        }
            }
            u = c = p = 0, y = b = 1, x = T = "", f = o;
            break;
        case 58:
            f = 1 + pl(T), p = m;
        default:
            if (y < 1) {
                if (_ == 123) --y;
                else if (_ == 125 && y++ == 0 && Vve() == 125) continue
            }
            switch (T += c4(_), _ * y) {
                case 38:
                    b = c > 0 ? 1 : (T += "\f", -1);
                    break;
                case 44:
                    a[u++] = (pl(T) - 1) * b, b = 1;
                    break;
                case 64:
                    Nd() === 45 && (T += yT(za())), d = Nd(), c = f = pl(x = T += Jve(PS())), _++;
                    break;
                case 45:
                    m === 45 && pl(T) == 2 && (y = 0)
            }
    }
    return s
}

function V8(t, e, n, r, i, s, o, a, l, u, c, f) {
    for (var d = i - 1, p = i === 0 ? s : [""], m = UK(p), y = 0, v = 0, b = 0; y < r; ++y)
        for (var _ = 0, x = Gm(t, d + 1, d = zK(v = o[y])), S = t; _ < m; ++_)(S = HK(v > 0 ? p[_] + " " + x : hn(x, /&\f/g, p[_]))) && (l[b++] = S);
    return rA(t, e, n, i === 0 ? tA : a, l, u, c, f)
}

function Qve(t, e, n, r) {
    return rA(t, e, n, FK, c4(Gve()), Gm(t, 2, -2), 0, r)
}

function j8(t, e, n, r, i) {
    return rA(t, e, n, u4, Gm(t, 0, r), Gm(t, r + 1, -1), r, i)
}

function GK(t, e, n) {
    switch (Uve(t, e)) {
        case 5103:
            return Hn + "print-" + t + t;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return Hn + t + t;
        case 4789:
            return bv + t + t;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return Hn + t + bv + t + ur + t + t;
        case 5936:
            switch (Ai(t, e + 11)) {
                case 114:
                    return Hn + t + ur + hn(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
                case 108:
                    return Hn + t + ur + hn(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
                case 45:
                    return Hn + t + ur + hn(t, /[svh]\w+-[tblr]{2}/, "lr") + t
            }
        case 6828:
        case 4268:
        case 2903:
            return Hn + t + ur + t + t;
        case 6165:
            return Hn + t + ur + "flex-" + t + t;
        case 5187:
            return Hn + t + hn(t, /(\w+).+(:[^]+)/, Hn + "box-$1$2" + ur + "flex-$1$2") + t;
        case 5443:
            return Hn + t + ur + "flex-item-" + hn(t, /flex-|-self/g, "") + (cu(t, /flex-|baseline/) ? "" : ur + "grid-row-" + hn(t, /flex-|-self/g, "")) + t;
        case 4675:
            return Hn + t + ur + "flex-line-pack" + hn(t, /align-content|flex-|-self/g, "") + t;
        case 5548:
            return Hn + t + ur + hn(t, "shrink", "negative") + t;
        case 5292:
            return Hn + t + ur + hn(t, "basis", "preferred-size") + t;
        case 6060:
            return Hn + "box-" + hn(t, "-grow", "") + Hn + t + ur + hn(t, "grow", "positive") + t;
        case 4554:
            return Hn + hn(t, /([^-])(transform)/g, "$1" + Hn + "$2") + t;
        case 6187:
            return hn(hn(hn(t, /(zoom-|grab)/, Hn + "$1"), /(image-set)/, Hn + "$1"), t, "") + t;
        case 5495:
        case 3959:
            return hn(t, /(image-set\([^]*)/, Hn + "$1$`$1");
        case 4968:
            return hn(hn(t, /(.+:)(flex-)?(.*)/, Hn + "box-pack:$3" + ur + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Hn + t + t;
        case 4200:
            if (!cu(t, /flex-|baseline/)) return ur + "grid-column-align" + Gm(t, e) + t;
            break;
        case 2592:
        case 3360:
            return ur + hn(t, "template-", "") + t;
        case 4384:
        case 3616:
            return n && n.some(function(r, i) {
                return e = i, cu(r.props, /grid-\w+-end/)
            }) ? ~TS(t + (n = n[e].value), "span", 0) ? t : ur + hn(t, "-start", "") + t + ur + "grid-row-span:" + (~TS(n, "span", 0) ? cu(n, /\d+/) : +cu(n, /\d+/) - +cu(t, /\d+/)) + ";" : ur + hn(t, "-start", "") + t;
        case 4896:
        case 4128:
            return n && n.some(function(r) {
                return cu(r.props, /grid-\w+-start/)
            }) ? t : ur + hn(hn(t, "-end", "-span"), "span ", "") + t;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return hn(t, /(.+)-inline(.+)/, Hn + "$1$2") + t;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (pl(t) - 1 - e > 6) switch (Ai(t, e + 1)) {
                case 109:
                    if (Ai(t, e + 4) !== 45) break;
                case 102:
                    return hn(t, /(.+:)(.+)-([^]+)/, "$1" + Hn + "$2-$3$1" + bv + (Ai(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
                case 115:
                    return ~TS(t, "stretch", 0) ? GK(hn(t, "stretch", "fill-available"), e, n) + t : t
            }
            break;
        case 5152:
        case 5920:
            return hn(t, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(r, i, s, o, a, l, u) {
                return ur + i + ":" + s + u + (o ? ur + i + "-span:" + (a ? l : +l - +s) + u : "") + t
            });
        case 4949:
            if (Ai(t, e + 6) === 121) return hn(t, ":", ":" + Hn) + t;
            break;
        case 6444:
            switch (Ai(t, Ai(t, 14) === 45 ? 18 : 11)) {
                case 120:
                    return hn(t, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + Hn + (Ai(t, 14) === 45 ? "inline-" : "") + "box$3$1" + Hn + "$2$3$1" + ur + "$2box$3") + t;
                case 100:
                    return hn(t, ":", ":" + ur) + t
            }
            break;
        case 5719:
        case 2647:
        case 2135:
        case 3927:
        case 2391:
            return hn(t, "scroll-", "scroll-snap-") + t
    }
    return t
}

function Uw(t, e) {
    for (var n = "", r = 0; r < t.length; r++) n += e(t[r], r, t, e) || "";
    return n
}

function Zve(t, e, n, r) {
    switch (t.type) {
        case Hve:
            if (t.children.length) break;
        case zve:
        case u4:
            return t.return = t.return || t.value;
        case FK:
            return "";
        case NK:
            return t.return = t.value + "{" + Uw(t.children, r) + "}";
        case tA:
            if (!pl(t.value = t.props.join(","))) return ""
    }
    return pl(n = Uw(t.children, r)) ? t.return = t.value + "{" + n + "}" : ""
}

function e0e(t) {
    var e = UK(t);
    return function(n, r, i, s) {
        for (var o = "", a = 0; a < e; a++) o += t[a](n, r, i, s) || "";
        return o
    }
}

function t0e(t) {
    return function(e) {
        e.root || (e = e.return) && t(e)
    }
}

function n0e(t, e, n, r) {
    if (t.length > -1 && !t.return) switch (t.type) {
        case u4:
            t.return = GK(t.value, t.length, n);
            return;
        case NK:
            return Uw([xc(t, {
                value: hn(t.value, "@", "@" + Hn)
            })], r);
        case tA:
            if (t.length) return $ve(n = t.props, function(i) {
                switch (cu(i, r = /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        eh(xc(t, {
                            props: [hn(i, /:(read-\w+)/, ":" + bv + "$1")]
                        })), eh(xc(t, {
                            props: [i]
                        })), W3(t, {
                            props: G8(n, r)
                        });
                        break;
                    case "::placeholder":
                        eh(xc(t, {
                            props: [hn(i, /:(plac\w+)/, ":" + Hn + "input-$1")]
                        })), eh(xc(t, {
                            props: [hn(i, /:(plac\w+)/, ":" + bv + "$1")]
                        })), eh(xc(t, {
                            props: [hn(i, /:(plac\w+)/, ur + "input-$1")]
                        })), eh(xc(t, {
                            props: [i]
                        })), W3(t, {
                            props: G8(n, r)
                        });
                        break
                }
                return ""
            })
    }
}
var r0e = {
        animationIterationCount: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    },
    jm = typeof process < "u" && process.env !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled",
    VK = "active",
    jK = "data-styled-version",
    sA = "6.1.8",
    f4 = `/*!sc*/
`,
    d4 = typeof window < "u" && "HTMLElement" in window,
    i0e = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" && {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY),
    s0e = {},
    oA = Object.freeze([]),
    Wm = Object.freeze({});

function WK(t, e, n) {
    return n === void 0 && (n = Wm), t.theme !== n.theme && t.theme || e || n.theme
}
var KK = new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]),
    o0e = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
    a0e = /(^-|-$)/g;

function W8(t) {
    return t.replace(o0e, "-").replace(a0e, "")
}
var l0e = /(a)(d)/gi,
    a_ = 52,
    K8 = function(t) {
        return String.fromCharCode(t + (t > 25 ? 39 : 97))
    };

function X3(t) {
    var e, n = "";
    for (e = Math.abs(t); e > a_; e = e / a_ | 0) n = K8(e % a_) + n;
    return (K8(e % a_) + n).replace(l0e, "$1-$2")
}
var vT, qK = 5381,
    jh = function(t, e) {
        for (var n = e.length; n;) t = 33 * t ^ e.charCodeAt(--n);
        return t
    },
    XK = function(t) {
        return jh(qK, t)
    };

function JK(t) {
    return X3(XK(t) >>> 0)
}

function u0e(t) {
    return t.displayName || t.name || "Component"
}

function bT(t) {
    return typeof t == "string" && !0
}
var YK = typeof Symbol == "function" && Symbol.for,
    QK = YK ? Symbol.for("react.memo") : 60115,
    c0e = YK ? Symbol.for("react.forward_ref") : 60112,
    f0e = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
    },
    d0e = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
    },
    ZK = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    },
    p0e = ((vT = {})[c0e] = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    }, vT[QK] = ZK, vT);

function q8(t) {
    return ("type" in (e = t) && e.type.$$typeof) === QK ? ZK : "$$typeof" in t ? p0e[t.$$typeof] : f0e;
    var e
}
var h0e = Object.defineProperty,
    m0e = Object.getOwnPropertyNames,
    X8 = Object.getOwnPropertySymbols,
    g0e = Object.getOwnPropertyDescriptor,
    y0e = Object.getPrototypeOf,
    J8 = Object.prototype;

function eq(t, e, n) {
    if (typeof e != "string") {
        if (J8) {
            var r = y0e(e);
            r && r !== J8 && eq(t, r, n)
        }
        var i = m0e(e);
        X8 && (i = i.concat(X8(e)));
        for (var s = q8(t), o = q8(e), a = 0; a < i.length; ++a) {
            var l = i[a];
            if (!(l in d0e || n && n[l] || o && l in o || s && l in s)) {
                var u = g0e(e, l);
                try {
                    h0e(t, l, u)
                } catch {}
            }
        }
    }
    return t
}

function op(t) {
    return typeof t == "function"
}

function p4(t) {
    return typeof t == "object" && "styledComponentId" in t
}

function Ed(t, e) {
    return t && e ? "".concat(t, " ").concat(e) : t || e || ""
}

function J3(t, e) {
    if (t.length === 0) return "";
    for (var n = t[0], r = 1; r < t.length; r++) n += e ? e + t[r] : t[r];
    return n
}

function E0(t) {
    return t !== null && typeof t == "object" && t.constructor.name === Object.name && !("props" in t && t.$$typeof)
}

function Y3(t, e, n) {
    if (n === void 0 && (n = !1), !n && !E0(t) && !Array.isArray(t)) return e;
    if (Array.isArray(e))
        for (var r = 0; r < e.length; r++) t[r] = Y3(t[r], e[r]);
    else if (E0(e))
        for (var r in e) t[r] = Y3(t[r], e[r]);
    return t
}

function h4(t, e) {
    Object.defineProperty(t, "toString", {
        value: e
    })
}

function ap(t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
    return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(e.length > 0 ? " Args: ".concat(e.join(", ")) : ""))
}
var v0e = function() {
        function t(e) {
            this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e
        }
        return t.prototype.indexOfGroup = function(e) {
            for (var n = 0, r = 0; r < e; r++) n += this.groupSizes[r];
            return n
        }, t.prototype.insertRules = function(e, n) {
            if (e >= this.groupSizes.length) {
                for (var r = this.groupSizes, i = r.length, s = i; e >= s;)
                    if ((s <<= 1) < 0) throw ap(16, "".concat(e));
                this.groupSizes = new Uint32Array(s), this.groupSizes.set(r), this.length = s;
                for (var o = i; o < s; o++) this.groupSizes[o] = 0
            }
            for (var a = this.indexOfGroup(e + 1), l = (o = 0, n.length); o < l; o++) this.tag.insertRule(a, n[o]) && (this.groupSizes[e]++, a++)
        }, t.prototype.clearGroup = function(e) {
            if (e < this.length) {
                var n = this.groupSizes[e],
                    r = this.indexOfGroup(e),
                    i = r + n;
                this.groupSizes[e] = 0;
                for (var s = r; s < i; s++) this.tag.deleteRule(r)
            }
        }, t.prototype.getGroup = function(e) {
            var n = "";
            if (e >= this.length || this.groupSizes[e] === 0) return n;
            for (var r = this.groupSizes[e], i = this.indexOfGroup(e), s = i + r, o = i; o < s; o++) n += "".concat(this.tag.getRule(o)).concat(f4);
            return n
        }, t
    }(),
    RS = new Map,
    $w = new Map,
    OS = 1,
    l_ = function(t) {
        if (RS.has(t)) return RS.get(t);
        for (; $w.has(OS);) OS++;
        var e = OS++;
        return RS.set(t, e), $w.set(e, t), e
    },
    b0e = function(t, e) {
        OS = e + 1, RS.set(t, e), $w.set(e, t)
    },
    x0e = "style[".concat(jm, "][").concat(jK, '="').concat(sA, '"]'),
    _0e = new RegExp("^".concat(jm, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),
    S0e = function(t, e, n) {
        for (var r, i = n.split(","), s = 0, o = i.length; s < o; s++)(r = i[s]) && t.registerName(e, r)
    },
    w0e = function(t, e) {
        for (var n, r = ((n = e.textContent) !== null && n !== void 0 ? n : "").split(f4), i = [], s = 0, o = r.length; s < o; s++) {
            var a = r[s].trim();
            if (a) {
                var l = a.match(_0e);
                if (l) {
                    var u = 0 | parseInt(l[1], 10),
                        c = l[2];
                    u !== 0 && (b0e(c, u), S0e(t, c, l[3]), t.getTag().insertRules(u, i)), i.length = 0
                } else i.push(a)
            }
        }
    };

function E0e() {
    return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null
}
var tq = function(t) {
        var e = document.head,
            n = t || e,
            r = document.createElement("style"),
            i = function(a) {
                var l = Array.from(a.querySelectorAll("style[".concat(jm, "]")));
                return l[l.length - 1]
            }(n),
            s = i !== void 0 ? i.nextSibling : null;
        r.setAttribute(jm, VK), r.setAttribute(jK, sA);
        var o = E0e();
        return o && r.setAttribute("nonce", o), n.insertBefore(r, s), r
    },
    A0e = function() {
        function t(e) {
            this.element = tq(e), this.element.appendChild(document.createTextNode("")), this.sheet = function(n) {
                if (n.sheet) return n.sheet;
                for (var r = document.styleSheets, i = 0, s = r.length; i < s; i++) {
                    var o = r[i];
                    if (o.ownerNode === n) return o
                }
                throw ap(17)
            }(this.element), this.length = 0
        }
        return t.prototype.insertRule = function(e, n) {
            try {
                return this.sheet.insertRule(n, e), this.length++, !0
            } catch {
                return !1
            }
        }, t.prototype.deleteRule = function(e) {
            this.sheet.deleteRule(e), this.length--
        }, t.prototype.getRule = function(e) {
            var n = this.sheet.cssRules[e];
            return n && n.cssText ? n.cssText : ""
        }, t
    }(),
    C0e = function() {
        function t(e) {
            this.element = tq(e), this.nodes = this.element.childNodes, this.length = 0
        }
        return t.prototype.insertRule = function(e, n) {
            if (e <= this.length && e >= 0) {
                var r = document.createTextNode(n);
                return this.element.insertBefore(r, this.nodes[e] || null), this.length++, !0
            }
            return !1
        }, t.prototype.deleteRule = function(e) {
            this.element.removeChild(this.nodes[e]), this.length--
        }, t.prototype.getRule = function(e) {
            return e < this.length ? this.nodes[e].textContent : ""
        }, t
    }(),
    M0e = function() {
        function t(e) {
            this.rules = [], this.length = 0
        }
        return t.prototype.insertRule = function(e, n) {
            return e <= this.length && (this.rules.splice(e, 0, n), this.length++, !0)
        }, t.prototype.deleteRule = function(e) {
            this.rules.splice(e, 1), this.length--
        }, t.prototype.getRule = function(e) {
            return e < this.length ? this.rules[e] : ""
        }, t
    }(),
    Y8 = d4,
    T0e = {
        isServer: !d4,
        useCSSOMInjection: !i0e
    },
    Gw = function() {
        function t(e, n, r) {
            e === void 0 && (e = Wm), n === void 0 && (n = {});
            var i = this;
            this.options = ai(ai({}, T0e), e), this.gs = n, this.names = new Map(r), this.server = !!e.isServer, !this.server && d4 && Y8 && (Y8 = !1, function(s) {
                for (var o = document.querySelectorAll(x0e), a = 0, l = o.length; a < l; a++) {
                    var u = o[a];
                    u && u.getAttribute(jm) !== VK && (w0e(s, u), u.parentNode && u.parentNode.removeChild(u))
                }
            }(this)), h4(this, function() {
                return function(s) {
                    for (var o = s.getTag(), a = o.length, l = "", u = function(f) {
                            var d = function(b) {
                                return $w.get(b)
                            }(f);
                            if (d === void 0) return "continue";
                            var p = s.names.get(d),
                                m = o.getGroup(f);
                            if (p === void 0 || m.length === 0) return "continue";
                            var y = "".concat(jm, ".g").concat(f, '[id="').concat(d, '"]'),
                                v = "";
                            p !== void 0 && p.forEach(function(b) {
                                b.length > 0 && (v += "".concat(b, ","))
                            }), l += "".concat(m).concat(y, '{content:"').concat(v, '"}').concat(f4)
                        }, c = 0; c < a; c++) u(c);
                    return l
                }(i)
            })
        }
        return t.registerId = function(e) {
            return l_(e)
        }, t.prototype.reconstructWithOptions = function(e, n) {
            return n === void 0 && (n = !0), new t(ai(ai({}, this.options), e), this.gs, n && this.names || void 0)
        }, t.prototype.allocateGSInstance = function(e) {
            return this.gs[e] = (this.gs[e] || 0) + 1
        }, t.prototype.getTag = function() {
            return this.tag || (this.tag = (e = function(n) {
                var r = n.useCSSOMInjection,
                    i = n.target;
                return n.isServer ? new M0e(i) : r ? new A0e(i) : new C0e(i)
            }(this.options), new v0e(e)));
            var e
        }, t.prototype.hasNameForId = function(e, n) {
            return this.names.has(e) && this.names.get(e).has(n)
        }, t.prototype.registerName = function(e, n) {
            if (l_(e), this.names.has(e)) this.names.get(e).add(n);
            else {
                var r = new Set;
                r.add(n), this.names.set(e, r)
            }
        }, t.prototype.insertRules = function(e, n, r) {
            this.registerName(e, n), this.getTag().insertRules(l_(e), r)
        }, t.prototype.clearNames = function(e) {
            this.names.has(e) && this.names.get(e).clear()
        }, t.prototype.clearRules = function(e) {
            this.getTag().clearGroup(l_(e)), this.clearNames(e)
        }, t.prototype.clearTag = function() {
            this.tag = void 0
        }, t
    }(),
    P0e = /&/g,
    I0e = /^\s*\/\/.*$/gm;

function nq(t, e) {
    return t.map(function(n) {
        return n.type === "rule" && (n.value = "".concat(e, " ").concat(n.value), n.value = n.value.replaceAll(",", ",".concat(e, " ")), n.props = n.props.map(function(r) {
            return "".concat(e, " ").concat(r)
        })), Array.isArray(n.children) && n.type !== "@keyframes" && (n.children = nq(n.children, e)), n
    })
}

function rq(t) {
    var e, n, r, i = t === void 0 ? Wm : t,
        s = i.options,
        o = s === void 0 ? Wm : s,
        a = i.plugins,
        l = a === void 0 ? oA : a,
        u = function(d, p, m) {
            return m.startsWith(n) && m.endsWith(n) && m.replaceAll(n, "").length > 0 ? ".".concat(e) : d
        },
        c = l.slice();
    c.push(function(d) {
        d.type === tA && d.value.includes("&") && (d.props[0] = d.props[0].replace(P0e, n).replace(r, u))
    }), o.prefix && c.push(n0e), c.push(Zve);
    var f = function(d, p, m, y) {
        p === void 0 && (p = ""), m === void 0 && (m = ""), y === void 0 && (y = "&"), e = y, n = p, r = new RegExp("\\".concat(n, "\\b"), "g");
        var v = d.replace(I0e, ""),
            b = Yve(m || p ? "".concat(m, " ").concat(p, " { ").concat(v, " }") : v);
        o.namespace && (b = nq(b, o.namespace));
        var _ = [];
        return Uw(b, e0e(c.concat(t0e(function(x) {
            return _.push(x)
        })))), _
    };
    return f.hash = l.length ? l.reduce(function(d, p) {
        return p.name || ap(15), jh(d, p.name)
    }, qK).toString() : "", f
}
var R0e = new Gw,
    Q3 = rq(),
    m4 = Bt.createContext({
        shouldForwardProp: void 0,
        styleSheet: R0e,
        stylis: Q3
    });
m4.Consumer;
var O0e = Bt.createContext(void 0);

function Vw() {
    return P.useContext(m4)
}

function ZHe(t) {
    var e = P.useState(t.stylisPlugins),
        n = e[0],
        r = e[1],
        i = Vw().styleSheet,
        s = P.useMemo(function() {
            var l = i;
            return t.sheet ? l = t.sheet : t.target && (l = l.reconstructWithOptions({
                target: t.target
            }, !1)), t.disableCSSOMInjection && (l = l.reconstructWithOptions({
                useCSSOMInjection: !1
            })), l
        }, [t.disableCSSOMInjection, t.sheet, t.target, i]),
        o = P.useMemo(function() {
            return rq({
                options: {
                    namespace: t.namespace,
                    prefix: t.enableVendorPrefixes
                },
                plugins: n
            })
        }, [t.enableVendorPrefixes, t.namespace, n]);
    P.useEffect(function() {
        Nve(n, t.stylisPlugins) || r(t.stylisPlugins)
    }, [t.stylisPlugins]);
    var a = P.useMemo(function() {
        return {
            shouldForwardProp: t.shouldForwardProp,
            styleSheet: s,
            stylis: o
        }
    }, [t.shouldForwardProp, s, o]);
    return Bt.createElement(m4.Provider, {
        value: a
    }, Bt.createElement(O0e.Provider, {
        value: o
    }, t.children))
}
var D0e = function() {
        function t(e, n) {
            var r = this;
            this.inject = function(i, s) {
                s === void 0 && (s = Q3);
                var o = r.name + s.hash;
                i.hasNameForId(r.id, o) || i.insertRules(r.id, o, s(r.rules, o, "@keyframes"))
            }, this.name = e, this.id = "sc-keyframes-".concat(e), this.rules = n, h4(this, function() {
                throw ap(12, String(r.name))
            })
        }
        return t.prototype.getName = function(e) {
            return e === void 0 && (e = Q3), this.name + e.hash
        }, t
    }(),
    L0e = function(t) {
        return t >= "A" && t <= "Z"
    };

function Q8(t) {
    for (var e = "", n = 0; n < t.length; n++) {
        var r = t[n];
        if (n === 1 && r === "-" && t[0] === "-") return t;
        L0e(r) ? e += "-" + r.toLowerCase() : e += r
    }
    return e.startsWith("ms-") ? "-" + e : e
}
var iq = function(t) {
        return t == null || t === !1 || t === ""
    },
    sq = function(t) {
        var e, n, r = [];
        for (var i in t) {
            var s = t[i];
            t.hasOwnProperty(i) && !iq(s) && (Array.isArray(s) && s.isCss || op(s) ? r.push("".concat(Q8(i), ":"), s, ";") : E0(s) ? r.push.apply(r, w0(w0(["".concat(i, " {")], sq(s), !1), ["}"], !1)) : r.push("".concat(Q8(i), ": ").concat((e = i, (n = s) == null || typeof n == "boolean" || n === "" ? "" : typeof n != "number" || n === 0 || e in r0e || e.startsWith("--") ? String(n).trim() : "".concat(n, "px")), ";")))
        }
        return r
    };

function Zc(t, e, n, r) {
    if (iq(t)) return [];
    if (p4(t)) return [".".concat(t.styledComponentId)];
    if (op(t)) {
        if (!op(s = t) || s.prototype && s.prototype.isReactComponent || !e) return [t];
        var i = t(e);
        return Zc(i, e, n, r)
    }
    var s;
    return t instanceof D0e ? n ? (t.inject(n, r), [t.getName(r)]) : [t] : E0(t) ? sq(t) : Array.isArray(t) ? Array.prototype.concat.apply(oA, t.map(function(o) {
        return Zc(o, e, n, r)
    })) : [t.toString()]
}

function oq(t) {
    for (var e = 0; e < t.length; e += 1) {
        var n = t[e];
        if (op(n) && !p4(n)) return !1
    }
    return !0
}
var k0e = XK(sA),
    B0e = function() {
        function t(e, n, r) {
            this.rules = e, this.staticRulesId = "", this.isStatic = (r === void 0 || r.isStatic) && oq(e), this.componentId = n, this.baseHash = jh(k0e, n), this.baseStyle = r, Gw.registerId(n)
        }
        return t.prototype.generateAndInjectStyles = function(e, n, r) {
            var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, n, r) : "";
            if (this.isStatic && !r.hash)
                if (this.staticRulesId && n.hasNameForId(this.componentId, this.staticRulesId)) i = Ed(i, this.staticRulesId);
                else {
                    var s = J3(Zc(this.rules, e, n, r)),
                        o = X3(jh(this.baseHash, s) >>> 0);
                    if (!n.hasNameForId(this.componentId, o)) {
                        var a = r(s, ".".concat(o), void 0, this.componentId);
                        n.insertRules(this.componentId, o, a)
                    }
                    i = Ed(i, o), this.staticRulesId = o
                }
            else {
                for (var l = jh(this.baseHash, r.hash), u = "", c = 0; c < this.rules.length; c++) {
                    var f = this.rules[c];
                    if (typeof f == "string") u += f;
                    else if (f) {
                        var d = J3(Zc(f, e, n, r));
                        l = jh(l, d + c), u += d
                    }
                }
                if (u) {
                    var p = X3(l >>> 0);
                    n.hasNameForId(this.componentId, p) || n.insertRules(this.componentId, p, r(u, ".".concat(p), void 0, this.componentId)), i = Ed(i, p)
                }
            }
            return i
        }, t
    }(),
    A0 = Bt.createContext(void 0);
A0.Consumer;

function eUe(t) {
    var e = Bt.useContext(A0),
        n = P.useMemo(function() {
            return function(r, i) {
                if (!r) throw ap(14);
                if (op(r)) {
                    var s = r(i);
                    return s
                }
                if (Array.isArray(r) || typeof r != "object") throw ap(8);
                return i ? ai(ai({}, i), r) : r
            }(t.theme, e)
        }, [t.theme, e]);
    return t.children ? Bt.createElement(A0.Provider, {
        value: n
    }, t.children) : null
}
var xT = {};

function F0e(t, e, n) {
    var r = p4(t),
        i = t,
        s = !bT(t),
        o = e.attrs,
        a = o === void 0 ? oA : o,
        l = e.componentId,
        u = l === void 0 ? function(S, E) {
            var A = typeof S != "string" ? "sc" : W8(S);
            xT[A] = (xT[A] || 0) + 1;
            var T = "".concat(A, "-").concat(JK(sA + A + xT[A]));
            return E ? "".concat(E, "-").concat(T) : T
        }(e.displayName, e.parentComponentId) : l,
        c = e.displayName,
        f = c === void 0 ? function(S) {
            return bT(S) ? "styled.".concat(S) : "Styled(".concat(u0e(S), ")")
        }(t) : c,
        d = e.displayName && e.componentId ? "".concat(W8(e.displayName), "-").concat(e.componentId) : e.componentId || u,
        p = r && i.attrs ? i.attrs.concat(a).filter(Boolean) : a,
        m = e.shouldForwardProp;
    if (r && i.shouldForwardProp) {
        var y = i.shouldForwardProp;
        if (e.shouldForwardProp) {
            var v = e.shouldForwardProp;
            m = function(S, E) {
                return y(S, E) && v(S, E)
            }
        } else m = y
    }
    var b = new B0e(n, d, r ? i.componentStyle : void 0);

    function _(S, E) {
        return function(A, T, M) {
            var I = A.attrs,
                O = A.componentStyle,
                k = A.defaultProps,
                H = A.foldedComponentIds,
                N = A.styledComponentId,
                B = A.target,
                U = Bt.useContext(A0),
                q = Vw(),
                Q = A.shouldForwardProp || q.shouldForwardProp,
                F = WK(T, U, k) || Wm,
                G = function(re, _e, fe) {
                    for (var ue, ve = ai(ai({}, _e), {
                            className: void 0,
                            theme: fe
                        }), xe = 0; xe < re.length; xe += 1) {
                        var be = op(ue = re[xe]) ? ue(ve) : ue;
                        for (var he in be) ve[he] = he === "className" ? Ed(ve[he], be[he]) : he === "style" ? ai(ai({}, ve[he]), be[he]) : be[he]
                    }
                    return _e.className && (ve.className = Ed(ve.className, _e.className)), ve
                }(I, T, F),
                W = G.as || B,
                se = {};
            for (var ee in G) G[ee] === void 0 || ee[0] === "$" || ee === "as" || ee === "theme" && G.theme === F || (ee === "forwardedAs" ? se.as = G.forwardedAs : Q && !Q(ee, W) || (se[ee] = G[ee]));
            var ae = function(re, _e) {
                    var fe = Vw(),
                        ue = re.generateAndInjectStyles(_e, fe.styleSheet, fe.stylis);
                    return ue
                }(O, G),
                de = Ed(H, N);
            return ae && (de += " " + ae), G.className && (de += " " + G.className), se[bT(W) && !KK.has(W) ? "class" : "className"] = de, se.ref = M, P.createElement(W, se)
        }(x, S, E)
    }
    _.displayName = f;
    var x = Bt.forwardRef(_);
    return x.attrs = p, x.componentStyle = b, x.displayName = f, x.shouldForwardProp = m, x.foldedComponentIds = r ? Ed(i.foldedComponentIds, i.styledComponentId) : "", x.styledComponentId = d, x.target = r ? i.target : t, Object.defineProperty(x, "defaultProps", {
        get: function() {
            return this._foldedDefaultProps
        },
        set: function(S) {
            this._foldedDefaultProps = r ? function(E) {
                for (var A = [], T = 1; T < arguments.length; T++) A[T - 1] = arguments[T];
                for (var M = 0, I = A; M < I.length; M++) Y3(E, I[M], !0);
                return E
            }({}, i.defaultProps, S) : S
        }
    }), h4(x, function() {
        return ".".concat(x.styledComponentId)
    }), s && eq(x, t, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0
    }), x
}

function Z8(t, e) {
    for (var n = [t[0]], r = 0, i = e.length; r < i; r += 1) n.push(e[r], t[r + 1]);
    return n
}
var e9 = function(t) {
    return Object.assign(t, {
        isCss: !0
    })
};

function aq(t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
    if (op(t) || E0(t)) return e9(Zc(Z8(oA, w0([t], e, !0))));
    var r = t;
    return e.length === 0 && r.length === 1 && typeof r[0] == "string" ? Zc(r) : e9(Zc(Z8(r, e)))
}

function Z3(t, e, n) {
    if (n === void 0 && (n = Wm), !e) throw ap(1, e);
    var r = function(i) {
        for (var s = [], o = 1; o < arguments.length; o++) s[o - 1] = arguments[o];
        return t(e, n, aq.apply(void 0, w0([i], s, !1)))
    };
    return r.attrs = function(i) {
        return Z3(t, e, ai(ai({}, n), {
            attrs: Array.prototype.concat(n.attrs, i).filter(Boolean)
        }))
    }, r.withConfig = function(i) {
        return Z3(t, e, ai(ai({}, n), i))
    }, r
}
var lq = function(t) {
        return Z3(F0e, t)
    },
    N0e = lq;
KK.forEach(function(t) {
    N0e[t] = lq(t)
});
var z0e = function() {
    function t(e, n) {
        this.rules = e, this.componentId = n, this.isStatic = oq(e), Gw.registerId(this.componentId + 1)
    }
    return t.prototype.createStyles = function(e, n, r, i) {
        var s = i(J3(Zc(this.rules, n, r, i)), ""),
            o = this.componentId + e;
        r.insertRules(o, o, s)
    }, t.prototype.removeStyles = function(e, n) {
        n.clearRules(this.componentId + e)
    }, t.prototype.renderStyles = function(e, n, r, i) {
        e > 2 && Gw.registerId(this.componentId + e), this.removeStyles(e, r), this.createStyles(e, n, r, i)
    }, t
}();

function tUe(t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
    var r = aq.apply(void 0, w0([t], e, !1)),
        i = "sc-global-".concat(JK(JSON.stringify(r))),
        s = new z0e(r, i),
        o = function(l) {
            var u = Vw(),
                c = Bt.useContext(A0),
                f = Bt.useRef(u.styleSheet.allocateGSInstance(i)).current;
            return u.styleSheet.server && a(f, l, u.styleSheet, c, u.stylis), Bt.useLayoutEffect(function() {
                if (!u.styleSheet.server) return a(f, l, u.styleSheet, c, u.stylis),
                    function() {
                        return s.removeStyles(f, u.styleSheet)
                    }
            }, [f, l, u.styleSheet, c, u.stylis]), null
        };

    function a(l, u, c, f, d) {
        if (s.isStatic) s.renderStyles(l, s0e, c, d);
        else {
            var p = ai(ai({}, u), {
                theme: WK(u, f, o.defaultProps)
            });
            s.renderStyles(l, p, c, d)
        }
    }
    return Bt.memo(o)
}

function jw(t) {
    if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}

function Ww(t, e) {
    return Ww = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, Ww(t, e)
}

function uq(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ww(t, e)
}
var or = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aA = 60103,
    lA = 60106,
    R1 = 60107,
    O1 = 60108,
    D1 = 60114,
    L1 = 60109,
    k1 = 60110,
    B1 = 60112,
    F1 = 60113,
    g4 = 60120,
    N1 = 60115,
    z1 = 60116,
    cq = 60121,
    fq = 60122,
    dq = 60117,
    pq = 60129,
    hq = 60131;
if (typeof Symbol == "function" && Symbol.for) {
    var Di = Symbol.for;
    aA = Di("react.element"), lA = Di("react.portal"), R1 = Di("react.fragment"), O1 = Di("react.strict_mode"), D1 = Di("react.profiler"), L1 = Di("react.provider"), k1 = Di("react.context"), B1 = Di("react.forward_ref"), F1 = Di("react.suspense"), g4 = Di("react.suspense_list"), N1 = Di("react.memo"), z1 = Di("react.lazy"), cq = Di("react.block"), fq = Di("react.server.block"), dq = Di("react.fundamental"), pq = Di("react.debug_trace_mode"), hq = Di("react.legacy_hidden")
}

function Za(t) {
    if (typeof t == "object" && t !== null) {
        var e = t.$$typeof;
        switch (e) {
            case aA:
                switch (t = t.type, t) {
                    case R1:
                    case D1:
                    case O1:
                    case F1:
                    case g4:
                        return t;
                    default:
                        switch (t = t && t.$$typeof, t) {
                            case k1:
                            case B1:
                            case z1:
                            case N1:
                            case L1:
                                return t;
                            default:
                                return e
                        }
                }
            case lA:
                return e
        }
    }
}
var H0e = L1,
    U0e = aA,
    $0e = B1,
    G0e = R1,
    V0e = z1,
    j0e = N1,
    W0e = lA,
    K0e = D1,
    q0e = O1,
    X0e = F1;
or.ContextConsumer = k1;
or.ContextProvider = H0e;
or.Element = U0e;
or.ForwardRef = $0e;
or.Fragment = G0e;
or.Lazy = V0e;
or.Memo = j0e;
or.Portal = W0e;
or.Profiler = K0e;
or.StrictMode = q0e;
or.Suspense = X0e;
or.isAsyncMode = function() {
    return !1
};
or.isConcurrentMode = function() {
    return !1
};
or.isContextConsumer = function(t) {
    return Za(t) === k1
};
or.isContextProvider = function(t) {
    return Za(t) === L1
};
or.isElement = function(t) {
    return typeof t == "object" && t !== null && t.$$typeof === aA
};
or.isForwardRef = function(t) {
    return Za(t) === B1
};
or.isFragment = function(t) {
    return Za(t) === R1
};
or.isLazy = function(t) {
    return Za(t) === z1
};
or.isMemo = function(t) {
    return Za(t) === N1
};
or.isPortal = function(t) {
    return Za(t) === lA
};
or.isProfiler = function(t) {
    return Za(t) === D1
};
or.isStrictMode = function(t) {
    return Za(t) === O1
};
or.isSuspense = function(t) {
    return Za(t) === F1
};
or.isValidElementType = function(t) {
    return typeof t == "string" || typeof t == "function" || t === R1 || t === D1 || t === pq || t === O1 || t === F1 || t === g4 || t === hq || typeof t == "object" && t !== null && (t.$$typeof === z1 || t.$$typeof === N1 || t.$$typeof === L1 || t.$$typeof === k1 || t.$$typeof === B1 || t.$$typeof === dq || t.$$typeof === cq || t[0] === fq)
};
or.typeOf = Za;
let t9 = t => typeof t == "object" && t != null && t.nodeType === 1,
    n9 = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip",
    _T = (t, e) => {
        if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
            let n = getComputedStyle(t, null);
            return n9(n.overflowY, e) || n9(n.overflowX, e) || (r => {
                let i = (s => {
                    if (!s.ownerDocument || !s.ownerDocument.defaultView) return null;
                    try {
                        return s.ownerDocument.defaultView.frameElement
                    } catch {
                        return null
                    }
                })(r);
                return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth)
            })(t)
        }
        return !1
    },
    u_ = (t, e, n, r, i, s, o, a) => s < t && o > e || s > t && o < e ? 0 : s <= t && a <= n || o >= e && a >= n ? s - t - r : o > e && a < n || s < t && a > n ? o - e + i : 0,
    J0e = t => {
        let e = t.parentElement;
        return e ? ? (t.getRootNode().host || null)
    };
var Y0e = (t, e) => {
        var n, r, i, s, o, a;
        if (typeof document > "u") return [];
        let {
            scrollMode: l,
            block: u,
            inline: c,
            boundary: f,
            skipOverflowHiddenElements: d
        } = e, p = typeof f == "function" ? f : B => B !== f;
        if (!t9(t)) throw new TypeError("Invalid target");
        let m = document.scrollingElement || document.documentElement,
            y = [],
            v = t;
        for (; t9(v) && p(v);) {
            if (v = J0e(v), v === m) {
                y.push(v);
                break
            }
            v != null && v === document.body && _T(v) && !_T(document.documentElement) || v != null && _T(v, d) && y.push(v)
        }
        let b = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth,
            _ = (s = (i = window.visualViewport) == null ? void 0 : i.height) != null ? s : innerHeight,
            x = (o = window.scrollX) != null ? o : pageXOffset,
            S = (a = window.scrollY) != null ? a : pageYOffset,
            {
                height: E,
                width: A,
                top: T,
                right: M,
                bottom: I,
                left: O
            } = t.getBoundingClientRect(),
            k = u === "start" || u === "nearest" ? T : u === "end" ? I : T + E / 2,
            H = c === "center" ? O + A / 2 : c === "end" ? M : O,
            N = [];
        for (let B = 0; B < y.length; B++) {
            let U = y[B],
                {
                    height: q,
                    width: Q,
                    top: F,
                    right: G,
                    bottom: W,
                    left: se
                } = U.getBoundingClientRect();
            if (l === "if-needed" && T >= 0 && O >= 0 && I <= _ && M <= b && T >= F && I <= W && O >= se && M <= G) return N;
            let ee = getComputedStyle(U),
                ae = parseInt(ee.borderLeftWidth, 10),
                de = parseInt(ee.borderTopWidth, 10),
                re = parseInt(ee.borderRightWidth, 10),
                _e = parseInt(ee.borderBottomWidth, 10),
                fe = 0,
                ue = 0,
                ve = "offsetWidth" in U ? U.offsetWidth - U.clientWidth - ae - re : 0,
                xe = "offsetHeight" in U ? U.offsetHeight - U.clientHeight - de - _e : 0,
                be = "offsetWidth" in U ? U.offsetWidth === 0 ? 0 : Q / U.offsetWidth : 0,
                he = "offsetHeight" in U ? U.offsetHeight === 0 ? 0 : q / U.offsetHeight : 0;
            if (m === U) fe = u === "start" ? k : u === "end" ? k - _ : u === "nearest" ? u_(S, S + _, _, de, _e, S + k, S + k + E, E) : k - _ / 2, ue = c === "start" ? H : c === "center" ? H - b / 2 : c === "end" ? H - b : u_(x, x + b, b, ae, re, x + H, x + H + A, A), fe = Math.max(0, fe + S), ue = Math.max(0, ue + x);
            else {
                fe = u === "start" ? k - F - de : u === "end" ? k - W + _e + xe : u === "nearest" ? u_(F, W, q, de, _e + xe, k, k + E, E) : k - (F + q / 2) + xe / 2, ue = c === "start" ? H - se - ae : c === "center" ? H - (se + Q / 2) + ve / 2 : c === "end" ? H - G + re + ve : u_(se, G, Q, ae, re + ve, H, H + A, A);
                let {
                    scrollLeft: me,
                    scrollTop: Ce
                } = U;
                fe = Math.max(0, Math.min(Ce + fe / he, U.scrollHeight - q / he + xe)), ue = Math.max(0, Math.min(me + ue / be, U.scrollWidth - Q / be + ve)), k += Ce - fe, H += me - ue
            }
            N.push({
                el: U,
                top: fe,
                left: ue
            })
        }
        return N
    },
    Q0e = 0;

function y4() {}

function Z0e(t, e) {
    if (t) {
        var n = Y0e(t, {
            boundary: e,
            block: "nearest",
            scrollMode: "if-needed"
        });
        n.forEach(function(r) {
            var i = r.el,
                s = r.top,
                o = r.left;
            i.scrollTop = s, i.scrollLeft = o
        })
    }
}

function r9(t, e, n) {
    var r = t === e || e instanceof n.Node && t.contains && t.contains(e);
    return r
}

function mq(t, e) {
    var n;

    function r() {
        n && clearTimeout(n)
    }

    function i() {
        for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
        r(), n = setTimeout(function() {
            n = null, t.apply(void 0, o)
        }, e)
    }
    return i.cancel = r, i
}

function ou() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return function(r) {
        for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) s[o - 1] = arguments[o];
        return e.some(function(a) {
            return a && a.apply(void 0, [r].concat(s)), r.preventDownshiftDefault || r.hasOwnProperty("nativeEvent") && r.nativeEvent.preventDownshiftDefault
        })
    }
}

function c_() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return function(r) {
        e.forEach(function(i) {
            typeof i == "function" ? i(r) : i && (i.current = r)
        })
    }
}

function e1e() {
    return String(Q0e++)
}

function t1e(t) {
    var e = t.isOpen,
        n = t.resultCount,
        r = t.previousResultCount;
    return e ? n ? n !== r ? n + " result" + (n === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select." : "" : "No results are available." : ""
}

function eR(t, e) {
    return Object.keys(t).reduce(function(n, r) {
        return n[r] = gq(e, r) ? e[r] : t[r], n
    }, {})
}

function gq(t, e) {
    return t[e] !== void 0
}

function n1e(t) {
    var e = t.key,
        n = t.keyCode;
    return n >= 37 && n <= 40 && e.indexOf("Arrow") !== 0 ? "Arrow" + e : e
}

function f_(t, e, n, r, i) {
    if (i === void 0 && (i = !0), n === 0) return -1;
    var s = n - 1;
    (typeof e != "number" || e < 0 || e >= n) && (e = t > 0 ? -1 : s + 1);
    var o = e + t;
    o < 0 ? o = i ? s : 0 : o > s && (o = i ? 0 : s);
    var a = C0(t, o, n, r, i);
    return a === -1 ? e >= n ? -1 : e : a
}

function C0(t, e, n, r, i) {
    var s = r(e);
    if (!s || !s.hasAttribute("disabled")) return e;
    if (t > 0) {
        for (var o = e + 1; o < n; o++)
            if (!r(o).hasAttribute("disabled")) return o
    } else
        for (var a = e - 1; a >= 0; a--)
            if (!r(a).hasAttribute("disabled")) return a;
    return i ? t > 0 ? C0(1, 0, n, r, !1) : C0(-1, n - 1, n, r, !1) : -1
}

function i9(t, e, n, r) {
    return r === void 0 && (r = !0), e.some(function(i) {
        return i && (r9(i, t, n) || r && r9(i, n.document.activeElement, n))
    })
}
var r1e = mq(function(t) {
    yq(t).textContent = ""
}, 500);

function i1e(t, e) {
    var n = yq(e);
    t && (n.textContent = t, r1e(e))
}

function yq(t) {
    t === void 0 && (t = document);
    var e = t.getElementById("a11y-status-message");
    return e || (e = t.createElement("div"), e.setAttribute("id", "a11y-status-message"), e.setAttribute("role", "status"), e.setAttribute("aria-live", "polite"), e.setAttribute("aria-relevant", "additions text"), Object.assign(e.style, {
        border: "0",
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        width: "1px"
    }), t.body.appendChild(e), e)
}
var s1e = ["isInitialMount", "highlightedIndex", "items", "environment"],
    vq = {
        highlightedIndex: -1,
        isOpen: !1,
        selectedItem: null,
        inputValue: ""
    };

function o1e(t, e, n) {
    var r = t.props,
        i = t.type,
        s = {};
    Object.keys(e).forEach(function(o) {
        a1e(o, t, e, n), n[o] !== e[o] && (s[o] = n[o])
    }), r.onStateChange && Object.keys(s).length && r.onStateChange(Y({
        type: i
    }, s))
}

function a1e(t, e, n, r) {
    var i = e.props,
        s = e.type,
        o = "on" + v4(t) + "Change";
    i[o] && r[t] !== void 0 && r[t] !== n[t] && i[o](Y({
        type: s
    }, r))
}

function l1e(t, e) {
    return e.changes
}

function u1e(t) {
    var e = t.selectedItem,
        n = t.itemToString;
    return e ? n(e) + " has been selected." : ""
}
var c1e = mq(function(t, e) {
        i1e(t(), e)
    }, 200),
    f1e = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? P.useLayoutEffect : P.useEffect;

function d1e(t) {
    var e = t.id,
        n = e === void 0 ? "downshift-" + e1e() : e,
        r = t.labelId,
        i = t.menuId,
        s = t.getItemId,
        o = t.toggleButtonId,
        a = t.inputId,
        l = P.useRef({
            labelId: r || n + "-label",
            menuId: i || n + "-menu",
            getItemId: s || function(u) {
                return n + "-item-" + u
            },
            toggleButtonId: o || n + "-toggle-button",
            inputId: a || n + "-input"
        });
    return l.current
}

function p1e(t, e, n) {
    return t !== void 0 ? t : n.length === 0 ? -1 : n.indexOf(e)
}

function h1e(t) {
    return t ? String(t) : ""
}

function v4(t) {
    return "" + t.slice(0, 1).toUpperCase() + t.slice(1)
}

function bq(t) {
    var e = P.useRef(t);
    return e.current = t, e
}

function m1e(t, e, n) {
    var r = P.useRef(),
        i = P.useRef(),
        s = P.useCallback(function(d, p) {
            i.current = p, d = eR(d, p.props);
            var m = t(d, p),
                y = p.props.stateReducer(d, Y({}, p, {
                    changes: m
                }));
            return y
        }, [t]),
        o = P.useReducer(s, e),
        a = o[0],
        l = o[1],
        u = bq(n),
        c = P.useCallback(function(d) {
            return l(Y({
                props: u.current
            }, d))
        }, [u]),
        f = i.current;
    return P.useEffect(function() {
        f && r.current && r.current !== a && o1e(f, eR(r.current, f.props), a), r.current = a
    }, [a, n, f]), [a, c]
}
var xv = {
    itemToString: h1e,
    stateReducer: l1e,
    getA11ySelectionMessage: u1e,
    scrollIntoView: Z0e,
    environment: typeof window > "u" ? {} : window
};

function Lo(t, e, n) {
    n === void 0 && (n = vq);
    var r = t["default" + v4(e)];
    return r !== void 0 ? r : n[e]
}

function d_(t, e, n) {
    n === void 0 && (n = vq);
    var r = t[e];
    if (r !== void 0) return r;
    var i = t["initial" + v4(e)];
    return i !== void 0 ? i : Lo(t, e, n)
}

function g1e(t) {
    var e = d_(t, "selectedItem"),
        n = d_(t, "isOpen"),
        r = d_(t, "highlightedIndex"),
        i = d_(t, "inputValue");
    return {
        highlightedIndex: r < 0 && e && n ? t.items.indexOf(e) : r,
        isOpen: n,
        selectedItem: e,
        inputValue: i
    }
}

function _v(t, e, n) {
    var r = t.items,
        i = t.initialHighlightedIndex,
        s = t.defaultHighlightedIndex,
        o = e.selectedItem,
        a = e.highlightedIndex;
    return r.length === 0 ? -1 : i !== void 0 && a === i ? i : s !== void 0 ? s : o ? r.indexOf(o) : n === 0 ? -1 : n < 0 ? r.length - 1 : 0
}

function y1e(t, e, n, r) {
    var i = P.useRef({
        isMouseDown: !1,
        isTouchMove: !1
    });
    return P.useEffect(function() {
        var s = function() {
                i.current.isMouseDown = !0
            },
            o = function(f) {
                i.current.isMouseDown = !1, t && !i9(f.target, e.map(function(d) {
                    return d.current
                }), n) && r()
            },
            a = function() {
                i.current.isTouchMove = !1
            },
            l = function() {
                i.current.isTouchMove = !0
            },
            u = function(f) {
                t && !i.current.isTouchMove && !i9(f.target, e.map(function(d) {
                    return d.current
                }), n, !1) && r()
            };
        return n.addEventListener("mousedown", s), n.addEventListener("mouseup", o), n.addEventListener("touchstart", a), n.addEventListener("touchmove", l), n.addEventListener("touchend", u),
            function() {
                n.removeEventListener("mousedown", s), n.removeEventListener("mouseup", o), n.removeEventListener("touchstart", a), n.removeEventListener("touchmove", l), n.removeEventListener("touchend", u)
            }
    }, [t, n]), i
}
var v1e = function() {
    return y4
};

function s9(t, e, n) {
    var r = n.isInitialMount,
        i = n.highlightedIndex,
        s = n.items,
        o = n.environment,
        a = Rt(n, s1e);
    P.useEffect(function() {
        r || c1e(function() {
            return t(Y({
                highlightedIndex: i,
                highlightedItem: s[i],
                resultCount: s.length
            }, a))
        }, o.document)
    }, e)
}

function b1e(t) {
    var e = t.highlightedIndex,
        n = t.isOpen,
        r = t.itemRefs,
        i = t.getItemNodeFromIndex,
        s = t.menuElement,
        o = t.scrollIntoView,
        a = P.useRef(!0);
    return f1e(function() {
        e < 0 || !n || !Object.keys(r.current).length || (a.current === !1 ? a.current = !0 : o(i(e), s))
    }, [e]), a
}
var x1e = y4;

function _1e(t, e, n) {
    var r = e.type,
        i = e.props,
        s;
    switch (r) {
        case n.ItemMouseMove:
            s = {
                highlightedIndex: e.disabled ? -1 : e.index
            };
            break;
        case n.MenuMouseLeave:
            s = {
                highlightedIndex: -1
            };
            break;
        case n.ToggleButtonClick:
        case n.FunctionToggleMenu:
            s = {
                isOpen: !t.isOpen,
                highlightedIndex: t.isOpen ? -1 : _v(i, t, 0)
            };
            break;
        case n.FunctionOpenMenu:
            s = {
                isOpen: !0,
                highlightedIndex: _v(i, t, 0)
            };
            break;
        case n.FunctionCloseMenu:
            s = {
                isOpen: !1
            };
            break;
        case n.FunctionSetHighlightedIndex:
            s = {
                highlightedIndex: e.highlightedIndex
            };
            break;
        case n.FunctionSetInputValue:
            s = {
                inputValue: e.inputValue
            };
            break;
        case n.FunctionReset:
            s = {
                highlightedIndex: Lo(i, "highlightedIndex"),
                isOpen: Lo(i, "isOpen"),
                selectedItem: Lo(i, "selectedItem"),
                inputValue: Lo(i, "inputValue")
            };
            break;
        default:
            throw new Error("Reducer called without proper action type.")
    }
    return Y({}, t, s)
}
Le.array.isRequired, Le.func, Le.func, Le.func, Le.number, Le.number, Le.number, Le.bool, Le.bool, Le.bool, Le.any, Le.any, Le.any, Le.string, Le.string, Le.string, Le.func, Le.string, Le.func, Le.func, Le.func, Le.func, Le.func, Le.shape({
    addEventListener: Le.func,
    removeEventListener: Le.func,
    document: Le.shape({
        getElementById: Le.func,
        activeElement: Le.any,
        body: Le.any
    })
});

function S1e(t) {
    var e = t.isOpen,
        n = t.resultCount,
        r = t.previousResultCount;
    return e ? n ? n !== r ? "".concat(n, " result").concat(n === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.") : "" : "No results are available." : ""
}
ai(ai({}, xv), {
    getA11yStatusMessage: S1e
});
var b4 = 0,
    x4 = 1,
    _4 = 2,
    S4 = 3,
    w4 = 4,
    E4 = 5,
    A4 = 6,
    C4 = 7,
    M4 = 8,
    Kw = 9,
    T4 = 10,
    xq = 11,
    _q = 12,
    P4 = 13,
    Sq = 14,
    wq = 15,
    Eq = 16,
    Aq = 17,
    Cq = 18,
    I4 = 19,
    Mq = 20,
    Tq = 21,
    R4 = 22,
    Pq = Object.freeze({
        __proto__: null,
        InputKeyDownArrowDown: b4,
        InputKeyDownArrowUp: x4,
        InputKeyDownEscape: _4,
        InputKeyDownHome: S4,
        InputKeyDownEnd: w4,
        InputKeyDownPageUp: E4,
        InputKeyDownPageDown: A4,
        InputKeyDownEnter: C4,
        InputChange: M4,
        InputBlur: Kw,
        InputFocus: T4,
        MenuMouseLeave: xq,
        ItemMouseMove: _q,
        ItemClick: P4,
        ToggleButtonClick: Sq,
        FunctionToggleMenu: wq,
        FunctionOpenMenu: Eq,
        FunctionCloseMenu: Aq,
        FunctionSetHighlightedIndex: Cq,
        FunctionSelectItem: I4,
        FunctionSetInputValue: Mq,
        FunctionReset: Tq,
        ControlledPropUpdatedSelectedItem: R4
    });

function w1e(t) {
    var e = g1e(t),
        n = e.selectedItem,
        r = e.inputValue;
    return r === "" && n && t.defaultInputValue === void 0 && t.initialInputValue === void 0 && t.inputValue === void 0 && (r = t.itemToString(n)), Y({}, e, {
        inputValue: r
    })
}
Le.array.isRequired, Le.func, Le.func, Le.func, Le.number, Le.number, Le.number, Le.bool, Le.bool, Le.bool, Le.any, Le.any, Le.any, Le.string, Le.string, Le.string, Le.string, Le.string, Le.string, Le.func, Le.string, Le.string, Le.func, Le.func, Le.func, Le.func, Le.func, Le.func, Le.shape({
    addEventListener: Le.func,
    removeEventListener: Le.func,
    document: Le.shape({
        getElementById: Le.func,
        activeElement: Le.any,
        body: Le.any
    })
});

function E1e(t, e, n) {
    var r = P.useRef(),
        i = m1e(t, e, n),
        s = i[0],
        o = i[1];
    return P.useEffect(function() {
        gq(n, "selectedItem") && (r.current !== n.selectedItem && o({
            type: R4,
            inputValue: n.itemToString(n.selectedItem)
        }), r.current = s.selectedItem === r.current ? n.selectedItem : s.selectedItem)
    }), [eR(s, n), o]
}
var A1e = y4,
    C1e = Y({}, xv, {
        getA11yStatusMessage: t1e
    });

function M1e(t, e) {
    var n = e.type,
        r = e.props,
        i = e.altKey,
        s;
    switch (n) {
        case P4:
            s = {
                isOpen: Lo(r, "isOpen"),
                highlightedIndex: Lo(r, "highlightedIndex"),
                selectedItem: r.items[e.index],
                inputValue: r.itemToString(r.items[e.index])
            };
            break;
        case b4:
            t.isOpen ? s = {
                highlightedIndex: f_(1, t.highlightedIndex, r.items.length, e.getItemNodeFromIndex, !0)
            } : s = {
                highlightedIndex: i && t.selectedItem == null ? -1 : _v(r, t, 1, e.getItemNodeFromIndex),
                isOpen: r.items.length >= 0
            };
            break;
        case x4:
            t.isOpen ? i ? s = Y({
                isOpen: Lo(r, "isOpen"),
                highlightedIndex: Lo(r, "highlightedIndex")
            }, t.highlightedIndex >= 0 && {
                selectedItem: r.items[t.highlightedIndex],
                inputValue: r.itemToString(r.items[t.highlightedIndex])
            }) : s = {
                highlightedIndex: f_(-1, t.highlightedIndex, r.items.length, e.getItemNodeFromIndex, !0)
            } : s = {
                highlightedIndex: _v(r, t, -1, e.getItemNodeFromIndex),
                isOpen: r.items.length >= 0
            };
            break;
        case C4:
            s = Y({
                isOpen: Lo(r, "isOpen"),
                highlightedIndex: Lo(r, "highlightedIndex")
            }, t.highlightedIndex >= 0 && {
                selectedItem: r.items[t.highlightedIndex],
                inputValue: r.itemToString(r.items[t.highlightedIndex])
            });
            break;
        case _4:
            s = Y({
                isOpen: !1,
                highlightedIndex: -1
            }, !t.isOpen && {
                selectedItem: null,
                inputValue: ""
            });
            break;
        case E4:
            s = {
                highlightedIndex: f_(-10, t.highlightedIndex, r.items.length, e.getItemNodeFromIndex, !1)
            };
            break;
        case A4:
            s = {
                highlightedIndex: f_(10, t.highlightedIndex, r.items.length, e.getItemNodeFromIndex, !1)
            };
            break;
        case S4:
            s = {
                highlightedIndex: C0(1, 0, r.items.length, e.getItemNodeFromIndex, !1)
            };
            break;
        case w4:
            s = {
                highlightedIndex: C0(-1, r.items.length - 1, r.items.length, e.getItemNodeFromIndex, !1)
            };
            break;
        case Kw:
            s = Y({
                isOpen: !1,
                highlightedIndex: -1
            }, t.highlightedIndex >= 0 && e.selectItem && {
                selectedItem: r.items[t.highlightedIndex],
                inputValue: r.itemToString(r.items[t.highlightedIndex])
            });
            break;
        case M4:
            s = {
                isOpen: !0,
                highlightedIndex: Lo(r, "highlightedIndex"),
                inputValue: e.inputValue
            };
            break;
        case T4:
            s = {
                isOpen: !0,
                highlightedIndex: _v(r, t, 0)
            };
            break;
        case I4:
            s = {
                selectedItem: e.selectedItem,
                inputValue: r.itemToString(e.selectedItem)
            };
            break;
        case R4:
            s = {
                inputValue: e.inputValue
            };
            break;
        default:
            return _1e(t, e, Pq)
    }
    return Y({}, t, s)
}
var T1e = ["onMouseLeave", "refKey", "ref"],
    P1e = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
    I1e = ["onClick", "onPress", "refKey", "ref"],
    R1e = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
O1e.stateChangeTypes = Pq;

function O1e(t) {
    t === void 0 && (t = {}), A1e();
    var e = Y({}, C1e, t),
        n = e.initialIsOpen,
        r = e.defaultIsOpen,
        i = e.items,
        s = e.scrollIntoView,
        o = e.environment,
        a = e.getA11yStatusMessage,
        l = e.getA11ySelectionMessage,
        u = e.itemToString,
        c = w1e(e),
        f = E1e(M1e, c, e),
        d = f[0],
        p = f[1],
        m = d.isOpen,
        y = d.highlightedIndex,
        v = d.selectedItem,
        b = d.inputValue,
        _ = P.useRef(null),
        x = P.useRef({}),
        S = P.useRef(null),
        E = P.useRef(null),
        A = P.useRef(!0),
        T = d1e(e),
        M = P.useRef(),
        I = bq({
            state: d,
            props: e
        }),
        O = P.useCallback(function(fe) {
            return x.current[T.getItemId(fe)]
        }, [T]);
    s9(a, [m, y, b, i], Y({
        isInitialMount: A.current,
        previousResultCount: M.current,
        items: i,
        environment: o,
        itemToString: u
    }, d)), s9(l, [v], Y({
        isInitialMount: A.current,
        previousResultCount: M.current,
        items: i,
        environment: o,
        itemToString: u
    }, d));
    var k = b1e({
        menuElement: _.current,
        highlightedIndex: y,
        isOpen: m,
        itemRefs: x,
        scrollIntoView: s,
        getItemNodeFromIndex: O
    });
    x1e({
        isInitialMount: A.current,
        props: e,
        state: d
    }), P.useEffect(function() {
        var fe = n || r || m;
        fe && S.current && S.current.focus()
    }, []), P.useEffect(function() {
        A.current || (M.current = i.length)
    });
    var H = y1e(m, [S, _, E], o, function() {
            p({
                type: Kw,
                selectItem: !1
            })
        }),
        N = v1e();
    P.useEffect(function() {
        return A.current = !1,
            function() {
                A.current = !0
            }
    }, []), P.useEffect(function() {
        if (!m) x.current = {};
        else if (document.activeElement !== S.current) {
            var fe;
            S == null || (fe = S.current) == null || fe.focus()
        }
    }, [m]);
    var B = P.useMemo(function() {
            return {
                ArrowDown: function(ue) {
                    ue.preventDefault(), p({
                        type: b4,
                        altKey: ue.altKey,
                        getItemNodeFromIndex: O
                    })
                },
                ArrowUp: function(ue) {
                    ue.preventDefault(), p({
                        type: x4,
                        altKey: ue.altKey,
                        getItemNodeFromIndex: O
                    })
                },
                Home: function(ue) {
                    I.current.state.isOpen && (ue.preventDefault(), p({
                        type: S4,
                        getItemNodeFromIndex: O
                    }))
                },
                End: function(ue) {
                    I.current.state.isOpen && (ue.preventDefault(), p({
                        type: w4,
                        getItemNodeFromIndex: O
                    }))
                },
                Escape: function(ue) {
                    var ve = I.current.state;
                    (ve.isOpen || ve.inputValue || ve.selectedItem || ve.highlightedIndex > -1) && (ue.preventDefault(), p({
                        type: _4
                    }))
                },
                Enter: function(ue) {
                    var ve = I.current.state;
                    !ve.isOpen || ue.which === 229 || (ue.preventDefault(), p({
                        type: C4,
                        getItemNodeFromIndex: O
                    }))
                },
                PageUp: function(ue) {
                    I.current.state.isOpen && (ue.preventDefault(), p({
                        type: E4,
                        getItemNodeFromIndex: O
                    }))
                },
                PageDown: function(ue) {
                    I.current.state.isOpen && (ue.preventDefault(), p({
                        type: A4,
                        getItemNodeFromIndex: O
                    }))
                }
            }
        }, [p, I, O]),
        U = P.useCallback(function(fe) {
            return Y({
                id: T.labelId,
                htmlFor: T.inputId
            }, fe)
        }, [T]),
        q = P.useCallback(function(fe, ue) {
            var ve, xe = fe === void 0 ? {} : fe,
                be = xe.onMouseLeave,
                he = xe.refKey,
                me = he === void 0 ? "ref" : he,
                Ce = xe.ref,
                Ne = Rt(xe, T1e),
                De = ue === void 0 ? {} : ue;
            return De.suppressRefError, Y((ve = {}, ve[me] = c_(Ce, function(je) {
                _.current = je
            }), ve.id = T.menuId, ve.role = "listbox", ve["aria-labelledby"] = T.labelId, ve.onMouseLeave = ou(be, function() {
                p({
                    type: xq
                })
            }), ve), Ne)
        }, [p, N, T]),
        Q = P.useCallback(function(fe) {
            var ue, ve, xe = fe === void 0 ? {} : fe,
                be = xe.item,
                he = xe.index,
                me = xe.refKey,
                Ce = me === void 0 ? "ref" : me,
                Ne = xe.ref,
                De = xe.onMouseMove,
                je = xe.onMouseDown,
                Ke = xe.onClick;
            xe.onPress;
            var He = xe.disabled,
                qe = Rt(xe, P1e),
                Xe = I.current,
                K = Xe.props,
                V = Xe.state,
                ge = p1e(he, be, K.items);
            if (ge < 0) throw new Error("Pass either item or item index in getItemProps!");
            var Be = "onClick",
                ze = Ke,
                Ue = function() {
                    he !== V.highlightedIndex && (k.current = !1, p({
                        type: _q,
                        index: he,
                        disabled: He
                    }))
                },
                Ye = function() {
                    p({
                        type: P4,
                        index: he
                    })
                },
                Te = function(lt) {
                    return lt.preventDefault()
                };
            return Y((ue = {}, ue[Ce] = c_(Ne, function(we) {
                we && (x.current[T.getItemId(ge)] = we)
            }), ue.disabled = He, ue.role = "option", ue["aria-selected"] = "" + (ge === V.highlightedIndex), ue.id = T.getItemId(ge), ue), !He && (ve = {}, ve[Be] = ou(ze, Ye), ve), {
                onMouseMove: ou(De, Ue),
                onMouseDown: ou(je, Te)
            }, qe)
        }, [p, I, k, T]),
        F = P.useCallback(function(fe) {
            var ue, ve = fe === void 0 ? {} : fe,
                xe = ve.onClick;
            ve.onPress;
            var be = ve.refKey,
                he = be === void 0 ? "ref" : be,
                me = ve.ref,
                Ce = Rt(ve, I1e),
                Ne = I.current.state,
                De = function() {
                    p({
                        type: Sq
                    })
                };
            return Y((ue = {}, ue[he] = c_(me, function(je) {
                E.current = je
            }), ue["aria-controls"] = T.menuId, ue["aria-expanded"] = Ne.isOpen, ue.id = T.toggleButtonId, ue.tabIndex = -1, ue), !Ce.disabled && Y({}, {
                onClick: ou(xe, De)
            }), Ce)
        }, [p, I, T]),
        G = P.useCallback(function(fe, ue) {
            var ve, xe = fe === void 0 ? {} : fe,
                be = xe.onKeyDown,
                he = xe.onChange,
                me = xe.onInput,
                Ce = xe.onFocus,
                Ne = xe.onBlur;
            xe.onChangeText;
            var De = xe.refKey,
                je = De === void 0 ? "ref" : De,
                Ke = xe.ref,
                He = Rt(xe, R1e),
                qe = ue === void 0 ? {} : ue;
            qe.suppressRefError;
            var Xe = I.current.state,
                K = function(we) {
                    var lt = n1e(we);
                    lt && B[lt] && B[lt](we)
                },
                V = function(we) {
                    p({
                        type: M4,
                        inputValue: we.target.value
                    })
                },
                ge = function() {
                    Xe.isOpen && !H.current.isMouseDown && p({
                        type: Kw,
                        selectItem: !0
                    })
                },
                Be = function() {
                    Xe.isOpen || p({
                        type: T4
                    })
                },
                ze = "onChange",
                Ue = {};
            if (!He.disabled) {
                var Ye;
                Ue = (Ye = {}, Ye[ze] = ou(he, me, V), Ye.onKeyDown = ou(be, K), Ye.onBlur = ou(Ne, ge), Ye.onFocus = ou(Ce, Be), Ye)
            }
            return Y((ve = {}, ve[je] = c_(Ke, function(Te) {
                S.current = Te
            }), ve["aria-activedescendant"] = Xe.isOpen && Xe.highlightedIndex > -1 ? T.getItemId(Xe.highlightedIndex) : "", ve["aria-autocomplete"] = "list", ve["aria-controls"] = T.menuId, ve["aria-expanded"] = Xe.isOpen, ve["aria-labelledby"] = T.labelId, ve.autoComplete = "off", ve.id = T.inputId, ve.role = "combobox", ve.value = Xe.inputValue, ve), Ue, He)
        }, [p, B, I, H, N, T]),
        W = P.useCallback(function() {
            p({
                type: wq
            })
        }, [p]),
        se = P.useCallback(function() {
            p({
                type: Aq
            })
        }, [p]),
        ee = P.useCallback(function() {
            p({
                type: Eq
            })
        }, [p]),
        ae = P.useCallback(function(fe) {
            p({
                type: Cq,
                highlightedIndex: fe
            })
        }, [p]),
        de = P.useCallback(function(fe) {
            p({
                type: I4,
                selectedItem: fe
            })
        }, [p]),
        re = P.useCallback(function(fe) {
            p({
                type: Mq,
                inputValue: fe
            })
        }, [p]),
        _e = P.useCallback(function() {
            p({
                type: Tq
            })
        }, [p]);
    return {
        getItemProps: Q,
        getLabelProps: U,
        getMenuProps: q,
        getInputProps: G,
        getToggleButtonProps: F,
        toggleMenu: W,
        openMenu: ee,
        closeMenu: se,
        setHighlightedIndex: ae,
        setInputValue: re,
        selectItem: de,
        reset: _e,
        highlightedIndex: y,
        isOpen: m,
        selectedItem: v,
        inputValue: b
    }
}

function D1e(t) {
    var e = t.removedSelectedItem,
        n = t.itemToString;
    return n(e) + " has been removed."
}
Le.array, Le.array, Le.array, Le.func, Le.func, Le.func, Le.number, Le.number, Le.number, Le.func, Le.func, Le.string, Le.string, Le.shape({
    addEventListener: Le.func,
    removeEventListener: Le.func,
    document: Le.shape({
        getElementById: Le.func,
        activeElement: Le.any,
        body: Le.any
    })
});
xv.itemToString, xv.stateReducer, xv.environment;

function Iq(t) {
    if (Array.isArray(t)) return t
}

function L1e(t, e) {
    var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (n != null) {
        var r, i, s, o, a = [],
            l = !0,
            u = !1;
        try {
            if (s = (n = n.call(t)).next, e === 0) {
                if (Object(n) !== n) return;
                l = !1
            } else
                for (; !(l = (r = s.call(n)).done) && (a.push(r.value), a.length !== e); l = !0);
        } catch (c) {
            u = !0, i = c
        } finally {
            try {
                if (!l && n.return != null && (o = n.return(), Object(o) !== o)) return
            } finally {
                if (u) throw i
            }
        }
        return a
    }
}

function tR(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
}

function O4(t, e) {
    if (t) {
        if (typeof t == "string") return tR(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tR(t, e)
    }
}

function Rq() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function ln(t, e) {
    return Iq(t) || L1e(t, e) || O4(t, e) || Rq()
}

function zu(t, e) {
    if (t == null) return {};
    var n = Rt(t, e),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (i = 0; i < s.length; i++) r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
    }
    return n
}
var k1e = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];

function B1e(t) {
    var e = t.defaultInputValue,
        n = e === void 0 ? "" : e,
        r = t.defaultMenuIsOpen,
        i = r === void 0 ? !1 : r,
        s = t.defaultValue,
        o = s === void 0 ? null : s,
        a = t.inputValue,
        l = t.menuIsOpen,
        u = t.onChange,
        c = t.onInputChange,
        f = t.onMenuClose,
        d = t.onMenuOpen,
        p = t.value,
        m = zu(t, k1e),
        y = P.useState(a !== void 0 ? a : n),
        v = ln(y, 2),
        b = v[0],
        _ = v[1],
        x = P.useState(l !== void 0 ? l : i),
        S = ln(x, 2),
        E = S[0],
        A = S[1],
        T = P.useState(p !== void 0 ? p : o),
        M = ln(T, 2),
        I = M[0],
        O = M[1],
        k = P.useCallback(function(F, G) {
            typeof u == "function" && u(F, G), O(F)
        }, [u]),
        H = P.useCallback(function(F, G) {
            var W;
            typeof c == "function" && (W = c(F, G)), _(W !== void 0 ? W : F)
        }, [c]),
        N = P.useCallback(function() {
            typeof d == "function" && d(), A(!0)
        }, [d]),
        B = P.useCallback(function() {
            typeof f == "function" && f(), A(!1)
        }, [f]),
        U = a !== void 0 ? a : b,
        q = l !== void 0 ? l : E,
        Q = p !== void 0 ? p : I;
    return et(et({}, m), {}, {
        inputValue: U,
        menuIsOpen: q,
        onChange: k,
        onInputChange: H,
        onMenuClose: B,
        onMenuOpen: N,
        value: Q
    })
}

function Wu(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function o9(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, fV(r.key), r)
    }
}

function Ku(t, e, n) {
    return e && o9(t.prototype, e), n && o9(t, n), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}

function H1(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && Ww(t, e)
}

function Km(t) {
    return Km = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Km(t)
}

function D4() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (D4 = function() {
        return !!t
    })()
}

function Oq(t, e) {
    if (e && (yi(e) === "object" || typeof e == "function")) return e;
    if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return jw(t)
}

function L4(t) {
    var e = D4();
    return function() {
        var r = Km(t),
            i;
        if (e) {
            var s = Km(this).constructor;
            i = Reflect.construct(r, arguments, s)
        } else i = r.apply(this, arguments);
        return Oq(this, i)
    }
}

function F1e(t) {
    if (Array.isArray(t)) return tR(t)
}

function Dq(t) {
    if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
}

function N1e() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function zl(t) {
    return F1e(t) || Dq(t) || O4(t) || N1e()
}

function z1e(t) {
    if (t.sheet) return t.sheet;
    for (var e = 0; e < document.styleSheets.length; e++)
        if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e]
}

function H1e(t) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e
}
var U1e = function() {
        function t(n) {
            var r = this;
            this._insertTag = function(i) {
                var s;
                r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, s), r.tags.push(i)
            }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null
        }
        var e = t.prototype;
        return e.hydrate = function(r) {
            r.forEach(this._insertTag)
        }, e.insert = function(r) {
            this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(H1e(this));
            var i = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
                var s = z1e(i);
                try {
                    s.insertRule(r, s.cssRules.length)
                } catch {}
            } else i.appendChild(document.createTextNode(r));
            this.ctr++
        }, e.flush = function() {
            this.tags.forEach(function(r) {
                return r.parentNode && r.parentNode.removeChild(r)
            }), this.tags = [], this.ctr = 0
        }, t
    }(),
    ns = "-ms-",
    qw = "-moz-",
    Fn = "-webkit-",
    Lq = "comm",
    k4 = "rule",
    B4 = "decl",
    $1e = "@import",
    kq = "@keyframes",
    G1e = "@layer",
    V1e = Math.abs,
    uA = String.fromCharCode,
    j1e = Object.assign;

function W1e(t, e) {
    return Fi(t, 0) ^ 45 ? (((e << 2 ^ Fi(t, 0)) << 2 ^ Fi(t, 1)) << 2 ^ Fi(t, 2)) << 2 ^ Fi(t, 3) : 0
}

function Bq(t) {
    return t.trim()
}

function K1e(t, e) {
    return (t = e.exec(t)) ? t[0] : t
}

function Nn(t, e, n) {
    return t.replace(e, n)
}

function nR(t, e) {
    return t.indexOf(e)
}

function Fi(t, e) {
    return t.charCodeAt(e) | 0
}

function M0(t, e, n) {
    return t.slice(e, n)
}

function hl(t) {
    return t.length
}

function F4(t) {
    return t.length
}

function p_(t, e) {
    return e.push(t), t
}

function q1e(t, e) {
    return t.map(e).join("")
}
var cA = 1,
    qm = 1,
    Fq = 0,
    Ks = 0,
    si = 0,
    Cg = "";

function fA(t, e, n, r, i, s, o) {
    return {
        value: t,
        root: e,
        parent: n,
        type: r,
        props: i,
        children: s,
        line: cA,
        column: qm,
        length: o,
        return: ""
    }
}

function Cy(t, e) {
    return j1e(fA("", null, null, "", null, null, 0), t, {
        length: -t.length
    }, e)
}

function X1e() {
    return si
}

function J1e() {
    return si = Ks > 0 ? Fi(Cg, --Ks) : 0, qm--, si === 10 && (qm = 1, cA--), si
}

function co() {
    return si = Ks < Fq ? Fi(Cg, Ks++) : 0, qm++, si === 10 && (qm = 1, cA++), si
}

function Pl() {
    return Fi(Cg, Ks)
}

function DS() {
    return Ks
}

function U1(t, e) {
    return M0(Cg, t, e)
}

function T0(t) {
    switch (t) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1
    }
    return 0
}

function Nq(t) {
    return cA = qm = 1, Fq = hl(Cg = t), Ks = 0, []
}

function zq(t) {
    return Cg = "", t
}

function LS(t) {
    return Bq(U1(Ks - 1, rR(t === 91 ? t + 2 : t === 40 ? t + 1 : t)))
}

function Y1e(t) {
    for (;
        (si = Pl()) && si < 33;) co();
    return T0(t) > 2 || T0(si) > 3 ? "" : " "
}

function Q1e(t, e) {
    for (; --e && co() && !(si < 48 || si > 102 || si > 57 && si < 65 || si > 70 && si < 97););
    return U1(t, DS() + (e < 6 && Pl() == 32 && co() == 32))
}

function rR(t) {
    for (; co();) switch (si) {
        case t:
            return Ks;
        case 34:
        case 39:
            t !== 34 && t !== 39 && rR(si);
            break;
        case 40:
            t === 41 && rR(t);
            break;
        case 92:
            co();
            break
    }
    return Ks
}

function Z1e(t, e) {
    for (; co() && t + si !== 47 + 10;)
        if (t + si === 42 + 42 && Pl() === 47) break;
    return "/*" + U1(e, Ks - 1) + "*" + uA(t === 47 ? t : co())
}

function ebe(t) {
    for (; !T0(Pl());) co();
    return U1(t, Ks)
}

function Hq(t) {
    return zq(kS("", null, null, null, [""], t = Nq(t), 0, [0], t))
}

function kS(t, e, n, r, i, s, o, a, l) {
    for (var u = 0, c = 0, f = o, d = 0, p = 0, m = 0, y = 1, v = 1, b = 1, _ = 0, x = "", S = i, E = s, A = r, T = x; v;) switch (m = _, _ = co()) {
        case 40:
            if (m != 108 && Fi(T, f - 1) == 58) {
                nR(T += Nn(LS(_), "&", "&\f"), "&\f") != -1 && (b = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            T += LS(_);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            T += Y1e(m);
            break;
        case 92:
            T += Q1e(DS() - 1, 7);
            continue;
        case 47:
            switch (Pl()) {
                case 42:
                case 47:
                    p_(tbe(Z1e(co(), DS()), e, n), l);
                    break;
                default:
                    T += "/"
            }
            break;
        case 123 * y:
            a[u++] = hl(T) * b;
        case 125 * y:
        case 59:
        case 0:
            switch (_) {
                case 0:
                case 125:
                    v = 0;
                case 59 + c:
                    b == -1 && (T = Nn(T, /\f/g, "")), p > 0 && hl(T) - f && p_(p > 32 ? l9(T + ";", r, n, f - 1) : l9(Nn(T, " ", "") + ";", r, n, f - 2), l);
                    break;
                case 59:
                    T += ";";
                default:
                    if (p_(A = a9(T, e, n, u, c, i, a, x, S = [], E = [], f), s), _ === 123)
                        if (c === 0) kS(T, e, A, A, S, s, f, a, E);
                        else switch (d === 99 && Fi(T, 3) === 110 ? 100 : d) {
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                                kS(t, A, A, r && p_(a9(t, A, A, 0, 0, i, a, x, i, S = [], f), E), i, E, f, a, r ? S : E);
                                break;
                            default:
                                kS(T, A, A, A, [""], E, 0, a, E)
                        }
            }
            u = c = p = 0, y = b = 1, x = T = "", f = o;
            break;
        case 58:
            f = 1 + hl(T), p = m;
        default:
            if (y < 1) {
                if (_ == 123) --y;
                else if (_ == 125 && y++ == 0 && J1e() == 125) continue
            }
            switch (T += uA(_), _ * y) {
                case 38:
                    b = c > 0 ? 1 : (T += "\f", -1);
                    break;
                case 44:
                    a[u++] = (hl(T) - 1) * b, b = 1;
                    break;
                case 64:
                    Pl() === 45 && (T += LS(co())), d = Pl(), c = f = hl(x = T += ebe(DS())), _++;
                    break;
                case 45:
                    m === 45 && hl(T) == 2 && (y = 0)
            }
    }
    return s
}

function a9(t, e, n, r, i, s, o, a, l, u, c) {
    for (var f = i - 1, d = i === 0 ? s : [""], p = F4(d), m = 0, y = 0, v = 0; m < r; ++m)
        for (var b = 0, _ = M0(t, f + 1, f = V1e(y = o[m])), x = t; b < p; ++b)(x = Bq(y > 0 ? d[b] + " " + _ : Nn(_, /&\f/g, d[b]))) && (l[v++] = x);
    return fA(t, e, n, i === 0 ? k4 : a, l, u, c)
}

function tbe(t, e, n) {
    return fA(t, e, n, Lq, uA(X1e()), M0(t, 2, -2), 0)
}

function l9(t, e, n, r) {
    return fA(t, e, n, B4, M0(t, 0, r), M0(t, r + 1, -1), r)
}

function zd(t, e) {
    for (var n = "", r = F4(t), i = 0; i < r; i++) n += e(t[i], i, t, e) || "";
    return n
}

function Uq(t, e, n, r) {
    switch (t.type) {
        case G1e:
            if (t.children.length) break;
        case $1e:
        case B4:
            return t.return = t.return || t.value;
        case Lq:
            return "";
        case kq:
            return t.return = t.value + "{" + zd(t.children, r) + "}";
        case k4:
            t.value = t.props.join(",")
    }
    return hl(n = zd(t.children, r)) ? t.return = t.value + "{" + n + "}" : ""
}

function nbe(t) {
    var e = F4(t);
    return function(n, r, i, s) {
        for (var o = "", a = 0; a < e; a++) o += t[a](n, r, i, s) || "";
        return o
    }
}

function rbe(t) {
    return function(e) {
        e.root || (e = e.return) && t(e)
    }
}
var ibe = function(e, n, r) {
        for (var i = 0, s = 0; i = s, s = Pl(), i === 38 && s === 12 && (n[r] = 1), !T0(s);) co();
        return U1(e, Ks)
    },
    sbe = function(e, n) {
        var r = -1,
            i = 44;
        do switch (T0(i)) {
            case 0:
                i === 38 && Pl() === 12 && (n[r] = 1), e[r] += ibe(Ks - 1, n, r);
                break;
            case 2:
                e[r] += LS(i);
                break;
            case 4:
                if (i === 44) {
                    e[++r] = Pl() === 58 ? "&\f" : "", n[r] = e[r].length;
                    break
                }
            default:
                e[r] += uA(i)
        }
        while (i = co());
        return e
    },
    obe = function(e, n) {
        return zq(sbe(Nq(e), n))
    },
    u9 = new WeakMap,
    abe = function(e) {
        if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
            for (var n = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule";)
                if (r = r.parent, !r) return;
            if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !u9.get(r)) && !i) {
                u9.set(e, !0);
                for (var s = [], o = obe(n, s), a = r.props, l = 0, u = 0; l < o.length; l++)
                    for (var c = 0; c < a.length; c++, u++) e.props[u] = s[l] ? o[l].replace(/&\f/g, a[c]) : a[c] + " " + o[l]
            }
        }
    },
    lbe = function(e) {
        if (e.type === "decl") {
            var n = e.value;
            n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (e.return = "", e.value = "")
        }
    };

function $q(t, e) {
    switch (W1e(t, e)) {
        case 5103:
            return Fn + "print-" + t + t;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return Fn + t + t;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return Fn + t + qw + t + ns + t + t;
        case 6828:
        case 4268:
            return Fn + t + ns + t + t;
        case 6165:
            return Fn + t + ns + "flex-" + t + t;
        case 5187:
            return Fn + t + Nn(t, /(\w+).+(:[^]+)/, Fn + "box-$1$2" + ns + "flex-$1$2") + t;
        case 5443:
            return Fn + t + ns + "flex-item-" + Nn(t, /flex-|-self/, "") + t;
        case 4675:
            return Fn + t + ns + "flex-line-pack" + Nn(t, /align-content|flex-|-self/, "") + t;
        case 5548:
            return Fn + t + ns + Nn(t, "shrink", "negative") + t;
        case 5292:
            return Fn + t + ns + Nn(t, "basis", "preferred-size") + t;
        case 6060:
            return Fn + "box-" + Nn(t, "-grow", "") + Fn + t + ns + Nn(t, "grow", "positive") + t;
        case 4554:
            return Fn + Nn(t, /([^-])(transform)/g, "$1" + Fn + "$2") + t;
        case 6187:
            return Nn(Nn(Nn(t, /(zoom-|grab)/, Fn + "$1"), /(image-set)/, Fn + "$1"), t, "") + t;
        case 5495:
        case 3959:
            return Nn(t, /(image-set\([^]*)/, Fn + "$1$`$1");
        case 4968:
            return Nn(Nn(t, /(.+:)(flex-)?(.*)/, Fn + "box-pack:$3" + ns + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Fn + t + t;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return Nn(t, /(.+)-inline(.+)/, Fn + "$1$2") + t;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (hl(t) - 1 - e > 6) switch (Fi(t, e + 1)) {
                case 109:
                    if (Fi(t, e + 4) !== 45) break;
                case 102:
                    return Nn(t, /(.+:)(.+)-([^]+)/, "$1" + Fn + "$2-$3$1" + qw + (Fi(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
                case 115:
                    return ~nR(t, "stretch") ? $q(Nn(t, "stretch", "fill-available"), e) + t : t
            }
            break;
        case 4949:
            if (Fi(t, e + 1) !== 115) break;
        case 6444:
            switch (Fi(t, hl(t) - 3 - (~nR(t, "!important") && 10))) {
                case 107:
                    return Nn(t, ":", ":" + Fn) + t;
                case 101:
                    return Nn(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Fn + (Fi(t, 14) === 45 ? "inline-" : "") + "box$3$1" + Fn + "$2$3$1" + ns + "$2box$3") + t
            }
            break;
        case 5936:
            switch (Fi(t, e + 11)) {
                case 114:
                    return Fn + t + ns + Nn(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
                case 108:
                    return Fn + t + ns + Nn(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
                case 45:
                    return Fn + t + ns + Nn(t, /[svh]\w+-[tblr]{2}/, "lr") + t
            }
            return Fn + t + ns + t + t
    }
    return t
}
var ube = function(e, n, r, i) {
        if (e.length > -1 && !e.return) switch (e.type) {
            case B4:
                e.return = $q(e.value, e.length);
                break;
            case kq:
                return zd([Cy(e, {
                    value: Nn(e.value, "@", "@" + Fn)
                })], i);
            case k4:
                if (e.length) return q1e(e.props, function(s) {
                    switch (K1e(s, /(::plac\w+|:read-\w+)/)) {
                        case ":read-only":
                        case ":read-write":
                            return zd([Cy(e, {
                                props: [Nn(s, /:(read-\w+)/, ":" + qw + "$1")]
                            })], i);
                        case "::placeholder":
                            return zd([Cy(e, {
                                props: [Nn(s, /:(plac\w+)/, ":" + Fn + "input-$1")]
                            }), Cy(e, {
                                props: [Nn(s, /:(plac\w+)/, ":" + qw + "$1")]
                            }), Cy(e, {
                                props: [Nn(s, /:(plac\w+)/, ns + "input-$1")]
                            })], i)
                    }
                    return ""
                })
        }
    },
    cbe = [ube],
    Gq = function(e) {
        var n = e.key;
        if (n === "css") {
            var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
            Array.prototype.forEach.call(r, function(y) {
                var v = y.getAttribute("data-emotion");
                v.indexOf(" ") !== -1 && (document.head.appendChild(y), y.setAttribute("data-s", ""))
            })
        }
        var i = e.stylisPlugins || cbe,
            s = {},
            o, a = [];
        o = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function(y) {
            for (var v = y.getAttribute("data-emotion").split(" "), b = 1; b < v.length; b++) s[v[b]] = !0;
            a.push(y)
        });
        var l, u = [abe, lbe]; {
            var c, f = [Uq, rbe(function(y) {
                    c.insert(y)
                })],
                d = nbe(u.concat(i, f)),
                p = function(v) {
                    return zd(Hq(v), d)
                };
            l = function(v, b, _, x) {
                c = _, p(v ? v + "{" + b.styles + "}" : b.styles), x && (m.inserted[b.name] = !0)
            }
        }
        var m = {
            key: n,
            sheet: new U1e({
                key: n,
                container: o,
                nonce: e.nonce,
                speedy: e.speedy,
                prepend: e.prepend,
                insertionPoint: e.insertionPoint
            }),
            nonce: e.nonce,
            inserted: s,
            registered: {},
            insert: l
        };
        return m.sheet.hydrate(a), m
    },
    fbe = !0;

function Vq(t, e, n) {
    var r = "";
    return n.split(" ").forEach(function(i) {
        t[i] !== void 0 ? e.push(t[i] + ";") : r += i + " "
    }), r
}
var N4 = function(e, n, r) {
        var i = e.key + "-" + n.name;
        (r === !1 || fbe === !1) && e.registered[i] === void 0 && (e.registered[i] = n.styles)
    },
    z4 = function(e, n, r) {
        N4(e, n, r);
        var i = e.key + "-" + n.name;
        if (e.inserted[n.name] === void 0) {
            var s = n;
            do e.insert(n === s ? "." + i : "", s, e.sheet, !0), s = s.next; while (s !== void 0)
        }
    };

function dbe(t) {
    for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4) n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
        case 3:
            e ^= (t.charCodeAt(r + 2) & 255) << 16;
        case 2:
            e ^= (t.charCodeAt(r + 1) & 255) << 8;
        case 1:
            e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16)
    }
    return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36)
}
var pbe = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    },
    hbe = /[A-Z]|^ms/g,
    mbe = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
    jq = function(e) {
        return e.charCodeAt(1) === 45
    },
    c9 = function(e) {
        return e != null && typeof e != "boolean"
    },
    ST = BK(function(t) {
        return jq(t) ? t : t.replace(hbe, "-$&").toLowerCase()
    }),
    f9 = function(e, n) {
        switch (e) {
            case "animation":
            case "animationName":
                if (typeof n == "string") return n.replace(mbe, function(r, i, s) {
                    return ml = {
                        name: i,
                        styles: s,
                        next: ml
                    }, i
                })
        }
        return pbe[e] !== 1 && !jq(e) && typeof n == "number" && n !== 0 ? n + "px" : n
    };

function P0(t, e, n) {
    if (n == null) return "";
    if (n.__emotion_styles !== void 0) return n;
    switch (typeof n) {
        case "boolean":
            return "";
        case "object":
            {
                if (n.anim === 1) return ml = {
                    name: n.name,
                    styles: n.styles,
                    next: ml
                }, n.name;
                if (n.styles !== void 0) {
                    var r = n.next;
                    if (r !== void 0)
                        for (; r !== void 0;) ml = {
                            name: r.name,
                            styles: r.styles,
                            next: ml
                        }, r = r.next;
                    var i = n.styles + ";";
                    return i
                }
                return gbe(t, e, n)
            }
        case "function":
            {
                if (t !== void 0) {
                    var s = ml,
                        o = n(t);
                    return ml = s, P0(t, e, o)
                }
                break
            }
    }
    if (e == null) return n;
    var a = e[n];
    return a !== void 0 ? a : n
}

function gbe(t, e, n) {
    var r = "";
    if (Array.isArray(n))
        for (var i = 0; i < n.length; i++) r += P0(t, e, n[i]) + ";";
    else
        for (var s in n) {
            var o = n[s];
            if (typeof o != "object") e != null && e[o] !== void 0 ? r += s + "{" + e[o] + "}" : c9(o) && (r += ST(s) + ":" + f9(s, o) + ";");
            else if (Array.isArray(o) && typeof o[0] == "string" && (e == null || e[o[0]] === void 0))
                for (var a = 0; a < o.length; a++) c9(o[a]) && (r += ST(s) + ":" + f9(s, o[a]) + ";");
            else {
                var l = P0(t, e, o);
                switch (s) {
                    case "animation":
                    case "animationName":
                        {
                            r += ST(s) + ":" + l + ";";
                            break
                        }
                    default:
                        r += s + "{" + l + "}"
                }
            }
        }
    return r
}
var d9 = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
    ml, dA = function(e, n, r) {
        if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0) return e[0];
        var i = !0,
            s = "";
        ml = void 0;
        var o = e[0];
        o == null || o.raw === void 0 ? (i = !1, s += P0(r, n, o)) : s += o[0];
        for (var a = 1; a < e.length; a++) s += P0(r, n, e[a]), i && (s += o[a]);
        d9.lastIndex = 0;
        for (var l = "", u;
            (u = d9.exec(s)) !== null;) l += "-" + u[1];
        var c = dbe(s) + l;
        return {
            name: c,
            styles: s,
            next: ml
        }
    },
    ybe = function(e) {
        return e()
    },
    Wq = Am["useInsertionEffect"] ? Am["useInsertionEffect"] : !1,
    Kq = Wq || ybe,
    p9 = Wq || P.useLayoutEffect,
    H4 = {}.hasOwnProperty,
    qq = P.createContext(typeof HTMLElement < "u" ? Gq({
        key: "css"
    }) : null),
    vbe = qq.Provider,
    U4 = function(e) {
        return P.forwardRef(function(n, r) {
            var i = P.useContext(qq);
            return e(n, i, r)
        })
    },
    $1 = P.createContext({}),
    iR = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__",
    bbe = function(e, n) {
        var r = {};
        for (var i in n) H4.call(n, i) && (r[i] = n[i]);
        return r[iR] = e, r
    },
    xbe = function(e) {
        var n = e.cache,
            r = e.serialized,
            i = e.isStringTag;
        return N4(n, r, i), Kq(function() {
            return z4(n, r, i)
        }), null
    },
    _be = U4(function(t, e, n) {
        var r = t.css;
        typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
        var i = t[iR],
            s = [r],
            o = "";
        typeof t.className == "string" ? o = Vq(e.registered, s, t.className) : t.className != null && (o = t.className + " ");
        var a = dA(s, void 0, P.useContext($1));
        o += e.key + "-" + a.name;
        var l = {};
        for (var u in t) H4.call(t, u) && u !== "css" && u !== iR && (l[u] = t[u]);
        return l.ref = n, l.className = o, P.createElement(P.Fragment, null, P.createElement(xbe, {
            cache: e,
            serialized: a,
            isStringTag: typeof i == "string"
        }), P.createElement(i, l))
    }),
    Sbe = _be,
    Ut = function(e, n) {
        var r = arguments;
        if (n == null || !H4.call(n, "css")) return P.createElement.apply(void 0, r);
        var i = r.length,
            s = new Array(i);
        s[0] = Sbe, s[1] = bbe(e, n);
        for (var o = 2; o < i; o++) s[o] = r[o];
        return P.createElement.apply(null, s)
    },
    wbe = U4(function(t, e) {
        var n = t.styles,
            r = dA([n], void 0, P.useContext($1)),
            i = P.useRef();
        return p9(function() {
            var s = e.key + "-global",
                o = new e.sheet.constructor({
                    key: s,
                    nonce: e.sheet.nonce,
                    container: e.sheet.container,
                    speedy: e.sheet.isSpeedy
                }),
                a = !1,
                l = document.querySelector('style[data-emotion="' + s + " " + r.name + '"]');
            return e.sheet.tags.length && (o.before = e.sheet.tags[0]), l !== null && (a = !0, l.setAttribute("data-emotion", s), o.hydrate([l])), i.current = [o, a],
                function() {
                    o.flush()
                }
        }, [e]), p9(function() {
            var s = i.current,
                o = s[0],
                a = s[1];
            if (a) {
                s[1] = !1;
                return
            }
            if (r.next !== void 0 && z4(e, r.next, !0), o.tags.length) {
                var l = o.tags[o.tags.length - 1].nextElementSibling;
                o.before = l, o.flush()
            }
            e.insert("", r, o, !1)
        }, [e, r.name]), null
    });

function pA() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return dA(e)
}
var G1 = function() {
    var e = pA.apply(void 0, arguments),
        n = "animation-" + e.name;
    return {
        name: n,
        styles: "@keyframes " + n + "{" + e.styles + "}",
        anim: 1,
        toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
};

function Ebe(t, e) {
    return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, {
        raw: {
            value: Object.freeze(e)
        }
    }))
}

function Abe(t) {
    return { ...t,
        top: t.y,
        left: t.x,
        right: t.x + t.width,
        bottom: t.y + t.height
    }
}
const Cbe = ["top", "right", "bottom", "left"];
Cbe.reduce((t, e) => t.concat(e, e + "-start", e + "-end"), []);
const Mbe = Math.min,
    Tbe = Math.max,
    Xw = Math.round,
    h_ = Math.floor,
    Jw = t => ({
        x: t,
        y: t
    });

function Xq(t) {
    return Yq(t) ? (t.nodeName || "").toLowerCase() : "#document"
}

function Ha(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}

function Jq(t) {
    var e;
    return (e = (Yq(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}

function Yq(t) {
    return t instanceof Node || t instanceof Ha(t).Node
}

function sR(t) {
    return t instanceof Element || t instanceof Ha(t).Element
}

function $4(t) {
    return t instanceof HTMLElement || t instanceof Ha(t).HTMLElement
}

function h9(t) {
    return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Ha(t).ShadowRoot
}

function Qq(t) {
    const {
        overflow: e,
        overflowX: n,
        overflowY: r,
        display: i
    } = G4(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i)
}

function Pbe() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}

function Ibe(t) {
    return ["html", "body", "#document"].includes(Xq(t))
}

function G4(t) {
    return Ha(t).getComputedStyle(t)
}

function Rbe(t) {
    if (Xq(t) === "html") return t;
    const e = t.assignedSlot || t.parentNode || h9(t) && t.host || Jq(t);
    return h9(e) ? e.host : e
}

function Zq(t) {
    const e = Rbe(t);
    return Ibe(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : $4(e) && Qq(e) ? e : Zq(e)
}

function Yw(t, e, n) {
    var r;
    e === void 0 && (e = []), n === void 0 && (n = !0);
    const i = Zq(t),
        s = i === ((r = t.ownerDocument) == null ? void 0 : r.body),
        o = Ha(i);
    return s ? e.concat(o, o.visualViewport || [], Qq(i) ? i : [], o.frameElement && n ? Yw(o.frameElement) : []) : e.concat(i, Yw(i, [], n))
}

function Obe(t) {
    const e = G4(t);
    let n = parseFloat(e.width) || 0,
        r = parseFloat(e.height) || 0;
    const i = $4(t),
        s = i ? t.offsetWidth : n,
        o = i ? t.offsetHeight : r,
        a = Xw(n) !== s || Xw(r) !== o;
    return a && (n = s, r = o), {
        width: n,
        height: r,
        $: a
    }
}

function V4(t) {
    return sR(t) ? t : t.contextElement
}

function wT(t) {
    const e = V4(t);
    if (!$4(e)) return Jw(1);
    const n = e.getBoundingClientRect(),
        {
            width: r,
            height: i,
            $: s
        } = Obe(e);
    let o = (s ? Xw(n.width) : n.width) / r,
        a = (s ? Xw(n.height) : n.height) / i;
    return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
        x: o,
        y: a
    }
}
const Dbe = Jw(0);

function Lbe(t) {
    const e = Ha(t);
    return !Pbe() || !e.visualViewport ? Dbe : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}

function kbe(t, e, n) {
    return e === void 0 && (e = !1), !n || e && n !== Ha(t) ? !1 : e
}

function m9(t, e, n, r) {
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    const i = t.getBoundingClientRect(),
        s = V4(t);
    let o = Jw(1);
    e && (r ? sR(r) && (o = wT(r)) : o = wT(t));
    const a = kbe(s, n, r) ? Lbe(s) : Jw(0);
    let l = (i.left + a.x) / o.x,
        u = (i.top + a.y) / o.y,
        c = i.width / o.x,
        f = i.height / o.y;
    if (s) {
        const d = Ha(s),
            p = r && sR(r) ? Ha(r) : r;
        let m = d,
            y = m.frameElement;
        for (; y && r && p !== m;) {
            const v = wT(y),
                b = y.getBoundingClientRect(),
                _ = G4(y),
                x = b.left + (y.clientLeft + parseFloat(_.paddingLeft)) * v.x,
                S = b.top + (y.clientTop + parseFloat(_.paddingTop)) * v.y;
            l *= v.x, u *= v.y, c *= v.x, f *= v.y, l += x, u += S, m = Ha(y), y = m.frameElement
        }
    }
    return Abe({
        width: c,
        height: f,
        x: l,
        y: u
    })
}

function Bbe(t, e) {
    let n = null,
        r;
    const i = Jq(t);

    function s() {
        var a;
        clearTimeout(r), (a = n) == null || a.disconnect(), n = null
    }

    function o(a, l) {
        a === void 0 && (a = !1), l === void 0 && (l = 1), s();
        const {
            left: u,
            top: c,
            width: f,
            height: d
        } = t.getBoundingClientRect();
        if (a || e(), !f || !d) return;
        const p = h_(c),
            m = h_(i.clientWidth - (u + f)),
            y = h_(i.clientHeight - (c + d)),
            v = h_(u),
            _ = {
                rootMargin: -p + "px " + -m + "px " + -y + "px " + -v + "px",
                threshold: Tbe(0, Mbe(1, l)) || 1
            };
        let x = !0;

        function S(E) {
            const A = E[0].intersectionRatio;
            if (A !== l) {
                if (!x) return o();
                A ? o(!1, A) : r = setTimeout(() => {
                    o(!1, 1e-7)
                }, 100)
            }
            x = !1
        }
        try {
            n = new IntersectionObserver(S, { ..._,
                root: i.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(S, _)
        }
        n.observe(t)
    }
    return o(!0), s
}

function Fbe(t, e, n, r) {
    r === void 0 && (r = {});
    const {
        ancestorScroll: i = !0,
        ancestorResize: s = !0,
        elementResize: o = typeof ResizeObserver == "function",
        layoutShift: a = typeof IntersectionObserver == "function",
        animationFrame: l = !1
    } = r, u = V4(t), c = i || s ? [...u ? Yw(u) : [], ...Yw(e)] : [];
    c.forEach(b => {
        i && b.addEventListener("scroll", n, {
            passive: !0
        }), s && b.addEventListener("resize", n)
    });
    const f = u && a ? Bbe(u, n) : null;
    let d = -1,
        p = null;
    o && (p = new ResizeObserver(b => {
        let [_] = b;
        _ && _.target === u && p && (p.unobserve(e), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
            var x;
            (x = p) == null || x.observe(e)
        })), n()
    }), u && !l && p.observe(u), p.observe(e));
    let m, y = l ? m9(t) : null;
    l && v();

    function v() {
        const b = m9(t);
        y && (b.x !== y.x || b.y !== y.y || b.width !== y.width || b.height !== y.height) && n(), y = b, m = requestAnimationFrame(v)
    }
    return n(), () => {
        var b;
        c.forEach(_ => {
            i && _.removeEventListener("scroll", n), s && _.removeEventListener("resize", n)
        }), f == null || f(), (b = p) == null || b.disconnect(), p = null, l && cancelAnimationFrame(m)
    }
}
var oR = P.useLayoutEffect,
    Nbe = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"],
    Qw = function() {};

function zbe(t, e) {
    return e ? e[0] === "-" ? t + e : t + "__" + e : t
}

function Hbe(t, e) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++) r[i - 2] = arguments[i];
    var s = [].concat(r);
    if (e && t)
        for (var o in e) e.hasOwnProperty(o) && e[o] && s.push("".concat(zbe(t, o)));
    return s.filter(function(a) {
        return a
    }).map(function(a) {
        return String(a).trim()
    }).join(" ")
}
var g9 = function(e) {
        return Xbe(e) ? e.filter(Boolean) : yi(e) === "object" && e !== null ? [e] : []
    },
    eX = function(e) {
        e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
        var n = zu(e, Nbe);
        return et({}, n)
    },
    Nr = function(e, n, r) {
        var i = e.cx,
            s = e.getStyles,
            o = e.getClassNames,
            a = e.className;
        return {
            css: s(n, e),
            className: i(r ? ? {}, o(n, e), a)
        }
    };

function hA(t) {
    return [document.documentElement, document.body, window].indexOf(t) > -1
}

function Ube(t) {
    return hA(t) ? window.innerHeight : t.clientHeight
}

function tX(t) {
    return hA(t) ? window.pageYOffset : t.scrollTop
}

function Zw(t, e) {
    if (hA(t)) {
        window.scrollTo(0, e);
        return
    }
    t.scrollTop = e
}

function $be(t) {
    var e = getComputedStyle(t),
        n = e.position === "absolute",
        r = /(auto|scroll)/;
    if (e.position === "fixed") return document.documentElement;
    for (var i = t; i = i.parentElement;)
        if (e = getComputedStyle(i), !(n && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX)) return i;
    return document.documentElement
}

function Gbe(t, e, n, r) {
    return n * ((t = t / r - 1) * t * t + 1) + e
}

function m_(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200,
        r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Qw,
        i = tX(t),
        s = e - i,
        o = 10,
        a = 0;

    function l() {
        a += o;
        var u = Gbe(a, i, s, n);
        Zw(t, u), a < n ? window.requestAnimationFrame(l) : r(t)
    }
    l()
}

function y9(t, e) {
    var n = t.getBoundingClientRect(),
        r = e.getBoundingClientRect(),
        i = e.offsetHeight / 3;
    r.bottom + i > n.bottom ? Zw(t, Math.min(e.offsetTop + e.clientHeight - t.offsetHeight + i, t.scrollHeight)) : r.top - i < n.top && Zw(t, Math.max(e.offsetTop - i, 0))
}

function Vbe(t) {
    var e = t.getBoundingClientRect();
    return {
        bottom: e.bottom,
        height: e.height,
        left: e.left,
        right: e.right,
        top: e.top,
        width: e.width
    }
}

function v9() {
    try {
        return document.createEvent("TouchEvent"), !0
    } catch {
        return !1
    }
}

function jbe() {
    try {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    } catch {
        return !1
    }
}
var nX = !1,
    Wbe = {
        get passive() {
            return nX = !0
        }
    },
    g_ = typeof window < "u" ? window : {};
g_.addEventListener && g_.removeEventListener && (g_.addEventListener("p", Qw, Wbe), g_.removeEventListener("p", Qw, !1));
var Kbe = nX;

function qbe(t) {
    return t != null
}

function Xbe(t) {
    return Array.isArray(t)
}

function y_(t, e, n) {
    return t ? e : n
}
var Jbe = function(e) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
    var s = Object.entries(e).filter(function(o) {
        var a = ln(o, 1),
            l = a[0];
        return !r.includes(l)
    });
    return s.reduce(function(o, a) {
        var l = ln(a, 2),
            u = l[0],
            c = l[1];
        return o[u] = c, o
    }, {})
};

function Ybe(t) {
    var e = t.maxHeight,
        n = t.menuEl,
        r = t.minHeight,
        i = t.placement,
        s = t.shouldScroll,
        o = t.isFixedPosition,
        a = t.controlHeight,
        l = $be(n),
        u = {
            placement: "bottom",
            maxHeight: e
        };
    if (!n || !n.offsetParent) return u;
    var c = l.getBoundingClientRect(),
        f = c.height,
        d = n.getBoundingClientRect(),
        p = d.bottom,
        m = d.height,
        y = d.top,
        v = n.offsetParent.getBoundingClientRect(),
        b = v.top,
        _ = o ? window.innerHeight : Ube(l),
        x = tX(l),
        S = parseInt(getComputedStyle(n).marginBottom, 10),
        E = parseInt(getComputedStyle(n).marginTop, 10),
        A = b - E,
        T = _ - y,
        M = A + x,
        I = f - x - y,
        O = p - _ + x + S,
        k = x + y - E,
        H = 160;
    switch (i) {
        case "auto":
        case "bottom":
            if (T >= m) return {
                placement: "bottom",
                maxHeight: e
            };
            if (I >= m && !o) return s && m_(l, O, H), {
                placement: "bottom",
                maxHeight: e
            };
            if (!o && I >= r || o && T >= r) {
                s && m_(l, O, H);
                var N = o ? T - S : I - S;
                return {
                    placement: "bottom",
                    maxHeight: N
                }
            }
            if (i === "auto" || o) {
                var B = e,
                    U = o ? A : M;
                return U >= r && (B = Math.min(U - S - a, e)), {
                    placement: "top",
                    maxHeight: B
                }
            }
            if (i === "bottom") return s && Zw(l, O), {
                placement: "bottom",
                maxHeight: e
            };
            break;
        case "top":
            if (A >= m) return {
                placement: "top",
                maxHeight: e
            };
            if (M >= m && !o) return s && m_(l, k, H), {
                placement: "top",
                maxHeight: e
            };
            if (!o && M >= r || o && A >= r) {
                var q = e;
                return (!o && M >= r || o && A >= r) && (q = o ? A - E : M - E), s && m_(l, k, H), {
                    placement: "top",
                    maxHeight: q
                }
            }
            return {
                placement: "bottom",
                maxHeight: e
            };
        default:
            throw new Error('Invalid placement provided "'.concat(i, '".'))
    }
    return u
}

function Qbe(t) {
    var e = {
        bottom: "top",
        top: "bottom"
    };
    return t ? e[t] : "bottom"
}
var rX = function(e) {
        return e === "auto" ? "bottom" : e
    },
    Zbe = function(e, n) {
        var r, i = e.placement,
            s = e.theme,
            o = s.borderRadius,
            a = s.spacing,
            l = s.colors;
        return et((r = {
            label: "menu"
        }, En(r, Qbe(i), "100%"), En(r, "position", "absolute"), En(r, "width", "100%"), En(r, "zIndex", 1), r), n ? {} : {
            backgroundColor: l.neutral0,
            borderRadius: o,
            boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
            marginBottom: a.menuGutter,
            marginTop: a.menuGutter
        })
    },
    iX = P.createContext(null),
    exe = function(e) {
        var n = e.children,
            r = e.minMenuHeight,
            i = e.maxMenuHeight,
            s = e.menuPlacement,
            o = e.menuPosition,
            a = e.menuShouldScrollIntoView,
            l = e.theme,
            u = P.useContext(iX) || {},
            c = u.setPortalPlacement,
            f = P.useRef(null),
            d = P.useState(i),
            p = ln(d, 2),
            m = p[0],
            y = p[1],
            v = P.useState(null),
            b = ln(v, 2),
            _ = b[0],
            x = b[1],
            S = l.spacing.controlHeight;
        return oR(function() {
            var E = f.current;
            if (E) {
                var A = o === "fixed",
                    T = a && !A,
                    M = Ybe({
                        maxHeight: i,
                        menuEl: E,
                        minHeight: r,
                        placement: s,
                        shouldScroll: T,
                        isFixedPosition: A,
                        controlHeight: S
                    });
                y(M.maxHeight), x(M.placement), c == null || c(M.placement)
            }
        }, [i, s, o, a, r, c, S]), n({
            ref: f,
            placerProps: et(et({}, e), {}, {
                placement: _ || rX(s),
                maxHeight: m
            })
        })
    },
    txe = function(e) {
        var n = e.children,
            r = e.innerRef,
            i = e.innerProps;
        return Ut("div", Y({}, Nr(e, "menu", {
            menu: !0
        }), {
            ref: r
        }, i), n)
    },
    nxe = function(e, n) {
        var r = e.maxHeight,
            i = e.theme.spacing.baseUnit;
        return et({
            maxHeight: r,
            overflowY: "auto",
            position: "relative",
            WebkitOverflowScrolling: "touch"
        }, n ? {} : {
            paddingBottom: i,
            paddingTop: i
        })
    },
    rxe = function(e) {
        var n = e.children,
            r = e.innerProps,
            i = e.innerRef,
            s = e.isMulti;
        return Ut("div", Y({}, Nr(e, "menuList", {
            "menu-list": !0,
            "menu-list--is-multi": s
        }), {
            ref: i
        }, r), n)
    },
    sX = function(e, n) {
        var r = e.theme,
            i = r.spacing.baseUnit,
            s = r.colors;
        return et({
            textAlign: "center"
        }, n ? {} : {
            color: s.neutral40,
            padding: "".concat(i * 2, "px ").concat(i * 3, "px")
        })
    },
    ixe = sX,
    sxe = sX,
    oX = function(e) {
        var n = e.children,
            r = e.innerProps;
        return Ut("div", Y({}, Nr(e, "noOptionsMessage", {
            "menu-notice": !0,
            "menu-notice--no-options": !0
        }), r), n)
    };
oX.defaultProps = {
    children: "No options"
};
var aX = function(e) {
    var n = e.children,
        r = e.innerProps;
    return Ut("div", Y({}, Nr(e, "loadingMessage", {
        "menu-notice": !0,
        "menu-notice--loading": !0
    }), r), n)
};
aX.defaultProps = {
    children: "Loading..."
};
var oxe = function(e) {
        var n = e.rect,
            r = e.offset,
            i = e.position;
        return {
            left: n.left,
            position: i,
            top: r,
            width: n.width,
            zIndex: 1
        }
    },
    axe = function(e) {
        var n = e.appendTo,
            r = e.children,
            i = e.controlElement,
            s = e.innerProps,
            o = e.menuPlacement,
            a = e.menuPosition,
            l = P.useRef(null),
            u = P.useRef(null),
            c = P.useState(rX(o)),
            f = ln(c, 2),
            d = f[0],
            p = f[1],
            m = P.useMemo(function() {
                return {
                    setPortalPlacement: p
                }
            }, []),
            y = P.useState(null),
            v = ln(y, 2),
            b = v[0],
            _ = v[1],
            x = P.useCallback(function() {
                if (i) {
                    var T = Vbe(i),
                        M = a === "fixed" ? 0 : window.pageYOffset,
                        I = T[d] + M;
                    (I !== (b == null ? void 0 : b.offset) || T.left !== (b == null ? void 0 : b.rect.left) || T.width !== (b == null ? void 0 : b.rect.width)) && _({
                        offset: I,
                        rect: T
                    })
                }
            }, [i, a, d, b == null ? void 0 : b.offset, b == null ? void 0 : b.rect.left, b == null ? void 0 : b.rect.width]);
        oR(function() {
            x()
        }, [x]);
        var S = P.useCallback(function() {
            typeof u.current == "function" && (u.current(), u.current = null), i && l.current && (u.current = Fbe(i, l.current, x, {
                elementResize: "ResizeObserver" in window
            }))
        }, [i, x]);
        oR(function() {
            S()
        }, [S]);
        var E = P.useCallback(function(T) {
            l.current = T, S()
        }, [S]);
        if (!n && a !== "fixed" || !b) return null;
        var A = Ut("div", Y({
            ref: E
        }, Nr(et(et({}, e), {}, {
            offset: b.offset,
            position: a,
            rect: b.rect
        }), "menuPortal", {
            "menu-portal": !0
        }), s), r);
        return Ut(iX.Provider, {
            value: m
        }, n ? r1.createPortal(A, n) : A)
    },
    lxe = function(e) {
        var n = e.isDisabled,
            r = e.isRtl;
        return {
            label: "container",
            direction: r ? "rtl" : void 0,
            pointerEvents: n ? "none" : void 0,
            position: "relative"
        }
    },
    uxe = function(e) {
        var n = e.children,
            r = e.innerProps,
            i = e.isDisabled,
            s = e.isRtl;
        return Ut("div", Y({}, Nr(e, "container", {
            "--is-disabled": i,
            "--is-rtl": s
        }), r), n)
    },
    cxe = function(e, n) {
        var r = e.theme.spacing,
            i = e.isMulti,
            s = e.hasValue,
            o = e.selectProps.controlShouldRenderValue;
        return et({
            alignItems: "center",
            display: i && s && o ? "flex" : "grid",
            flex: 1,
            flexWrap: "wrap",
            WebkitOverflowScrolling: "touch",
            position: "relative",
            overflow: "hidden"
        }, n ? {} : {
            padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
        })
    },
    fxe = function(e) {
        var n = e.children,
            r = e.innerProps,
            i = e.isMulti,
            s = e.hasValue;
        return Ut("div", Y({}, Nr(e, "valueContainer", {
            "value-container": !0,
            "value-container--is-multi": i,
            "value-container--has-value": s
        }), r), n)
    },
    dxe = function() {
        return {
            alignItems: "center",
            alignSelf: "stretch",
            display: "flex",
            flexShrink: 0
        }
    },
    pxe = function(e) {
        var n = e.children,
            r = e.innerProps;
        return Ut("div", Y({}, Nr(e, "indicatorsContainer", {
            indicators: !0
        }), r), n)
    },
    b9, hxe = ["size"],
    mxe = {
        name: "8mmkcg",
        styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
    },
    lX = function(e) {
        var n = e.size,
            r = zu(e, hxe);
        return Ut("svg", Y({
            height: n,
            width: n,
            viewBox: "0 0 20 20",
            "aria-hidden": "true",
            focusable: "false",
            css: mxe
        }, r))
    },
    j4 = function(e) {
        return Ut(lX, Y({
            size: 20
        }, e), Ut("path", {
            d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
        }))
    },
    uX = function(e) {
        return Ut(lX, Y({
            size: 20
        }, e), Ut("path", {
            d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
        }))
    },
    cX = function(e, n) {
        var r = e.isFocused,
            i = e.theme,
            s = i.spacing.baseUnit,
            o = i.colors;
        return et({
            label: "indicatorContainer",
            display: "flex",
            transition: "color 150ms"
        }, n ? {} : {
            color: r ? o.neutral60 : o.neutral20,
            padding: s * 2,
            ":hover": {
                color: r ? o.neutral80 : o.neutral40
            }
        })
    },
    gxe = cX,
    yxe = function(e) {
        var n = e.children,
            r = e.innerProps;
        return Ut("div", Y({}, Nr(e, "dropdownIndicator", {
            indicator: !0,
            "dropdown-indicator": !0
        }), r), n || Ut(uX, null))
    },
    vxe = cX,
    bxe = function(e) {
        var n = e.children,
            r = e.innerProps;
        return Ut("div", Y({}, Nr(e, "clearIndicator", {
            indicator: !0,
            "clear-indicator": !0
        }), r), n || Ut(j4, null))
    },
    xxe = function(e, n) {
        var r = e.isDisabled,
            i = e.theme,
            s = i.spacing.baseUnit,
            o = i.colors;
        return et({
            label: "indicatorSeparator",
            alignSelf: "stretch",
            width: 1
        }, n ? {} : {
            backgroundColor: r ? o.neutral10 : o.neutral20,
            marginBottom: s * 2,
            marginTop: s * 2
        })
    },
    _xe = function(e) {
        var n = e.innerProps;
        return Ut("span", Y({}, n, Nr(e, "indicatorSeparator", {
            "indicator-separator": !0
        })))
    },
    Sxe = G1(b9 || (b9 = Ebe([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))),
    wxe = function(e, n) {
        var r = e.isFocused,
            i = e.size,
            s = e.theme,
            o = s.colors,
            a = s.spacing.baseUnit;
        return et({
            label: "loadingIndicator",
            display: "flex",
            transition: "color 150ms",
            alignSelf: "center",
            fontSize: i,
            lineHeight: 1,
            marginRight: i,
            textAlign: "center",
            verticalAlign: "middle"
        }, n ? {} : {
            color: r ? o.neutral60 : o.neutral20,
            padding: a * 2
        })
    },
    ET = function(e) {
        var n = e.delay,
            r = e.offset;
        return Ut("span", {
            css: pA({
                animation: "".concat(Sxe, " 1s ease-in-out ").concat(n, "ms infinite;"),
                backgroundColor: "currentColor",
                borderRadius: "1em",
                display: "inline-block",
                marginLeft: r ? "1em" : void 0,
                height: "1em",
                verticalAlign: "top",
                width: "1em"
            }, "", "")
        })
    },
    fX = function(e) {
        var n = e.innerProps,
            r = e.isRtl;
        return Ut("div", Y({}, Nr(e, "loadingIndicator", {
            indicator: !0,
            "loading-indicator": !0
        }), n), Ut(ET, {
            delay: 0,
            offset: r
        }), Ut(ET, {
            delay: 160,
            offset: !0
        }), Ut(ET, {
            delay: 320,
            offset: !r
        }))
    };
fX.defaultProps = {
    size: 4
};
var Exe = function(e, n) {
        var r = e.isDisabled,
            i = e.isFocused,
            s = e.theme,
            o = s.colors,
            a = s.borderRadius,
            l = s.spacing;
        return et({
            label: "control",
            alignItems: "center",
            cursor: "default",
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "space-between",
            minHeight: l.controlHeight,
            outline: "0 !important",
            position: "relative",
            transition: "all 100ms"
        }, n ? {} : {
            backgroundColor: r ? o.neutral5 : o.neutral0,
            borderColor: r ? o.neutral10 : i ? o.primary : o.neutral20,
            borderRadius: a,
            borderStyle: "solid",
            borderWidth: 1,
            boxShadow: i ? "0 0 0 1px ".concat(o.primary) : void 0,
            "&:hover": {
                borderColor: i ? o.primary : o.neutral30
            }
        })
    },
    Axe = function(e) {
        var n = e.children,
            r = e.isDisabled,
            i = e.isFocused,
            s = e.innerRef,
            o = e.innerProps,
            a = e.menuIsOpen;
        return Ut("div", Y({
            ref: s
        }, Nr(e, "control", {
            control: !0,
            "control--is-disabled": r,
            "control--is-focused": i,
            "control--menu-is-open": a
        }), o), n)
    },
    Cxe = ["data"],
    Mxe = function(e, n) {
        var r = e.theme.spacing;
        return n ? {} : {
            paddingBottom: r.baseUnit * 2,
            paddingTop: r.baseUnit * 2
        }
    },
    Txe = function(e) {
        var n = e.children,
            r = e.cx,
            i = e.getStyles,
            s = e.getClassNames,
            o = e.Heading,
            a = e.headingProps,
            l = e.innerProps,
            u = e.label,
            c = e.theme,
            f = e.selectProps;
        return Ut("div", Y({}, Nr(e, "group", {
            group: !0
        }), l), Ut(o, Y({}, a, {
            selectProps: f,
            theme: c,
            getStyles: i,
            getClassNames: s,
            cx: r
        }), u), Ut("div", null, n))
    },
    Pxe = function(e, n) {
        var r = e.theme,
            i = r.colors,
            s = r.spacing;
        return et({
            label: "group",
            cursor: "default",
            display: "block"
        }, n ? {} : {
            color: i.neutral40,
            fontSize: "75%",
            fontWeight: 500,
            marginBottom: "0.25em",
            paddingLeft: s.baseUnit * 3,
            paddingRight: s.baseUnit * 3,
            textTransform: "uppercase"
        })
    },
    Ixe = function(e) {
        var n = eX(e);
        n.data;
        var r = zu(n, Cxe);
        return Ut("div", Y({}, Nr(e, "groupHeading", {
            "group-heading": !0
        }), r))
    },
    Rxe = ["innerRef", "isDisabled", "isHidden", "inputClassName"],
    Oxe = function(e, n) {
        var r = e.isDisabled,
            i = e.value,
            s = e.theme,
            o = s.spacing,
            a = s.colors;
        return et(et({
            visibility: r ? "hidden" : "visible",
            transform: i ? "translateZ(0)" : ""
        }, Dxe), n ? {} : {
            margin: o.baseUnit / 2,
            paddingBottom: o.baseUnit / 2,
            paddingTop: o.baseUnit / 2,
            color: a.neutral80
        })
    },
    dX = {
        gridArea: "1 / 2",
        font: "inherit",
        minWidth: "2px",
        border: 0,
        margin: 0,
        outline: 0,
        padding: 0
    },
    Dxe = {
        flex: "1 1 auto",
        display: "inline-grid",
        gridArea: "1 / 1 / 2 / 3",
        gridTemplateColumns: "0 min-content",
        "&:after": et({
            content: 'attr(data-value) " "',
            visibility: "hidden",
            whiteSpace: "pre"
        }, dX)
    },
    Lxe = function(e) {
        return et({
            label: "input",
            color: "inherit",
            background: 0,
            opacity: e ? 0 : 1,
            width: "100%"
        }, dX)
    },
    kxe = function(e) {
        var n = e.cx,
            r = e.value,
            i = eX(e),
            s = i.innerRef,
            o = i.isDisabled,
            a = i.isHidden,
            l = i.inputClassName,
            u = zu(i, Rxe);
        return Ut("div", Y({}, Nr(e, "input", {
            "input-container": !0
        }), {
            "data-value": r || ""
        }), Ut("input", Y({
            className: n({
                input: !0
            }, l),
            ref: s,
            style: Lxe(a),
            disabled: o
        }, u)))
    },
    Bxe = function(e, n) {
        var r = e.theme,
            i = r.spacing,
            s = r.borderRadius,
            o = r.colors;
        return et({
            label: "multiValue",
            display: "flex",
            minWidth: 0
        }, n ? {} : {
            backgroundColor: o.neutral10,
            borderRadius: s / 2,
            margin: i.baseUnit / 2
        })
    },
    Fxe = function(e, n) {
        var r = e.theme,
            i = r.borderRadius,
            s = r.colors,
            o = e.cropWithEllipsis;
        return et({
            overflow: "hidden",
            textOverflow: o || o === void 0 ? "ellipsis" : void 0,
            whiteSpace: "nowrap"
        }, n ? {} : {
            borderRadius: i / 2,
            color: s.neutral80,
            fontSize: "85%",
            padding: 3,
            paddingLeft: 6
        })
    },
    Nxe = function(e, n) {
        var r = e.theme,
            i = r.spacing,
            s = r.borderRadius,
            o = r.colors,
            a = e.isFocused;
        return et({
            alignItems: "center",
            display: "flex"
        }, n ? {} : {
            borderRadius: s / 2,
            backgroundColor: a ? o.dangerLight : void 0,
            paddingLeft: i.baseUnit,
            paddingRight: i.baseUnit,
            ":hover": {
                backgroundColor: o.dangerLight,
                color: o.danger
            }
        })
    },
    pX = function(e) {
        var n = e.children,
            r = e.innerProps;
        return Ut("div", r, n)
    },
    zxe = pX,
    Hxe = pX;

function Uxe(t) {
    var e = t.children,
        n = t.innerProps;
    return Ut("div", Y({
        role: "button"
    }, n), e || Ut(j4, {
        size: 14
    }))
}
var $xe = function(e) {
        var n = e.children,
            r = e.components,
            i = e.data,
            s = e.innerProps,
            o = e.isDisabled,
            a = e.removeProps,
            l = e.selectProps,
            u = r.Container,
            c = r.Label,
            f = r.Remove;
        return Ut(u, {
            data: i,
            innerProps: et(et({}, Nr(e, "multiValue", {
                "multi-value": !0,
                "multi-value--is-disabled": o
            })), s),
            selectProps: l
        }, Ut(c, {
            data: i,
            innerProps: et({}, Nr(e, "multiValueLabel", {
                "multi-value__label": !0
            })),
            selectProps: l
        }, n), Ut(f, {
            data: i,
            innerProps: et(et({}, Nr(e, "multiValueRemove", {
                "multi-value__remove": !0
            })), {}, {
                "aria-label": "Remove ".concat(n || "option")
            }, a),
            selectProps: l
        }))
    },
    Gxe = function(e, n) {
        var r = e.isDisabled,
            i = e.isFocused,
            s = e.isSelected,
            o = e.theme,
            a = o.spacing,
            l = o.colors;
        return et({
            label: "option",
            cursor: "default",
            display: "block",
            fontSize: "inherit",
            width: "100%",
            userSelect: "none",
            WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
        }, n ? {} : {
            backgroundColor: s ? l.primary : i ? l.primary25 : "transparent",
            color: r ? l.neutral20 : s ? l.neutral0 : "inherit",
            padding: "".concat(a.baseUnit * 2, "px ").concat(a.baseUnit * 3, "px"),
            ":active": {
                backgroundColor: r ? void 0 : s ? l.primary : l.primary50
            }
        })
    },
    Vxe = function(e) {
        var n = e.children,
            r = e.isDisabled,
            i = e.isFocused,
            s = e.isSelected,
            o = e.innerRef,
            a = e.innerProps;
        return Ut("div", Y({}, Nr(e, "option", {
            option: !0,
            "option--is-disabled": r,
            "option--is-focused": i,
            "option--is-selected": s
        }), {
            ref: o,
            "aria-disabled": r
        }, a), n)
    },
    jxe = function(e, n) {
        var r = e.theme,
            i = r.spacing,
            s = r.colors;
        return et({
            label: "placeholder",
            gridArea: "1 / 1 / 2 / 3"
        }, n ? {} : {
            color: s.neutral50,
            marginLeft: i.baseUnit / 2,
            marginRight: i.baseUnit / 2
        })
    },
    Wxe = function(e) {
        var n = e.children,
            r = e.innerProps;
        return Ut("div", Y({}, Nr(e, "placeholder", {
            placeholder: !0
        }), r), n)
    },
    Kxe = function(e, n) {
        var r = e.isDisabled,
            i = e.theme,
            s = i.spacing,
            o = i.colors;
        return et({
            label: "singleValue",
            gridArea: "1 / 1 / 2 / 3",
            maxWidth: "100%",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
        }, n ? {} : {
            color: r ? o.neutral40 : o.neutral80,
            marginLeft: s.baseUnit / 2,
            marginRight: s.baseUnit / 2
        })
    },
    qxe = function(e) {
        var n = e.children,
            r = e.isDisabled,
            i = e.innerProps;
        return Ut("div", Y({}, Nr(e, "singleValue", {
            "single-value": !0,
            "single-value--is-disabled": r
        }), i), n)
    },
    Xxe = {
        ClearIndicator: bxe,
        Control: Axe,
        DropdownIndicator: yxe,
        DownChevron: uX,
        CrossIcon: j4,
        Group: Txe,
        GroupHeading: Ixe,
        IndicatorsContainer: pxe,
        IndicatorSeparator: _xe,
        Input: kxe,
        LoadingIndicator: fX,
        Menu: txe,
        MenuList: rxe,
        MenuPortal: axe,
        LoadingMessage: aX,
        NoOptionsMessage: oX,
        MultiValue: $xe,
        MultiValueContainer: zxe,
        MultiValueLabel: Hxe,
        MultiValueRemove: Uxe,
        Option: Vxe,
        Placeholder: Wxe,
        SelectContainer: uxe,
        SingleValue: qxe,
        ValueContainer: fxe
    },
    Jxe = function(e) {
        return et(et({}, Xxe), e.components)
    },
    x9 = Number.isNaN || function(e) {
        return typeof e == "number" && e !== e
    };

function Yxe(t, e) {
    return !!(t === e || x9(t) && x9(e))
}

function Qxe(t, e) {
    if (t.length !== e.length) return !1;
    for (var n = 0; n < t.length; n++)
        if (!Yxe(t[n], e[n])) return !1;
    return !0
}

function Zxe(t, e) {
    e === void 0 && (e = Qxe);
    var n = null;

    function r() {
        for (var i = [], s = 0; s < arguments.length; s++) i[s] = arguments[s];
        if (n && n.lastThis === this && e(i, n.lastArgs)) return n.lastResult;
        var o = t.apply(this, i);
        return n = {
            lastResult: o,
            lastArgs: i,
            lastThis: this
        }, o
    }
    return r.clear = function() {
        n = null
    }, r
}
var e_e = {
        name: "7pg0cj-a11yText",
        styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
    },
    _9 = function(e) {
        return Ut("span", Y({
            css: e_e
        }, e))
    },
    t_e = {
        guidance: function(e) {
            var n = e.isSearchable,
                r = e.isMulti,
                i = e.isDisabled,
                s = e.tabSelectsValue,
                o = e.context;
            switch (o) {
                case "menu":
                    return "Use Up and Down to choose options".concat(i ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(s ? ", press Tab to select the option and exit the menu" : "", ".");
                case "input":
                    return "".concat(e["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "");
                case "value":
                    return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
                default:
                    return ""
            }
        },
        onChange: function(e) {
            var n = e.action,
                r = e.label,
                i = r === void 0 ? "" : r,
                s = e.labels,
                o = e.isDisabled;
            switch (n) {
                case "deselect-option":
                case "pop-value":
                case "remove-value":
                    return "option ".concat(i, ", deselected.");
                case "clear":
                    return "All selected options have been cleared.";
                case "initial-input-focus":
                    return "option".concat(s.length > 1 ? "s" : "", " ").concat(s.join(","), ", selected.");
                case "select-option":
                    return o ? "option ".concat(i, " is disabled. Select another option.") : "option ".concat(i, ", selected.");
                default:
                    return ""
            }
        },
        onFocus: function(e) {
            var n = e.context,
                r = e.focused,
                i = e.options,
                s = e.label,
                o = s === void 0 ? "" : s,
                a = e.selectValue,
                l = e.isDisabled,
                u = e.isSelected,
                c = function(m, y) {
                    return m && m.length ? "".concat(m.indexOf(y) + 1, " of ").concat(m.length) : ""
                };
            if (n === "value" && a) return "value ".concat(o, " focused, ").concat(c(a, r), ".");
            if (n === "menu") {
                var f = l ? " disabled" : "",
                    d = "".concat(u ? "selected" : "focused").concat(f);
                return "option ".concat(o, " ").concat(d, ", ").concat(c(i, r), ".")
            }
            return ""
        },
        onFilter: function(e) {
            var n = e.inputValue,
                r = e.resultsMessage;
            return "".concat(r).concat(n ? " for search term " + n : "", ".")
        }
    },
    n_e = function(e) {
        var n = e.ariaSelection,
            r = e.focusedOption,
            i = e.focusedValue,
            s = e.focusableOptions,
            o = e.isFocused,
            a = e.selectValue,
            l = e.selectProps,
            u = e.id,
            c = l.ariaLiveMessages,
            f = l.getOptionLabel,
            d = l.inputValue,
            p = l.isMulti,
            m = l.isOptionDisabled,
            y = l.isSearchable,
            v = l.menuIsOpen,
            b = l.options,
            _ = l.screenReaderStatus,
            x = l.tabSelectsValue,
            S = l["aria-label"],
            E = l["aria-live"],
            A = P.useMemo(function() {
                return et(et({}, t_e), c || {})
            }, [c]),
            T = P.useMemo(function() {
                var B = "";
                if (n && A.onChange) {
                    var U = n.option,
                        q = n.options,
                        Q = n.removedValue,
                        F = n.removedValues,
                        G = n.value,
                        W = function(fe) {
                            return Array.isArray(fe) ? null : fe
                        },
                        se = Q || U || W(G),
                        ee = se ? f(se) : "",
                        ae = q || F || void 0,
                        de = ae ? ae.map(f) : [],
                        re = et({
                            isDisabled: se && m(se, a),
                            label: ee,
                            labels: de
                        }, n);
                    B = A.onChange(re)
                }
                return B
            }, [n, A, m, a, f]),
            M = P.useMemo(function() {
                var B = "",
                    U = r || i,
                    q = !!(r && a && a.includes(r));
                if (U && A.onFocus) {
                    var Q = {
                        focused: U,
                        label: f(U),
                        isDisabled: m(U, a),
                        isSelected: q,
                        options: s,
                        context: U === r ? "menu" : "value",
                        selectValue: a
                    };
                    B = A.onFocus(Q)
                }
                return B
            }, [r, i, f, m, A, s, a]),
            I = P.useMemo(function() {
                var B = "";
                if (v && b.length && A.onFilter) {
                    var U = _({
                        count: s.length
                    });
                    B = A.onFilter({
                        inputValue: d,
                        resultsMessage: U
                    })
                }
                return B
            }, [s, d, v, A, b, _]),
            O = P.useMemo(function() {
                var B = "";
                if (A.guidance) {
                    var U = i ? "value" : v ? "menu" : "input";
                    B = A.guidance({
                        "aria-label": S,
                        context: U,
                        isDisabled: r && m(r, a),
                        isMulti: p,
                        isSearchable: y,
                        tabSelectsValue: x
                    })
                }
                return B
            }, [S, r, i, p, m, y, v, A, a, x]),
            k = "".concat(M, " ").concat(I, " ").concat(O),
            H = Ut(P.Fragment, null, Ut("span", {
                id: "aria-selection"
            }, T), Ut("span", {
                id: "aria-context"
            }, k)),
            N = (n == null ? void 0 : n.action) === "initial-input-focus";
        return Ut(P.Fragment, null, Ut(_9, {
            id: u
        }, N && H), Ut(_9, {
            "aria-live": E,
            "aria-atomic": "false",
            "aria-relevant": "additions text"
        }, o && !N && H))
    },
    aR = [{
        base: "A",
        letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
    }, {
        base: "AA",
        letters: "Ꜳ"
    }, {
        base: "AE",
        letters: "ÆǼǢ"
    }, {
        base: "AO",
        letters: "Ꜵ"
    }, {
        base: "AU",
        letters: "Ꜷ"
    }, {
        base: "AV",
        letters: "ꜸꜺ"
    }, {
        base: "AY",
        letters: "Ꜽ"
    }, {
        base: "B",
        letters: "BⒷＢḂḄḆɃƂƁ"
    }, {
        base: "C",
        letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
    }, {
        base: "D",
        letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
    }, {
        base: "DZ",
        letters: "ǱǄ"
    }, {
        base: "Dz",
        letters: "ǲǅ"
    }, {
        base: "E",
        letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
    }, {
        base: "F",
        letters: "FⒻＦḞƑꝻ"
    }, {
        base: "G",
        letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
    }, {
        base: "H",
        letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
    }, {
        base: "I",
        letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
    }, {
        base: "J",
        letters: "JⒿＪĴɈ"
    }, {
        base: "K",
        letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
    }, {
        base: "L",
        letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
    }, {
        base: "LJ",
        letters: "Ǉ"
    }, {
        base: "Lj",
        letters: "ǈ"
    }, {
        base: "M",
        letters: "MⓂＭḾṀṂⱮƜ"
    }, {
        base: "N",
        letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
    }, {
        base: "NJ",
        letters: "Ǌ"
    }, {
        base: "Nj",
        letters: "ǋ"
    }, {
        base: "O",
        letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
    }, {
        base: "OI",
        letters: "Ƣ"
    }, {
        base: "OO",
        letters: "Ꝏ"
    }, {
        base: "OU",
        letters: "Ȣ"
    }, {
        base: "P",
        letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
    }, {
        base: "Q",
        letters: "QⓆＱꝖꝘɊ"
    }, {
        base: "R",
        letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
    }, {
        base: "S",
        letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
    }, {
        base: "T",
        letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
    }, {
        base: "TZ",
        letters: "Ꜩ"
    }, {
        base: "U",
        letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
    }, {
        base: "V",
        letters: "VⓋＶṼṾƲꝞɅ"
    }, {
        base: "VY",
        letters: "Ꝡ"
    }, {
        base: "W",
        letters: "WⓌＷẀẂŴẆẄẈⱲ"
    }, {
        base: "X",
        letters: "XⓍＸẊẌ"
    }, {
        base: "Y",
        letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
    }, {
        base: "Z",
        letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
    }, {
        base: "a",
        letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
    }, {
        base: "aa",
        letters: "ꜳ"
    }, {
        base: "ae",
        letters: "æǽǣ"
    }, {
        base: "ao",
        letters: "ꜵ"
    }, {
        base: "au",
        letters: "ꜷ"
    }, {
        base: "av",
        letters: "ꜹꜻ"
    }, {
        base: "ay",
        letters: "ꜽ"
    }, {
        base: "b",
        letters: "bⓑｂḃḅḇƀƃɓ"
    }, {
        base: "c",
        letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
    }, {
        base: "d",
        letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
    }, {
        base: "dz",
        letters: "ǳǆ"
    }, {
        base: "e",
        letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
    }, {
        base: "f",
        letters: "fⓕｆḟƒꝼ"
    }, {
        base: "g",
        letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
    }, {
        base: "h",
        letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
    }, {
        base: "hv",
        letters: "ƕ"
    }, {
        base: "i",
        letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
    }, {
        base: "j",
        letters: "jⓙｊĵǰɉ"
    }, {
        base: "k",
        letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
    }, {
        base: "l",
        letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
    }, {
        base: "lj",
        letters: "ǉ"
    }, {
        base: "m",
        letters: "mⓜｍḿṁṃɱɯ"
    }, {
        base: "n",
        letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
    }, {
        base: "nj",
        letters: "ǌ"
    }, {
        base: "o",
        letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
    }, {
        base: "oi",
        letters: "ƣ"
    }, {
        base: "ou",
        letters: "ȣ"
    }, {
        base: "oo",
        letters: "ꝏ"
    }, {
        base: "p",
        letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
    }, {
        base: "q",
        letters: "qⓠｑɋꝗꝙ"
    }, {
        base: "r",
        letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
    }, {
        base: "s",
        letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
    }, {
        base: "t",
        letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
    }, {
        base: "tz",
        letters: "ꜩ"
    }, {
        base: "u",
        letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
    }, {
        base: "v",
        letters: "vⓥｖṽṿʋꝟʌ"
    }, {
        base: "vy",
        letters: "ꝡ"
    }, {
        base: "w",
        letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
    }, {
        base: "x",
        letters: "xⓧｘẋẍ"
    }, {
        base: "y",
        letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
    }, {
        base: "z",
        letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
    }],
    r_e = new RegExp("[" + aR.map(function(t) {
        return t.letters
    }).join("") + "]", "g"),
    hX = {};
for (var AT = 0; AT < aR.length; AT++)
    for (var CT = aR[AT], MT = 0; MT < CT.letters.length; MT++) hX[CT.letters[MT]] = CT.base;
var mX = function(e) {
        return e.replace(r_e, function(n) {
            return hX[n]
        })
    },
    i_e = Zxe(mX),
    S9 = function(e) {
        return e.replace(/^\s+|\s+$/g, "")
    },
    s_e = function(e) {
        return "".concat(e.label, " ").concat(e.value)
    },
    o_e = function(e) {
        return function(n, r) {
            if (n.data.__isNew__) return !0;
            var i = et({
                    ignoreCase: !0,
                    ignoreAccents: !0,
                    stringify: s_e,
                    trim: !0,
                    matchFrom: "any"
                }, e),
                s = i.ignoreCase,
                o = i.ignoreAccents,
                a = i.stringify,
                l = i.trim,
                u = i.matchFrom,
                c = l ? S9(r) : r,
                f = l ? S9(a(n)) : a(n);
            return s && (c = c.toLowerCase(), f = f.toLowerCase()), o && (c = i_e(c), f = mX(f)), u === "start" ? f.substr(0, c.length) === c : f.indexOf(c) > -1
        }
    },
    a_e = ["innerRef"];

function l_e(t) {
    var e = t.innerRef,
        n = zu(t, a_e),
        r = Jbe(n, "onExited", "in", "enter", "exit", "appear");
    return Ut("input", Y({
        ref: e
    }, r, {
        css: pA({
            label: "dummyInput",
            background: 0,
            border: 0,
            caretColor: "transparent",
            fontSize: "inherit",
            gridArea: "1 / 1 / 2 / 3",
            outline: 0,
            padding: 0,
            width: 1,
            color: "transparent",
            left: -100,
            opacity: 0,
            position: "relative",
            transform: "scale(.01)"
        }, "", "")
    }))
}
var u_e = function(e) {
    e.preventDefault(), e.stopPropagation()
};

function c_e(t) {
    var e = t.isEnabled,
        n = t.onBottomArrive,
        r = t.onBottomLeave,
        i = t.onTopArrive,
        s = t.onTopLeave,
        o = P.useRef(!1),
        a = P.useRef(!1),
        l = P.useRef(0),
        u = P.useRef(null),
        c = P.useCallback(function(v, b) {
            if (u.current !== null) {
                var _ = u.current,
                    x = _.scrollTop,
                    S = _.scrollHeight,
                    E = _.clientHeight,
                    A = u.current,
                    T = b > 0,
                    M = S - E - x,
                    I = !1;
                M > b && o.current && (r && r(v), o.current = !1), T && a.current && (s && s(v), a.current = !1), T && b > M ? (n && !o.current && n(v), A.scrollTop = S, I = !0, o.current = !0) : !T && -b > x && (i && !a.current && i(v), A.scrollTop = 0, I = !0, a.current = !0), I && u_e(v)
            }
        }, [n, r, i, s]),
        f = P.useCallback(function(v) {
            c(v, v.deltaY)
        }, [c]),
        d = P.useCallback(function(v) {
            l.current = v.changedTouches[0].clientY
        }, []),
        p = P.useCallback(function(v) {
            var b = l.current - v.changedTouches[0].clientY;
            c(v, b)
        }, [c]),
        m = P.useCallback(function(v) {
            if (v) {
                var b = Kbe ? {
                    passive: !1
                } : !1;
                v.addEventListener("wheel", f, b), v.addEventListener("touchstart", d, b), v.addEventListener("touchmove", p, b)
            }
        }, [p, d, f]),
        y = P.useCallback(function(v) {
            v && (v.removeEventListener("wheel", f, !1), v.removeEventListener("touchstart", d, !1), v.removeEventListener("touchmove", p, !1))
        }, [p, d, f]);
    return P.useEffect(function() {
            if (e) {
                var v = u.current;
                return m(v),
                    function() {
                        y(v)
                    }
            }
        }, [e, m, y]),
        function(v) {
            u.current = v
        }
}
var w9 = ["boxSizing", "height", "overflow", "paddingRight", "position"],
    E9 = {
        boxSizing: "border-box",
        overflow: "hidden",
        position: "relative",
        height: "100%"
    };

function A9(t) {
    t.preventDefault()
}

function C9(t) {
    t.stopPropagation()
}

function M9() {
    var t = this.scrollTop,
        e = this.scrollHeight,
        n = t + this.offsetHeight;
    t === 0 ? this.scrollTop = 1 : n === e && (this.scrollTop = t - 1)
}

function T9() {
    return "ontouchstart" in window || navigator.maxTouchPoints
}
var P9 = !!(typeof window < "u" && window.document && window.document.createElement),
    My = 0,
    th = {
        capture: !1,
        passive: !1
    };

function f_e(t) {
    var e = t.isEnabled,
        n = t.accountForScrollbars,
        r = n === void 0 ? !0 : n,
        i = P.useRef({}),
        s = P.useRef(null),
        o = P.useCallback(function(l) {
            if (P9) {
                var u = document.body,
                    c = u && u.style;
                if (r && w9.forEach(function(m) {
                        var y = c && c[m];
                        i.current[m] = y
                    }), r && My < 1) {
                    var f = parseInt(i.current.paddingRight, 10) || 0,
                        d = document.body ? document.body.clientWidth : 0,
                        p = window.innerWidth - d + f || 0;
                    Object.keys(E9).forEach(function(m) {
                        var y = E9[m];
                        c && (c[m] = y)
                    }), c && (c.paddingRight = "".concat(p, "px"))
                }
                u && T9() && (u.addEventListener("touchmove", A9, th), l && (l.addEventListener("touchstart", M9, th), l.addEventListener("touchmove", C9, th))), My += 1
            }
        }, [r]),
        a = P.useCallback(function(l) {
            if (P9) {
                var u = document.body,
                    c = u && u.style;
                My = Math.max(My - 1, 0), r && My < 1 && w9.forEach(function(f) {
                    var d = i.current[f];
                    c && (c[f] = d)
                }), u && T9() && (u.removeEventListener("touchmove", A9, th), l && (l.removeEventListener("touchstart", M9, th), l.removeEventListener("touchmove", C9, th)))
            }
        }, [r]);
    return P.useEffect(function() {
            if (e) {
                var l = s.current;
                return o(l),
                    function() {
                        a(l)
                    }
            }
        }, [e, o, a]),
        function(l) {
            s.current = l
        }
}
var d_e = function() {
        return document.activeElement && document.activeElement.blur()
    },
    p_e = {
        name: "1kfdb0e",
        styles: "position:fixed;left:0;bottom:0;right:0;top:0"
    };

function h_e(t) {
    var e = t.children,
        n = t.lockEnabled,
        r = t.captureEnabled,
        i = r === void 0 ? !0 : r,
        s = t.onBottomArrive,
        o = t.onBottomLeave,
        a = t.onTopArrive,
        l = t.onTopLeave,
        u = c_e({
            isEnabled: i,
            onBottomArrive: s,
            onBottomLeave: o,
            onTopArrive: a,
            onTopLeave: l
        }),
        c = f_e({
            isEnabled: n
        }),
        f = function(p) {
            u(p), c(p)
        };
    return Ut(P.Fragment, null, n && Ut("div", {
        onClick: d_e,
        css: p_e
    }), e(f))
}
var m_e = {
        name: "1a0ro4n-requiredInput",
        styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
    },
    g_e = function(e) {
        var n = e.name,
            r = e.onFocus;
        return Ut("input", {
            required: !0,
            name: n,
            tabIndex: -1,
            onFocus: r,
            css: m_e,
            value: "",
            onChange: function() {}
        })
    },
    y_e = function(e) {
        return e.label
    },
    v_e = function(e) {
        return e.label
    },
    b_e = function(e) {
        return e.value
    },
    x_e = function(e) {
        return !!e.isDisabled
    },
    __e = {
        clearIndicator: vxe,
        container: lxe,
        control: Exe,
        dropdownIndicator: gxe,
        group: Mxe,
        groupHeading: Pxe,
        indicatorsContainer: dxe,
        indicatorSeparator: xxe,
        input: Oxe,
        loadingIndicator: wxe,
        loadingMessage: sxe,
        menu: Zbe,
        menuList: nxe,
        menuPortal: oxe,
        multiValue: Bxe,
        multiValueLabel: Fxe,
        multiValueRemove: Nxe,
        noOptionsMessage: ixe,
        option: Gxe,
        placeholder: jxe,
        singleValue: Kxe,
        valueContainer: cxe
    },
    S_e = {
        primary: "#2684FF",
        primary75: "#4C9AFF",
        primary50: "#B2D4FF",
        primary25: "#DEEBFF",
        danger: "#DE350B",
        dangerLight: "#FFBDAD",
        neutral0: "hsl(0, 0%, 100%)",
        neutral5: "hsl(0, 0%, 95%)",
        neutral10: "hsl(0, 0%, 90%)",
        neutral20: "hsl(0, 0%, 80%)",
        neutral30: "hsl(0, 0%, 70%)",
        neutral40: "hsl(0, 0%, 60%)",
        neutral50: "hsl(0, 0%, 50%)",
        neutral60: "hsl(0, 0%, 40%)",
        neutral70: "hsl(0, 0%, 30%)",
        neutral80: "hsl(0, 0%, 20%)",
        neutral90: "hsl(0, 0%, 10%)"
    },
    w_e = 4,
    gX = 4,
    E_e = 38,
    A_e = gX * 2,
    C_e = {
        baseUnit: gX,
        controlHeight: E_e,
        menuGutter: A_e
    },
    TT = {
        borderRadius: w_e,
        colors: S_e,
        spacing: C_e
    },
    M_e = {
        "aria-live": "polite",
        backspaceRemovesValue: !0,
        blurInputOnSelect: v9(),
        captureMenuScroll: !v9(),
        classNames: {},
        closeMenuOnSelect: !0,
        closeMenuOnScroll: !1,
        components: {},
        controlShouldRenderValue: !0,
        escapeClearsValue: !1,
        filterOption: o_e(),
        formatGroupLabel: y_e,
        getOptionLabel: v_e,
        getOptionValue: b_e,
        isDisabled: !1,
        isLoading: !1,
        isMulti: !1,
        isRtl: !1,
        isSearchable: !0,
        isOptionDisabled: x_e,
        loadingMessage: function() {
            return "Loading..."
        },
        maxMenuHeight: 300,
        minMenuHeight: 140,
        menuIsOpen: !1,
        menuPlacement: "bottom",
        menuPosition: "absolute",
        menuShouldBlockScroll: !1,
        menuShouldScrollIntoView: !jbe(),
        noOptionsMessage: function() {
            return "No options"
        },
        openMenuOnFocus: !1,
        openMenuOnClick: !0,
        options: [],
        pageSize: 5,
        placeholder: "Select...",
        screenReaderStatus: function(e) {
            var n = e.count;
            return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available")
        },
        styles: {},
        tabIndex: 0,
        tabSelectsValue: !0,
        unstyled: !1
    };

function I9(t, e, n, r) {
    var i = xX(t, e, n),
        s = _X(t, e, n),
        o = bX(t, e),
        a = e2(t, e);
    return {
        type: "option",
        data: e,
        isDisabled: i,
        isSelected: s,
        label: o,
        value: a,
        index: r
    }
}

function yX(t, e) {
    return t.options.map(function(n, r) {
        if ("options" in n) {
            var i = n.options.map(function(o, a) {
                return I9(t, o, e, a)
            }).filter(function(o) {
                return R9(t, o)
            });
            return i.length > 0 ? {
                type: "group",
                data: n,
                options: i,
                index: r
            } : void 0
        }
        var s = I9(t, n, e, r);
        return R9(t, s) ? s : void 0
    }).filter(qbe)
}

function vX(t) {
    return t.reduce(function(e, n) {
        return n.type === "group" ? e.push.apply(e, zl(n.options.map(function(r) {
            return r.data
        }))) : e.push(n.data), e
    }, [])
}

function T_e(t, e) {
    return vX(yX(t, e))
}

function R9(t, e) {
    var n = t.inputValue,
        r = n === void 0 ? "" : n,
        i = e.data,
        s = e.isSelected,
        o = e.label,
        a = e.value;
    return (!wX(t) || !s) && SX(t, {
        label: o,
        value: a,
        data: i
    }, r)
}

function P_e(t, e) {
    var n = t.focusedValue,
        r = t.selectValue,
        i = r.indexOf(n);
    if (i > -1) {
        var s = e.indexOf(n);
        if (s > -1) return n;
        if (i < e.length) return e[i]
    }
    return null
}

function I_e(t, e) {
    var n = t.focusedOption;
    return n && e.indexOf(n) > -1 ? n : e[0]
}
var bX = function(e, n) {
        return e.getOptionLabel(n)
    },
    e2 = function(e, n) {
        return e.getOptionValue(n)
    };

function xX(t, e, n) {
    return typeof t.isOptionDisabled == "function" ? t.isOptionDisabled(e, n) : !1
}

function _X(t, e, n) {
    if (n.indexOf(e) > -1) return !0;
    if (typeof t.isOptionSelected == "function") return t.isOptionSelected(e, n);
    var r = e2(t, e);
    return n.some(function(i) {
        return e2(t, i) === r
    })
}

function SX(t, e, n) {
    return t.filterOption ? t.filterOption(e, n) : !0
}
var wX = function(e) {
        var n = e.hideSelectedOptions,
            r = e.isMulti;
        return n === void 0 ? r : n
    },
    R_e = 1,
    EX = function(t) {
        H1(n, t);
        var e = L4(n);

        function n(r) {
            var i;
            if (Wu(this, n), i = e.call(this, r), i.state = {
                    ariaSelection: null,
                    focusedOption: null,
                    focusedValue: null,
                    inputIsHidden: !1,
                    isFocused: !1,
                    selectValue: [],
                    clearFocusValueOnUpdate: !1,
                    prevWasFocused: !1,
                    inputIsHiddenAfterUpdate: void 0,
                    prevProps: void 0
                }, i.blockOptionHover = !1, i.isComposing = !1, i.commonProps = void 0, i.initialTouchX = 0, i.initialTouchY = 0, i.instancePrefix = "", i.openAfterFocus = !1, i.scrollToFocusedOptionOnUpdate = !1, i.userIsDragging = void 0, i.controlRef = null, i.getControlRef = function(a) {
                    i.controlRef = a
                }, i.focusedOptionRef = null, i.getFocusedOptionRef = function(a) {
                    i.focusedOptionRef = a
                }, i.menuListRef = null, i.getMenuListRef = function(a) {
                    i.menuListRef = a
                }, i.inputRef = null, i.getInputRef = function(a) {
                    i.inputRef = a
                }, i.focus = i.focusInput, i.blur = i.blurInput, i.onChange = function(a, l) {
                    var u = i.props,
                        c = u.onChange,
                        f = u.name;
                    l.name = f, i.ariaOnChange(a, l), c(a, l)
                }, i.setValue = function(a, l, u) {
                    var c = i.props,
                        f = c.closeMenuOnSelect,
                        d = c.isMulti,
                        p = c.inputValue;
                    i.onInputChange("", {
                        action: "set-value",
                        prevInputValue: p
                    }), f && (i.setState({
                        inputIsHiddenAfterUpdate: !d
                    }), i.onMenuClose()), i.setState({
                        clearFocusValueOnUpdate: !0
                    }), i.onChange(a, {
                        action: l,
                        option: u
                    })
                }, i.selectOption = function(a) {
                    var l = i.props,
                        u = l.blurInputOnSelect,
                        c = l.isMulti,
                        f = l.name,
                        d = i.state.selectValue,
                        p = c && i.isOptionSelected(a, d),
                        m = i.isOptionDisabled(a, d);
                    if (p) {
                        var y = i.getOptionValue(a);
                        i.setValue(d.filter(function(v) {
                            return i.getOptionValue(v) !== y
                        }), "deselect-option", a)
                    } else if (!m) c ? i.setValue([].concat(zl(d), [a]), "select-option", a) : i.setValue(a, "select-option");
                    else {
                        i.ariaOnChange(a, {
                            action: "select-option",
                            option: a,
                            name: f
                        });
                        return
                    }
                    u && i.blurInput()
                }, i.removeValue = function(a) {
                    var l = i.props.isMulti,
                        u = i.state.selectValue,
                        c = i.getOptionValue(a),
                        f = u.filter(function(p) {
                            return i.getOptionValue(p) !== c
                        }),
                        d = y_(l, f, f[0] || null);
                    i.onChange(d, {
                        action: "remove-value",
                        removedValue: a
                    }), i.focusInput()
                }, i.clearValue = function() {
                    var a = i.state.selectValue;
                    i.onChange(y_(i.props.isMulti, [], null), {
                        action: "clear",
                        removedValues: a
                    })
                }, i.popValue = function() {
                    var a = i.props.isMulti,
                        l = i.state.selectValue,
                        u = l[l.length - 1],
                        c = l.slice(0, l.length - 1),
                        f = y_(a, c, c[0] || null);
                    i.onChange(f, {
                        action: "pop-value",
                        removedValue: u
                    })
                }, i.getValue = function() {
                    return i.state.selectValue
                }, i.cx = function() {
                    for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++) l[u] = arguments[u];
                    return Hbe.apply(void 0, [i.props.classNamePrefix].concat(l))
                }, i.getOptionLabel = function(a) {
                    return bX(i.props, a)
                }, i.getOptionValue = function(a) {
                    return e2(i.props, a)
                }, i.getStyles = function(a, l) {
                    var u = i.props.unstyled,
                        c = __e[a](l, u);
                    c.boxSizing = "border-box";
                    var f = i.props.styles[a];
                    return f ? f(c, l) : c
                }, i.getClassNames = function(a, l) {
                    var u, c;
                    return (u = (c = i.props.classNames)[a]) === null || u === void 0 ? void 0 : u.call(c, l)
                }, i.getElementId = function(a) {
                    return "".concat(i.instancePrefix, "-").concat(a)
                }, i.getComponents = function() {
                    return Jxe(i.props)
                }, i.buildCategorizedOptions = function() {
                    return yX(i.props, i.state.selectValue)
                }, i.getCategorizedOptions = function() {
                    return i.props.menuIsOpen ? i.buildCategorizedOptions() : []
                }, i.buildFocusableOptions = function() {
                    return vX(i.buildCategorizedOptions())
                }, i.getFocusableOptions = function() {
                    return i.props.menuIsOpen ? i.buildFocusableOptions() : []
                }, i.ariaOnChange = function(a, l) {
                    i.setState({
                        ariaSelection: et({
                            value: a
                        }, l)
                    })
                }, i.onMenuMouseDown = function(a) {
                    a.button === 0 && (a.stopPropagation(), a.preventDefault(), i.focusInput())
                }, i.onMenuMouseMove = function(a) {
                    i.blockOptionHover = !1
                }, i.onControlMouseDown = function(a) {
                    if (!a.defaultPrevented) {
                        var l = i.props.openMenuOnClick;
                        i.state.isFocused ? i.props.menuIsOpen ? a.target.tagName !== "INPUT" && a.target.tagName !== "TEXTAREA" && i.onMenuClose() : l && i.openMenu("first") : (l && (i.openAfterFocus = !0), i.focusInput()), a.target.tagName !== "INPUT" && a.target.tagName !== "TEXTAREA" && a.preventDefault()
                    }
                }, i.onDropdownIndicatorMouseDown = function(a) {
                    if (!(a && a.type === "mousedown" && a.button !== 0) && !i.props.isDisabled) {
                        var l = i.props,
                            u = l.isMulti,
                            c = l.menuIsOpen;
                        i.focusInput(), c ? (i.setState({
                            inputIsHiddenAfterUpdate: !u
                        }), i.onMenuClose()) : i.openMenu("first"), a.preventDefault()
                    }
                }, i.onClearIndicatorMouseDown = function(a) {
                    a && a.type === "mousedown" && a.button !== 0 || (i.clearValue(), a.preventDefault(), i.openAfterFocus = !1, a.type === "touchend" ? i.focusInput() : setTimeout(function() {
                        return i.focusInput()
                    }))
                }, i.onScroll = function(a) {
                    typeof i.props.closeMenuOnScroll == "boolean" ? a.target instanceof HTMLElement && hA(a.target) && i.props.onMenuClose() : typeof i.props.closeMenuOnScroll == "function" && i.props.closeMenuOnScroll(a) && i.props.onMenuClose()
                }, i.onCompositionStart = function() {
                    i.isComposing = !0
                }, i.onCompositionEnd = function() {
                    i.isComposing = !1
                }, i.onTouchStart = function(a) {
                    var l = a.touches,
                        u = l && l.item(0);
                    u && (i.initialTouchX = u.clientX, i.initialTouchY = u.clientY, i.userIsDragging = !1)
                }, i.onTouchMove = function(a) {
                    var l = a.touches,
                        u = l && l.item(0);
                    if (u) {
                        var c = Math.abs(u.clientX - i.initialTouchX),
                            f = Math.abs(u.clientY - i.initialTouchY),
                            d = 5;
                        i.userIsDragging = c > d || f > d
                    }
                }, i.onTouchEnd = function(a) {
                    i.userIsDragging || (i.controlRef && !i.controlRef.contains(a.target) && i.menuListRef && !i.menuListRef.contains(a.target) && i.blurInput(), i.initialTouchX = 0, i.initialTouchY = 0)
                }, i.onControlTouchEnd = function(a) {
                    i.userIsDragging || i.onControlMouseDown(a)
                }, i.onClearIndicatorTouchEnd = function(a) {
                    i.userIsDragging || i.onClearIndicatorMouseDown(a)
                }, i.onDropdownIndicatorTouchEnd = function(a) {
                    i.userIsDragging || i.onDropdownIndicatorMouseDown(a)
                }, i.handleInputChange = function(a) {
                    var l = i.props.inputValue,
                        u = a.currentTarget.value;
                    i.setState({
                        inputIsHiddenAfterUpdate: !1
                    }), i.onInputChange(u, {
                        action: "input-change",
                        prevInputValue: l
                    }), i.props.menuIsOpen || i.onMenuOpen()
                }, i.onInputFocus = function(a) {
                    i.props.onFocus && i.props.onFocus(a), i.setState({
                        inputIsHiddenAfterUpdate: !1,
                        isFocused: !0
                    }), (i.openAfterFocus || i.props.openMenuOnFocus) && i.openMenu("first"), i.openAfterFocus = !1
                }, i.onInputBlur = function(a) {
                    var l = i.props.inputValue;
                    if (i.menuListRef && i.menuListRef.contains(document.activeElement)) {
                        i.inputRef.focus();
                        return
                    }
                    i.props.onBlur && i.props.onBlur(a), i.onInputChange("", {
                        action: "input-blur",
                        prevInputValue: l
                    }), i.onMenuClose(), i.setState({
                        focusedValue: null,
                        isFocused: !1
                    })
                }, i.onOptionHover = function(a) {
                    i.blockOptionHover || i.state.focusedOption === a || i.setState({
                        focusedOption: a
                    })
                }, i.shouldHideSelectedOptions = function() {
                    return wX(i.props)
                }, i.onValueInputFocus = function(a) {
                    a.preventDefault(), a.stopPropagation(), i.focus()
                }, i.onKeyDown = function(a) {
                    var l = i.props,
                        u = l.isMulti,
                        c = l.backspaceRemovesValue,
                        f = l.escapeClearsValue,
                        d = l.inputValue,
                        p = l.isClearable,
                        m = l.isDisabled,
                        y = l.menuIsOpen,
                        v = l.onKeyDown,
                        b = l.tabSelectsValue,
                        _ = l.openMenuOnFocus,
                        x = i.state,
                        S = x.focusedOption,
                        E = x.focusedValue,
                        A = x.selectValue;
                    if (!m && !(typeof v == "function" && (v(a), a.defaultPrevented))) {
                        switch (i.blockOptionHover = !0, a.key) {
                            case "ArrowLeft":
                                if (!u || d) return;
                                i.focusValue("previous");
                                break;
                            case "ArrowRight":
                                if (!u || d) return;
                                i.focusValue("next");
                                break;
                            case "Delete":
                            case "Backspace":
                                if (d) return;
                                if (E) i.removeValue(E);
                                else {
                                    if (!c) return;
                                    u ? i.popValue() : p && i.clearValue()
                                }
                                break;
                            case "Tab":
                                if (i.isComposing || a.shiftKey || !y || !b || !S || _ && i.isOptionSelected(S, A)) return;
                                i.selectOption(S);
                                break;
                            case "Enter":
                                if (a.keyCode === 229) break;
                                if (y) {
                                    if (!S || i.isComposing) return;
                                    i.selectOption(S);
                                    break
                                }
                                return;
                            case "Escape":
                                y ? (i.setState({
                                    inputIsHiddenAfterUpdate: !1
                                }), i.onInputChange("", {
                                    action: "menu-close",
                                    prevInputValue: d
                                }), i.onMenuClose()) : p && f && i.clearValue();
                                break;
                            case " ":
                                if (d) return;
                                if (!y) {
                                    i.openMenu("first");
                                    break
                                }
                                if (!S) return;
                                i.selectOption(S);
                                break;
                            case "ArrowUp":
                                y ? i.focusOption("up") : i.openMenu("last");
                                break;
                            case "ArrowDown":
                                y ? i.focusOption("down") : i.openMenu("first");
                                break;
                            case "PageUp":
                                if (!y) return;
                                i.focusOption("pageup");
                                break;
                            case "PageDown":
                                if (!y) return;
                                i.focusOption("pagedown");
                                break;
                            case "Home":
                                if (!y) return;
                                i.focusOption("first");
                                break;
                            case "End":
                                if (!y) return;
                                i.focusOption("last");
                                break;
                            default:
                                return
                        }
                        a.preventDefault()
                    }
                }, i.instancePrefix = "react-select-" + (i.props.instanceId || ++R_e), i.state.selectValue = g9(r.value), r.menuIsOpen && i.state.selectValue.length) {
                var s = i.buildFocusableOptions(),
                    o = s.indexOf(i.state.selectValue[0]);
                i.state.focusedOption = s[o]
            }
            return i
        }
        return Ku(n, [{
            key: "componentDidMount",
            value: function() {
                this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && y9(this.menuListRef, this.focusedOptionRef)
            }
        }, {
            key: "componentDidUpdate",
            value: function(i) {
                var s = this.props,
                    o = s.isDisabled,
                    a = s.menuIsOpen,
                    l = this.state.isFocused;
                (l && !o && i.isDisabled || l && a && !i.menuIsOpen) && this.focusInput(), l && o && !i.isDisabled ? this.setState({
                    isFocused: !1
                }, this.onMenuClose) : !l && !o && i.isDisabled && this.inputRef === document.activeElement && this.setState({
                    isFocused: !0
                }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (y9(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1)
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0)
            }
        }, {
            key: "onMenuOpen",
            value: function() {
                this.props.onMenuOpen()
            }
        }, {
            key: "onMenuClose",
            value: function() {
                this.onInputChange("", {
                    action: "menu-close",
                    prevInputValue: this.props.inputValue
                }), this.props.onMenuClose()
            }
        }, {
            key: "onInputChange",
            value: function(i, s) {
                this.props.onInputChange(i, s)
            }
        }, {
            key: "focusInput",
            value: function() {
                this.inputRef && this.inputRef.focus()
            }
        }, {
            key: "blurInput",
            value: function() {
                this.inputRef && this.inputRef.blur()
            }
        }, {
            key: "openMenu",
            value: function(i) {
                var s = this,
                    o = this.state,
                    a = o.selectValue,
                    l = o.isFocused,
                    u = this.buildFocusableOptions(),
                    c = i === "first" ? 0 : u.length - 1;
                if (!this.props.isMulti) {
                    var f = u.indexOf(a[0]);
                    f > -1 && (c = f)
                }
                this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({
                    inputIsHiddenAfterUpdate: !1,
                    focusedValue: null,
                    focusedOption: u[c]
                }, function() {
                    return s.onMenuOpen()
                })
            }
        }, {
            key: "focusValue",
            value: function(i) {
                var s = this.state,
                    o = s.selectValue,
                    a = s.focusedValue;
                if (this.props.isMulti) {
                    this.setState({
                        focusedOption: null
                    });
                    var l = o.indexOf(a);
                    a || (l = -1);
                    var u = o.length - 1,
                        c = -1;
                    if (o.length) {
                        switch (i) {
                            case "previous":
                                l === 0 ? c = 0 : l === -1 ? c = u : c = l - 1;
                                break;
                            case "next":
                                l > -1 && l < u && (c = l + 1);
                                break
                        }
                        this.setState({
                            inputIsHidden: c !== -1,
                            focusedValue: o[c]
                        })
                    }
                }
            }
        }, {
            key: "focusOption",
            value: function() {
                var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first",
                    s = this.props.pageSize,
                    o = this.state.focusedOption,
                    a = this.getFocusableOptions();
                if (a.length) {
                    var l = 0,
                        u = a.indexOf(o);
                    o || (u = -1), i === "up" ? l = u > 0 ? u - 1 : a.length - 1 : i === "down" ? l = (u + 1) % a.length : i === "pageup" ? (l = u - s, l < 0 && (l = 0)) : i === "pagedown" ? (l = u + s, l > a.length - 1 && (l = a.length - 1)) : i === "last" && (l = a.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
                        focusedOption: a[l],
                        focusedValue: null
                    })
                }
            }
        }, {
            key: "getTheme",
            value: function() {
                return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(TT) : et(et({}, TT), this.props.theme) : TT
            }
        }, {
            key: "getCommonProps",
            value: function() {
                var i = this.clearValue,
                    s = this.cx,
                    o = this.getStyles,
                    a = this.getClassNames,
                    l = this.getValue,
                    u = this.selectOption,
                    c = this.setValue,
                    f = this.props,
                    d = f.isMulti,
                    p = f.isRtl,
                    m = f.options,
                    y = this.hasValue();
                return {
                    clearValue: i,
                    cx: s,
                    getStyles: o,
                    getClassNames: a,
                    getValue: l,
                    hasValue: y,
                    isMulti: d,
                    isRtl: p,
                    options: m,
                    selectOption: u,
                    selectProps: f,
                    setValue: c,
                    theme: this.getTheme()
                }
            }
        }, {
            key: "hasValue",
            value: function() {
                var i = this.state.selectValue;
                return i.length > 0
            }
        }, {
            key: "hasOptions",
            value: function() {
                return !!this.getFocusableOptions().length
            }
        }, {
            key: "isClearable",
            value: function() {
                var i = this.props,
                    s = i.isClearable,
                    o = i.isMulti;
                return s === void 0 ? o : s
            }
        }, {
            key: "isOptionDisabled",
            value: function(i, s) {
                return xX(this.props, i, s)
            }
        }, {
            key: "isOptionSelected",
            value: function(i, s) {
                return _X(this.props, i, s)
            }
        }, {
            key: "filterOption",
            value: function(i, s) {
                return SX(this.props, i, s)
            }
        }, {
            key: "formatOptionLabel",
            value: function(i, s) {
                if (typeof this.props.formatOptionLabel == "function") {
                    var o = this.props.inputValue,
                        a = this.state.selectValue;
                    return this.props.formatOptionLabel(i, {
                        context: s,
                        inputValue: o,
                        selectValue: a
                    })
                } else return this.getOptionLabel(i)
            }
        }, {
            key: "formatGroupLabel",
            value: function(i) {
                return this.props.formatGroupLabel(i)
            }
        }, {
            key: "startListeningComposition",
            value: function() {
                document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1))
            }
        }, {
            key: "stopListeningComposition",
            value: function() {
                document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd))
            }
        }, {
            key: "startListeningToTouch",
            value: function() {
                document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1))
            }
        }, {
            key: "stopListeningToTouch",
            value: function() {
                document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd))
            }
        }, {
            key: "renderInput",
            value: function() {
                var i = this.props,
                    s = i.isDisabled,
                    o = i.isSearchable,
                    a = i.inputId,
                    l = i.inputValue,
                    u = i.tabIndex,
                    c = i.form,
                    f = i.menuIsOpen,
                    d = i.required,
                    p = this.getComponents(),
                    m = p.Input,
                    y = this.state,
                    v = y.inputIsHidden,
                    b = y.ariaSelection,
                    _ = this.commonProps,
                    x = a || this.getElementId("input"),
                    S = et(et(et({
                        "aria-autocomplete": "list",
                        "aria-expanded": f,
                        "aria-haspopup": !0,
                        "aria-errormessage": this.props["aria-errormessage"],
                        "aria-invalid": this.props["aria-invalid"],
                        "aria-label": this.props["aria-label"],
                        "aria-labelledby": this.props["aria-labelledby"],
                        "aria-required": d,
                        role: "combobox"
                    }, f && {
                        "aria-controls": this.getElementId("listbox"),
                        "aria-owns": this.getElementId("listbox")
                    }), !o && {
                        "aria-readonly": !0
                    }), this.hasValue() ? (b == null ? void 0 : b.action) === "initial-input-focus" && {
                        "aria-describedby": this.getElementId("live-region")
                    } : {
                        "aria-describedby": this.getElementId("placeholder")
                    });
                return o ? P.createElement(m, Y({}, _, {
                    autoCapitalize: "none",
                    autoComplete: "off",
                    autoCorrect: "off",
                    id: x,
                    innerRef: this.getInputRef,
                    isDisabled: s,
                    isHidden: v,
                    onBlur: this.onInputBlur,
                    onChange: this.handleInputChange,
                    onFocus: this.onInputFocus,
                    spellCheck: "false",
                    tabIndex: u,
                    form: c,
                    type: "text",
                    value: l
                }, S)) : P.createElement(l_e, Y({
                    id: x,
                    innerRef: this.getInputRef,
                    onBlur: this.onInputBlur,
                    onChange: Qw,
                    onFocus: this.onInputFocus,
                    disabled: s,
                    tabIndex: u,
                    inputMode: "none",
                    form: c,
                    value: ""
                }, S))
            }
        }, {
            key: "renderPlaceholderOrValue",
            value: function() {
                var i = this,
                    s = this.getComponents(),
                    o = s.MultiValue,
                    a = s.MultiValueContainer,
                    l = s.MultiValueLabel,
                    u = s.MultiValueRemove,
                    c = s.SingleValue,
                    f = s.Placeholder,
                    d = this.commonProps,
                    p = this.props,
                    m = p.controlShouldRenderValue,
                    y = p.isDisabled,
                    v = p.isMulti,
                    b = p.inputValue,
                    _ = p.placeholder,
                    x = this.state,
                    S = x.selectValue,
                    E = x.focusedValue,
                    A = x.isFocused;
                if (!this.hasValue() || !m) return b ? null : P.createElement(f, Y({}, d, {
                    key: "placeholder",
                    isDisabled: y,
                    isFocused: A,
                    innerProps: {
                        id: this.getElementId("placeholder")
                    }
                }), _);
                if (v) return S.map(function(M, I) {
                    var O = M === E,
                        k = "".concat(i.getOptionLabel(M), "-").concat(i.getOptionValue(M));
                    return P.createElement(o, Y({}, d, {
                        components: {
                            Container: a,
                            Label: l,
                            Remove: u
                        },
                        isFocused: O,
                        isDisabled: y,
                        key: k,
                        index: I,
                        removeProps: {
                            onClick: function() {
                                return i.removeValue(M)
                            },
                            onTouchEnd: function() {
                                return i.removeValue(M)
                            },
                            onMouseDown: function(N) {
                                N.preventDefault()
                            }
                        },
                        data: M
                    }), i.formatOptionLabel(M, "value"))
                });
                if (b) return null;
                var T = S[0];
                return P.createElement(c, Y({}, d, {
                    data: T,
                    isDisabled: y
                }), this.formatOptionLabel(T, "value"))
            }
        }, {
            key: "renderClearIndicator",
            value: function() {
                var i = this.getComponents(),
                    s = i.ClearIndicator,
                    o = this.commonProps,
                    a = this.props,
                    l = a.isDisabled,
                    u = a.isLoading,
                    c = this.state.isFocused;
                if (!this.isClearable() || !s || l || !this.hasValue() || u) return null;
                var f = {
                    onMouseDown: this.onClearIndicatorMouseDown,
                    onTouchEnd: this.onClearIndicatorTouchEnd,
                    "aria-hidden": "true"
                };
                return P.createElement(s, Y({}, o, {
                    innerProps: f,
                    isFocused: c
                }))
            }
        }, {
            key: "renderLoadingIndicator",
            value: function() {
                var i = this.getComponents(),
                    s = i.LoadingIndicator,
                    o = this.commonProps,
                    a = this.props,
                    l = a.isDisabled,
                    u = a.isLoading,
                    c = this.state.isFocused;
                if (!s || !u) return null;
                var f = {
                    "aria-hidden": "true"
                };
                return P.createElement(s, Y({}, o, {
                    innerProps: f,
                    isDisabled: l,
                    isFocused: c
                }))
            }
        }, {
            key: "renderIndicatorSeparator",
            value: function() {
                var i = this.getComponents(),
                    s = i.DropdownIndicator,
                    o = i.IndicatorSeparator;
                if (!s || !o) return null;
                var a = this.commonProps,
                    l = this.props.isDisabled,
                    u = this.state.isFocused;
                return P.createElement(o, Y({}, a, {
                    isDisabled: l,
                    isFocused: u
                }))
            }
        }, {
            key: "renderDropdownIndicator",
            value: function() {
                var i = this.getComponents(),
                    s = i.DropdownIndicator;
                if (!s) return null;
                var o = this.commonProps,
                    a = this.props.isDisabled,
                    l = this.state.isFocused,
                    u = {
                        onMouseDown: this.onDropdownIndicatorMouseDown,
                        onTouchEnd: this.onDropdownIndicatorTouchEnd,
                        "aria-hidden": "true"
                    };
                return P.createElement(s, Y({}, o, {
                    innerProps: u,
                    isDisabled: a,
                    isFocused: l
                }))
            }
        }, {
            key: "renderMenu",
            value: function() {
                var i = this,
                    s = this.getComponents(),
                    o = s.Group,
                    a = s.GroupHeading,
                    l = s.Menu,
                    u = s.MenuList,
                    c = s.MenuPortal,
                    f = s.LoadingMessage,
                    d = s.NoOptionsMessage,
                    p = s.Option,
                    m = this.commonProps,
                    y = this.state.focusedOption,
                    v = this.props,
                    b = v.captureMenuScroll,
                    _ = v.inputValue,
                    x = v.isLoading,
                    S = v.loadingMessage,
                    E = v.minMenuHeight,
                    A = v.maxMenuHeight,
                    T = v.menuIsOpen,
                    M = v.menuPlacement,
                    I = v.menuPosition,
                    O = v.menuPortalTarget,
                    k = v.menuShouldBlockScroll,
                    H = v.menuShouldScrollIntoView,
                    N = v.noOptionsMessage,
                    B = v.onMenuScrollToTop,
                    U = v.onMenuScrollToBottom;
                if (!T) return null;
                var q = function(ae, de) {
                        var re = ae.type,
                            _e = ae.data,
                            fe = ae.isDisabled,
                            ue = ae.isSelected,
                            ve = ae.label,
                            xe = ae.value,
                            be = y === _e,
                            he = fe ? void 0 : function() {
                                return i.onOptionHover(_e)
                            },
                            me = fe ? void 0 : function() {
                                return i.selectOption(_e)
                            },
                            Ce = "".concat(i.getElementId("option"), "-").concat(de),
                            Ne = {
                                id: Ce,
                                onClick: me,
                                onMouseMove: he,
                                onMouseOver: he,
                                tabIndex: -1
                            };
                        return P.createElement(p, Y({}, m, {
                            innerProps: Ne,
                            data: _e,
                            isDisabled: fe,
                            isSelected: ue,
                            key: Ce,
                            label: ve,
                            type: re,
                            value: xe,
                            isFocused: be,
                            innerRef: be ? i.getFocusedOptionRef : void 0
                        }), i.formatOptionLabel(ae.data, "menu"))
                    },
                    Q;
                if (this.hasOptions()) Q = this.getCategorizedOptions().map(function(ee) {
                    if (ee.type === "group") {
                        var ae = ee.data,
                            de = ee.options,
                            re = ee.index,
                            _e = "".concat(i.getElementId("group"), "-").concat(re),
                            fe = "".concat(_e, "-heading");
                        return P.createElement(o, Y({}, m, {
                            key: _e,
                            data: ae,
                            options: de,
                            Heading: a,
                            headingProps: {
                                id: fe,
                                data: ee.data
                            },
                            label: i.formatGroupLabel(ee.data)
                        }), ee.options.map(function(ue) {
                            return q(ue, "".concat(re, "-").concat(ue.index))
                        }))
                    } else if (ee.type === "option") return q(ee, "".concat(ee.index))
                });
                else if (x) {
                    var F = S({
                        inputValue: _
                    });
                    if (F === null) return null;
                    Q = P.createElement(f, m, F)
                } else {
                    var G = N({
                        inputValue: _
                    });
                    if (G === null) return null;
                    Q = P.createElement(d, m, G)
                }
                var W = {
                        minMenuHeight: E,
                        maxMenuHeight: A,
                        menuPlacement: M,
                        menuPosition: I,
                        menuShouldScrollIntoView: H
                    },
                    se = P.createElement(exe, Y({}, m, W), function(ee) {
                        var ae = ee.ref,
                            de = ee.placerProps,
                            re = de.placement,
                            _e = de.maxHeight;
                        return P.createElement(l, Y({}, m, W, {
                            innerRef: ae,
                            innerProps: {
                                onMouseDown: i.onMenuMouseDown,
                                onMouseMove: i.onMenuMouseMove,
                                id: i.getElementId("listbox")
                            },
                            isLoading: x,
                            placement: re
                        }), P.createElement(h_e, {
                            captureEnabled: b,
                            onTopArrive: B,
                            onBottomArrive: U,
                            lockEnabled: k
                        }, function(fe) {
                            return P.createElement(u, Y({}, m, {
                                innerRef: function(ve) {
                                    i.getMenuListRef(ve), fe(ve)
                                },
                                isLoading: x,
                                maxHeight: _e,
                                focusedOption: y
                            }), Q)
                        }))
                    });
                return O || I === "fixed" ? P.createElement(c, Y({}, m, {
                    appendTo: O,
                    controlElement: this.controlRef,
                    menuPlacement: M,
                    menuPosition: I
                }), se) : se
            }
        }, {
            key: "renderFormField",
            value: function() {
                var i = this,
                    s = this.props,
                    o = s.delimiter,
                    a = s.isDisabled,
                    l = s.isMulti,
                    u = s.name,
                    c = s.required,
                    f = this.state.selectValue;
                if (!(!u || a)) {
                    if (c && !this.hasValue()) return P.createElement(g_e, {
                        name: u,
                        onFocus: this.onValueInputFocus
                    });
                    if (l)
                        if (o) {
                            var d = f.map(function(y) {
                                return i.getOptionValue(y)
                            }).join(o);
                            return P.createElement("input", {
                                name: u,
                                type: "hidden",
                                value: d
                            })
                        } else {
                            var p = f.length > 0 ? f.map(function(y, v) {
                                return P.createElement("input", {
                                    key: "i-".concat(v),
                                    name: u,
                                    type: "hidden",
                                    value: i.getOptionValue(y)
                                })
                            }) : P.createElement("input", {
                                name: u,
                                type: "hidden",
                                value: ""
                            });
                            return P.createElement("div", null, p)
                        }
                    else {
                        var m = f[0] ? this.getOptionValue(f[0]) : "";
                        return P.createElement("input", {
                            name: u,
                            type: "hidden",
                            value: m
                        })
                    }
                }
            }
        }, {
            key: "renderLiveRegion",
            value: function() {
                var i = this.commonProps,
                    s = this.state,
                    o = s.ariaSelection,
                    a = s.focusedOption,
                    l = s.focusedValue,
                    u = s.isFocused,
                    c = s.selectValue,
                    f = this.getFocusableOptions();
                return P.createElement(n_e, Y({}, i, {
                    id: this.getElementId("live-region"),
                    ariaSelection: o,
                    focusedOption: a,
                    focusedValue: l,
                    isFocused: u,
                    selectValue: c,
                    focusableOptions: f
                }))
            }
        }, {
            key: "render",
            value: function() {
                var i = this.getComponents(),
                    s = i.Control,
                    o = i.IndicatorsContainer,
                    a = i.SelectContainer,
                    l = i.ValueContainer,
                    u = this.props,
                    c = u.className,
                    f = u.id,
                    d = u.isDisabled,
                    p = u.menuIsOpen,
                    m = this.state.isFocused,
                    y = this.commonProps = this.getCommonProps();
                return P.createElement(a, Y({}, y, {
                    className: c,
                    innerProps: {
                        id: f,
                        onKeyDown: this.onKeyDown
                    },
                    isDisabled: d,
                    isFocused: m
                }), this.renderLiveRegion(), P.createElement(s, Y({}, y, {
                    innerRef: this.getControlRef,
                    innerProps: {
                        onMouseDown: this.onControlMouseDown,
                        onTouchEnd: this.onControlTouchEnd
                    },
                    isDisabled: d,
                    isFocused: m,
                    menuIsOpen: p
                }), P.createElement(l, Y({}, y, {
                    isDisabled: d
                }), this.renderPlaceholderOrValue(), this.renderInput()), P.createElement(o, Y({}, y, {
                    isDisabled: d
                }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField())
            }
        }], [{
            key: "getDerivedStateFromProps",
            value: function(i, s) {
                var o = s.prevProps,
                    a = s.clearFocusValueOnUpdate,
                    l = s.inputIsHiddenAfterUpdate,
                    u = s.ariaSelection,
                    c = s.isFocused,
                    f = s.prevWasFocused,
                    d = i.options,
                    p = i.value,
                    m = i.menuIsOpen,
                    y = i.inputValue,
                    v = i.isMulti,
                    b = g9(p),
                    _ = {};
                if (o && (p !== o.value || d !== o.options || m !== o.menuIsOpen || y !== o.inputValue)) {
                    var x = m ? T_e(i, b) : [],
                        S = a ? P_e(s, b) : null,
                        E = I_e(s, x);
                    _ = {
                        selectValue: b,
                        focusedOption: E,
                        focusedValue: S,
                        clearFocusValueOnUpdate: !1
                    }
                }
                var A = l != null && i !== o ? {
                        inputIsHidden: l,
                        inputIsHiddenAfterUpdate: void 0
                    } : {},
                    T = u,
                    M = c && f;
                return c && !M && (T = {
                    value: y_(v, b, b[0] || null),
                    options: b,
                    action: "initial-input-focus"
                }, M = !f), (u == null ? void 0 : u.action) === "initial-input-focus" && (T = null), et(et(et({}, _), A), {}, {
                    prevProps: i,
                    ariaSelection: T,
                    prevWasFocused: M
                })
            }
        }]), n
    }(P.Component);
EX.defaultProps = M_e;
var O_e = P.forwardRef(function(t, e) {
    var n = B1e(t);
    return P.createElement(EX, Y({
        ref: e
    }, n))
});
const nUe = O_e;

function D_e() {
    if (console && console.warn) {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        typeof e[0] == "string" && (e[0] = `react-i18next:: ${e[0]}`), console.warn(...e)
    }
}
const O9 = {};

function lR() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    typeof e[0] == "string" && O9[e[0]] || (typeof e[0] == "string" && (O9[e[0]] = new Date), D_e(...e))
}
const AX = (t, e) => () => {
    if (t.isInitialized) e();
    else {
        const n = () => {
            setTimeout(() => {
                t.off("initialized", n)
            }, 0), e()
        };
        t.on("initialized", n)
    }
};

function D9(t, e, n) {
    t.loadNamespaces(e, AX(t, n))
}

function L9(t, e, n, r) {
    typeof n == "string" && (n = [n]), n.forEach(i => {
        t.options.ns.indexOf(i) < 0 && t.options.ns.push(i)
    }), t.loadLanguages(e, AX(t, r))
}

function L_e(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = e.languages[0],
        i = e.options ? e.options.fallbackLng : !1,
        s = e.languages[e.languages.length - 1];
    if (r.toLowerCase() === "cimode") return !0;
    const o = (a, l) => {
        const u = e.services.backendConnector.state[`${a}|${l}`];
        return u === -1 || u === 2
    };
    return n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && e.services.backendConnector.backend && e.isLanguageChangingTo && !o(e.isLanguageChangingTo, t) ? !1 : !!(e.hasResourceBundle(r, t) || !e.services.backendConnector.backend || e.options.resources && !e.options.partialBundledLanguages || o(r, t) && (!i || o(s, t)))
}

function k_e(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return !e.languages || !e.languages.length ? (lR("i18n.languages were undefined or empty", e.languages), !0) : e.options.ignoreJSONStructure !== void 0 ? e.hasLoadedNamespace(t, {
        lng: n.lng,
        precheck: (i, s) => {
            if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && i.services.backendConnector.backend && i.isLanguageChangingTo && !s(i.isLanguageChangingTo, t)) return !1
        }
    }) : L_e(t, e, n)
}
const B_e = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
    F_e = {
        "&amp;": "&",
        "&#38;": "&",
        "&lt;": "<",
        "&#60;": "<",
        "&gt;": ">",
        "&#62;": ">",
        "&apos;": "'",
        "&#39;": "'",
        "&quot;": '"',
        "&#34;": '"',
        "&nbsp;": " ",
        "&#160;": " ",
        "&copy;": "©",
        "&#169;": "©",
        "&reg;": "®",
        "&#174;": "®",
        "&hellip;": "…",
        "&#8230;": "…",
        "&#x2F;": "/",
        "&#47;": "/"
    },
    N_e = t => F_e[t],
    z_e = t => t.replace(B_e, N_e);
let uR = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: !0,
    unescape: z_e
};

function H_e() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    uR = { ...uR,
        ...t
    }
}

function U_e() {
    return uR
}
let CX;

function $_e(t) {
    CX = t
}

function G_e() {
    return CX
}
const rUe = {
        type: "3rdParty",
        init(t) {
            H_e(t.options.react), $_e(t)
        }
    },
    V_e = P.createContext();
class j_e {
    constructor() {
        this.usedNamespaces = {}
    }
    addUsedNamespaces(e) {
        e.forEach(n => {
            this.usedNamespaces[n] || (this.usedNamespaces[n] = !0)
        })
    }
    getUsedNamespaces() {
        return Object.keys(this.usedNamespaces)
    }
}
const W_e = (t, e) => {
    const n = P.useRef();
    return P.useEffect(() => {
        n.current = e ? n.current : t
    }, [t, e]), n.current
};

function MX(t, e, n, r) {
    return t.getFixedT(e, n, r)
}

function K_e(t, e, n, r) {
    return P.useCallback(MX(t, e, n, r), [t, e, n, r])
}

function iUe(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
        i18n: n
    } = e, {
        i18n: r,
        defaultNS: i
    } = P.useContext(V_e) || {}, s = n || r || G_e();
    if (s && !s.reportNamespaces && (s.reportNamespaces = new j_e), !s) {
        lR("You will need to pass in an i18next instance by using initReactI18next");
        const S = (A, T) => typeof T == "string" ? T : T && typeof T == "object" && typeof T.defaultValue == "string" ? T.defaultValue : Array.isArray(A) ? A[A.length - 1] : A,
            E = [S, {}, !1];
        return E.t = S, E.i18n = {}, E.ready = !1, E
    }
    s.options.react && s.options.react.wait !== void 0 && lR("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const o = { ...U_e(),
            ...s.options.react,
            ...e
        },
        {
            useSuspense: a,
            keyPrefix: l
        } = o;
    let u = t || i || s.options && s.options.defaultNS;
    u = typeof u == "string" ? [u] : u || ["translation"], s.reportNamespaces.addUsedNamespaces && s.reportNamespaces.addUsedNamespaces(u);
    const c = (s.isInitialized || s.initializedStoreOnce) && u.every(S => k_e(S, s, o)),
        f = K_e(s, e.lng || null, o.nsMode === "fallback" ? u : u[0], l),
        d = () => f,
        p = () => MX(s, e.lng || null, o.nsMode === "fallback" ? u : u[0], l),
        [m, y] = P.useState(d);
    let v = u.join();
    e.lng && (v = `${e.lng}${v}`);
    const b = W_e(v),
        _ = P.useRef(!0);
    P.useEffect(() => {
        const {
            bindI18n: S,
            bindI18nStore: E
        } = o;
        _.current = !0, !c && !a && (e.lng ? L9(s, e.lng, u, () => {
            _.current && y(p)
        }) : D9(s, u, () => {
            _.current && y(p)
        })), c && b && b !== v && _.current && y(p);

        function A() {
            _.current && y(p)
        }
        return S && s && s.on(S, A), E && s && s.store.on(E, A), () => {
            _.current = !1, S && s && S.split(" ").forEach(T => s.off(T, A)), E && s && E.split(" ").forEach(T => s.store.off(T, A))
        }
    }, [s, v]), P.useEffect(() => {
        _.current && c && y(d)
    }, [s, l, c]);
    const x = [m, s, c];
    if (x.t = m, x.i18n = s, x.ready = c, c || !c && !a) return x;
    throw new Promise(S => {
        e.lng ? L9(s, e.lng, u, () => S()) : D9(s, u, () => S())
    })
}
var q_e = {},
    Sl = {},
    Da = _n && _n.__assign || function() {
        return Da = Object.assign || function(t) {
            for (var e, n = 1, r = arguments.length; n < r; n++) {
                e = arguments[n];
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            return t
        }, Da.apply(this, arguments)
    },
    bs = _n && _n.__spreadArrays || function() {
        for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
        for (var r = Array(t), i = 0, e = 0; e < n; e++)
            for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++) r[i] = s[o];
        return r
    },
    Io;
Object.defineProperty(Sl, "__esModule", {
    value: !0
});
Sl.parseExpr = Sl.evalExpr = Sl.evalAST = Sl.validate = void 0;
var Bs;
(function(t) {
    t[t.Operator = 0] = "Operator", t[t.Value = 1] = "Value", t[t.InfixOp = 2] = "InfixOp", t[t.Expr = 3] = "Expr"
})(Bs || (Bs = {}));
var _t;
(function(t) {
    t[t.ExprStart = 0] = "ExprStart", t[t.NumCont = 1] = "NumCont", t[t.VarDecl = 2] = "VarDecl", t[t.Op = 3] = "Op", t.Get = "get", t.Seperator = " ", t.Or = "||", t.And = "&&", t.Eq = "==", t.LT = "<", t.LTE = "<=", t.GT = ">", t.GTE = ">=", t.Not = "!", t.NotEq = "!=", t.GetStart = "{", t.GetEnd = "}", t.Prop = ".", t.BracketStart = "(", t.BracketEnd = ")"
})(_t || (_t = {}));

function X_e(t) {
    var e = t.replace(/\s+/gi, _t.Seperator);
    return e.split("")
}

function TX(t) {
    return [_t.Or, _t.And, _t.Eq, _t.LTE, _t.GTE, _t.NotEq].includes(t)
}

function PX(t) {
    return [_t.LT, _t.GT].includes(t)
}

function J_e(t) {
    return TX(t.op) || PX(t.op)
}

function Y_e(t) {
    return typeof t == "number" || t.id !== void 0
}

function Q_e(t) {
    return t === _t.Not
}

function Z_e(t) {
    return Array.isArray(t)
}

function k9(t) {
    return [_t.GetStart].includes(t)
}

function B9(t) {
    return [_t.GetEnd].includes(t)
}

function cR(t) {
    return [_t.BracketStart].includes(t)
}

function F9(t) {
    return [_t.BracketEnd].includes(t)
}

function PT(t) {
    return /[0-9]/.test(t)
}

function N9(t) {
    for (var e = 0, n = 0; e < t.length;) {
        if (F9(t[e]) && n === 0) return e;
        cR(t[e]) ? n++ : F9(t[e]) && n--, e++
    }
    throw new Error("Unbalanced brackets in: " + t)
}

function IT(t) {
    return t ? [] : [_t.Not]
}

function Kr(t, e) {
    var n = t.op,
        r = t.partial,
        i = e[0],
        s = e.slice(1);
    if (e.length === 0) switch (n) {
        case _t.NumCont:
            return [parseInt(r)];
        case _t.ExprStart:
            return [];
        default:
            throw new Error("Unexpected character encountered at end while in state: " + n)
    }
    switch (n) {
        case _t.ExprStart:
            {
                var o = i + (s[0] !== void 0 ? s[0] : "");
                if (PT(i)) return Kr({
                    op: _t.NumCont,
                    partial: i
                }, s);
                if (i === _t.Seperator) return Kr({
                    op: _t.ExprStart,
                    partial: ""
                }, s);
                if (TX(o)) return bs([{
                    op: o
                }], Kr({
                    op: _t.ExprStart,
                    partial: ""
                }, s.slice(1)));
                if (PX(i)) return bs([{
                    op: i
                }], Kr({
                    op: _t.ExprStart,
                    partial: ""
                }, s));
                if (k9(i)) return Kr({
                    op: _t.VarDecl,
                    partial: ""
                }, s);
                if (cR(i)) {
                    var a = N9(s);
                    return bs([Kr({
                        op: _t.ExprStart,
                        partial: ""
                    }, s.slice(0, a))], Kr({
                        op: _t.ExprStart,
                        partial: ""
                    }, s.slice(a + 1)))
                } else {
                    if (i === _t.Not) return Kr({
                        op: _t.Not,
                        partial: !1
                    }, s);
                    throw new Error("Unexpected character encountered in expr decl: " + i)
                }
            }
        case _t.Not:
            {
                if (PT(i)) return bs(IT(r), Kr({
                    op: _t.NumCont,
                    partial: i
                }, s));
                if (k9(i)) return bs(IT(r), Kr({
                    op: _t.VarDecl,
                    partial: ""
                }, s));
                if (cR(i)) {
                    var a = N9(s);
                    return bs(IT(r), bs([Kr({
                        op: _t.ExprStart,
                        partial: ""
                    }, s.slice(0, a))], Kr({
                        op: _t.ExprStart,
                        partial: ""
                    }, s.slice(a + 1))))
                } else {
                    if (i === _t.Not) return Kr({
                        op: _t.Not,
                        partial: !r
                    }, s);
                    throw new Error("Unexpected character encountered after !: " + i)
                }
            }
        case _t.VarDecl:
            {
                if (/[0-9a-zA-Z_-]/.test(i)) return Kr({
                    op: _t.VarDecl,
                    partial: r + i
                }, s);
                if (i === _t.Prop) return Kr({
                    op: _t.Prop,
                    partial: {
                        id: r,
                        prop: ""
                    }
                }, s);
                if (B9(i)) return bs([{
                    id: r
                }], Kr({
                    op: _t.ExprStart,
                    partial: ""
                }, s));
                throw new Error("Unexpected character encountered in var decl: " + i)
            }
        case _t.Prop:
            {
                if (PT(i)) return Kr({
                    op: _t.Prop,
                    partial: Da(Da({}, r), {
                        prop: r.prop + i
                    })
                }, s);
                if (B9(i)) return bs([Da(Da({}, r), {
                    prop: parseInt(r.prop)
                })], Kr({
                    op: _t.ExprStart,
                    partial: ""
                }, s));
                throw new Error("Unexpected character encountered in var decl: " + i)
            }
        case _t.NumCont:
            return /[0-9]/.test(i) ? Kr({
                op: _t.NumCont,
                partial: r + i
            }, s) : bs([parseInt(r, 10)], Kr({
                op: _t.ExprStart,
                partial: ""
            }, e))
    }
}

function wc(t, e) {
    var n = e[0],
        r = e.slice(1);
    if (e.length === 0) {
        if (t === Bs.Value) return [];
        throw new Error("Unexpected token at end of expr: " + t)
    }
    switch (t) {
        case Bs.InfixOp:
        case Bs.Operator:
        case Bs.Expr:
            {
                if (Q_e(n)) return bs([{
                    mod: _t.Not,
                    val: wc(Bs.InfixOp, [r[0]])
                }], wc(Bs.Value, r.slice(1)));
                if (Z_e(n)) return bs([wc(Bs.Expr, n)], wc(Bs.Value, r));
                if (Y_e(n)) return bs([n], wc(Bs.Value, r));
                throw new Error("Unexpected start of expr: " + n)
            }
        case Bs.Value:
            {
                if (J_e(n)) return bs([n], wc(Bs.Operator, r));
                throw new Error("Unexpected token following Value: " + n)
            }
    }
    throw new Error("unreachable")
}
Sl.validate = wc;

function eSe(t) {
    var e = [_t.Or, _t.And, _t.NotEq, _t.Eq, _t.GTE, _t.GT, _t.LTE, _t.LT],
        n = e.findIndex(function(r) {
            return t.some(function(i) {
                return i.op === r
            })
        });
    return n === -1 ? -1 : t.findIndex(function(r) {
        return r.op === e[n]
    })
}

function tSe(t, e) {
    return Object.keys(e).reduce(function(n, r) {
        return n[r] = Math.max(0, n[r], e[r]), n
    }, Da({}, t))
}

function Qy(t, e) {
    var n;
    if (e === void 0 && (e = {}), Array.isArray(t)) {
        var r = eSe(t);
        if (r === -1) {
            if (t.length === 1) return Qy(t[0], e);
            throw new Error("Expression has multiple entries but no operators")
        } else {
            var i = Qy(t.slice(0, r), e),
                s = Qy(t.slice(r + 1), e);
            return {
                ast: {
                    op: t[r].op,
                    arg: [i.ast, s.ast]
                },
                state: tSe(i.state, s.state)
            }
        }
    } else {
        if (typeof t == "number") return {
            ast: t,
            state: e
        };
        if (typeof t.id == "string") return {
            ast: {
                op: _t.Get,
                arg: [t.id, t.prop ? t.prop : 0]
            },
            state: Da(Da({}, e), (n = {}, n[t.id] = Math.max(0, t.prop), n))
        };
        if (t.mod === _t.Not) {
            var o = Qy(t.val, e);
            return {
                ast: {
                    op: _t.Not,
                    arg: [o.ast]
                },
                state: Da(Da({}, e), o.state)
            }
        } else throw new Error("Error building AST while encountering: " + JSON.stringify(t))
    }
}
var nSe = function(t, e, n) {
        return t[e][n]
    },
    rSe = function(t, e, n) {
        return e || n
    },
    iSe = function(t, e, n) {
        return e && n
    },
    sSe = function(t, e) {
        return !e
    },
    oSe = function(t, e, n) {
        return e != n
    },
    aSe = function(t, e, n) {
        return e == n
    },
    lSe = function(t, e, n) {
        return e < n
    },
    uSe = function(t, e, n) {
        return e <= n
    },
    cSe = function(t, e, n) {
        return e > n
    },
    fSe = function(t, e, n) {
        return e >= n
    },
    dSe = (Io = {}, Io[_t.Get] = nSe, Io[_t.Or] = rSe, Io[_t.And] = iSe, Io[_t.Not] = sSe, Io[_t.NotEq] = oSe, Io[_t.Eq] = aSe, Io[_t.GT] = cSe, Io[_t.GTE] = fSe, Io[_t.LT] = lSe, Io[_t.LTE] = uSe, Io);

function pSe(t, e) {
    var n = t.op,
        r = t.arg,
        i = dSe[n];
    if (i) return i.apply(void 0, bs([e], r.map(function(s) {
        return W4(s, e)
    })));
    throw new Error("Op lookup failed: " + n)
}

function W4(t, e) {
    if (t.op !== void 0) return pSe(t, e);
    if (typeof t == "number" || typeof t == "boolean" || typeof t == "string") return t
}
Sl.evalAST = W4;

function hSe(t, e) {
    return W4(IX(t).ast, e)
}
Sl.evalExpr = hSe;

function IX(t) {
    var e = X_e(t),
        n = Kr({
            op: _t.ExprStart,
            partial: ""
        }, e);
    return Qy(wc(Bs.Expr, n))
}
Sl.parseExpr = IX;
(function(t) {
    var e = _n && _n.__createBinding || (Object.create ? function(r, i, s, o) {
            o === void 0 && (o = s), Object.defineProperty(r, o, {
                enumerable: !0,
                get: function() {
                    return i[s]
                }
            })
        } : function(r, i, s, o) {
            o === void 0 && (o = s), r[o] = i[s]
        }),
        n = _n && _n.__exportStar || function(r, i) {
            for (var s in r) s !== "default" && !i.hasOwnProperty(s) && e(i, r, s)
        };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), n(Sl, t)
})(q_e);
const RX = Object.prototype.toString;

function K4(t) {
    switch (RX.call(t)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
            return !0;
        default:
            return Af(t, Error)
    }
}

function Mg(t, e) {
    return RX.call(t) === `[object ${e}]`
}

function OX(t) {
    return Mg(t, "ErrorEvent")
}

function z9(t) {
    return Mg(t, "DOMError")
}

function mSe(t) {
    return Mg(t, "DOMException")
}

function lp(t) {
    return Mg(t, "String")
}

function gSe(t) {
    return t === null || typeof t != "object" && typeof t != "function"
}

function mA(t) {
    return Mg(t, "Object")
}

function q4(t) {
    return typeof Event < "u" && Af(t, Event)
}

function ySe(t) {
    return typeof Element < "u" && Af(t, Element)
}

function vSe(t) {
    return Mg(t, "RegExp")
}

function DX(t) {
    return !!(t && t.then && typeof t.then == "function")
}

function bSe(t) {
    return mA(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
}

function xSe(t) {
    return typeof t == "number" && t !== t
}

function Af(t, e) {
    try {
        return t instanceof e
    } catch {
        return !1
    }
}

function v_(t) {
    return t && t.Math == Math ? t : void 0
}
const Ua = typeof globalThis == "object" && v_(globalThis) || typeof window == "object" && v_(window) || typeof self == "object" && v_(self) || typeof global == "object" && v_(global) || function() {
    return this
}() || {};

function gA() {
    return Ua
}

function X4(t, e, n) {
    const r = n || Ua,
        i = r.__SENTRY__ = r.__SENTRY__ || {};
    return i[t] || (i[t] = e())
}
const _Se = gA(),
    SSe = 80;

function fR(t, e = {}) {
    try {
        let n = t;
        const r = 5,
            i = [];
        let s = 0,
            o = 0;
        const a = " > ",
            l = a.length;
        let u;
        const c = Array.isArray(e) ? e : e.keyAttrs,
            f = !Array.isArray(e) && e.maxStringLength || SSe;
        for (; n && s++ < r && (u = wSe(n, c), !(u === "html" || s > 1 && o + i.length * l + u.length >= f));) i.push(u), o += u.length, n = n.parentNode;
        return i.reverse().join(a)
    } catch {
        return "<unknown>"
    }
}

function wSe(t, e) {
    const n = t,
        r = [];
    let i, s, o, a, l;
    if (!n || !n.tagName) return "";
    r.push(n.tagName.toLowerCase());
    const u = e && e.length ? e.filter(f => n.getAttribute(f)).map(f => [f, n.getAttribute(f)]) : null;
    if (u && u.length) u.forEach(f => {
        r.push(`[${f[0]}="${f[1]}"]`)
    });
    else if (n.id && r.push(`#${n.id}`), i = n.className, i && lp(i))
        for (s = i.split(/\s+/), l = 0; l < s.length; l++) r.push(`.${s[l]}`);
    const c = ["aria-label", "type", "name", "title", "alt"];
    for (l = 0; l < c.length; l++) o = c[l], a = n.getAttribute(o), a && r.push(`[${o}="${a}"]`);
    return r.join("")
}

function ESe() {
    try {
        return _Se.document.location.href
    } catch {
        return ""
    }
}
class Zy extends Error {
    constructor(e, n = "warn") {
        super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n
    }
}
const ASe = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function CSe(t) {
    return t === "http" || t === "https"
}

function MSe(t, e = !1) {
    const {
        host: n,
        path: r,
        pass: i,
        port: s,
        projectId: o,
        protocol: a,
        publicKey: l
    } = t;
    return `${a}://${l}${e&&i?`:${i}`:""}@${n}${s?`:${s}`:""}/${r&&`${r}/`}${o}`
}

function TSe(t) {
    const e = ASe.exec(t);
    if (!e) throw new Zy(`Invalid Sentry Dsn: ${t}`);
    const [n, r, i = "", s, o = "", a] = e.slice(1);
    let l = "",
        u = a;
    const c = u.split("/");
    if (c.length > 1 && (l = c.slice(0, -1).join("/"), u = c.pop()), u) {
        const f = u.match(/^\d+/);
        f && (u = f[0])
    }
    return LX({
        host: s,
        pass: i,
        path: l,
        projectId: u,
        port: o,
        protocol: n,
        publicKey: r
    })
}

function LX(t) {
    return {
        protocol: t.protocol,
        publicKey: t.publicKey || "",
        pass: t.pass || "",
        host: t.host,
        port: t.port || "",
        path: t.path || "",
        projectId: t.projectId
    }
}

function PSe(t) {
    if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return;
    const {
        port: e,
        projectId: n,
        protocol: r
    } = t;
    if (["protocol", "publicKey", "host", "projectId"].forEach(s => {
            if (!t[s]) throw new Zy(`Invalid Sentry Dsn: ${s} missing`)
        }), !n.match(/^\d+$/)) throw new Zy(`Invalid Sentry Dsn: Invalid projectId ${n}`);
    if (!CSe(r)) throw new Zy(`Invalid Sentry Dsn: Invalid protocol ${r}`);
    if (e && isNaN(parseInt(e, 10))) throw new Zy(`Invalid Sentry Dsn: Invalid port ${e}`);
    return !0
}

function ISe(t) {
    const e = typeof t == "string" ? TSe(t) : LX(t);
    return PSe(e), e
}
const RSe = "Sentry Logger ",
    t2 = ["debug", "info", "warn", "error", "log", "assert", "trace"];

function kX(t) {
    if (!("console" in Ua)) return t();
    const e = Ua.console,
        n = {};
    t2.forEach(r => {
        const i = e[r] && e[r].__sentry_original__;
        r in e && i && (n[r] = e[r], e[r] = i)
    });
    try {
        return t()
    } finally {
        Object.keys(n).forEach(r => {
            e[r] = n[r]
        })
    }
}

function H9() {
    let t = !1;
    const e = {
        enable: () => {
            t = !0
        },
        disable: () => {
            t = !1
        }
    };
    return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? t2.forEach(n => {
        e[n] = (...r) => {
            t && kX(() => {
                Ua.console[n](`${RSe}[${n}]:`, ...r)
            })
        }
    }) : t2.forEach(n => {
        e[n] = () => {}
    }), e
}
let Jr;
typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Jr = X4("logger", H9) : Jr = H9();

function U9(t, e = 0) {
    return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0,e)}...`
}

function $9(t, e) {
    if (!Array.isArray(t)) return "";
    const n = [];
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        try {
            n.push(String(i))
        } catch {
            n.push("[value cannot be serialized]")
        }
    }
    return n.join(e)
}

function OSe(t, e, n = !1) {
    return lp(t) ? vSe(e) ? e.test(t) : lp(e) ? n ? t === e : t.includes(e) : !1 : !1
}

function J4(t, e = [], n = !1) {
    return e.some(r => OSe(t, r, n))
}

function os(t, e, n) {
    if (!(e in t)) return;
    const r = t[e],
        i = n(r);
    if (typeof i == "function") try {
        BX(i, r)
    } catch {}
    t[e] = i
}

function Y4(t, e, n) {
    Object.defineProperty(t, e, {
        value: n,
        writable: !0,
        configurable: !0
    })
}

function BX(t, e) {
    const n = e.prototype || {};
    t.prototype = e.prototype = n, Y4(t, "__sentry_original__", e)
}

function Q4(t) {
    return t.__sentry_original__
}

function FX(t) {
    if (K4(t)) return {
        message: t.message,
        name: t.name,
        stack: t.stack,
        ...V9(t)
    };
    if (q4(t)) {
        const e = {
            type: t.type,
            target: G9(t.target),
            currentTarget: G9(t.currentTarget),
            ...V9(t)
        };
        return typeof CustomEvent < "u" && Af(t, CustomEvent) && (e.detail = t.detail), e
    } else return t
}

function G9(t) {
    try {
        return ySe(t) ? fR(t) : Object.prototype.toString.call(t)
    } catch {
        return "<unknown>"
    }
}

function V9(t) {
    if (typeof t == "object" && t !== null) {
        const e = {};
        for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e
    } else return {}
}

function DSe(t, e = 40) {
    const n = Object.keys(FX(t));
    if (n.sort(), !n.length) return "[object has no keys]";
    if (n[0].length >= e) return U9(n[0], e);
    for (let r = n.length; r > 0; r--) {
        const i = n.slice(0, r).join(", ");
        if (!(i.length > e)) return r === n.length ? i : U9(i, e)
    }
    return ""
}

function LSe(t) {
    return dR(t, new Map)
}

function dR(t, e) {
    if (mA(t)) {
        const n = e.get(t);
        if (n !== void 0) return n;
        const r = {};
        e.set(t, r);
        for (const i of Object.keys(t)) typeof t[i] < "u" && (r[i] = dR(t[i], e));
        return r
    }
    if (Array.isArray(t)) {
        const n = e.get(t);
        if (n !== void 0) return n;
        const r = [];
        return e.set(t, r), t.forEach(i => {
            r.push(dR(i, e))
        }), r
    }
    return t
}
const RT = "<anonymous>";

function mf(t) {
    try {
        return !t || typeof t != "function" ? RT : t.name || RT
    } catch {
        return RT
    }
}
const Ad = gA();

function kSe() {
    if (!("fetch" in Ad)) return !1;
    try {
        return new Headers, new Request("http://www.example.com"), new Response, !0
    } catch {
        return !1
    }
}

function j9(t) {
    return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}

function BSe() {
    if (!kSe()) return !1;
    if (j9(Ad.fetch)) return !0;
    let t = !1;
    const e = Ad.document;
    if (e && typeof e.createElement == "function") try {
        const n = e.createElement("iframe");
        n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = j9(n.contentWindow.fetch)), e.head.removeChild(n)
    } catch (n) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
    }
    return t
}

function FSe() {
    const t = Ad.chrome,
        e = t && t.app && t.app.runtime,
        n = "history" in Ad && !!Ad.history.pushState && !!Ad.history.replaceState;
    return !e && n
}
const _r = gA(),
    Sv = {},
    W9 = {};

function NSe(t) {
    if (!W9[t]) switch (W9[t] = !0, t) {
        case "console":
            zSe();
            break;
        case "dom":
            qSe();
            break;
        case "xhr":
            GSe();
            break;
        case "fetch":
            HSe();
            break;
        case "history":
            VSe();
            break;
        case "error":
            XSe();
            break;
        case "unhandledrejection":
            JSe();
            break;
        default:
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn("unknown instrumentation type:", t);
            return
    }
}

function ud(t, e) {
    Sv[t] = Sv[t] || [], Sv[t].push(e), NSe(t)
}

function $a(t, e) {
    if (!(!t || !Sv[t]))
        for (const n of Sv[t] || []) try {
            n(e)
        } catch (r) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${mf(n)}
Error:`, r)
        }
}

function zSe() {
    "console" in _r && t2.forEach(function(t) {
        t in _r.console && os(_r.console, t, function(e) {
            return function(...n) {
                $a("console", {
                    args: n,
                    level: t
                }), e && e.apply(_r.console, n)
            }
        })
    })
}

function HSe() {
    BSe() && os(_r, "fetch", function(t) {
        return function(...e) {
            const n = {
                args: e,
                fetchData: {
                    method: USe(e),
                    url: $Se(e)
                },
                startTimestamp: Date.now()
            };
            return $a("fetch", { ...n
            }), t.apply(_r, e).then(r => ($a("fetch", { ...n,
                endTimestamp: Date.now(),
                response: r
            }), r), r => {
                throw $a("fetch", { ...n,
                    endTimestamp: Date.now(),
                    error: r
                }), r
            })
        }
    })
}

function USe(t = []) {
    return "Request" in _r && Af(t[0], Request) && t[0].method ? String(t[0].method).toUpperCase() : t[1] && t[1].method ? String(t[1].method).toUpperCase() : "GET"
}

function $Se(t = []) {
    return typeof t[0] == "string" ? t[0] : "Request" in _r && Af(t[0], Request) ? t[0].url : String(t[0])
}

function GSe() {
    if (!("XMLHttpRequest" in _r)) return;
    const t = XMLHttpRequest.prototype;
    os(t, "open", function(e) {
        return function(...n) {
            const r = this,
                i = n[1],
                s = r.__sentry_xhr__ = {
                    method: lp(n[0]) ? n[0].toUpperCase() : n[0],
                    url: n[1]
                };
            lp(i) && s.method === "POST" && i.match(/sentry_key/) && (r.__sentry_own_request__ = !0);
            const o = function() {
                if (r.readyState === 4) {
                    try {
                        s.status_code = r.status
                    } catch {}
                    $a("xhr", {
                        args: n,
                        endTimestamp: Date.now(),
                        startTimestamp: Date.now(),
                        xhr: r
                    })
                }
            };
            return "onreadystatechange" in r && typeof r.onreadystatechange == "function" ? os(r, "onreadystatechange", function(a) {
                return function(...l) {
                    return o(), a.apply(r, l)
                }
            }) : r.addEventListener("readystatechange", o), e.apply(r, n)
        }
    }), os(t, "send", function(e) {
        return function(...n) {
            return this.__sentry_xhr__ && n[0] !== void 0 && (this.__sentry_xhr__.body = n[0]), $a("xhr", {
                args: n,
                startTimestamp: Date.now(),
                xhr: this
            }), e.apply(this, n)
        }
    })
}
let b_;

function VSe() {
    if (!FSe()) return;
    const t = _r.onpopstate;
    _r.onpopstate = function(...n) {
        const r = _r.location.href,
            i = b_;
        if (b_ = r, $a("history", {
                from: i,
                to: r
            }), t) try {
            return t.apply(this, n)
        } catch {}
    };

    function e(n) {
        return function(...r) {
            const i = r.length > 2 ? r[2] : void 0;
            if (i) {
                const s = b_,
                    o = String(i);
                b_ = o, $a("history", {
                    from: s,
                    to: o
                })
            }
            return n.apply(this, r)
        }
    }
    os(_r.history, "pushState", e), os(_r.history, "replaceState", e)
}
const jSe = 1e3;
let x_, __;

function WSe(t, e) {
    if (!t || t.type !== e.type) return !0;
    try {
        if (t.target !== e.target) return !0
    } catch {}
    return !1
}

function KSe(t) {
    if (t.type !== "keypress") return !1;
    try {
        const e = t.target;
        if (!e || !e.tagName) return !0;
        if (e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) return !1
    } catch {}
    return !0
}

function K9(t, e = !1) {
    return n => {
        if (!n || __ === n || KSe(n)) return;
        const r = n.type === "keypress" ? "input" : n.type;
        x_ === void 0 ? (t({
            event: n,
            name: r,
            global: e
        }), __ = n) : WSe(__, n) && (t({
            event: n,
            name: r,
            global: e
        }), __ = n), clearTimeout(x_), x_ = _r.setTimeout(() => {
            x_ = void 0
        }, jSe)
    }
}

function qSe() {
    if (!("document" in _r)) return;
    const t = $a.bind(null, "dom"),
        e = K9(t, !0);
    _r.document.addEventListener("click", e, !1), _r.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
        const r = _r[n] && _r[n].prototype;
        !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (os(r, "addEventListener", function(i) {
            return function(s, o, a) {
                if (s === "click" || s == "keypress") try {
                    const l = this,
                        u = l.__sentry_instrumentation_handlers__ = l.__sentry_instrumentation_handlers__ || {},
                        c = u[s] = u[s] || {
                            refCount: 0
                        };
                    if (!c.handler) {
                        const f = K9(t);
                        c.handler = f, i.call(this, s, f, a)
                    }
                    c.refCount++
                } catch {}
                return i.call(this, s, o, a)
            }
        }), os(r, "removeEventListener", function(i) {
            return function(s, o, a) {
                if (s === "click" || s == "keypress") try {
                    const l = this,
                        u = l.__sentry_instrumentation_handlers__ || {},
                        c = u[s];
                    c && (c.refCount--, c.refCount <= 0 && (i.call(this, s, c.handler, a), c.handler = void 0, delete u[s]), Object.keys(u).length === 0 && delete l.__sentry_instrumentation_handlers__)
                } catch {}
                return i.call(this, s, o, a)
            }
        }))
    })
}
let OT = null;

function XSe() {
    OT = _r.onerror, _r.onerror = function(t, e, n, r, i) {
        return $a("error", {
            column: r,
            error: i,
            line: n,
            msg: t,
            url: e
        }), OT ? OT.apply(this, arguments) : !1
    }
}
let DT = null;

function JSe() {
    DT = _r.onunhandledrejection, _r.onunhandledrejection = function(t) {
        return $a("unhandledrejection", t), DT ? DT.apply(this, arguments) : !0
    }
}

function YSe() {
    const t = typeof WeakSet == "function",
        e = t ? new WeakSet : [];

    function n(i) {
        if (t) return e.has(i) ? !0 : (e.add(i), !1);
        for (let s = 0; s < e.length; s++)
            if (e[s] === i) return !0;
        return e.push(i), !1
    }

    function r(i) {
        if (t) e.delete(i);
        else
            for (let s = 0; s < e.length; s++)
                if (e[s] === i) {
                    e.splice(s, 1);
                    break
                }
    }
    return [n, r]
}

function wv() {
    const t = Ua,
        e = t.crypto || t.msCrypto;
    if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
    const n = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
}

function NX(t) {
    return t.exception && t.exception.values ? t.exception.values[0] : void 0
}

function Cd(t) {
    const {
        message: e,
        event_id: n
    } = t;
    if (e) return e;
    const r = NX(t);
    return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
}

function pR(t, e, n) {
    const r = t.exception = t.exception || {},
        i = r.values = r.values || [],
        s = i[0] = i[0] || {};
    s.value || (s.value = e || ""), s.type || (s.type = n || "Error")
}

function n2(t, e) {
    const n = NX(t);
    if (!n) return;
    const r = {
            type: "generic",
            handled: !0
        },
        i = n.mechanism;
    if (n.mechanism = { ...r,
            ...i,
            ...e
        }, e && "data" in e) {
        const s = { ...i && i.data,
            ...e.data
        };
        n.mechanism.data = s
    }
}

function QSe(t) {
    return Array.isArray(t) ? t : [t]
}

function ZSe() {
    return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}

function zX() {
    return !ZSe() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
}

function ewe(t, e) {
    return t.require(e)
}

function twe(t, e = 1 / 0, n = 1 / 0) {
    try {
        return hR("", t, e, n)
    } catch (r) {
        return {
            ERROR: `**non-serializable** (${r})`
        }
    }
}

function HX(t, e = 3, n = 100 * 1024) {
    const r = twe(t, e);
    return swe(r) > n ? HX(t, e - 1, n) : r
}

function hR(t, e, n = 1 / 0, r = 1 / 0, i = YSe()) {
    const [s, o] = i;
    if (e === null || ["number", "boolean", "string"].includes(typeof e) && !xSe(e)) return e;
    const a = nwe(t, e);
    if (!a.startsWith("[object ")) return a;
    if (e.__sentry_skip_normalization__) return e;
    let l = n;
    if (typeof e.__sentry_override_normalization_depth__ == "number" && (l = e.__sentry_override_normalization_depth__), l === 0) return a.replace("object ", "");
    if (s(e)) return "[Circular ~]";
    const u = e;
    if (u && typeof u.toJSON == "function") try {
        const p = u.toJSON();
        return hR("", p, l - 1, r, i)
    } catch {}
    const c = Array.isArray(e) ? [] : {};
    let f = 0;
    const d = FX(e);
    for (const p in d) {
        if (!Object.prototype.hasOwnProperty.call(d, p)) continue;
        if (f >= r) {
            c[p] = "[MaxProperties ~]";
            break
        }
        const m = d[p];
        c[p] = hR(p, m, l - 1, r, i), f++
    }
    return o(e), c
}

function nwe(t, e) {
    try {
        return t === "domain" && e && typeof e == "object" && e._events ? "[Domain]" : t === "domainEmitter" ? "[DomainEmitter]" : typeof global < "u" && e === global ? "[Global]" : typeof window < "u" && e === window ? "[Window]" : typeof document < "u" && e === document ? "[Document]" : bSe(e) ? "[SyntheticEvent]" : typeof e == "number" && e !== e ? "[NaN]" : e === void 0 ? "[undefined]" : typeof e == "function" ? `[Function: ${mf(e)}]` : typeof e == "symbol" ? `[${String(e)}]` : typeof e == "bigint" ? `[BigInt: ${String(e)}]` : `[object ${rwe(e)}]`
    } catch (n) {
        return `**non-serializable** (${n})`
    }
}

function rwe(t) {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : "null prototype"
}

function iwe(t) {
    return ~-encodeURI(t).split(/%..|./).length
}

function swe(t) {
    return iwe(JSON.stringify(t))
}
var fu;
(function(t) {
    t[t.PENDING = 0] = "PENDING";
    const n = 1;
    t[t.RESOLVED = n] = "RESOLVED";
    const r = 2;
    t[t.REJECTED = r] = "REJECTED"
})(fu || (fu = {}));
class cl {
    __init() {
        this._state = fu.PENDING
    }
    __init2() {
        this._handlers = []
    }
    constructor(e) {
        cl.prototype.__init.call(this), cl.prototype.__init2.call(this), cl.prototype.__init3.call(this), cl.prototype.__init4.call(this), cl.prototype.__init5.call(this), cl.prototype.__init6.call(this);
        try {
            e(this._resolve, this._reject)
        } catch (n) {
            this._reject(n)
        }
    }
    then(e, n) {
        return new cl((r, i) => {
            this._handlers.push([!1, s => {
                if (!e) r(s);
                else try {
                    r(e(s))
                } catch (o) {
                    i(o)
                }
            }, s => {
                if (!n) i(s);
                else try {
                    r(n(s))
                } catch (o) {
                    i(o)
                }
            }]), this._executeHandlers()
        })
    } catch (e) {
        return this.then(n => n, e)
    } finally(e) {
        return new cl((n, r) => {
            let i, s;
            return this.then(o => {
                s = !1, i = o, e && e()
            }, o => {
                s = !0, i = o, e && e()
            }).then(() => {
                if (s) {
                    r(i);
                    return
                }
                n(i)
            })
        })
    }
    __init3() {
        this._resolve = e => {
            this._setResult(fu.RESOLVED, e)
        }
    }
    __init4() {
        this._reject = e => {
            this._setResult(fu.REJECTED, e)
        }
    }
    __init5() {
        this._setResult = (e, n) => {
            if (this._state === fu.PENDING) {
                if (DX(n)) {
                    n.then(this._resolve, this._reject);
                    return
                }
                this._state = e, this._value = n, this._executeHandlers()
            }
        }
    }
    __init6() {
        this._executeHandlers = () => {
            if (this._state === fu.PENDING) return;
            const e = this._handlers.slice();
            this._handlers = [], e.forEach(n => {
                n[0] || (this._state === fu.RESOLVED && n[1](this._value), this._state === fu.REJECTED && n[2](this._value), n[0] = !0)
            })
        }
    }
}

function LT(t) {
    if (!t) return {};
    const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!e) return {};
    const n = e[6] || "",
        r = e[8] || "";
    return {
        host: e[4],
        path: e[5],
        protocol: e[2],
        relative: e[5] + n + r
    }
}
const owe = ["fatal", "error", "warning", "log", "info", "debug"];

function awe(t) {
    return t === "warn" ? "warning" : owe.includes(t) ? t : "log"
}
const UX = gA(),
    mR = {
        nowSeconds: () => Date.now() / 1e3
    };

function lwe() {
    const {
        performance: t
    } = UX;
    if (!t || !t.now) return;
    const e = Date.now() - t.now();
    return {
        now: () => t.now(),
        timeOrigin: e
    }
}

function uwe() {
    try {
        return ewe(module, "perf_hooks").performance
    } catch {
        return
    }
}
const kT = zX() ? uwe() : lwe(),
    q9 = kT === void 0 ? mR : {
        nowSeconds: () => (kT.timeOrigin + kT.now()) / 1e3
    },
    $X = mR.nowSeconds.bind(mR),
    GX = q9.nowSeconds.bind(q9);
(() => {
    const {
        performance: t
    } = UX;
    if (!t || !t.now) return;
    const e = 3600 * 1e3,
        n = t.now(),
        r = Date.now(),
        i = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e,
        s = i < e,
        o = t.timing && t.timing.navigationStart,
        l = typeof o == "number" ? Math.abs(o + n - r) : e,
        u = l < e;
    return s || u ? i <= l ? t.timeOrigin : o : r
})();
const cwe = "production";

function fwe(t) {
    const e = GX(),
        n = {
            sid: wv(),
            init: !0,
            timestamp: e,
            started: e,
            duration: 0,
            status: "ok",
            errors: 0,
            ignoreDuration: !1,
            toJSON: () => pwe(n)
        };
    return t && yA(n, t), n
}

function yA(t, e = {}) {
    if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || GX(), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : wv()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration) t.duration = void 0;
    else if (typeof e.duration == "number") t.duration = e.duration;
    else {
        const n = t.timestamp - t.started;
        t.duration = n >= 0 ? n : 0
    }
    e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status)
}

function dwe(t, e) {
    let n = {};
    e ? n = {
        status: e
    } : t.status === "ok" && (n = {
        status: "exited"
    }), yA(t, n)
}

function pwe(t) {
    return LSe({
        sid: `${t.sid}`,
        init: t.init,
        started: new Date(t.started * 1e3).toISOString(),
        timestamp: new Date(t.timestamp * 1e3).toISOString(),
        status: t.status,
        errors: t.errors,
        did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
        duration: t.duration,
        attrs: {
            release: t.release,
            environment: t.environment,
            ip_address: t.ipAddress,
            user_agent: t.userAgent
        }
    })
}
const hwe = 100;
class Hd {
    constructor() {
        this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
    }
    static clone(e) {
        const n = new Hd;
        return e && (n._breadcrumbs = [...e._breadcrumbs], n._tags = { ...e._tags
        }, n._extra = { ...e._extra
        }, n._contexts = { ...e._contexts
        }, n._user = e._user, n._level = e._level, n._span = e._span, n._session = e._session, n._transactionName = e._transactionName, n._fingerprint = e._fingerprint, n._eventProcessors = [...e._eventProcessors], n._requestSession = e._requestSession, n._attachments = [...e._attachments], n._sdkProcessingMetadata = { ...e._sdkProcessingMetadata
        }), n
    }
    addScopeListener(e) {
        this._scopeListeners.push(e)
    }
    addEventProcessor(e) {
        return this._eventProcessors.push(e), this
    }
    setUser(e) {
        return this._user = e || {}, this._session && yA(this._session, {
            user: e
        }), this._notifyScopeListeners(), this
    }
    getUser() {
        return this._user
    }
    getRequestSession() {
        return this._requestSession
    }
    setRequestSession(e) {
        return this._requestSession = e, this
    }
    setTags(e) {
        return this._tags = { ...this._tags,
            ...e
        }, this._notifyScopeListeners(), this
    }
    setTag(e, n) {
        return this._tags = { ...this._tags,
            [e]: n
        }, this._notifyScopeListeners(), this
    }
    setExtras(e) {
        return this._extra = { ...this._extra,
            ...e
        }, this._notifyScopeListeners(), this
    }
    setExtra(e, n) {
        return this._extra = { ...this._extra,
            [e]: n
        }, this._notifyScopeListeners(), this
    }
    setFingerprint(e) {
        return this._fingerprint = e, this._notifyScopeListeners(), this
    }
    setLevel(e) {
        return this._level = e, this._notifyScopeListeners(), this
    }
    setTransactionName(e) {
        return this._transactionName = e, this._notifyScopeListeners(), this
    }
    setContext(e, n) {
        return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this
    }
    setSpan(e) {
        return this._span = e, this._notifyScopeListeners(), this
    }
    getSpan() {
        return this._span
    }
    getTransaction() {
        const e = this.getSpan();
        return e && e.transaction
    }
    setSession(e) {
        return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
    }
    getSession() {
        return this._session
    }
    update(e) {
        if (!e) return this;
        if (typeof e == "function") {
            const n = e(this);
            return n instanceof Hd ? n : this
        }
        return e instanceof Hd ? (this._tags = { ...this._tags,
            ...e._tags
        }, this._extra = { ...this._extra,
            ...e._extra
        }, this._contexts = { ...this._contexts,
            ...e._contexts
        }, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : mA(e) && (e = e, this._tags = { ...this._tags,
            ...e.tags
        }, this._extra = { ...this._extra,
            ...e.extra
        }, this._contexts = { ...this._contexts,
            ...e.contexts
        }, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this
    }
    clear() {
        return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
    }
    addBreadcrumb(e, n) {
        const r = typeof n == "number" ? n : hwe;
        if (r <= 0) return this;
        const i = {
            timestamp: $X(),
            ...e
        };
        return this._breadcrumbs = [...this._breadcrumbs, i].slice(-r), this._notifyScopeListeners(), this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [], this._notifyScopeListeners(), this
    }
    addAttachment(e) {
        return this._attachments.push(e), this
    }
    getAttachments() {
        return this._attachments
    }
    clearAttachments() {
        return this._attachments = [], this
    }
    applyToEvent(e, n = {}) {
        if (this._extra && Object.keys(this._extra).length && (e.extra = { ...this._extra,
                ...e.extra
            }), this._tags && Object.keys(this._tags).length && (e.tags = { ...this._tags,
                ...e.tags
            }), this._user && Object.keys(this._user).length && (e.user = { ...this._user,
                ...e.user
            }), this._contexts && Object.keys(this._contexts).length && (e.contexts = { ...this._contexts,
                ...e.contexts
            }), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
            e.contexts = {
                trace: this._span.getTraceContext(),
                ...e.contexts
            };
            const r = this._span.transaction && this._span.transaction.name;
            r && (e.tags = {
                transaction: r,
                ...e.tags
            })
        }
        return this._applyFingerprint(e), e.breadcrumbs = [...e.breadcrumbs || [], ...this._breadcrumbs], e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = { ...e.sdkProcessingMetadata,
            ...this._sdkProcessingMetadata
        }, this._notifyEventProcessors([...VX(), ...this._eventProcessors], e, n)
    }
    setSDKProcessingMetadata(e) {
        return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata,
            ...e
        }, this
    }
    _notifyEventProcessors(e, n, r, i = 0) {
        return new cl((s, o) => {
            const a = e[i];
            if (n === null || typeof a != "function") s(n);
            else {
                const l = a({ ...n
                }, r);
                (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && a.id && l === null && Jr.log(`Event processor "${a.id}" dropped event`), DX(l) ? l.then(u => this._notifyEventProcessors(e, u, r, i + 1).then(s)).then(null, o) : this._notifyEventProcessors(e, l, r, i + 1).then(s).then(null, o)
            }
        })
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
            e(this)
        }), this._notifyingListeners = !1)
    }
    _applyFingerprint(e) {
        e.fingerprint = e.fingerprint ? QSe(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
    }
}

function VX() {
    return X4("globalEventProcessors", () => [])
}

function jX(t) {
    VX().push(t)
}
const Z4 = 4,
    mwe = 100;
class V1 {
    __init() {
        this._stack = [{}]
    }
    constructor(e, n = new Hd, r = Z4) {
        this._version = r, V1.prototype.__init.call(this), this.getStackTop().scope = n, e && this.bindClient(e)
    }
    isOlderThan(e) {
        return this._version < e
    }
    bindClient(e) {
        const n = this.getStackTop();
        n.client = e, e && e.setupIntegrations && e.setupIntegrations()
    }
    pushScope() {
        const e = Hd.clone(this.getScope());
        return this.getStack().push({
            client: this.getClient(),
            scope: e
        }), e
    }
    popScope() {
        return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
    }
    withScope(e) {
        const n = this.pushScope();
        try {
            e(n)
        } finally {
            this.popScope()
        }
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getStack() {
        return this._stack
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    captureException(e, n) {
        const r = this._lastEventId = n && n.event_id ? n.event_id : wv(),
            i = new Error("Sentry syntheticException");
        return this._withClient((s, o) => {
            s.captureException(e, {
                originalException: e,
                syntheticException: i,
                ...n,
                event_id: r
            }, o)
        }), r
    }
    captureMessage(e, n, r) {
        const i = this._lastEventId = r && r.event_id ? r.event_id : wv(),
            s = new Error(e);
        return this._withClient((o, a) => {
            o.captureMessage(e, n, {
                originalException: e,
                syntheticException: s,
                ...r,
                event_id: i
            }, a)
        }), i
    }
    captureEvent(e, n) {
        const r = n && n.event_id ? n.event_id : wv();
        return e.type || (this._lastEventId = r), this._withClient((i, s) => {
            i.captureEvent(e, { ...n,
                event_id: r
            }, s)
        }), r
    }
    lastEventId() {
        return this._lastEventId
    }
    addBreadcrumb(e, n) {
        const {
            scope: r,
            client: i
        } = this.getStackTop();
        if (!r || !i) return;
        const {
            beforeBreadcrumb: s = null,
            maxBreadcrumbs: o = mwe
        } = i.getOptions && i.getOptions() || {};
        if (o <= 0) return;
        const l = {
                timestamp: $X(),
                ...e
            },
            u = s ? kX(() => s(l, n)) : l;
        u !== null && r.addBreadcrumb(u, o)
    }
    setUser(e) {
        const n = this.getScope();
        n && n.setUser(e)
    }
    setTags(e) {
        const n = this.getScope();
        n && n.setTags(e)
    }
    setExtras(e) {
        const n = this.getScope();
        n && n.setExtras(e)
    }
    setTag(e, n) {
        const r = this.getScope();
        r && r.setTag(e, n)
    }
    setExtra(e, n) {
        const r = this.getScope();
        r && r.setExtra(e, n)
    }
    setContext(e, n) {
        const r = this.getScope();
        r && r.setContext(e, n)
    }
    configureScope(e) {
        const {
            scope: n,
            client: r
        } = this.getStackTop();
        n && r && e(n)
    }
    run(e) {
        const n = X9(this);
        try {
            e(this)
        } finally {
            X9(n)
        }
    }
    getIntegration(e) {
        const n = this.getClient();
        if (!n) return null;
        try {
            return n.getIntegration(e)
        } catch {
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
        }
    }
    startTransaction(e, n) {
        return this._callExtensionMethod("startTransaction", e, n)
    }
    traceHeaders() {
        return this._callExtensionMethod("traceHeaders")
    }
    captureSession(e = !1) {
        if (e) return this.endSession();
        this._sendSessionUpdate()
    }
    endSession() {
        const e = this.getStackTop(),
            n = e && e.scope,
            r = n && n.getSession();
        r && dwe(r), this._sendSessionUpdate(), n && n.setSession()
    }
    startSession(e) {
        const {
            scope: n,
            client: r
        } = this.getStackTop(), {
            release: i,
            environment: s = cwe
        } = r && r.getOptions() || {}, {
            userAgent: o
        } = Ua.navigator || {}, a = fwe({
            release: i,
            environment: s,
            ...n && {
                user: n.getUser()
            },
            ...o && {
                userAgent: o
            },
            ...e
        });
        if (n) {
            const l = n.getSession && n.getSession();
            l && l.status === "ok" && yA(l, {
                status: "exited"
            }), this.endSession(), n.setSession(a)
        }
        return a
    }
    shouldSendDefaultPii() {
        const e = this.getClient(),
            n = e && e.getOptions();
        return !!(n && n.sendDefaultPii)
    }
    _sendSessionUpdate() {
        const {
            scope: e,
            client: n
        } = this.getStackTop();
        if (!e) return;
        const r = e.getSession();
        r && n && n.captureSession && n.captureSession(r)
    }
    _withClient(e) {
        const {
            scope: n,
            client: r
        } = this.getStackTop();
        r && e(r, n)
    }
    _callExtensionMethod(e, ...n) {
        const i = vA().__SENTRY__;
        if (i && i.extensions && typeof i.extensions[e] == "function") return i.extensions[e].apply(this, n);
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`Extension method ${e} couldn't be found, doing nothing.`)
    }
}

function vA() {
    return Ua.__SENTRY__ = Ua.__SENTRY__ || {
        extensions: {},
        hub: void 0
    }, Ua
}

function X9(t) {
    const e = vA(),
        n = Tc(e);
    return ek(e, t), n
}

function Vi() {
    const t = vA();
    return (!WX(t) || Tc(t).isOlderThan(Z4)) && ek(t, new V1), zX() ? gwe(t) : Tc(t)
}

function gwe(t) {
    try {
        const e = vA().__SENTRY__,
            n = e && e.extensions && e.extensions.domain && e.extensions.domain.active;
        if (!n) return Tc(t);
        if (!WX(n) || Tc(n).isOlderThan(Z4)) {
            const r = Tc(t).getStackTop();
            ek(n, new V1(r.client, Hd.clone(r.scope)))
        }
        return Tc(n)
    } catch {
        return Tc(t)
    }
}

function WX(t) {
    return !!(t && t.__SENTRY__ && t.__SENTRY__.hub)
}

function Tc(t) {
    return X4("hub", () => new V1, t)
}

function ek(t, e) {
    if (!t) return !1;
    const n = t.__SENTRY__ = t.__SENTRY__ || {};
    return n.hub = e, !0
}

function KX(t, e) {
    return Vi().captureException(t, {
        captureContext: e
    })
}

function ywe(t) {
    Vi().configureScope(t)
}

function qX(t) {
    Vi().withScope(t)
}

function vwe(t) {
    const e = t.protocol ? `${t.protocol}:` : "",
        n = t.port ? `:${t.port}` : "";
    return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
}

function bwe(t, e) {
    const n = ISe(t),
        r = `${vwe(n)}embed/error-page/`;
    let i = `dsn=${MSe(n)}`;
    for (const s in e)
        if (s !== "dsn")
            if (s === "user") {
                const o = e.user;
                if (!o) continue;
                o.name && (i += `&name=${encodeURIComponent(o.name)}`), o.email && (i += `&email=${encodeURIComponent(o.email)}`)
            } else i += `&${encodeURIComponent(s)}=${encodeURIComponent(e[s])}`;
    return `${r}?${i}`
}
let J9;
class I0 {
    constructor() {
        I0.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "FunctionToString"
    }
    __init() {
        this.name = I0.id
    }
    setupOnce() {
        J9 = Function.prototype.toString, Function.prototype.toString = function(...e) {
            const n = Q4(this) || this;
            return J9.apply(n, e)
        }
    }
}
I0.__initStatic();
const xwe = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
class pm {
    static __initStatic() {
        this.id = "InboundFilters"
    }
    __init() {
        this.name = pm.id
    }
    constructor(e = {}) {
        this._options = e, pm.prototype.__init.call(this)
    }
    setupOnce(e, n) {
        const r = i => {
            const s = n();
            if (s) {
                const o = s.getIntegration(pm);
                if (o) {
                    const a = s.getClient(),
                        l = a ? a.getOptions() : {},
                        u = _we(o._options, l);
                    return Swe(i, u) ? null : i
                }
            }
            return i
        };
        r.id = this.name, e(r)
    }
}
pm.__initStatic();

function _we(t = {}, e = {}) {
    return {
        allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
        denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
        ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...xwe],
        ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
    }
}

function Swe(t, e) {
    return e.ignoreInternal && Mwe(t) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`Event dropped due to being internal Sentry Error.
Event: ${Cd(t)}`), !0) : wwe(t, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Cd(t)}`), !0) : Ewe(t, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Cd(t)}.
Url: ${r2(t)}`), !0) : Awe(t, e.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Cd(t)}.
Url: ${r2(t)}`), !0)
}

function wwe(t, e) {
    return !e || !e.length ? !1 : Cwe(t).some(n => J4(n, e))
}

function Ewe(t, e) {
    if (!e || !e.length) return !1;
    const n = r2(t);
    return n ? J4(n, e) : !1
}

function Awe(t, e) {
    if (!e || !e.length) return !0;
    const n = r2(t);
    return n ? J4(n, e) : !0
}

function Cwe(t) {
    if (t.message) return [t.message];
    if (t.exception) try {
        const {
            type: e = "",
            value: n = ""
        } = t.exception.values && t.exception.values[0] || {};
        return [`${n}`, `${e}: ${n}`]
    } catch {
        return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.error(`Cannot extract message for event ${Cd(t)}`), []
    }
    return []
}

function Mwe(t) {
    try {
        return t.exception.values[0].type === "SentryError"
    } catch {}
    return !1
}

function Twe(t = []) {
    for (let e = t.length - 1; e >= 0; e--) {
        const n = t[e];
        if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
    }
    return null
}

function r2(t) {
    try {
        let e;
        try {
            e = t.exception.values[0].stacktrace.frames
        } catch {}
        return e ? Twe(e) : null
    } catch {
        return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.error(`Cannot extract url for event ${Cd(t)}`), null
    }
}
const Ni = Ua;
let gR = 0;

function XX() {
    return gR > 0
}

function Pwe() {
    gR++, setTimeout(() => {
        gR--
    })
}

function Xm(t, e = {}, n) {
    if (typeof t != "function") return t;
    try {
        const i = t.__sentry_wrapped__;
        if (i) return i;
        if (Q4(t)) return t
    } catch {
        return t
    }
    const r = function() {
        const i = Array.prototype.slice.call(arguments);
        try {
            n && typeof n == "function" && n.apply(this, arguments);
            const s = i.map(o => Xm(o, e));
            return t.apply(this, s)
        } catch (s) {
            throw Pwe(), qX(o => {
                o.addEventProcessor(a => (e.mechanism && (pR(a, void 0, void 0), n2(a, e.mechanism)), a.extra = { ...a.extra,
                    arguments: i
                }, a)), KX(s)
            }), s
        }
    };
    try {
        for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && (r[i] = t[i])
    } catch {}
    BX(r, t), Y4(t, "__sentry_wrapped__", r);
    try {
        Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
            get() {
                return t.name
            }
        })
    } catch {}
    return r
}

function JX(t, e) {
    const n = tk(t, e),
        r = {
            type: e && e.name,
            value: Dwe(e)
        };
    return n.length && (r.stacktrace = {
        frames: n
    }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function Iwe(t, e, n, r) {
    const s = Vi().getClient(),
        o = s && s.getOptions().normalizeDepth,
        a = {
            exception: {
                values: [{
                    type: q4(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
                    value: `Non-Error ${r?"promise rejection":"exception"} captured with keys: ${DSe(e)}`
                }]
            },
            extra: {
                __serialized__: HX(e, o)
            }
        };
    if (n) {
        const l = tk(t, n);
        l.length && (a.exception.values[0].stacktrace = {
            frames: l
        })
    }
    return a
}

function BT(t, e) {
    return {
        exception: {
            values: [JX(t, e)]
        }
    }
}

function tk(t, e) {
    const n = e.stacktrace || e.stack || "",
        r = Owe(e);
    try {
        return t(n, r)
    } catch {}
    return []
}
const Rwe = /Minified React error #\d+;/i;

function Owe(t) {
    if (t) {
        if (typeof t.framesToPop == "number") return t.framesToPop;
        if (Rwe.test(t.message)) return 1
    }
    return 0
}

function Dwe(t) {
    const e = t && t.message;
    return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
}

function YX(t, e, n, r, i) {
    let s;
    if (OX(e) && e.error) return BT(t, e.error);
    if (z9(e) || mSe(e)) {
        const o = e;
        if ("stack" in e) s = BT(t, e);
        else {
            const a = o.name || (z9(o) ? "DOMError" : "DOMException"),
                l = o.message ? `${a}: ${o.message}` : a;
            s = Y9(t, l, n, r), pR(s, l)
        }
        return "code" in o && (s.tags = { ...s.tags,
            "DOMException.code": `${o.code}`
        }), s
    }
    return K4(e) ? BT(t, e) : mA(e) || q4(e) ? (s = Iwe(t, e, n, i), n2(s, {
        synthetic: !0
    }), s) : (s = Y9(t, e, n, r), pR(s, `${e}`, void 0), n2(s, {
        synthetic: !0
    }), s)
}

function Y9(t, e, n, r) {
    const i = {
        message: e
    };
    if (r && n) {
        const s = tk(t, n);
        s.length && (i.exception = {
            values: [{
                value: e,
                stacktrace: {
                    frames: s
                }
            }]
        })
    }
    return i
}
const S_ = 1024,
    Lwe = "Breadcrumbs";
class R0 {
    static __initStatic() {
        this.id = Lwe
    }
    __init() {
        this.name = R0.id
    }
    constructor(e) {
        R0.prototype.__init.call(this), this.options = {
            console: !0,
            dom: !0,
            fetch: !0,
            history: !0,
            sentry: !0,
            xhr: !0,
            ...e
        }
    }
    setupOnce() {
        this.options.console && ud("console", Bwe), this.options.dom && ud("dom", kwe(this.options.dom)), this.options.xhr && ud("xhr", Fwe), this.options.fetch && ud("fetch", Nwe), this.options.history && ud("history", zwe)
    }
    addSentryBreadcrumb(e) {
        this.options.sentry && Vi().addBreadcrumb({
            category: `sentry.${e.type==="transaction"?"transaction":"event"}`,
            event_id: e.event_id,
            level: e.level,
            message: Cd(e)
        }, {
            event: e
        })
    }
}
R0.__initStatic();

function kwe(t) {
    function e(n) {
        let r, i = typeof t == "object" ? t.serializeAttribute : void 0,
            s = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
        s && s > S_ && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn(`\`dom.maxStringLength\` cannot exceed ${S_}, but a value of ${s} was configured. Sentry will use ${S_} instead.`), s = S_), typeof i == "string" && (i = [i]);
        try {
            const o = n.event;
            r = Hwe(o) ? fR(o.target, {
                keyAttrs: i,
                maxStringLength: s
            }) : fR(o, {
                keyAttrs: i,
                maxStringLength: s
            })
        } catch {
            r = "<unknown>"
        }
        r.length !== 0 && Vi().addBreadcrumb({
            category: `ui.${n.name}`,
            message: r
        }, {
            event: n.event,
            name: n.name,
            global: n.global
        })
    }
    return e
}

function Bwe(t) {
    for (let n = 0; n < t.args.length; n++)
        if (t.args[n] === "ref=Ref<") {
            t.args[n + 1] = "viewRef";
            break
        }
    const e = {
        category: "console",
        data: {
            arguments: t.args,
            logger: "console"
        },
        level: awe(t.level),
        message: $9(t.args, " ")
    };
    if (t.level === "assert")
        if (t.args[0] === !1) e.message = `Assertion failed: ${$9(t.args.slice(1)," ")||"console.assert"}`, e.data.arguments = t.args.slice(1);
        else return;
    Vi().addBreadcrumb(e, {
        input: t.args,
        level: t.level
    })
}

function Fwe(t) {
    if (t.endTimestamp) {
        if (t.xhr.__sentry_own_request__) return;
        const {
            method: e,
            url: n,
            status_code: r,
            body: i
        } = t.xhr.__sentry_xhr__ || {};
        Vi().addBreadcrumb({
            category: "xhr",
            data: {
                method: e,
                url: n,
                status_code: r
            },
            type: "http"
        }, {
            xhr: t.xhr,
            input: i
        });
        return
    }
}

function Nwe(t) {
    t.endTimestamp && (t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST" || (t.error ? Vi().addBreadcrumb({
        category: "fetch",
        data: t.fetchData,
        level: "error",
        type: "http"
    }, {
        data: t.error,
        input: t.args
    }) : Vi().addBreadcrumb({
        category: "fetch",
        data: { ...t.fetchData,
            status_code: t.response && t.response.status
        },
        type: "http"
    }, {
        input: t.args,
        response: t.response
    })))
}

function zwe(t) {
    let e = t.from,
        n = t.to;
    const r = LT(Ni.location.href);
    let i = LT(e);
    const s = LT(n);
    i.path || (i = r), r.protocol === s.protocol && r.host === s.host && (n = s.relative), r.protocol === i.protocol && r.host === i.host && (e = i.relative), Vi().addBreadcrumb({
        category: "navigation",
        data: {
            from: e,
            to: n
        }
    })
}

function Hwe(t) {
    return t && !!t.target
}
class ef {
    static __initStatic() {
        this.id = "GlobalHandlers"
    }
    __init() {
        this.name = ef.id
    }
    __init2() {
        this._installFunc = {
            onerror: Uwe,
            onunhandledrejection: $we
        }
    }
    constructor(e) {
        ef.prototype.__init.call(this), ef.prototype.__init2.call(this), this._options = {
            onerror: !0,
            onunhandledrejection: !0,
            ...e
        }
    }
    setupOnce() {
        Error.stackTraceLimit = 50;
        const e = this._options;
        for (const n in e) {
            const r = this._installFunc[n];
            r && e[n] && (jwe(n), r(), this._installFunc[n] = void 0)
        }
    }
}
ef.__initStatic();

function Uwe() {
    ud("error", t => {
        const [e, n, r] = eJ();
        if (!e.getIntegration(ef)) return;
        const {
            msg: i,
            url: s,
            line: o,
            column: a,
            error: l
        } = t;
        if (XX() || l && l.__sentry_own_request__) return;
        const u = l === void 0 && lp(i) ? Vwe(i, s, o, a) : QX(YX(n, l || i, void 0, r, !1), s, o, a);
        u.level = "error", ZX(e, l, u, "onerror")
    })
}

function $we() {
    ud("unhandledrejection", t => {
        const [e, n, r] = eJ();
        if (!e.getIntegration(ef)) return;
        let i = t;
        try {
            "reason" in t ? i = t.reason : "detail" in t && "reason" in t.detail && (i = t.detail.reason)
        } catch {}
        if (XX() || i && i.__sentry_own_request__) return !0;
        const s = gSe(i) ? Gwe(i) : YX(n, i, void 0, r, !0);
        s.level = "error", ZX(e, i, s, "onunhandledrejection")
    })
}

function Gwe(t) {
    return {
        exception: {
            values: [{
                type: "UnhandledRejection",
                value: `Non-Error promise rejection captured with value: ${String(t)}`
            }]
        }
    }
}

function Vwe(t, e, n, r) {
    const i = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    let s = OX(t) ? t.message : t,
        o = "Error";
    const a = s.match(i);
    return a && (o = a[1], s = a[2]), QX({
        exception: {
            values: [{
                type: o,
                value: s
            }]
        }
    }, e, n, r)
}

function QX(t, e, n, r) {
    const i = t.exception = t.exception || {},
        s = i.values = i.values || [],
        o = s[0] = s[0] || {},
        a = o.stacktrace = o.stacktrace || {},
        l = a.frames = a.frames || [],
        u = isNaN(parseInt(r, 10)) ? void 0 : r,
        c = isNaN(parseInt(n, 10)) ? void 0 : n,
        f = lp(e) && e.length > 0 ? e : ESe();
    return l.length === 0 && l.push({
        colno: u,
        filename: f,
        function: "?",
        in_app: !0,
        lineno: c
    }), t
}

function jwe(t) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.log(`Global Handler attached: ${t}`)
}

function ZX(t, e, n, r) {
    n2(n, {
        handled: !1,
        type: r
    }), t.captureEvent(n, {
        originalException: e
    })
}

function eJ() {
    const t = Vi(),
        e = t.getClient(),
        n = e && e.getOptions() || {
            stackParser: () => [],
            attachStacktrace: !1
        };
    return [t, n.stackParser, n.attachStacktrace]
}
const Wwe = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
class O0 {
    static __initStatic() {
        this.id = "TryCatch"
    }
    __init() {
        this.name = O0.id
    }
    constructor(e) {
        O0.prototype.__init.call(this), this._options = {
            XMLHttpRequest: !0,
            eventTarget: !0,
            requestAnimationFrame: !0,
            setInterval: !0,
            setTimeout: !0,
            ...e
        }
    }
    setupOnce() {
        this._options.setTimeout && os(Ni, "setTimeout", Q9), this._options.setInterval && os(Ni, "setInterval", Q9), this._options.requestAnimationFrame && os(Ni, "requestAnimationFrame", Kwe), this._options.XMLHttpRequest && "XMLHttpRequest" in Ni && os(XMLHttpRequest.prototype, "send", qwe);
        const e = this._options.eventTarget;
        e && (Array.isArray(e) ? e : Wwe).forEach(Xwe)
    }
}
O0.__initStatic();

function Q9(t) {
    return function(...e) {
        const n = e[0];
        return e[0] = Xm(n, {
            mechanism: {
                data: {
                    function: mf(t)
                },
                handled: !0,
                type: "instrument"
            }
        }), t.apply(this, e)
    }
}

function Kwe(t) {
    return function(e) {
        return t.apply(this, [Xm(e, {
            mechanism: {
                data: {
                    function: "requestAnimationFrame",
                    handler: mf(t)
                },
                handled: !0,
                type: "instrument"
            }
        })])
    }
}

function qwe(t) {
    return function(...e) {
        const n = this;
        return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(i => {
            i in n && typeof n[i] == "function" && os(n, i, function(s) {
                const o = {
                        mechanism: {
                            data: {
                                function: i,
                                handler: mf(s)
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    },
                    a = Q4(s);
                return a && (o.mechanism.data.handler = mf(a)), Xm(s, o)
            })
        }), t.apply(this, e)
    }
}

function Xwe(t) {
    const e = Ni,
        n = e[t] && e[t].prototype;
    !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (os(n, "addEventListener", function(r) {
        return function(i, s, o) {
            try {
                typeof s.handleEvent == "function" && (s.handleEvent = Xm(s.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: mf(s),
                            target: t
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }))
            } catch {}
            return r.apply(this, [i, Xm(s, {
                mechanism: {
                    data: {
                        function: "addEventListener",
                        handler: mf(s),
                        target: t
                    },
                    handled: !0,
                    type: "instrument"
                }
            }), o])
        }
    }), os(n, "removeEventListener", function(r) {
        return function(i, s, o) {
            const a = s;
            try {
                const l = a && a.__sentry_wrapped__;
                l && r.call(this, i, l, o)
            } catch {}
            return r.call(this, i, a, o)
        }
    }))
}
const Jwe = "cause",
    Ywe = 5;
class hm {
    static __initStatic() {
        this.id = "LinkedErrors"
    }
    __init() {
        this.name = hm.id
    }
    constructor(e = {}) {
        hm.prototype.__init.call(this), this._key = e.key || Jwe, this._limit = e.limit || Ywe
    }
    setupOnce() {
        const e = Vi().getClient();
        e && jX((n, r) => {
            const i = Vi().getIntegration(hm);
            return i ? Qwe(e.getOptions().stackParser, i._key, i._limit, n, r) : n
        })
    }
}
hm.__initStatic();

function Qwe(t, e, n, r, i) {
    if (!r.exception || !r.exception.values || !i || !Af(i.originalException, Error)) return r;
    const s = tJ(t, n, i.originalException, e);
    return r.exception.values = [...s, ...r.exception.values], r
}

function tJ(t, e, n, r, i = []) {
    if (!Af(n[r], Error) || i.length + 1 >= e) return i;
    const s = JX(t, n[r]);
    return tJ(t, e, n[r], r, [s, ...i])
}
class mm {
    constructor() {
        mm.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "HttpContext"
    }
    __init() {
        this.name = mm.id
    }
    setupOnce() {
        jX(e => {
            if (Vi().getIntegration(mm)) {
                if (!Ni.navigator && !Ni.location && !Ni.document) return e;
                const n = e.request && e.request.url || Ni.location && Ni.location.href,
                    {
                        referrer: r
                    } = Ni.document || {},
                    {
                        userAgent: i
                    } = Ni.navigator || {},
                    s = { ...e.request && e.request.headers,
                        ...r && {
                            Referer: r
                        },
                        ...i && {
                            "User-Agent": i
                        }
                    },
                    o = { ...e.request,
                        ...n && {
                            url: n
                        },
                        headers: s
                    };
                return { ...e,
                    request: o
                }
            }
            return e
        })
    }
}
mm.__initStatic();
class gm {
    constructor() {
        gm.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "Dedupe"
    }
    __init() {
        this.name = gm.id
    }
    setupOnce(e, n) {
        const r = i => {
            if (i.type) return i;
            const s = n().getIntegration(gm);
            if (s) {
                try {
                    if (Zwe(i, s._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn("Event dropped due to being a duplicate of previously captured event."), null
                } catch {
                    return s._previousEvent = i
                }
                return s._previousEvent = i
            }
            return i
        };
        r.id = this.name, e(r)
    }
}
gm.__initStatic();

function Zwe(t, e) {
    return e ? !!(e2e(t, e) || t2e(t, e)) : !1
}

function e2e(t, e) {
    const n = t.message,
        r = e.message;
    return !(!n && !r || n && !r || !n && r || n !== r || !rJ(t, e) || !nJ(t, e))
}

function t2e(t, e) {
    const n = Z9(e),
        r = Z9(t);
    return !(!n || !r || n.type !== r.type || n.value !== r.value || !rJ(t, e) || !nJ(t, e))
}

function nJ(t, e) {
    let n = ez(t),
        r = ez(e);
    if (!n && !r) return !0;
    if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
    for (let i = 0; i < r.length; i++) {
        const s = r[i],
            o = n[i];
        if (s.filename !== o.filename || s.lineno !== o.lineno || s.colno !== o.colno || s.function !== o.function) return !1
    }
    return !0
}

function rJ(t, e) {
    let n = t.fingerprint,
        r = e.fingerprint;
    if (!n && !r) return !0;
    if (n && !r || !n && r) return !1;
    n = n, r = r;
    try {
        return n.join("") === r.join("")
    } catch {
        return !1
    }
}

function Z9(t) {
    return t.exception && t.exception.values && t.exception.values[0]
}

function ez(t) {
    const e = t.exception;
    if (e) try {
        return e.values[0].stacktrace.frames
    } catch {
        return
    }
}
new pm, new I0, new O0, new R0, new ef, new hm, new gm, new mm;

function n2e(t = {}, e = Vi()) {
    if (!Ni.document) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.error("Global document not defined in showReportDialog call");
        return
    }
    const {
        client: n,
        scope: r
    } = e.getStackTop(), i = t.dsn || n && n.getDsn();
    if (!i) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.error("DSN not configured for showReportDialog call");
        return
    }
    r && (t.user = { ...r.getUser(),
        ...t.user
    }), t.eventId || (t.eventId = e.lastEventId());
    const s = Ni.document.createElement("script");
    s.async = !0, s.src = bwe(i, t), t.onLoad && (s.onload = t.onLoad);
    const o = Ni.document.head || Ni.document.body;
    o ? o.appendChild(s) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.error("Not injecting report dialog. No injection point found in HTML")
}

function r2e(t) {
    const e = t.match(/^([^.]+)/);
    return e !== null && parseInt(e[0]) >= 17
}
const tz = {
    componentStack: null,
    error: null,
    eventId: null
};
let sUe = class yR extends P.Component {
    constructor(...e) {
        super(...e), yR.prototype.__init.call(this), yR.prototype.__init2.call(this)
    }
    __init() {
        this.state = tz
    }
    componentDidCatch(e, {
        componentStack: n
    }) {
        const {
            beforeCapture: r,
            onError: i,
            showDialog: s,
            dialogOptions: o
        } = this.props;
        qX(a => {
            if (r2e(P.version) && K4(e)) {
                const u = new Error(e.message);
                u.name = `React ErrorBoundary ${u.name}`, u.stack = n, e.cause = u
            }
            r && r(a, e, n);
            const l = KX(e, {
                contexts: {
                    react: {
                        componentStack: n
                    }
                }
            });
            i && i(e, n, l), s && n2e({ ...o,
                eventId: l
            }), this.setState({
                error: e,
                componentStack: n,
                eventId: l
            })
        })
    }
    componentDidMount() {
        const {
            onMount: e
        } = this.props;
        e && e()
    }
    componentWillUnmount() {
        const {
            error: e,
            componentStack: n,
            eventId: r
        } = this.state, {
            onUnmount: i
        } = this.props;
        i && i(e, n, r)
    }
    __init2() {
        this.resetErrorBoundary = () => {
            const {
                onReset: e
            } = this.props, {
                error: n,
                componentStack: r,
                eventId: i
            } = this.state;
            e && e(n, r, i), this.setState(tz)
        }
    }
    render() {
        const {
            fallback: e,
            children: n
        } = this.props, r = this.state;
        if (r.error) {
            let i;
            return typeof e == "function" ? i = e({
                error: r.error,
                componentStack: r.componentStack,
                resetError: this.resetErrorBoundary,
                eventId: r.eventId
            }) : i = e, P.isValidElement(i) ? i : (e && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Jr.warn("fallback did not produce a valid ReactElement"), null)
        }
        return typeof n == "function" ? n() : n
    }
};
const i2e = "redux.action",
    s2e = "info",
    o2e = {
        actionTransformer: t => t,
        stateTransformer: t => t || null
    };

function oUe(t) {
    const e = { ...o2e,
        ...t
    };
    return n => (r, i) => n((o, a) => {
        const l = r(o, a);
        return ywe(u => {
            const c = e.actionTransformer(a);
            typeof c < "u" && c !== null && u.addBreadcrumb({
                category: i2e,
                data: c,
                type: s2e
            });
            const f = e.stateTransformer(l);
            if (typeof f < "u" && f !== null) {
                const p = Vi().getClient(),
                    m = p && p.getOptions(),
                    y = m && m.normalizeDepth || 3,
                    v = {
                        state: {
                            type: "redux",
                            value: f
                        }
                    };
                Y4(v, "__sentry_override_normalization_depth__", 3 + y), u.setContext("state", v)
            } else u.setContext("state", null);
            const {
                configureScopeWithState: d
            } = e;
            typeof d == "function" && d(u, l)
        }), l
    }, i)
}
const a2e = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    l2e = a2e ? P.useLayoutEffect : P.useEffect,
    u2e = P.useInsertionEffect || l2e,
    iJ = t => {
        const e = P.useRef([t, (...n) => e[0](...n)]).current;
        return u2e(() => {
            e[0] = t
        }), e[1]
    },
    c2e = (t = "", e = location.pathname) => e.toLowerCase().indexOf(t.toLowerCase()) ? "~" + e : e.slice(t.length) || "/",
    f2e = (t, e = "") => t[0] === "~" ? t.slice(1) : e + t,
    d2e = "popstate",
    nk = "pushState",
    rk = "replaceState",
    p2e = "hashchange",
    nz = [d2e, nk, rk, p2e],
    h2e = t => {
        for (const e of nz) addEventListener(e, t);
        return () => {
            for (const e of nz) removeEventListener(e, t)
        }
    },
    m2e = t => KG.useSyncExternalStore(h2e, t),
    g2e = () => location.pathname,
    y2e = () => m2e(g2e),
    v2e = (t, {
        replace: e = !1
    } = {}) => history[e ? rk : nk](null, "", t),
    b2e = (t = {}) => [c2e(t.base, y2e()), iJ((e, n) => v2e(f2e(e, t.base), n))];
if (typeof history < "u")
    for (const t of [nk, rk]) {
        const e = history[t];
        history[t] = function() {
            const n = e.apply(this, arguments),
                r = new Event(t);
            return r.arguments = arguments, dispatchEvent(r), n
        }
    }

function x2e(t = S2e) {
    let e = {};
    const n = r => e[r] || (e[r] = t(r));
    return (r, i) => {
        const {
            regexp: s,
            keys: o
        } = n(r || ""), a = s.exec(i);
        return a ? [!0, o.reduce((u, c, f) => (u[c.name] = a[f + 1], u), {})] : [!1, null]
    }
}
const rz = t => t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1"),
    _2e = (t, e, n) => {
        let r = t ? "((?:[^\\/]+?)(?:\\/(?:[^\\/]+?))*)" : "([^\\/]+?)";
        return e && n && (r = "(?:\\/" + r + ")"), r + (e ? "?" : "")
    },
    S2e = t => {
        const e = /:([A-Za-z0-9_]+)([?+*]?)/g;
        let n = null,
            r = 0,
            i = [],
            s = "";
        for (;
            (n = e.exec(t)) !== null;) {
            const [o, a, l] = n, u = l === "+" || l === "*", c = l === "?" || l === "*", f = c && t[n.index - 1] === "/" ? 1 : 0, d = t.substring(r, n.index - f);
            i.push({
                name: a
            }), r = e.lastIndex, s += rz(d) + _2e(u, c, f)
        }
        return s += rz(t.substring(r)), {
            keys: i,
            regexp: new RegExp("^" + s + "(?:\\/)?$", "i")
        }
    },
    w2e = {
        hook: b2e,
        matcher: x2e(),
        base: ""
    },
    E2e = P.createContext(w2e),
    ik = () => P.useContext(E2e),
    sk = t => t.hook(t),
    aUe = () => sk(ik()),
    A2e = t => {
        const e = ik(),
            [n] = sk(e);
        return e.matcher(t, n)
    },
    lUe = ({
        path: t,
        match: e,
        component: n,
        children: r
    }) => {
        const i = A2e(t),
            [s, o] = e || i;
        return s ? n ? P.createElement(n, {
            params: o
        }) : typeof r == "function" ? r(o) : r : null
    },
    uUe = P.forwardRef((t, e) => {
        const n = ik(),
            [, r] = sk(n),
            {
                to: i,
                href: s = i,
                children: o,
                onClick: a
            } = t,
            l = iJ(f => {
                f.ctrlKey || f.metaKey || f.altKey || f.shiftKey || f.button !== 0 || (a && a(f), f.defaultPrevented || (f.preventDefault(), r(i || s, t)))
            }),
            u = {
                href: s[0] === "~" ? s.slice(1) : n.base + s,
                onClick: l,
                to: null,
                ref: e
            },
            c = P.isValidElement(o) ? o : P.createElement("a", t);
        return P.cloneElement(c, u)
    });
var sJ = {
    exports: {}
};
(function(t) {
    (function() {
        var e = ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "borderStyle", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing", "tabSize", "MozTabSize"],
            n = typeof window < "u",
            r = n && window.mozInnerScreenX != null;

        function i(s, o, a) {
            if (!n) throw new Error("textarea-caret-position#getCaretCoordinates should only be called in a browser");
            var l = a && a.debug || !1;
            if (l) {
                var u = document.querySelector("#input-textarea-caret-position-mirror-div");
                u && u.parentNode.removeChild(u)
            }
            var c = document.createElement("div");
            c.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(c);
            var f = c.style,
                d = window.getComputedStyle ? getComputedStyle(s) : s.currentStyle;
            f.whiteSpace = "pre-wrap", s.nodeName !== "INPUT" && (f.wordWrap = "break-word"), f.position = "absolute", l || (f.visibility = "hidden"), e.forEach(function(y) {
                f[y] = d[y]
            }), r ? s.scrollHeight > parseInt(d.height) && (f.overflowY = "scroll") : f.overflow = "hidden", c.textContent = s.value.substring(0, o), s.nodeName === "INPUT" && (c.textContent = c.textContent.replace(/\s/g, " "));
            var p = document.createElement("span");
            p.textContent = s.value.substring(o) || ".", c.appendChild(p);
            var m = {
                top: p.offsetTop + parseInt(d.borderTopWidth),
                left: p.offsetLeft + parseInt(d.borderLeftWidth)
            };
            return l ? p.style.backgroundColor = "#aaa" : document.body.removeChild(c), m
        }
        t.exports = i
    })()
})(sJ);
var C2e = sJ.exports;
const M2e = la(C2e);
var oJ = _n.CustomEvent;

function T2e() {
    try {
        var t = new oJ("cat", {
            detail: {
                foo: "bar"
            }
        });
        return t.type === "cat" && t.detail.foo === "bar"
    } catch {}
    return !1
}
var P2e = T2e() ? oJ : typeof document < "u" && typeof document.createEvent == "function" ? function(e, n) {
    var r = document.createEvent("CustomEvent");
    return n ? r.initCustomEvent(e, n.bubbles, n.cancelable, n.detail) : r.initCustomEvent(e, !1, !1, void 0), r
} : function(e, n) {
    var r = document.createEventObject();
    return r.type = e, n ? (r.bubbles = !!n.bubbles, r.cancelable = !!n.cancelable, r.detail = n.detail) : (r.bubbles = !1, r.cancelable = !1, r.detail = void 0), r
};
const I2e = la(P2e);

function R2e(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function O2e(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {},
            r = Object.keys(n);
        typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        }))), r.forEach(function(i) {
            R2e(t, i, n[i])
        })
    }
    return t
}

function j1(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function iz(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
}

function bA(t, e, n) {
    return e && iz(t.prototype, e), n && iz(t, n), t
}

function ym(t) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ym = function(n) {
        return typeof n
    } : ym = function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
    }, ym(t)
}

function BS(t) {
    return typeof Symbol == "function" && ym(Symbol.iterator) === "symbol" ? BS = function(n) {
        return ym(n)
    } : BS = function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : ym(n)
    }, BS(t)
}

function D2e(t) {
    if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}

function xA(t, e) {
    return e && (BS(e) === "object" || typeof e == "function") ? e : D2e(t)
}

function Jm(t) {
    return Jm = Object.setPrototypeOf ? Object.getPrototypeOf : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Jm(t)
}

function vR(t, e) {
    return vR = Object.setPrototypeOf || function(r, i) {
        return r.__proto__ = i, r
    }, vR(t, e)
}

function _A(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), e && vR(t, e)
}

function L2e(t) {
    if (Array.isArray(t)) {
        for (var e = 0, n = new Array(t.length); e < t.length; e++) n[e] = t[e];
        return n
    }
}

function k2e(t) {
    if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === "[object Arguments]") return Array.from(t)
}

function B2e() {
    throw new TypeError("Invalid attempt to spread non-iterable instance")
}

function F2e(t) {
    return L2e(t) || k2e(t) || B2e()
}
var ro = {
        ESC: 27,
        UP: 38,
        DOWN: 40,
        LEFT: 37,
        RIGHT: 39,
        ENTER: 13,
        TAB: 9
    },
    N2e = function t() {
        var e = this;
        j1(this, t), this.startListen = function(n) {
            n && n.addEventListener("keydown", e.f)
        }, this.stopListen = function(n) {
            n && n.removeEventListener("keydown", e.f)
        }, this.add = function(n, r) {
            var i = n;
            return typeof i != "object" && (i = [i]), e.listeners[e.index] = {
                keyCode: i,
                fn: r
            }, e.index++
        }, this.remove = function(n) {
            delete e.listeners[n]
        }, this.removeAll = function() {
            e.listeners = {}, e.index = 1
        }, this.index = 1, this.listeners = {}, this.f = function(n) {
            if (n) {
                var r = n.keyCode || n.which;
                Object.values(e.listeners).forEach(function(i) {
                    var s = i.keyCode,
                        o = i.fn;
                    s.includes(r) && (n.stopPropagation(), n.preventDefault(), o(n))
                })
            }
        }
    },
    Md = new N2e,
    z2e = function(t) {
        _A(e, t);

        function e() {
            var n, r;
            j1(this, e);
            for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++) s[o] = arguments[o];
            return r = xA(this, (n = Jm(e)).call.apply(n, [this].concat(s))), r.selectItem = function() {
                var a = r.props,
                    l = a.item,
                    u = a.onSelectHandler;
                u(l)
            }, r
        }
        return bA(e, [{
            key: "shouldComponentUpdate",
            value: function(r) {
                return this.props.item !== r.item || this.props.selected !== r.selected || this.props.style !== r.style || this.props.className !== r.className
            }
        }, {
            key: "render",
            value: function() {
                var r = this,
                    i = this.props,
                    s = i.component,
                    o = i.style,
                    a = i.onClickHandler,
                    l = i.item,
                    u = i.selected,
                    c = i.className,
                    f = i.innerRef;
                return Bt.createElement("li", {
                    className: "rta__item  ".concat(u === !0 ? "rta__item--selected" : "", " ").concat(c || ""),
                    style: o
                }, Bt.createElement("div", {
                    className: "rta__entity ".concat(u === !0 ? "rta__entity--selected" : ""),
                    role: "button",
                    tabIndex: 0,
                    onClick: a,
                    onFocus: this.selectItem,
                    onMouseEnter: this.selectItem,
                    onTouchStart: function() {
                        r.clicked = !0, r.selectItem()
                    },
                    onTouchEnd: function(p) {
                        p.preventDefault(), r.clicked && a(p)
                    },
                    onTouchMove: function() {
                        r.clicked = !1
                    },
                    onTouchCancel: function() {
                        r.clicked = !1
                    },
                    ref: f
                }, Bt.createElement(s, {
                    selected: u,
                    entity: l
                })))
            }
        }]), e
    }(Bt.Component),
    H2e = function(t) {
        _A(e, t);

        function e() {
            var n, r;
            j1(this, e);
            for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++) s[o] = arguments[o];
            return r = xA(this, (n = Jm(e)).call.apply(n, [this].concat(s))), r.state = {
                selectedItem: null
            }, r.cachedIdOfItems = new Map, r.onPressEnter = function(a) {
                typeof a < "u" && a.preventDefault();
                var l = r.props.values;
                r.modifyText(l[r.getPositionInList()])
            }, r.getPositionInList = function() {
                var a = r.props.values,
                    l = r.state.selectedItem;
                return l ? a.findIndex(function(u) {
                    return r.getId(u) === r.getId(l)
                }) : 0
            }, r.getId = function(a) {
                if (r.cachedIdOfItems.has(a)) return r.cachedIdOfItems.get(a);
                var l = r.props.getTextToReplace(a),
                    u = function() {
                        if (l) {
                            if (l.key) return l.key;
                            if (typeof a == "string" || !a.key) return l.text
                        }
                        if (!a.key) throw new Error("Item ".concat(JSON.stringify(a), ' has to have defined "key" property'));
                        return a.key
                    },
                    c = u();
                return r.cachedIdOfItems.set(a, c), c
            }, r.listeners = [], r.itemsRef = {}, r.modifyText = function(a) {
                if (a) {
                    var l = r.props.onSelect;
                    l(a)
                }
            }, r.selectItem = function(a) {
                var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
                    u = r.props.onItemHighlighted;
                r.state.selectedItem !== a && r.setState({
                    selectedItem: a
                }, function() {
                    u(a), l && r.props.dropdownScroll(r.itemsRef[r.getId(a)])
                })
            }, r.scroll = function(a) {
                a.preventDefault();
                var l = r.props.values,
                    u = a.keyCode || a.which,
                    c = r.getPositionInList(),
                    f;
                switch (u) {
                    case ro.DOWN:
                        f = c + 1;
                        break;
                    case ro.UP:
                        f = c - 1;
                        break;
                    default:
                        f = c;
                        break
                }
                f = (f % l.length + l.length) % l.length, r.selectItem(l[f], [ro.DOWN, ro.UP].includes(u))
            }, r.isSelected = function(a) {
                var l = r.state.selectedItem;
                return l ? r.getId(l) === r.getId(a) : !1
            }, r
        }
        return bA(e, [{
            key: "componentDidMount",
            value: function() {
                this.listeners.push(Md.add([ro.DOWN, ro.UP], this.scroll), Md.add([ro.ENTER, ro.TAB], this.onPressEnter));
                var r = this.props.values;
                r && r[0] && this.selectItem(r[0])
            }
        }, {
            key: "componentDidUpdate",
            value: function(r) {
                var i = this,
                    s = r.values,
                    o = this.props.values,
                    a = s.map(function(u) {
                        return i.getId(u)
                    }).join(""),
                    l = o.map(function(u) {
                        return i.getId(u)
                    }).join("");
                a !== l && o && o[0] && this.selectItem(o[0])
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                for (var r; this.listeners.length;) r = this.listeners.pop(), Md.remove(r)
            }
        }, {
            key: "render",
            value: function() {
                var r = this,
                    i = this.props,
                    s = i.values,
                    o = i.component,
                    a = i.style,
                    l = i.itemClassName,
                    u = i.className,
                    c = i.itemStyle;
                return Bt.createElement("ul", {
                    className: "rta__list ".concat(u || ""),
                    style: a
                }, s.map(function(f) {
                    return Bt.createElement(z2e, {
                        key: r.getId(f),
                        innerRef: function(p) {
                            r.itemsRef[r.getId(f)] = p
                        },
                        selected: r.isSelected(f),
                        item: f,
                        className: l,
                        style: c,
                        onClickHandler: r.onPressEnter,
                        onSelectHandler: r.selectItem,
                        component: o
                    })
                }))
            }
        }]), e
    }(Bt.Component);

function U2e(t, e) {
    var n = parseInt(getComputedStyle(e).getPropertyValue("height"), 10),
        r = parseInt(getComputedStyle(t).getPropertyValue("height"), 10) - n,
        i = e.offsetTop,
        s = t.scrollTop;
    i < s + r && s < i || (t.scrollTop = i)
}
var sz = "next",
    gc = {
        X: {
            LEFT: "rta__autocomplete--left",
            RIGHT: "rta__autocomplete--right"
        },
        Y: {
            TOP: "rta__autocomplete--top",
            BOTTOM: "rta__autocomplete--bottom"
        }
    },
    oz = function(e) {
        return console.error("RTA: dataProvider fails: ".concat(e, `
    
Check the documentation or create issue if you think it's bug. https://github.com/webscopeio/react-textarea-autocomplete/issues`))
    },
    $2e = [".", "^", "$", "*", "+", "-", "?", "(", ")", "[", "]", "{", "}", "\\", "|"],
    w_ = function(e) {
        return F2e(e).map(function(n) {
            return $2e.includes(n) ? "\\".concat(n) : n
        }).join("")
    },
    G2e = function(t) {
        _A(e, t);

        function e() {
            return j1(this, e), xA(this, Jm(e).apply(this, arguments))
        }
        return bA(e, [{
            key: "componentDidMount",
            value: function() {
                var r = this.props.boundariesElement;
                if (typeof r == "string") {
                    var i = document.querySelector(r);
                    if (!i) throw new Error("RTA: Invalid prop boundariesElement: it has to be string or HTMLElement.");
                    this.containerElem = i
                } else if (r instanceof HTMLElement) this.containerElem = r;
                else throw new Error("RTA: Invalid prop boundariesElement: it has to be string or HTMLElement.");
                if (!this.containerElem || !this.containerElem.contains(this.ref)) throw new Error("RTA: Invalid prop boundariesElement: it has to be one of the parents of the RTA.")
            }
        }, {
            key: "componentDidUpdate",
            value: function() {
                var r, i, s = this.props.top || 0,
                    o = this.props.left || 0,
                    a = [],
                    l = [],
                    u = 0,
                    c = 0,
                    f = this.containerElem.getBoundingClientRect(),
                    d = this.ref.getBoundingClientRect(),
                    p = this.props.textareaRef.getBoundingClientRect(),
                    m = window.getComputedStyle(this.ref),
                    y = parseInt(m.getPropertyValue("margin-top"), 10),
                    v = parseInt(m.getPropertyValue("margin-bottom"), 10),
                    b = parseInt(m.getPropertyValue("margin-left"), 10),
                    _ = parseInt(m.getPropertyValue("margin-right"), 10),
                    x = y + v + p.top + s + d.height,
                    S = b + _ + p.left + o + d.width;
                S > f.right && p.left + o > d.width ? (c = o - d.width, a.push(gc.X.LEFT), l.push(gc.X.RIGHT)) : (c = o, a.push(gc.X.RIGHT), l.push(gc.X.LEFT)), x > f.bottom && p.top + s > d.height ? (u = s - d.height, a.push(gc.Y.TOP), l.push(gc.Y.BOTTOM)) : (u = s, a.push(gc.Y.BOTTOM), l.push(gc.Y.TOP)), this.props.renderToBody && (u += p.top, c += p.left), this.ref.style.top = "".concat(u, "px"), this.ref.style.left = "".concat(c, "px"), (r = this.ref.classList).remove.apply(r, l), (i = this.ref.classList).add.apply(i, a)
            }
        }, {
            key: "render",
            value: function() {
                var r = this,
                    i = this.props,
                    s = i.style,
                    o = i.className,
                    a = i.innerRef,
                    l = i.children,
                    u = i.renderToBody,
                    c = document.body,
                    f = Bt.createElement("div", {
                        ref: function(p) {
                            r.ref = p, a(p)
                        },
                        className: "rta__autocomplete ".concat(o || ""),
                        style: s
                    }, l);
                return u && c !== null ? kh.createPortal(f, c) : f
            }
        }]), e
    }(Bt.Component),
    V2e = function(t) {
        _A(e, t);

        function e(n) {
            var r;
            j1(this, e), r = xA(this, Jm(e).call(this, n)), r.state = {
                top: null,
                left: null,
                currentTrigger: null,
                actualToken: "",
                data: null,
                value: "",
                dataLoading: !1,
                selectionEnd: 0,
                component: null,
                textToReplace: null
            }, r.escListenerInit = function() {
                r.escListener || (r.escListener = Md.add(ro.ESC, r._closeAutocomplete))
            }, r.escListenerDestroy = function() {
                r.escListener && (Md.remove(r.escListener), r.escListener = null)
            }, r.getSelectionPosition = function() {
                return r.textareaRef ? {
                    selectionStart: r.textareaRef.selectionStart,
                    selectionEnd: r.textareaRef.selectionEnd
                } : null
            }, r.getSelectedText = function() {
                if (!r.textareaRef) return null;
                var l = r.textareaRef,
                    u = l.selectionStart,
                    c = l.selectionEnd;
                return u === c ? null : r.state.value.substr(u, c - u)
            }, r.setCaretPosition = function() {
                var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                r.textareaRef && (r.textareaRef.focus(), r.textareaRef.setSelectionRange(l, l))
            }, r.getCaretPosition = function() {
                if (!r.textareaRef) return 0;
                var l = r.textareaRef.selectionEnd;
                return l
            }, r._handleCaretChange = function(l) {
                var u = function() {
                    var d = r.getCaretPosition() - 1;
                    r.lastTrigger = r.lastTrigger ? d : 0
                };
                if (l.type === "keydown") {
                    var c = l.keyCode || l.which;
                    switch (c) {
                        case ro.UP:
                        case ro.DOWN:
                            r._isAutocompleteOpen() || u();
                            break;
                        case ro.LEFT:
                        case ro.RIGHT:
                            u();
                            break
                    }
                    return
                }
                u()
            }, r._onSelect = function(l) {
                var u = r.state,
                    c = u.selectionEnd,
                    f = u.currentTrigger,
                    d = u.value,
                    p = r.props.onItemSelected;
                if (f) {
                    var m = r._getTextToReplace(f);
                    if (!m) {
                        r._closeAutocomplete();
                        return
                    }
                    var y = m(l);
                    if (!y) {
                        r._closeAutocomplete();
                        return
                    }
                    p && p({
                        currentTrigger: f,
                        item: l
                    });
                    var v = function(O, k, H) {
                            switch (O) {
                                case "start":
                                    return H;
                                case "next":
                                case "end":
                                    return H + k.length;
                                default:
                                    if (!Number.isInteger(O)) throw new Error('RTA: caretPosition should be "start", "next", "end" or number.');
                                    return O
                            }
                        },
                        b = d.slice(0, c),
                        _ = w_(f),
                        x = b.length - b.lastIndexOf(f),
                        S = b.search(new RegExp("(?!".concat(_, ")$"))) - x,
                        E = y.caretPosition === "next" ? "".concat(y.text, " ") : y.text,
                        A = v(y.caretPosition, E, S),
                        T = b.substring(0, S) + E,
                        M = d.replace(b, T);
                    r.setState({
                        value: M,
                        dataLoading: !1
                    }, function() {
                        var I = r.tokenRegExpEnding.exec(E),
                            O = I ? I[0].length : 1;
                        r.lastTrigger = A && A - O, r.textareaRef.value = M, r.textareaRef.selectionEnd = A, r._changeHandler();
                        var k = r.textareaRef.scrollTop;
                        r.setCaretPosition(A), window.chrome && (r.textareaRef.scrollTop = k)
                    })
                }
            }, r._getTextToReplace = function(l) {
                var u = r.props.trigger[l];
                if (!l || !u) return null;
                var c = u.output;
                return function(f) {
                    if (typeof f == "object" && (!c || typeof c != "function")) throw new Error('Output functor is not defined! If you are using items as object you have to define "output" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');
                    if (c) {
                        var d = c(f, l);
                        if (d === void 0 || typeof d == "number") throw new Error(`Output functor should return string or object in shape {text: string, caretPosition: string | number}.
Got "`.concat(String(d), '". Check the implementation for trigger "').concat(l, `"

See https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more information.
`));
                        if (d === null) return null;
                        if (typeof d == "string") return {
                            text: d,
                            caretPosition: sz
                        };
                        if (!d.text && typeof d.text != "string") throw new Error('Output "text" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger "'.concat(l, `"
`));
                        if (!d.caretPosition) throw new Error('Output "caretPosition" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger "'.concat(l, `"
`));
                        return d
                    }
                    if (typeof f != "string") throw new Error(`Output item should be string
`);
                    return {
                        text: "".concat(l).concat(f).concat(l),
                        caretPosition: sz
                    }
                }
            }, r._getCurrentTriggerSettings = function() {
                var l = r.state.currentTrigger;
                return l ? r.props.trigger[l] : null
            }, r._getValuesFromProvider = function() {
                var l = r.state,
                    u = l.currentTrigger,
                    c = l.actualToken,
                    f = r._getCurrentTriggerSettings();
                if (!(!u || !f)) {
                    var d = f.dataProvider,
                        p = f.component;
                    if (typeof d != "function") throw new Error("Trigger provider has to be a function!");
                    r.setState({
                        dataLoading: !0
                    });
                    var m = d(c);
                    m instanceof Promise || (m = Promise.resolve(m)), m.then(function(y) {
                        if (!Array.isArray(y)) throw new Error("Trigger provider has to provide an array!");
                        if (typeof p != "function") throw new Error("Component should be defined!");
                        if (u === r.state.currentTrigger) {
                            if (!y.length) {
                                r._closeAutocomplete();
                                return
                            }
                            r.setState({
                                dataLoading: !1,
                                data: y,
                                component: p
                            })
                        }
                    }).catch(function(y) {
                        return oz(y.message)
                    })
                }
            }, r._getSuggestions = function() {
                var l = r.state,
                    u = l.currentTrigger,
                    c = l.data;
                return !u || !c || c && !c.length ? null : c
            }, r._createRegExp = function() {
                var l = r.props.trigger;
                r.tokenRegExp = new RegExp("(".concat(Object.keys(l).sort(function(u, c) {
                    return u < c ? 1 : u > c ? -1 : 0
                }).map(function(u) {
                    return w_(u)
                }).join("|"), ")((?:(?!\\1)[^\\s])*$)")), r.tokenRegExpEnding = new RegExp("(".concat(Object.keys(l).sort(function(u, c) {
                    return u < c ? 1 : u > c ? -1 : 0
                }).map(function(u) {
                    return w_(u)
                }).join("|"), ")$"))
            }, r._closeAutocomplete = function() {
                var l = r.state.currentTrigger;
                r.escListenerDestroy(), r.setState({
                    data: null,
                    dataLoading: !1,
                    currentTrigger: null
                }, function() {
                    l && r._onItemHighlightedHandler(null)
                })
            }, r._cleanUpProps = function() {
                var l = O2e({}, r.props),
                    u = ["loadingComponent", "boundariesElement", "containerStyle", "minChar", "scrollToItem", "ref", "innerRef", "onChange", "onCaretPositionChange", "className", "value", "trigger", "listStyle", "itemStyle", "containerStyle", "loaderStyle", "className", "containerClassName", "listClassName", "itemClassName", "loaderClassName", "dropdownStyle", "dropdownClassName", "movePopupAsYouType", "textAreaComponent", "renderToBody", "onItemSelected", "onItemHighlighted"];
                for (var c in l) u.includes(c) && delete l[c];
                return l
            }, r._changeHandler = function(l) {
                var u = r.props,
                    c = u.trigger,
                    f = u.onChange,
                    d = u.minChar,
                    p = u.onCaretPositionChange,
                    m = u.movePopupAsYouType,
                    y = r.state,
                    v = y.top,
                    b = y.left,
                    _ = l;
                _ || (_ = new I2e("change", {
                    bubbles: !0
                }), r.textareaRef.dispatchEvent(_));
                var x = _.target || r.textareaRef,
                    S = x.selectionEnd,
                    E = x.value;
                if (r.lastValueBubbledEvent = E, f && _ && (_.persist && _.persist(), f(new Proxy(_, {
                        get: function(W, se, ee) {
                            return se === "target" ? x : Reflect.get(W, se, ee)
                        }
                    }))), p) {
                    var A = r.getCaretPosition();
                    p(A)
                }
                r.setState({
                    value: E
                });
                var T = function() {
                        var W = M2e(x, S),
                            se = W.top,
                            ee = W.left;
                        r.setState({
                            top: se - r.textareaRef.scrollTop || 0,
                            left: ee
                        })
                    },
                    M = function(W) {
                        r.lastTrigger = S - W, r._closeAutocomplete(), T()
                    };
                if (S <= r.lastTrigger) {
                    var I = E.slice(0, S),
                        O = r.tokenRegExp.exec(I);
                    M(O ? O[0].length : 0)
                }
                var k = E.slice(r.lastTrigger, S),
                    H = r.tokenRegExp.exec(k),
                    N = H && H[0],
                    B = H && H[1] || null,
                    U = B ? B.length - 1 : 0,
                    q = r.tokenRegExpEnding.exec(k);
                if (q ? M(q[0].length) : r._isAutocompleteOpen() || r._closeAutocomplete(), (!N || N.length <= d + U) && (r.state.currentTrigger && !c[r.state.currentTrigger].allowWhitespace || !r.state.currentTrigger)) {
                    r._closeAutocomplete();
                    return
                }
                if (B && c[B].afterWhitespace && !/\s/.test(E[S - N.length - 1]) && E[S - N.length - 1] !== void 0) {
                    r._closeAutocomplete();
                    return
                }
                if (r.state.currentTrigger && c[r.state.currentTrigger].allowWhitespace) {
                    if (H = new RegExp("".concat(w_(r.state.currentTrigger), ".*$")).exec(E.slice(0, S)), N = H && H[0], !N) {
                        r._closeAutocomplete();
                        return
                    }
                    B = Object.keys(c).find(function(G) {
                        return G.slice(0, U + 1) === N.slice(0, U + 1)
                    }) || null
                }
                var Q = N.slice(1);
                if (B) {
                    (m || v === null && b === null || r.state.currentTrigger !== B) && T(), r.escListenerInit();
                    var F = r._getTextToReplace(B);
                    r.setState({
                        selectionEnd: S,
                        currentTrigger: B,
                        textToReplace: F,
                        actualToken: Q
                    }, function() {
                        try {
                            r._getValuesFromProvider()
                        } catch (G) {
                            oz(G.message)
                        }
                    })
                }
            }, r._selectHandler = function(l) {
                var u = r.props,
                    c = u.onCaretPositionChange,
                    f = u.onSelect;
                if (c) {
                    var d = r.getCaretPosition();
                    c(d)
                }
                f && (l.persist(), f(l))
            }, r._shouldStayOpen = function(l) {
                var u = l.relatedTarget;
                return u === null && (u = document.activeElement), !!(r.dropdownRef && u instanceof Node && r.dropdownRef.contains(u))
            }, r._onClick = function(l) {
                var u = r.props.onClick;
                u && (l.persist(), u(l)), !r._shouldStayOpen(l) && r._closeAutocomplete()
            }, r._onBlur = function(l) {
                var u = r.props.onBlur;
                u && (l.persist(), u(l)), !r._shouldStayOpen(l) && r._closeAutocomplete()
            }, r._onScrollHandler = function() {
                r._closeAutocomplete()
            }, r._onItemHighlightedHandler = function(l) {
                var u = r.props.onItemHighlighted,
                    c = r.state.currentTrigger;
                if (u)
                    if (typeof u == "function") u({
                        currentTrigger: c,
                        item: l
                    });
                    else throw new Error("`onItemHighlighted` has to be a function")
            }, r._dropdownScroll = function(l) {
                var u = r.props.scrollToItem;
                if (u) {
                    if (u === !0) {
                        U2e(r.dropdownRef, l);
                        return
                    }
                    if (typeof u != "function" || u.length !== 2) throw new Error("`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.");
                    u(r.dropdownRef, l)
                }
            }, r._isAutocompleteOpen = function() {
                var l = r.state,
                    u = l.dataLoading,
                    c = l.currentTrigger,
                    f = r._getSuggestions();
                return !!((u || f) && c)
            }, r._textareaRef = function(l) {
                r.props.innerRef && r.props.innerRef(l), r.textareaRef = l
            }, r.lastTrigger = 0, r.escListener = null;
            var i = r.props,
                s = i.loadingComponent,
                o = i.trigger,
                a = i.value;
            if (a && (r.state.value = a), r._createRegExp(), !s) throw new Error("RTA: loadingComponent is not defined");
            if (!o) throw new Error("RTA: trigger is not defined");
            return r
        }
        return bA(e, [{
            key: "componentDidMount",
            value: function() {
                Md.startListen(this.textareaRef), this.textareaRef && this.textareaRef.addEventListener("focus", this._handleCaretChange), this.textareaRef && this.textareaRef.addEventListener("click", this._handleCaretChange), this.textareaRef && this.textareaRef.addEventListener("keydown", this._handleCaretChange)
            }
        }, {
            key: "componentDidUpdate",
            value: function(r) {
                var i = r.trigger,
                    s = r.value,
                    o = this.props,
                    a = o.trigger,
                    l = o.value;
                Object.keys(a).join("") !== Object.keys(i).join("") && this._createRegExp(), s !== l && this.lastValueBubbledEvent !== l && (this.lastTrigger = 0, this._changeHandler())
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                this.escListenerDestroy(), Md.stopListen(this.textareaRef), this.textareaRef && this.textareaRef.removeEventListener("focus", this._handleCaretChange), this.textareaRef && this.textareaRef.removeEventListener("click", this._handleCaretChange), this.textareaRef && this.textareaRef.removeEventListener("keydown", this._handleCaretChange)
            }
        }, {
            key: "render",
            value: function() {
                var r = this,
                    i = this.props,
                    s = i.loadingComponent,
                    o = i.style,
                    a = i.className,
                    l = i.listStyle,
                    u = i.itemStyle,
                    c = i.boundariesElement,
                    f = i.movePopupAsYouType,
                    d = i.listClassName,
                    p = i.itemClassName,
                    m = i.dropdownClassName,
                    y = i.dropdownStyle,
                    v = i.containerStyle,
                    b = i.containerClassName,
                    _ = i.loaderStyle,
                    x = i.loaderClassName,
                    S = i.textAreaComponent,
                    E = i.renderToBody,
                    A = this.state,
                    T = A.left,
                    M = A.top,
                    I = A.dataLoading,
                    O = A.component,
                    k = A.value,
                    H = A.textToReplace,
                    N = this._isAutocompleteOpen(),
                    B = this._getSuggestions(),
                    U = {},
                    q;
                return S.component ? (q = S.component, U[S.ref] = this._textareaRef) : (q = S, U.ref = this._textareaRef), Bt.createElement("div", {
                    className: "rta ".concat(I === !0 ? "rta--loading" : "", " ").concat(b || ""),
                    style: v
                }, Bt.createElement(q, Object.assign({}, this._cleanUpProps(), {
                    className: "rta__textarea ".concat(a || ""),
                    onChange: this._changeHandler,
                    onSelect: this._selectHandler,
                    onScroll: this._onScrollHandler,
                    onClick: this._onClick,
                    onBlur: this._onBlur,
                    value: k,
                    style: o
                }, U)), N && Bt.createElement(G2e, {
                    innerRef: function(F) {
                        r.dropdownRef = F
                    },
                    top: M,
                    left: T,
                    style: y,
                    className: m,
                    movePopupAsYouType: f,
                    boundariesElement: c,
                    textareaRef: this.textareaRef,
                    renderToBody: E
                }, B && O && H && Bt.createElement(H2e, {
                    values: B,
                    component: O,
                    style: l,
                    className: d,
                    itemClassName: p,
                    itemStyle: u,
                    getTextToReplace: H,
                    onItemHighlighted: this._onItemHighlightedHandler,
                    onSelect: this._onSelect,
                    dropdownScroll: this._dropdownScroll
                }), I && Bt.createElement("div", {
                    className: "rta__loader ".concat(B !== null ? "rta__loader--suggestion-data" : "rta__loader--empty-suggestion-data", " ").concat(x || ""),
                    style: _
                }, Bt.createElement(s, {
                    data: B
                }))))
            }
        }], [{
            key: "getDerivedStateFromProps",
            value: function(r) {
                var i = r.value;
                return i == null ? null : {
                    value: i
                }
            }
        }]), e
    }(Bt.Component);
V2e.defaultProps = {
    movePopupAsYouType: !1,
    value: null,
    minChar: 1,
    boundariesElement: "body",
    scrollToItem: !0,
    textAreaComponent: "textarea",
    renderToBody: !1
};

function D0(t) {
    let e = "https://mui.com/production-error/?code=" + t;
    for (let n = 1; n < arguments.length; n += 1) e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified MUI error #" + t + "; visit " + e + " for the full message."
}
const j2e = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: D0
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    SA = "$$material";
var W2e = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
    K2e = BK(function(t) {
        return W2e.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91
    }),
    q2e = K2e,
    X2e = function(e) {
        return e !== "theme"
    },
    az = function(e) {
        return typeof e == "string" && e.charCodeAt(0) > 96 ? q2e : X2e
    },
    lz = function(e, n, r) {
        var i;
        if (n) {
            var s = n.shouldForwardProp;
            i = e.__emotion_forwardProp && s ? function(o) {
                return e.__emotion_forwardProp(o) && s(o)
            } : s
        }
        return typeof i != "function" && r && (i = e.__emotion_forwardProp), i
    },
    J2e = function(e) {
        var n = e.cache,
            r = e.serialized,
            i = e.isStringTag;
        return N4(n, r, i), Kq(function() {
            return z4(n, r, i)
        }), null
    },
    Y2e = function t(e, n) {
        var r = e.__emotion_real === e,
            i = r && e.__emotion_base || e,
            s, o;
        n !== void 0 && (s = n.label, o = n.target);
        var a = lz(e, n, r),
            l = a || az(i),
            u = !l("as");
        return function() {
            var c = arguments,
                f = r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
            if (s !== void 0 && f.push("label:" + s + ";"), c[0] == null || c[0].raw === void 0) f.push.apply(f, c);
            else {
                f.push(c[0][0]);
                for (var d = c.length, p = 1; p < d; p++) f.push(c[p], c[0][p])
            }
            var m = U4(function(y, v, b) {
                var _ = u && y.as || i,
                    x = "",
                    S = [],
                    E = y;
                if (y.theme == null) {
                    E = {};
                    for (var A in y) E[A] = y[A];
                    E.theme = P.useContext($1)
                }
                typeof y.className == "string" ? x = Vq(v.registered, S, y.className) : y.className != null && (x = y.className + " ");
                var T = dA(f.concat(S), v.registered, E);
                x += v.key + "-" + T.name, o !== void 0 && (x += " " + o);
                var M = u && a === void 0 ? az(_) : l,
                    I = {};
                for (var O in y) u && O === "as" || M(O) && (I[O] = y[O]);
                return I.className = x, I.ref = b, P.createElement(P.Fragment, null, P.createElement(J2e, {
                    cache: v,
                    serialized: T,
                    isStringTag: typeof _ == "string"
                }), P.createElement(_, I))
            });
            return m.displayName = s !== void 0 ? s : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", m.defaultProps = e.defaultProps, m.__emotion_real = m, m.__emotion_base = i, m.__emotion_styles = f, m.__emotion_forwardProp = a, Object.defineProperty(m, "toString", {
                value: function() {
                    return "." + o
                }
            }), m.withComponent = function(y, v) {
                return t(y, Y({}, n, v, {
                    shouldForwardProp: lz(m, v, !0)
                })).apply(void 0, f)
            }, m
        }
    },
    Q2e = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"],
    bR = Y2e.bind();
Q2e.forEach(function(t) {
    bR[t] = bR(t)
});
let xR;
typeof document == "object" && (xR = Gq({
    key: "css",
    prepend: !0
}));

function Z2e(t) {
    const {
        injectFirst: e,
        children: n
    } = t;
    return e && xR ? gt(vbe, {
        value: xR,
        children: n
    }) : n
}

function eEe(t) {
    return t == null || Object.keys(t).length === 0
}

function tEe(t) {
    const {
        styles: e,
        defaultTheme: n = {}
    } = t;
    return gt(wbe, {
        styles: typeof e == "function" ? i => e(eEe(i) ? n : i) : e
    })
}
/**
 * @mui/styled-engine v5.15.14
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function ok(t, e) {
    return bR(t, e)
}
const aJ = (t, e) => {
        Array.isArray(t.__emotion_styles) && (t.__emotion_styles = e(t.__emotion_styles))
    },
    nEe = Object.freeze(Object.defineProperty({
        __proto__: null,
        GlobalStyles: tEe,
        StyledEngineProvider: Z2e,
        ThemeContext: $1,
        css: pA,
        default: ok,
        internal_processStyles: aJ,
        keyframes: G1
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function yu(t) {
    if (typeof t != "object" || t === null) return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}

function lJ(t) {
    if (!yu(t)) return t;
    const e = {};
    return Object.keys(t).forEach(n => {
        e[n] = lJ(t[n])
    }), e
}

function Yo(t, e, n = {
    clone: !0
}) {
    const r = n.clone ? Y({}, t) : t;
    return yu(t) && yu(e) && Object.keys(e).forEach(i => {
        i !== "__proto__" && (yu(e[i]) && i in t && yu(t[i]) ? r[i] = Yo(t[i], e[i], n) : n.clone ? r[i] = yu(e[i]) ? lJ(e[i]) : e[i] : r[i] = e[i])
    }), r
}
const rEe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Yo,
        isPlainObject: yu
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    iEe = ["values", "unit", "step"],
    sEe = t => {
        const e = Object.keys(t).map(n => ({
            key: n,
            val: t[n]
        })) || [];
        return e.sort((n, r) => n.val - r.val), e.reduce((n, r) => Y({}, n, {
            [r.key]: r.val
        }), {})
    };

function uJ(t) {
    const {
        values: e = {
            xs: 0,
            sm: 600,
            md: 900,
            lg: 1200,
            xl: 1536
        },
        unit: n = "px",
        step: r = 5
    } = t, i = Rt(t, iEe), s = sEe(e), o = Object.keys(s);

    function a(d) {
        return `@media (min-width:${typeof e[d]=="number"?e[d]:d}${n})`
    }

    function l(d) {
        return `@media (max-width:${(typeof e[d]=="number"?e[d]:d)-r/100}${n})`
    }

    function u(d, p) {
        const m = o.indexOf(p);
        return `@media (min-width:${typeof e[d]=="number"?e[d]:d}${n}) and (max-width:${(m!==-1&&typeof e[o[m]]=="number"?e[o[m]]:p)-r/100}${n})`
    }

    function c(d) {
        return o.indexOf(d) + 1 < o.length ? u(d, o[o.indexOf(d) + 1]) : a(d)
    }

    function f(d) {
        const p = o.indexOf(d);
        return p === 0 ? a(o[1]) : p === o.length - 1 ? l(o[p]) : u(d, o[o.indexOf(d) + 1]).replace("@media", "@media not all and")
    }
    return Y({
        keys: o,
        values: s,
        up: a,
        down: l,
        between: u,
        only: c,
        not: f,
        unit: n
    }, i)
}
const oEe = {
        borderRadius: 4
    },
    aEe = oEe;

function Ev(t, e) {
    return e ? Yo(t, e, {
        clone: !1
    }) : t
}
const ak = {
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    },
    uz = {
        keys: ["xs", "sm", "md", "lg", "xl"],
        up: t => `@media (min-width:${ak[t]}px)`
    };

function Wa(t, e, n) {
    const r = t.theme || {};
    if (Array.isArray(e)) {
        const s = r.breakpoints || uz;
        return e.reduce((o, a, l) => (o[s.up(s.keys[l])] = n(e[l]), o), {})
    }
    if (typeof e == "object") {
        const s = r.breakpoints || uz;
        return Object.keys(e).reduce((o, a) => {
            if (Object.keys(s.values || ak).indexOf(a) !== -1) {
                const l = s.up(a);
                o[l] = n(e[a], a)
            } else {
                const l = a;
                o[l] = e[l]
            }
            return o
        }, {})
    }
    return n(e)
}

function cJ(t = {}) {
    var e;
    return ((e = t.keys) == null ? void 0 : e.reduce((r, i) => {
        const s = t.up(i);
        return r[s] = {}, r
    }, {})) || {}
}

function fJ(t, e) {
    return t.reduce((n, r) => {
        const i = n[r];
        return (!i || Object.keys(i).length === 0) && delete n[r], n
    }, e)
}

function lEe(t, ...e) {
    const n = cJ(t),
        r = [n, ...e].reduce((i, s) => Yo(i, s), {});
    return fJ(Object.keys(n), r)
}

function uEe(t, e) {
    if (typeof t != "object") return {};
    const n = {},
        r = Object.keys(e);
    return Array.isArray(t) ? r.forEach((i, s) => {
        s < t.length && (n[i] = !0)
    }) : r.forEach(i => {
        t[i] != null && (n[i] = !0)
    }), n
}

function FT({
    values: t,
    breakpoints: e,
    base: n
}) {
    const r = n || uEe(t, e),
        i = Object.keys(r);
    if (i.length === 0) return t;
    let s;
    return i.reduce((o, a, l) => (Array.isArray(t) ? (o[a] = t[l] != null ? t[l] : t[s], s = l) : typeof t == "object" ? (o[a] = t[a] != null ? t[a] : t[s], s = a) : o[a] = t, o), {})
}

function Wt(t) {
    if (typeof t != "string") throw new Error(D0(7));
    return t.charAt(0).toUpperCase() + t.slice(1)
}
const cEe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Wt
}, Symbol.toStringTag, {
    value: "Module"
}));

function wA(t, e, n = !0) {
    if (!e || typeof e != "string") return null;
    if (t && t.vars && n) {
        const r = `vars.${e}`.split(".").reduce((i, s) => i && i[s] ? i[s] : null, t);
        if (r != null) return r
    }
    return e.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, t)
}

function i2(t, e, n, r = n) {
    let i;
    return typeof t == "function" ? i = t(n) : Array.isArray(t) ? i = t[n] || r : i = wA(t, n) || r, e && (i = e(i, r, t)), i
}

function Yr(t) {
    const {
        prop: e,
        cssProperty: n = t.prop,
        themeKey: r,
        transform: i
    } = t, s = o => {
        if (o[e] == null) return null;
        const a = o[e],
            l = o.theme,
            u = wA(l, r) || {};
        return Wa(o, a, f => {
            let d = i2(u, i, f);
            return f === d && typeof f == "string" && (d = i2(u, i, `${e}${f==="default"?"":Wt(f)}`, f)), n === !1 ? d : {
                [n]: d
            }
        })
    };
    return s.propTypes = {}, s.filterProps = [e], s
}

function fEe(t) {
    const e = {};
    return n => (e[n] === void 0 && (e[n] = t(n)), e[n])
}
const dEe = {
        m: "margin",
        p: "padding"
    },
    pEe = {
        t: "Top",
        r: "Right",
        b: "Bottom",
        l: "Left",
        x: ["Left", "Right"],
        y: ["Top", "Bottom"]
    },
    cz = {
        marginX: "mx",
        marginY: "my",
        paddingX: "px",
        paddingY: "py"
    },
    hEe = fEe(t => {
        if (t.length > 2)
            if (cz[t]) t = cz[t];
            else return [t];
        const [e, n] = t.split(""), r = dEe[e], i = pEe[n] || "";
        return Array.isArray(i) ? i.map(s => r + s) : [r + i]
    }),
    lk = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"],
    uk = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...lk, ...uk];

function W1(t, e, n, r) {
    var i;
    const s = (i = wA(t, e, !1)) != null ? i : n;
    return typeof s == "number" ? o => typeof o == "string" ? o : s * o : Array.isArray(s) ? o => typeof o == "string" ? o : s[o] : typeof s == "function" ? s : () => {}
}

function ck(t) {
    return W1(t, "spacing", 8)
}

function up(t, e) {
    if (typeof e == "string" || e == null) return e;
    const n = Math.abs(e),
        r = t(n);
    return e >= 0 ? r : typeof r == "number" ? -r : `-${r}`
}

function mEe(t, e) {
    return n => t.reduce((r, i) => (r[i] = up(e, n), r), {})
}

function gEe(t, e, n, r) {
    if (e.indexOf(n) === -1) return null;
    const i = hEe(n),
        s = mEe(i, r),
        o = t[n];
    return Wa(t, o, s)
}

function dJ(t, e) {
    const n = ck(t.theme);
    return Object.keys(t).map(r => gEe(t, e, r, n)).reduce(Ev, {})
}

function Dr(t) {
    return dJ(t, lk)
}
Dr.propTypes = {};
Dr.filterProps = lk;

function Lr(t) {
    return dJ(t, uk)
}
Lr.propTypes = {};
Lr.filterProps = uk;

function yEe(t = 8) {
    if (t.mui) return t;
    const e = ck({
            spacing: t
        }),
        n = (...r) => (r.length === 0 ? [1] : r).map(s => {
            const o = e(s);
            return typeof o == "number" ? `${o}px` : o
        }).join(" ");
    return n.mui = !0, n
}

function EA(...t) {
    const e = t.reduce((r, i) => (i.filterProps.forEach(s => {
            r[s] = i
        }), r), {}),
        n = r => Object.keys(r).reduce((i, s) => e[s] ? Ev(i, e[s](r)) : i, {});
    return n.propTypes = {}, n.filterProps = t.reduce((r, i) => r.concat(i.filterProps), []), n
}

function Ho(t) {
    return typeof t != "number" ? t : `${t}px solid`
}

function ca(t, e) {
    return Yr({
        prop: t,
        themeKey: "borders",
        transform: e
    })
}
const vEe = ca("border", Ho),
    bEe = ca("borderTop", Ho),
    xEe = ca("borderRight", Ho),
    _Ee = ca("borderBottom", Ho),
    SEe = ca("borderLeft", Ho),
    wEe = ca("borderColor"),
    EEe = ca("borderTopColor"),
    AEe = ca("borderRightColor"),
    CEe = ca("borderBottomColor"),
    MEe = ca("borderLeftColor"),
    TEe = ca("outline", Ho),
    PEe = ca("outlineColor"),
    AA = t => {
        if (t.borderRadius !== void 0 && t.borderRadius !== null) {
            const e = W1(t.theme, "shape.borderRadius", 4),
                n = r => ({
                    borderRadius: up(e, r)
                });
            return Wa(t, t.borderRadius, n)
        }
        return null
    };
AA.propTypes = {};
AA.filterProps = ["borderRadius"];
EA(vEe, bEe, xEe, _Ee, SEe, wEe, EEe, AEe, CEe, MEe, AA, TEe, PEe);
const CA = t => {
    if (t.gap !== void 0 && t.gap !== null) {
        const e = W1(t.theme, "spacing", 8),
            n = r => ({
                gap: up(e, r)
            });
        return Wa(t, t.gap, n)
    }
    return null
};
CA.propTypes = {};
CA.filterProps = ["gap"];
const MA = t => {
    if (t.columnGap !== void 0 && t.columnGap !== null) {
        const e = W1(t.theme, "spacing", 8),
            n = r => ({
                columnGap: up(e, r)
            });
        return Wa(t, t.columnGap, n)
    }
    return null
};
MA.propTypes = {};
MA.filterProps = ["columnGap"];
const TA = t => {
    if (t.rowGap !== void 0 && t.rowGap !== null) {
        const e = W1(t.theme, "spacing", 8),
            n = r => ({
                rowGap: up(e, r)
            });
        return Wa(t, t.rowGap, n)
    }
    return null
};
TA.propTypes = {};
TA.filterProps = ["rowGap"];
const IEe = Yr({
        prop: "gridColumn"
    }),
    REe = Yr({
        prop: "gridRow"
    }),
    OEe = Yr({
        prop: "gridAutoFlow"
    }),
    DEe = Yr({
        prop: "gridAutoColumns"
    }),
    LEe = Yr({
        prop: "gridAutoRows"
    }),
    kEe = Yr({
        prop: "gridTemplateColumns"
    }),
    BEe = Yr({
        prop: "gridTemplateRows"
    }),
    FEe = Yr({
        prop: "gridTemplateAreas"
    }),
    NEe = Yr({
        prop: "gridArea"
    });
EA(CA, MA, TA, IEe, REe, OEe, DEe, LEe, kEe, BEe, FEe, NEe);

function vm(t, e) {
    return e === "grey" ? e : t
}
const zEe = Yr({
        prop: "color",
        themeKey: "palette",
        transform: vm
    }),
    HEe = Yr({
        prop: "bgcolor",
        cssProperty: "backgroundColor",
        themeKey: "palette",
        transform: vm
    }),
    UEe = Yr({
        prop: "backgroundColor",
        themeKey: "palette",
        transform: vm
    });
EA(zEe, HEe, UEe);

function io(t) {
    return t <= 1 && t !== 0 ? `${t*100}%` : t
}
const $Ee = Yr({
        prop: "width",
        transform: io
    }),
    fk = t => {
        if (t.maxWidth !== void 0 && t.maxWidth !== null) {
            const e = n => {
                var r, i;
                const s = ((r = t.theme) == null || (r = r.breakpoints) == null || (r = r.values) == null ? void 0 : r[n]) || ak[n];
                return s ? ((i = t.theme) == null || (i = i.breakpoints) == null ? void 0 : i.unit) !== "px" ? {
                    maxWidth: `${s}${t.theme.breakpoints.unit}`
                } : {
                    maxWidth: s
                } : {
                    maxWidth: io(n)
                }
            };
            return Wa(t, t.maxWidth, e)
        }
        return null
    };
fk.filterProps = ["maxWidth"];
const GEe = Yr({
        prop: "minWidth",
        transform: io
    }),
    VEe = Yr({
        prop: "height",
        transform: io
    }),
    jEe = Yr({
        prop: "maxHeight",
        transform: io
    }),
    WEe = Yr({
        prop: "minHeight",
        transform: io
    });
Yr({
    prop: "size",
    cssProperty: "width",
    transform: io
});
Yr({
    prop: "size",
    cssProperty: "height",
    transform: io
});
const KEe = Yr({
    prop: "boxSizing"
});
EA($Ee, fk, GEe, VEe, jEe, WEe, KEe);
const qEe = {
        border: {
            themeKey: "borders",
            transform: Ho
        },
        borderTop: {
            themeKey: "borders",
            transform: Ho
        },
        borderRight: {
            themeKey: "borders",
            transform: Ho
        },
        borderBottom: {
            themeKey: "borders",
            transform: Ho
        },
        borderLeft: {
            themeKey: "borders",
            transform: Ho
        },
        borderColor: {
            themeKey: "palette"
        },
        borderTopColor: {
            themeKey: "palette"
        },
        borderRightColor: {
            themeKey: "palette"
        },
        borderBottomColor: {
            themeKey: "palette"
        },
        borderLeftColor: {
            themeKey: "palette"
        },
        outline: {
            themeKey: "borders",
            transform: Ho
        },
        outlineColor: {
            themeKey: "palette"
        },
        borderRadius: {
            themeKey: "shape.borderRadius",
            style: AA
        },
        color: {
            themeKey: "palette",
            transform: vm
        },
        bgcolor: {
            themeKey: "palette",
            cssProperty: "backgroundColor",
            transform: vm
        },
        backgroundColor: {
            themeKey: "palette",
            transform: vm
        },
        p: {
            style: Lr
        },
        pt: {
            style: Lr
        },
        pr: {
            style: Lr
        },
        pb: {
            style: Lr
        },
        pl: {
            style: Lr
        },
        px: {
            style: Lr
        },
        py: {
            style: Lr
        },
        padding: {
            style: Lr
        },
        paddingTop: {
            style: Lr
        },
        paddingRight: {
            style: Lr
        },
        paddingBottom: {
            style: Lr
        },
        paddingLeft: {
            style: Lr
        },
        paddingX: {
            style: Lr
        },
        paddingY: {
            style: Lr
        },
        paddingInline: {
            style: Lr
        },
        paddingInlineStart: {
            style: Lr
        },
        paddingInlineEnd: {
            style: Lr
        },
        paddingBlock: {
            style: Lr
        },
        paddingBlockStart: {
            style: Lr
        },
        paddingBlockEnd: {
            style: Lr
        },
        m: {
            style: Dr
        },
        mt: {
            style: Dr
        },
        mr: {
            style: Dr
        },
        mb: {
            style: Dr
        },
        ml: {
            style: Dr
        },
        mx: {
            style: Dr
        },
        my: {
            style: Dr
        },
        margin: {
            style: Dr
        },
        marginTop: {
            style: Dr
        },
        marginRight: {
            style: Dr
        },
        marginBottom: {
            style: Dr
        },
        marginLeft: {
            style: Dr
        },
        marginX: {
            style: Dr
        },
        marginY: {
            style: Dr
        },
        marginInline: {
            style: Dr
        },
        marginInlineStart: {
            style: Dr
        },
        marginInlineEnd: {
            style: Dr
        },
        marginBlock: {
            style: Dr
        },
        marginBlockStart: {
            style: Dr
        },
        marginBlockEnd: {
            style: Dr
        },
        displayPrint: {
            cssProperty: !1,
            transform: t => ({
                "@media print": {
                    display: t
                }
            })
        },
        display: {},
        overflow: {},
        textOverflow: {},
        visibility: {},
        whiteSpace: {},
        flexBasis: {},
        flexDirection: {},
        flexWrap: {},
        justifyContent: {},
        alignItems: {},
        alignContent: {},
        order: {},
        flex: {},
        flexGrow: {},
        flexShrink: {},
        alignSelf: {},
        justifyItems: {},
        justifySelf: {},
        gap: {
            style: CA
        },
        rowGap: {
            style: TA
        },
        columnGap: {
            style: MA
        },
        gridColumn: {},
        gridRow: {},
        gridAutoFlow: {},
        gridAutoColumns: {},
        gridAutoRows: {},
        gridTemplateColumns: {},
        gridTemplateRows: {},
        gridTemplateAreas: {},
        gridArea: {},
        position: {},
        zIndex: {
            themeKey: "zIndex"
        },
        top: {},
        right: {},
        bottom: {},
        left: {},
        boxShadow: {
            themeKey: "shadows"
        },
        width: {
            transform: io
        },
        maxWidth: {
            style: fk
        },
        minWidth: {
            transform: io
        },
        height: {
            transform: io
        },
        maxHeight: {
            transform: io
        },
        minHeight: {
            transform: io
        },
        boxSizing: {},
        fontFamily: {
            themeKey: "typography"
        },
        fontSize: {
            themeKey: "typography"
        },
        fontStyle: {
            themeKey: "typography"
        },
        fontWeight: {
            themeKey: "typography"
        },
        letterSpacing: {},
        textTransform: {},
        lineHeight: {},
        textAlign: {},
        typography: {
            cssProperty: !1,
            themeKey: "typography"
        }
    },
    K1 = qEe;

function XEe(...t) {
    const e = t.reduce((r, i) => r.concat(Object.keys(i)), []),
        n = new Set(e);
    return t.every(r => n.size === Object.keys(r).length)
}

function JEe(t, e) {
    return typeof t == "function" ? t(e) : t
}

function pJ() {
    function t(n, r, i, s) {
        const o = {
                [n]: r,
                theme: i
            },
            a = s[n];
        if (!a) return {
            [n]: r
        };
        const {
            cssProperty: l = n,
            themeKey: u,
            transform: c,
            style: f
        } = a;
        if (r == null) return null;
        if (u === "typography" && r === "inherit") return {
            [n]: r
        };
        const d = wA(i, u) || {};
        return f ? f(o) : Wa(o, r, m => {
            let y = i2(d, c, m);
            return m === y && typeof m == "string" && (y = i2(d, c, `${n}${m==="default"?"":Wt(m)}`, m)), l === !1 ? y : {
                [l]: y
            }
        })
    }

    function e(n) {
        var r;
        const {
            sx: i,
            theme: s = {}
        } = n || {};
        if (!i) return null;
        const o = (r = s.unstable_sxConfig) != null ? r : K1;

        function a(l) {
            let u = l;
            if (typeof l == "function") u = l(s);
            else if (typeof l != "object") return l;
            if (!u) return null;
            const c = cJ(s.breakpoints),
                f = Object.keys(c);
            let d = c;
            return Object.keys(u).forEach(p => {
                const m = JEe(u[p], s);
                if (m != null)
                    if (typeof m == "object")
                        if (o[p]) d = Ev(d, t(p, m, s, o));
                        else {
                            const y = Wa({
                                theme: s
                            }, m, v => ({
                                [p]: v
                            }));
                            XEe(y, m) ? d[p] = e({
                                sx: m,
                                theme: s
                            }) : d = Ev(d, y)
                        }
                else d = Ev(d, t(p, m, s, o))
            }), fJ(f, d)
        }
        return Array.isArray(i) ? i.map(a) : a(i)
    }
    return e
}
const hJ = pJ();
hJ.filterProps = ["sx"];
const q1 = hJ;

function mJ(t, e) {
    const n = this;
    return n.vars && typeof n.getColorSchemeSelector == "function" ? {
        [n.getColorSchemeSelector(t).replace(/(\[[^\]]+\])/, "*:where($1)")]: e
    } : n.palette.mode === t ? e : {}
}
const YEe = ["breakpoints", "palette", "spacing", "shape"];

function Tg(t = {}, ...e) {
    const {
        breakpoints: n = {},
        palette: r = {},
        spacing: i,
        shape: s = {}
    } = t, o = Rt(t, YEe), a = uJ(n), l = yEe(i);
    let u = Yo({
        breakpoints: a,
        direction: "ltr",
        components: {},
        palette: Y({
            mode: "light"
        }, r),
        spacing: l,
        shape: Y({}, aEe, s)
    }, o);
    return u.applyStyles = mJ, u = e.reduce((c, f) => Yo(c, f), u), u.unstable_sxConfig = Y({}, K1, o == null ? void 0 : o.unstable_sxConfig), u.unstable_sx = function(f) {
        return q1({
            sx: f,
            theme: this
        })
    }, u
}
const QEe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Tg,
    private_createBreakpoints: uJ,
    unstable_applyStyles: mJ
}, Symbol.toStringTag, {
    value: "Module"
}));

function ZEe(t) {
    return Object.keys(t).length === 0
}

function eAe(t = null) {
    const e = P.useContext($1);
    return !e || ZEe(e) ? t : e
}
const tAe = Tg();

function dk(t = tAe) {
    return eAe(t)
}
const nAe = ["sx"],
    rAe = t => {
        var e, n;
        const r = {
                systemProps: {},
                otherProps: {}
            },
            i = (e = t == null || (n = t.theme) == null ? void 0 : n.unstable_sxConfig) != null ? e : K1;
        return Object.keys(t).forEach(s => {
            i[s] ? r.systemProps[s] = t[s] : r.otherProps[s] = t[s]
        }), r
    };

function PA(t) {
    const {
        sx: e
    } = t, n = Rt(t, nAe), {
        systemProps: r,
        otherProps: i
    } = rAe(n);
    let s;
    return Array.isArray(e) ? s = [r, ...e] : typeof e == "function" ? s = (...o) => {
        const a = e(...o);
        return yu(a) ? Y({}, r, a) : r
    } : s = Y({}, r, e), Y({}, i, {
        sx: s
    })
}
const iAe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: q1,
        extendSxProp: PA,
        unstable_createStyleFunctionSx: pJ,
        unstable_defaultSxConfig: K1
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    fz = t => t,
    sAe = () => {
        let t = fz;
        return {
            configure(e) {
                t = e
            },
            generate(e) {
                return t(e)
            },
            reset() {
                t = fz
            }
        }
    },
    oAe = sAe(),
    pk = oAe;

function gJ(t) {
    var e, n, r = "";
    if (typeof t == "string" || typeof t == "number") r += t;
    else if (typeof t == "object")
        if (Array.isArray(t)) {
            var i = t.length;
            for (e = 0; e < i; e++) t[e] && (n = gJ(t[e])) && (r && (r += " "), r += n)
        } else
            for (n in t) t[n] && (r && (r += " "), r += n);
    return r
}

function Nt() {
    for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)(t = arguments[n]) && (e = gJ(t)) && (r && (r += " "), r += e);
    return r
}
const aAe = ["className", "component"];

function lAe(t = {}) {
    const {
        themeId: e,
        defaultTheme: n,
        defaultClassName: r = "MuiBox-root",
        generateClassName: i
    } = t, s = ok("div", {
        shouldForwardProp: a => a !== "theme" && a !== "sx" && a !== "as"
    })(q1);
    return P.forwardRef(function(l, u) {
        const c = dk(n),
            f = PA(l),
            {
                className: d,
                component: p = "div"
            } = f,
            m = Rt(f, aAe);
        return gt(s, Y({
            as: p,
            ref: u,
            className: Nt(d, i ? i(r) : r),
            theme: e && c[e] || c
        }, m))
    })
}
const yJ = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
};

function Jn(t, e, n = "Mui") {
    const r = yJ[e];
    return r ? `${n}-${r}` : `${pk.generate(t)}-${e}`
}

function tr(t, e, n = "Mui") {
    const r = {};
    return e.forEach(i => {
        r[i] = Jn(t, i, n)
    }), r
}
const uAe = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;

function vJ(t) {
    const e = `${t}`.match(uAe);
    return e && e[1] || ""
}

function bJ(t, e = "") {
    return t.displayName || t.name || vJ(t) || e
}

function dz(t, e, n) {
    const r = bJ(e);
    return t.displayName || (r !== "" ? `${n}(${r})` : n)
}

function cAe(t) {
    if (t != null) {
        if (typeof t == "string") return t;
        if (typeof t == "function") return bJ(t, "Component");
        if (typeof t == "object") switch (t.$$typeof) {
            case dv.ForwardRef:
                return dz(t, t.render, "ForwardRef");
            case dv.Memo:
                return dz(t, t.type, "memo");
            default:
                return
        }
    }
}
const fAe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: cAe,
        getFunctionName: vJ
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    dAe = ["ownerState"],
    pAe = ["variants"],
    hAe = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];

function mAe(t) {
    return Object.keys(t).length === 0
}

function gAe(t) {
    return typeof t == "string" && t.charCodeAt(0) > 96
}

function NT(t) {
    return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as"
}
const yAe = Tg(),
    vAe = t => t && t.charAt(0).toLowerCase() + t.slice(1);

function E_({
    defaultTheme: t,
    theme: e,
    themeId: n
}) {
    return mAe(e) ? t : e[n] || e
}

function bAe(t) {
    return t ? (e, n) => n[t] : null
}

function FS(t, e) {
    let {
        ownerState: n
    } = e, r = Rt(e, dAe);
    const i = typeof t == "function" ? t(Y({
        ownerState: n
    }, r)) : t;
    if (Array.isArray(i)) return i.flatMap(s => FS(s, Y({
        ownerState: n
    }, r)));
    if (i && typeof i == "object" && Array.isArray(i.variants)) {
        const {
            variants: s = []
        } = i;
        let a = Rt(i, pAe);
        return s.forEach(l => {
            let u = !0;
            typeof l.props == "function" ? u = l.props(Y({
                ownerState: n
            }, r, n)) : Object.keys(l.props).forEach(c => {
                (n == null ? void 0 : n[c]) !== l.props[c] && r[c] !== l.props[c] && (u = !1)
            }), u && (Array.isArray(a) || (a = [a]), a.push(typeof l.style == "function" ? l.style(Y({
                ownerState: n
            }, r, n)) : l.style))
        }), a
    }
    return i
}

function xAe(t = {}) {
    const {
        themeId: e,
        defaultTheme: n = yAe,
        rootShouldForwardProp: r = NT,
        slotShouldForwardProp: i = NT
    } = t, s = o => q1(Y({}, o, {
        theme: E_(Y({}, o, {
            defaultTheme: n,
            themeId: e
        }))
    }));
    return s.__mui_systemSx = !0, (o, a = {}) => {
        aJ(o, E => E.filter(A => !(A != null && A.__mui_systemSx)));
        const {
            name: l,
            slot: u,
            skipVariantsResolver: c,
            skipSx: f,
            overridesResolver: d = bAe(vAe(u))
        } = a, p = Rt(a, hAe), m = c !== void 0 ? c : u && u !== "Root" && u !== "root" || !1, y = f || !1;
        let v, b = NT;
        u === "Root" || u === "root" ? b = r : u ? b = i : gAe(o) && (b = void 0);
        const _ = ok(o, Y({
                shouldForwardProp: b,
                label: v
            }, p)),
            x = E => typeof E == "function" && E.__emotion_real !== E || yu(E) ? A => FS(E, Y({}, A, {
                theme: E_({
                    theme: A.theme,
                    defaultTheme: n,
                    themeId: e
                })
            })) : E,
            S = (E, ...A) => {
                let T = x(E);
                const M = A ? A.map(x) : [];
                l && d && M.push(k => {
                    const H = E_(Y({}, k, {
                        defaultTheme: n,
                        themeId: e
                    }));
                    if (!H.components || !H.components[l] || !H.components[l].styleOverrides) return null;
                    const N = H.components[l].styleOverrides,
                        B = {};
                    return Object.entries(N).forEach(([U, q]) => {
                        B[U] = FS(q, Y({}, k, {
                            theme: H
                        }))
                    }), d(k, B)
                }), l && !m && M.push(k => {
                    var H;
                    const N = E_(Y({}, k, {
                            defaultTheme: n,
                            themeId: e
                        })),
                        B = N == null || (H = N.components) == null || (H = H[l]) == null ? void 0 : H.variants;
                    return FS({
                        variants: B
                    }, Y({}, k, {
                        theme: N
                    }))
                }), y || M.push(s);
                const I = M.length - A.length;
                if (Array.isArray(E) && I > 0) {
                    const k = new Array(I).fill("");
                    T = [...E, ...k], T.raw = [...E.raw, ...k]
                }
                const O = _(T, ...M);
                return o.muiName && (O.muiName = o.muiName), O
            };
        return _.withConfig && (S.withConfig = _.withConfig), S
    }
}
const _Ae = xAe(),
    xJ = _Ae;

function hk(t, e) {
    const n = Y({}, e);
    return Object.keys(t).forEach(r => {
        if (r.toString().match(/^(components|slots)$/)) n[r] = Y({}, t[r], n[r]);
        else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
            const i = t[r] || {},
                s = e[r];
            n[r] = {}, !s || !Object.keys(s) ? n[r] = i : !i || !Object.keys(i) ? n[r] = s : (n[r] = Y({}, s), Object.keys(i).forEach(o => {
                n[r][o] = hk(i[o], s[o])
            }))
        } else n[r] === void 0 && (n[r] = t[r])
    }), n
}

function SAe(t) {
    const {
        theme: e,
        name: n,
        props: r
    } = t;
    return !e || !e.components || !e.components[n] || !e.components[n].defaultProps ? r : hk(e.components[n].defaultProps, r)
}

function mk({
    props: t,
    name: e,
    defaultTheme: n,
    themeId: r
}) {
    let i = dk(n);
    return r && (i = i[r] || i), SAe({
        theme: i,
        name: e,
        props: t
    })
}
const wAe = typeof window < "u" ? P.useLayoutEffect : P.useEffect,
    gf = wAe;

function EAe(t, e = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(e, Math.min(t, n))
}
const AAe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: EAe
}, Symbol.toStringTag, {
    value: "Module"
}));

function _R(...t) {
    return t.reduce((e, n) => n == null ? e : function(...i) {
        e.apply(this, i), n.apply(this, i)
    }, () => {})
}

function _J(t, e = 166) {
    let n;

    function r(...i) {
        const s = () => {
            t.apply(this, i)
        };
        clearTimeout(n), n = setTimeout(s, e)
    }
    return r.clear = () => {
        clearTimeout(n)
    }, r
}

function CAe(t, e) {
    return () => null
}

function SJ(t, e) {
    var n, r;
    return P.isValidElement(t) && e.indexOf((n = t.type.muiName) != null ? n : (r = t.type) == null || (r = r._payload) == null || (r = r.value) == null ? void 0 : r.muiName) !== -1
}

function Ga(t) {
    return t && t.ownerDocument || document
}

function Pg(t) {
    return Ga(t).defaultView || window
}

function MAe(t, e) {
    return () => null
}

function s2(t, e) {
    typeof t == "function" ? t(e) : t && (t.current = e)
}
let pz = 0;

function TAe(t) {
    const [e, n] = P.useState(t), r = t || e;
    return P.useEffect(() => {
        e == null && (pz += 1, n(`mui-${pz}`))
    }, [e]), r
}
const hz = Am["useId".toString()];

function gk(t) {
    if (hz !== void 0) {
        const e = hz();
        return t ? ? e
    }
    return TAe(t)
}

function PAe(t, e, n, r, i) {
    return null
}

function wJ({
    controlled: t,
    default: e,
    name: n,
    state: r = "value"
}) {
    const {
        current: i
    } = P.useRef(t !== void 0), [s, o] = P.useState(e), a = i ? t : s, l = P.useCallback(u => {
        i || o(u)
    }, []);
    return [a, l]
}

function wu(t) {
    const e = P.useRef(t);
    return gf(() => {
        e.current = t
    }), P.useRef((...n) => (0, e.current)(...n)).current
}

function ls(...t) {
    return P.useMemo(() => t.every(e => e == null) ? null : e => {
        t.forEach(n => {
            s2(n, e)
        })
    }, t)
}
const mz = {};

function IAe(t, e) {
    const n = P.useRef(mz);
    return n.current === mz && (n.current = t(e)), n
}
const RAe = [];

function OAe(t) {
    P.useEffect(t, RAe)
}
class X1 {
    constructor() {
        this.currentId = null, this.clear = () => {
            this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null)
        }, this.disposeEffect = () => this.clear
    }
    static create() {
        return new X1
    }
    start(e, n) {
        this.clear(), this.currentId = setTimeout(() => {
            this.currentId = null, n()
        }, e)
    }
}

function Wh() {
    const t = IAe(X1.create).current;
    return OAe(t.disposeEffect), t
}
let IA = !0,
    SR = !1;
const DAe = new X1,
    LAe = {
        text: !0,
        search: !0,
        url: !0,
        tel: !0,
        email: !0,
        password: !0,
        number: !0,
        date: !0,
        month: !0,
        week: !0,
        time: !0,
        datetime: !0,
        "datetime-local": !0
    };

function kAe(t) {
    const {
        type: e,
        tagName: n
    } = t;
    return !!(n === "INPUT" && LAe[e] && !t.readOnly || n === "TEXTAREA" && !t.readOnly || t.isContentEditable)
}

function BAe(t) {
    t.metaKey || t.altKey || t.ctrlKey || (IA = !0)
}

function zT() {
    IA = !1
}

function FAe() {
    this.visibilityState === "hidden" && SR && (IA = !0)
}

function NAe(t) {
    t.addEventListener("keydown", BAe, !0), t.addEventListener("mousedown", zT, !0), t.addEventListener("pointerdown", zT, !0), t.addEventListener("touchstart", zT, !0), t.addEventListener("visibilitychange", FAe, !0)
}

function zAe(t) {
    const {
        target: e
    } = t;
    try {
        return e.matches(":focus-visible")
    } catch {}
    return IA || kAe(e)
}

function yk() {
    const t = P.useCallback(i => {
            i != null && NAe(i.ownerDocument)
        }, []),
        e = P.useRef(!1);

    function n() {
        return e.current ? (SR = !0, DAe.start(100, () => {
            SR = !1
        }), e.current = !1, !0) : !1
    }

    function r(i) {
        return zAe(i) ? (e.current = !0, !0) : !1
    }
    return {
        isFocusVisibleRef: e,
        onFocus: r,
        onBlur: n,
        ref: t
    }
}

function HAe(t) {
    const e = t.documentElement.clientWidth;
    return Math.abs(window.innerWidth - e)
}

function Yn(t, e, n = void 0) {
    const r = {};
    return Object.keys(t).forEach(i => {
        r[i] = t[i].reduce((s, o) => {
            if (o) {
                const a = e(o);
                a !== "" && s.push(a), n && n[o] && s.push(n[o])
            }
            return s
        }, []).join(" ")
    }), r
}
const UAe = P.createContext(),
    EJ = () => {
        const t = P.useContext(UAe);
        return t ? ? !1
    },
    $Ae = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"],
    GAe = Tg(),
    VAe = xJ("div", {
        name: "MuiContainer",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, e[`maxWidth${Wt(String(n.maxWidth))}`], n.fixed && e.fixed, n.disableGutters && e.disableGutters]
        }
    }),
    jAe = t => mk({
        props: t,
        name: "MuiContainer",
        defaultTheme: GAe
    }),
    WAe = (t, e) => {
        const n = l => Jn(e, l),
            {
                classes: r,
                fixed: i,
                disableGutters: s,
                maxWidth: o
            } = t,
            a = {
                root: ["root", o && `maxWidth${Wt(String(o))}`, i && "fixed", s && "disableGutters"]
            };
        return Yn(a, n, r)
    };

function KAe(t = {}) {
    const {
        createStyledComponent: e = VAe,
        useThemeProps: n = jAe,
        componentName: r = "MuiContainer"
    } = t, i = e(({
        theme: o,
        ownerState: a
    }) => Y({
        width: "100%",
        marginLeft: "auto",
        boxSizing: "border-box",
        marginRight: "auto",
        display: "block"
    }, !a.disableGutters && {
        paddingLeft: o.spacing(2),
        paddingRight: o.spacing(2),
        [o.breakpoints.up("sm")]: {
            paddingLeft: o.spacing(3),
            paddingRight: o.spacing(3)
        }
    }), ({
        theme: o,
        ownerState: a
    }) => a.fixed && Object.keys(o.breakpoints.values).reduce((l, u) => {
        const c = u,
            f = o.breakpoints.values[c];
        return f !== 0 && (l[o.breakpoints.up(c)] = {
            maxWidth: `${f}${o.breakpoints.unit}`
        }), l
    }, {}), ({
        theme: o,
        ownerState: a
    }) => Y({}, a.maxWidth === "xs" && {
        [o.breakpoints.up("xs")]: {
            maxWidth: Math.max(o.breakpoints.values.xs, 444)
        }
    }, a.maxWidth && a.maxWidth !== "xs" && {
        [o.breakpoints.up(a.maxWidth)]: {
            maxWidth: `${o.breakpoints.values[a.maxWidth]}${o.breakpoints.unit}`
        }
    }));
    return P.forwardRef(function(a, l) {
        const u = n(a),
            {
                className: c,
                component: f = "div",
                disableGutters: d = !1,
                fixed: p = !1,
                maxWidth: m = "lg"
            } = u,
            y = Rt(u, $Ae),
            v = Y({}, u, {
                component: f,
                disableGutters: d,
                fixed: p,
                maxWidth: m
            }),
            b = WAe(v, r);
        return gt(i, Y({
            as: f,
            ownerState: v,
            className: Nt(b.root, c),
            ref: l
        }, y))
    })
}
const qAe = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"],
    XAe = Tg(),
    JAe = xJ("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (t, e) => e.root
    });

function YAe(t) {
    return mk({
        props: t,
        name: "MuiStack",
        defaultTheme: XAe
    })
}

function QAe(t, e) {
    const n = P.Children.toArray(t).filter(Boolean);
    return n.reduce((r, i, s) => (r.push(i), s < n.length - 1 && r.push(P.cloneElement(e, {
        key: `separator-${s}`
    })), r), [])
}
const ZAe = t => ({
        row: "Left",
        "row-reverse": "Right",
        column: "Top",
        "column-reverse": "Bottom"
    })[t],
    eCe = ({
        ownerState: t,
        theme: e
    }) => {
        let n = Y({
            display: "flex",
            flexDirection: "column"
        }, Wa({
            theme: e
        }, FT({
            values: t.direction,
            breakpoints: e.breakpoints.values
        }), r => ({
            flexDirection: r
        })));
        if (t.spacing) {
            const r = ck(e),
                i = Object.keys(e.breakpoints.values).reduce((l, u) => ((typeof t.spacing == "object" && t.spacing[u] != null || typeof t.direction == "object" && t.direction[u] != null) && (l[u] = !0), l), {}),
                s = FT({
                    values: t.direction,
                    base: i
                }),
                o = FT({
                    values: t.spacing,
                    base: i
                });
            typeof s == "object" && Object.keys(s).forEach((l, u, c) => {
                if (!s[l]) {
                    const d = u > 0 ? s[c[u - 1]] : "column";
                    s[l] = d
                }
            }), n = Yo(n, Wa({
                theme: e
            }, o, (l, u) => t.useFlexGap ? {
                gap: up(r, l)
            } : {
                "& > :not(style):not(style)": {
                    margin: 0
                },
                "& > :not(style) ~ :not(style)": {
                    [`margin${ZAe(u?s[u]:t.direction)}`]: up(r, l)
                }
            }))
        }
        return n = lEe(e.breakpoints, n), n
    };

function tCe(t = {}) {
    const {
        createStyledComponent: e = JAe,
        useThemeProps: n = YAe,
        componentName: r = "MuiStack"
    } = t, i = () => Yn({
        root: ["root"]
    }, l => Jn(r, l), {}), s = e(eCe);
    return P.forwardRef(function(l, u) {
        const c = n(l),
            f = PA(c),
            {
                component: d = "div",
                direction: p = "column",
                spacing: m = 0,
                divider: y,
                children: v,
                className: b,
                useFlexGap: _ = !1
            } = f,
            x = Rt(f, qAe),
            S = {
                direction: p,
                spacing: m,
                useFlexGap: _
            },
            E = i();
        return gt(s, Y({
            as: d,
            ownerState: S,
            ref: u,
            className: Nt(E.root, b)
        }, x, {
            children: y ? QAe(v, y) : v
        }))
    })
}

function nCe(t, e) {
    return Y({
        toolbar: {
            minHeight: 56,
            [t.up("xs")]: {
                "@media (orientation: landscape)": {
                    minHeight: 48
                }
            },
            [t.up("sm")]: {
                minHeight: 64
            }
        }
    }, e)
}
var Qr = {},
    AJ = {
        exports: {}
    };
(function(t) {
    function e(n) {
        return n && n.__esModule ? n : {
            default: n
        }
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(AJ);
var qu = AJ.exports;
const rCe = qa(j2e),
    iCe = qa(AAe);
var CJ = qu;
Object.defineProperty(Qr, "__esModule", {
    value: !0
});
var gi = Qr.alpha = IJ;
Qr.blend = yCe;
Qr.colorChannel = void 0;
var sCe = Qr.darken = bk;
Qr.decomposeColor = sa;
Qr.emphasize = gCe;
var oCe = Qr.getContrastRatio = dCe;
Qr.getLuminance = o2;
Qr.hexToRgb = MJ;
Qr.hslToRgb = PJ;
var aCe = Qr.lighten = xk;
Qr.private_safeAlpha = pCe;
Qr.private_safeColorChannel = void 0;
Qr.private_safeDarken = hCe;
Qr.private_safeEmphasize = RJ;
Qr.private_safeLighten = mCe;
Qr.recomposeColor = Ig;
Qr.rgbToHex = fCe;
var gz = CJ(rCe),
    lCe = CJ(iCe);

function vk(t, e = 0, n = 1) {
    return (0, lCe.default)(t, e, n)
}

function MJ(t) {
    t = t.slice(1);
    const e = new RegExp(`.{1,${t.length>=6?2:1}}`, "g");
    let n = t.match(e);
    return n && n[0].length === 1 && (n = n.map(r => r + r)), n ? `rgb${n.length===4?"a":""}(${n.map((r,i)=>i<3?parseInt(r,16):Math.round(parseInt(r,16)/255*1e3)/1e3).join(", ")})` : ""
}

function uCe(t) {
    const e = t.toString(16);
    return e.length === 1 ? `0${e}` : e
}

function sa(t) {
    if (t.type) return t;
    if (t.charAt(0) === "#") return sa(MJ(t));
    const e = t.indexOf("("),
        n = t.substring(0, e);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n) === -1) throw new Error((0, gz.default)(9, t));
    let r = t.substring(e + 1, t.length - 1),
        i;
    if (n === "color") {
        if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1) throw new Error((0, gz.default)(10, i))
    } else r = r.split(",");
    return r = r.map(s => parseFloat(s)), {
        type: n,
        values: r,
        colorSpace: i
    }
}
const TJ = t => {
    const e = sa(t);
    return e.values.slice(0, 3).map((n, r) => e.type.indexOf("hsl") !== -1 && r !== 0 ? `${n}%` : n).join(" ")
};
Qr.colorChannel = TJ;
const cCe = (t, e) => {
    try {
        return TJ(t)
    } catch {
        return t
    }
};
Qr.private_safeColorChannel = cCe;

function Ig(t) {
    const {
        type: e,
        colorSpace: n
    } = t;
    let {
        values: r
    } = t;
    return e.indexOf("rgb") !== -1 ? r = r.map((i, s) => s < 3 ? parseInt(i, 10) : i) : e.indexOf("hsl") !== -1 && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), e.indexOf("color") !== -1 ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${e}(${r})`
}

function fCe(t) {
    if (t.indexOf("#") === 0) return t;
    const {
        values: e
    } = sa(t);
    return `#${e.map((n,r)=>uCe(r===3?Math.round(255*n):n)).join("")}`
}

function PJ(t) {
    t = sa(t);
    const {
        values: e
    } = t, n = e[0], r = e[1] / 100, i = e[2] / 100, s = r * Math.min(i, 1 - i), o = (u, c = (u + n / 30) % 12) => i - s * Math.max(Math.min(c - 3, 9 - c, 1), -1);
    let a = "rgb";
    const l = [Math.round(o(0) * 255), Math.round(o(8) * 255), Math.round(o(4) * 255)];
    return t.type === "hsla" && (a += "a", l.push(e[3])), Ig({
        type: a,
        values: l
    })
}

function o2(t) {
    t = sa(t);
    let e = t.type === "hsl" || t.type === "hsla" ? sa(PJ(t)).values : t.values;
    return e = e.map(n => (t.type !== "color" && (n /= 255), n <= .03928 ? n / 12.92 : ((n + .055) / 1.055) ** 2.4)), Number((.2126 * e[0] + .7152 * e[1] + .0722 * e[2]).toFixed(3))
}

function dCe(t, e) {
    const n = o2(t),
        r = o2(e);
    return (Math.max(n, r) + .05) / (Math.min(n, r) + .05)
}

function IJ(t, e) {
    return t = sa(t), e = vk(e), (t.type === "rgb" || t.type === "hsl") && (t.type += "a"), t.type === "color" ? t.values[3] = `/${e}` : t.values[3] = e, Ig(t)
}

function pCe(t, e, n) {
    try {
        return IJ(t, e)
    } catch {
        return t
    }
}

function bk(t, e) {
    if (t = sa(t), e = vk(e), t.type.indexOf("hsl") !== -1) t.values[2] *= 1 - e;
    else if (t.type.indexOf("rgb") !== -1 || t.type.indexOf("color") !== -1)
        for (let n = 0; n < 3; n += 1) t.values[n] *= 1 - e;
    return Ig(t)
}

function hCe(t, e, n) {
    try {
        return bk(t, e)
    } catch {
        return t
    }
}

function xk(t, e) {
    if (t = sa(t), e = vk(e), t.type.indexOf("hsl") !== -1) t.values[2] += (100 - t.values[2]) * e;
    else if (t.type.indexOf("rgb") !== -1)
        for (let n = 0; n < 3; n += 1) t.values[n] += (255 - t.values[n]) * e;
    else if (t.type.indexOf("color") !== -1)
        for (let n = 0; n < 3; n += 1) t.values[n] += (1 - t.values[n]) * e;
    return Ig(t)
}

function mCe(t, e, n) {
    try {
        return xk(t, e)
    } catch {
        return t
    }
}

function gCe(t, e = .15) {
    return o2(t) > .5 ? bk(t, e) : xk(t, e)
}

function RJ(t, e, n) {
    try {
        return RJ(t, e)
    } catch {
        return t
    }
}

function yCe(t, e, n, r = 1) {
    const i = (l, u) => Math.round((l ** (1 / r) * (1 - n) + u ** (1 / r) * n) ** r),
        s = sa(t),
        o = sa(e),
        a = [i(s.values[0], o.values[0]), i(s.values[1], o.values[1]), i(s.values[2], o.values[2])];
    return Ig({
        type: "rgb",
        values: a
    })
}
const vCe = {
        black: "#000",
        white: "#fff"
    },
    L0 = vCe,
    bCe = {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#eeeeee",
        300: "#e0e0e0",
        400: "#bdbdbd",
        500: "#9e9e9e",
        600: "#757575",
        700: "#616161",
        800: "#424242",
        900: "#212121",
        A100: "#f5f5f5",
        A200: "#eeeeee",
        A400: "#bdbdbd",
        A700: "#616161"
    },
    xCe = bCe,
    _Ce = {
        50: "#f3e5f5",
        100: "#e1bee7",
        200: "#ce93d8",
        300: "#ba68c8",
        400: "#ab47bc",
        500: "#9c27b0",
        600: "#8e24aa",
        700: "#7b1fa2",
        800: "#6a1b9a",
        900: "#4a148c",
        A100: "#ea80fc",
        A200: "#e040fb",
        A400: "#d500f9",
        A700: "#aa00ff"
    },
    nh = _Ce,
    SCe = {
        50: "#ffebee",
        100: "#ffcdd2",
        200: "#ef9a9a",
        300: "#e57373",
        400: "#ef5350",
        500: "#f44336",
        600: "#e53935",
        700: "#d32f2f",
        800: "#c62828",
        900: "#b71c1c",
        A100: "#ff8a80",
        A200: "#ff5252",
        A400: "#ff1744",
        A700: "#d50000"
    },
    rh = SCe,
    wCe = {
        50: "#fff3e0",
        100: "#ffe0b2",
        200: "#ffcc80",
        300: "#ffb74d",
        400: "#ffa726",
        500: "#ff9800",
        600: "#fb8c00",
        700: "#f57c00",
        800: "#ef6c00",
        900: "#e65100",
        A100: "#ffd180",
        A200: "#ffab40",
        A400: "#ff9100",
        A700: "#ff6d00"
    },
    Ty = wCe,
    ECe = {
        50: "#e3f2fd",
        100: "#bbdefb",
        200: "#90caf9",
        300: "#64b5f6",
        400: "#42a5f5",
        500: "#2196f3",
        600: "#1e88e5",
        700: "#1976d2",
        800: "#1565c0",
        900: "#0d47a1",
        A100: "#82b1ff",
        A200: "#448aff",
        A400: "#2979ff",
        A700: "#2962ff"
    },
    ih = ECe,
    ACe = {
        50: "#e1f5fe",
        100: "#b3e5fc",
        200: "#81d4fa",
        300: "#4fc3f7",
        400: "#29b6f6",
        500: "#03a9f4",
        600: "#039be5",
        700: "#0288d1",
        800: "#0277bd",
        900: "#01579b",
        A100: "#80d8ff",
        A200: "#40c4ff",
        A400: "#00b0ff",
        A700: "#0091ea"
    },
    sh = ACe,
    CCe = {
        50: "#e8f5e9",
        100: "#c8e6c9",
        200: "#a5d6a7",
        300: "#81c784",
        400: "#66bb6a",
        500: "#4caf50",
        600: "#43a047",
        700: "#388e3c",
        800: "#2e7d32",
        900: "#1b5e20",
        A100: "#b9f6ca",
        A200: "#69f0ae",
        A400: "#00e676",
        A700: "#00c853"
    },
    oh = CCe,
    MCe = ["mode", "contrastThreshold", "tonalOffset"],
    yz = {
        text: {
            primary: "rgba(0, 0, 0, 0.87)",
            secondary: "rgba(0, 0, 0, 0.6)",
            disabled: "rgba(0, 0, 0, 0.38)"
        },
        divider: "rgba(0, 0, 0, 0.12)",
        background: {
            paper: L0.white,
            default: L0.white
        },
        action: {
            active: "rgba(0, 0, 0, 0.54)",
            hover: "rgba(0, 0, 0, 0.04)",
            hoverOpacity: .04,
            selected: "rgba(0, 0, 0, 0.08)",
            selectedOpacity: .08,
            disabled: "rgba(0, 0, 0, 0.26)",
            disabledBackground: "rgba(0, 0, 0, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(0, 0, 0, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .12
        }
    },
    HT = {
        text: {
            primary: L0.white,
            secondary: "rgba(255, 255, 255, 0.7)",
            disabled: "rgba(255, 255, 255, 0.5)",
            icon: "rgba(255, 255, 255, 0.5)"
        },
        divider: "rgba(255, 255, 255, 0.12)",
        background: {
            paper: "#121212",
            default: "#121212"
        },
        action: {
            active: L0.white,
            hover: "rgba(255, 255, 255, 0.08)",
            hoverOpacity: .08,
            selected: "rgba(255, 255, 255, 0.16)",
            selectedOpacity: .16,
            disabled: "rgba(255, 255, 255, 0.3)",
            disabledBackground: "rgba(255, 255, 255, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(255, 255, 255, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .24
        }
    };

function vz(t, e, n, r) {
    const i = r.light || r,
        s = r.dark || r * 1.5;
    t[e] || (t.hasOwnProperty(n) ? t[e] = t[n] : e === "light" ? t.light = aCe(t.main, i) : e === "dark" && (t.dark = sCe(t.main, s)))
}

function TCe(t = "light") {
    return t === "dark" ? {
        main: ih[200],
        light: ih[50],
        dark: ih[400]
    } : {
        main: ih[700],
        light: ih[400],
        dark: ih[800]
    }
}

function PCe(t = "light") {
    return t === "dark" ? {
        main: nh[200],
        light: nh[50],
        dark: nh[400]
    } : {
        main: nh[500],
        light: nh[300],
        dark: nh[700]
    }
}

function ICe(t = "light") {
    return t === "dark" ? {
        main: rh[500],
        light: rh[300],
        dark: rh[700]
    } : {
        main: rh[700],
        light: rh[400],
        dark: rh[800]
    }
}

function RCe(t = "light") {
    return t === "dark" ? {
        main: sh[400],
        light: sh[300],
        dark: sh[700]
    } : {
        main: sh[700],
        light: sh[500],
        dark: sh[900]
    }
}

function OCe(t = "light") {
    return t === "dark" ? {
        main: oh[400],
        light: oh[300],
        dark: oh[700]
    } : {
        main: oh[800],
        light: oh[500],
        dark: oh[900]
    }
}

function DCe(t = "light") {
    return t === "dark" ? {
        main: Ty[400],
        light: Ty[300],
        dark: Ty[700]
    } : {
        main: "#ed6c02",
        light: Ty[500],
        dark: Ty[900]
    }
}

function LCe(t) {
    const {
        mode: e = "light",
        contrastThreshold: n = 3,
        tonalOffset: r = .2
    } = t, i = Rt(t, MCe), s = t.primary || TCe(e), o = t.secondary || PCe(e), a = t.error || ICe(e), l = t.info || RCe(e), u = t.success || OCe(e), c = t.warning || DCe(e);

    function f(y) {
        return oCe(y, HT.text.primary) >= n ? HT.text.primary : yz.text.primary
    }
    const d = ({
            color: y,
            name: v,
            mainShade: b = 500,
            lightShade: _ = 300,
            darkShade: x = 700
        }) => {
            if (y = Y({}, y), !y.main && y[b] && (y.main = y[b]), !y.hasOwnProperty("main")) throw new Error(D0(11, v ? ` (${v})` : "", b));
            if (typeof y.main != "string") throw new Error(D0(12, v ? ` (${v})` : "", JSON.stringify(y.main)));
            return vz(y, "light", _, r), vz(y, "dark", x, r), y.contrastText || (y.contrastText = f(y.main)), y
        },
        p = {
            dark: HT,
            light: yz
        };
    return Yo(Y({
        common: Y({}, L0),
        mode: e,
        primary: d({
            color: s,
            name: "primary"
        }),
        secondary: d({
            color: o,
            name: "secondary",
            mainShade: "A400",
            lightShade: "A200",
            darkShade: "A700"
        }),
        error: d({
            color: a,
            name: "error"
        }),
        warning: d({
            color: c,
            name: "warning"
        }),
        info: d({
            color: l,
            name: "info"
        }),
        success: d({
            color: u,
            name: "success"
        }),
        grey: xCe,
        contrastThreshold: n,
        getContrastText: f,
        augmentColor: d,
        tonalOffset: r
    }, p[e]), i)
}
const kCe = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];

function BCe(t) {
    return Math.round(t * 1e5) / 1e5
}
const bz = {
        textTransform: "uppercase"
    },
    xz = '"Roboto", "Helvetica", "Arial", sans-serif';

function FCe(t, e) {
    const n = typeof e == "function" ? e(t) : e,
        {
            fontFamily: r = xz,
            fontSize: i = 14,
            fontWeightLight: s = 300,
            fontWeightRegular: o = 400,
            fontWeightMedium: a = 500,
            fontWeightBold: l = 700,
            htmlFontSize: u = 16,
            allVariants: c,
            pxToRem: f
        } = n,
        d = Rt(n, kCe),
        p = i / 14,
        m = f || (b => `${b/u*p}rem`),
        y = (b, _, x, S, E) => Y({
            fontFamily: r,
            fontWeight: b,
            fontSize: m(_),
            lineHeight: x
        }, r === xz ? {
            letterSpacing: `${BCe(S/_)}em`
        } : {}, E, c),
        v = {
            h1: y(s, 96, 1.167, -1.5),
            h2: y(s, 60, 1.2, -.5),
            h3: y(o, 48, 1.167, 0),
            h4: y(o, 34, 1.235, .25),
            h5: y(o, 24, 1.334, 0),
            h6: y(a, 20, 1.6, .15),
            subtitle1: y(o, 16, 1.75, .15),
            subtitle2: y(a, 14, 1.57, .1),
            body1: y(o, 16, 1.5, .15),
            body2: y(o, 14, 1.43, .15),
            button: y(a, 14, 1.75, .4, bz),
            caption: y(o, 12, 1.66, .4),
            overline: y(o, 12, 2.66, 1, bz),
            inherit: {
                fontFamily: "inherit",
                fontWeight: "inherit",
                fontSize: "inherit",
                lineHeight: "inherit",
                letterSpacing: "inherit"
            }
        };
    return Yo(Y({
        htmlFontSize: u,
        pxToRem: m,
        fontFamily: r,
        fontSize: i,
        fontWeightLight: s,
        fontWeightRegular: o,
        fontWeightMedium: a,
        fontWeightBold: l
    }, v), d, {
        clone: !1
    })
}
const NCe = .2,
    zCe = .14,
    HCe = .12;

function vr(...t) {
    return [`${t[0]}px ${t[1]}px ${t[2]}px ${t[3]}px rgba(0,0,0,${NCe})`, `${t[4]}px ${t[5]}px ${t[6]}px ${t[7]}px rgba(0,0,0,${zCe})`, `${t[8]}px ${t[9]}px ${t[10]}px ${t[11]}px rgba(0,0,0,${HCe})`].join(",")
}
const UCe = ["none", vr(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), vr(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), vr(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), vr(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), vr(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), vr(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), vr(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), vr(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), vr(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), vr(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), vr(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), vr(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), vr(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), vr(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), vr(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), vr(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), vr(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), vr(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), vr(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), vr(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), vr(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), vr(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), vr(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), vr(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)],
    $Ce = UCe,
    GCe = ["duration", "easing", "delay"],
    VCe = {
        easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
        easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
        easeIn: "cubic-bezier(0.4, 0, 1, 1)",
        sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    },
    jCe = {
        shortest: 150,
        shorter: 200,
        short: 250,
        standard: 300,
        complex: 375,
        enteringScreen: 225,
        leavingScreen: 195
    };

function _z(t) {
    return `${Math.round(t)}ms`
}

function WCe(t) {
    if (!t) return 0;
    const e = t / 36;
    return Math.round((4 + 15 * e ** .25 + e / 5) * 10)
}

function KCe(t) {
    const e = Y({}, VCe, t.easing),
        n = Y({}, jCe, t.duration);
    return Y({
        getAutoHeightDuration: WCe,
        create: (i = ["all"], s = {}) => {
            const {
                duration: o = n.standard,
                easing: a = e.easeInOut,
                delay: l = 0
            } = s;
            return Rt(s, GCe), (Array.isArray(i) ? i : [i]).map(u => `${u} ${typeof o=="string"?o:_z(o)} ${a} ${typeof l=="string"?l:_z(l)}`).join(",")
        }
    }, t, {
        easing: e,
        duration: n
    })
}
const qCe = {
        mobileStepper: 1e3,
        fab: 1050,
        speedDial: 1050,
        appBar: 1100,
        drawer: 1200,
        modal: 1300,
        snackbar: 1400,
        tooltip: 1500
    },
    XCe = qCe,
    JCe = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];

function OJ(t = {}, ...e) {
    const {
        mixins: n = {},
        palette: r = {},
        transitions: i = {},
        typography: s = {}
    } = t, o = Rt(t, JCe);
    if (t.vars) throw new Error(D0(18));
    const a = LCe(r),
        l = Tg(t);
    let u = Yo(l, {
        mixins: nCe(l.breakpoints, n),
        palette: a,
        shadows: $Ce.slice(),
        typography: FCe(a, s),
        transitions: KCe(i),
        zIndex: Y({}, XCe)
    });
    return u = Yo(u, o), u = e.reduce((c, f) => Yo(c, f), u), u.unstable_sxConfig = Y({}, K1, o == null ? void 0 : o.unstable_sxConfig), u.unstable_sx = function(f) {
        return q1({
            sx: f,
            theme: this
        })
    }, u
}
const YCe = OJ(),
    _k = YCe;

function Rg() {
    const t = dk(_k);
    return t[SA] || t
}

function Kn({
    props: t,
    name: e
}) {
    return mk({
        props: t,
        name: e,
        defaultTheme: _k,
        themeId: SA
    })
}
var J1 = {};
const QCe = qa(oie);
var UT = {
        exports: {}
    },
    Sz;

function ZCe() {
    return Sz || (Sz = 1, function(t) {
        function e(n, r) {
            if (n == null) return {};
            var i = {},
                s = Object.keys(n),
                o, a;
            for (a = 0; a < s.length; a++) o = s[a], !(r.indexOf(o) >= 0) && (i[o] = n[o]);
            return i
        }
        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
    }(UT)), UT.exports
}
const DJ = qa(nEe),
    eMe = qa(rEe),
    tMe = qa(cEe),
    nMe = qa(fAe),
    rMe = qa(QEe),
    iMe = qa(iAe);
var Og = qu;
Object.defineProperty(J1, "__esModule", {
    value: !0
});
var sMe = J1.default = vMe;
J1.shouldForwardProp = NS;
J1.systemDefaultTheme = void 0;
var Do = Og(QCe),
    wR = Og(ZCe()),
    wz = dMe(DJ),
    oMe = eMe;
Og(tMe);
Og(nMe);
var aMe = Og(rMe),
    lMe = Og(iMe);
const uMe = ["ownerState"],
    cMe = ["variants"],
    fMe = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];

function LJ(t) {
    if (typeof WeakMap != "function") return null;
    var e = new WeakMap,
        n = new WeakMap;
    return (LJ = function(r) {
        return r ? n : e
    })(t)
}

function dMe(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return {
        default: t
    };
    var n = LJ(e);
    if (n && n.has(t)) return n.get(t);
    var r = {
            __proto__: null
        },
        i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in t)
        if (s !== "default" && Object.prototype.hasOwnProperty.call(t, s)) {
            var o = i ? Object.getOwnPropertyDescriptor(t, s) : null;
            o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = t[s]
        }
    return r.default = t, n && n.set(t, r), r
}

function pMe(t) {
    return Object.keys(t).length === 0
}

function hMe(t) {
    return typeof t == "string" && t.charCodeAt(0) > 96
}

function NS(t) {
    return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as"
}
const mMe = J1.systemDefaultTheme = (0, aMe.default)(),
    gMe = t => t && t.charAt(0).toLowerCase() + t.slice(1);

function A_({
    defaultTheme: t,
    theme: e,
    themeId: n
}) {
    return pMe(e) ? t : e[n] || e
}

function yMe(t) {
    return t ? (e, n) => n[t] : null
}

function zS(t, e) {
    let {
        ownerState: n
    } = e, r = (0, wR.default)(e, uMe);
    const i = typeof t == "function" ? t((0, Do.default)({
        ownerState: n
    }, r)) : t;
    if (Array.isArray(i)) return i.flatMap(s => zS(s, (0, Do.default)({
        ownerState: n
    }, r)));
    if (i && typeof i == "object" && Array.isArray(i.variants)) {
        const {
            variants: s = []
        } = i;
        let a = (0, wR.default)(i, cMe);
        return s.forEach(l => {
            let u = !0;
            typeof l.props == "function" ? u = l.props((0, Do.default)({
                ownerState: n
            }, r, n)) : Object.keys(l.props).forEach(c => {
                (n == null ? void 0 : n[c]) !== l.props[c] && r[c] !== l.props[c] && (u = !1)
            }), u && (Array.isArray(a) || (a = [a]), a.push(typeof l.style == "function" ? l.style((0, Do.default)({
                ownerState: n
            }, r, n)) : l.style))
        }), a
    }
    return i
}

function vMe(t = {}) {
    const {
        themeId: e,
        defaultTheme: n = mMe,
        rootShouldForwardProp: r = NS,
        slotShouldForwardProp: i = NS
    } = t, s = o => (0, lMe.default)((0, Do.default)({}, o, {
        theme: A_((0, Do.default)({}, o, {
            defaultTheme: n,
            themeId: e
        }))
    }));
    return s.__mui_systemSx = !0, (o, a = {}) => {
        (0, wz.internal_processStyles)(o, E => E.filter(A => !(A != null && A.__mui_systemSx)));
        const {
            name: l,
            slot: u,
            skipVariantsResolver: c,
            skipSx: f,
            overridesResolver: d = yMe(gMe(u))
        } = a, p = (0, wR.default)(a, fMe), m = c !== void 0 ? c : u && u !== "Root" && u !== "root" || !1, y = f || !1;
        let v, b = NS;
        u === "Root" || u === "root" ? b = r : u ? b = i : hMe(o) && (b = void 0);
        const _ = (0, wz.default)(o, (0, Do.default)({
                shouldForwardProp: b,
                label: v
            }, p)),
            x = E => typeof E == "function" && E.__emotion_real !== E || (0, oMe.isPlainObject)(E) ? A => zS(E, (0, Do.default)({}, A, {
                theme: A_({
                    theme: A.theme,
                    defaultTheme: n,
                    themeId: e
                })
            })) : E,
            S = (E, ...A) => {
                let T = x(E);
                const M = A ? A.map(x) : [];
                l && d && M.push(k => {
                    const H = A_((0, Do.default)({}, k, {
                        defaultTheme: n,
                        themeId: e
                    }));
                    if (!H.components || !H.components[l] || !H.components[l].styleOverrides) return null;
                    const N = H.components[l].styleOverrides,
                        B = {};
                    return Object.entries(N).forEach(([U, q]) => {
                        B[U] = zS(q, (0, Do.default)({}, k, {
                            theme: H
                        }))
                    }), d(k, B)
                }), l && !m && M.push(k => {
                    var H;
                    const N = A_((0, Do.default)({}, k, {
                            defaultTheme: n,
                            themeId: e
                        })),
                        B = N == null || (H = N.components) == null || (H = H[l]) == null ? void 0 : H.variants;
                    return zS({
                        variants: B
                    }, (0, Do.default)({}, k, {
                        theme: N
                    }))
                }), y || M.push(s);
                const I = M.length - A.length;
                if (Array.isArray(E) && I > 0) {
                    const k = new Array(I).fill("");
                    T = [...E, ...k], T.raw = [...E.raw, ...k]
                }
                const O = _(T, ...M);
                return o.muiName && (O.muiName = o.muiName), O
            };
        return _.withConfig && (S.withConfig = _.withConfig), S
    }
}

function bMe(t) {
    return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as"
}
const xMe = t => bMe(t) && t !== "classes",
    Y1 = xMe,
    _Me = sMe({
        themeId: SA,
        defaultTheme: _k,
        rootShouldForwardProp: Y1
    }),
    en = _Me,
    SMe = t => {
        let e;
        return t < 1 ? e = 5.11916 * t ** 2 : e = 4.5 * Math.log(t + 1) + 2, (e / 100).toFixed(2)
    },
    Ez = SMe;

function ER(t) {
    return typeof t == "string"
}

function Kh(t, e, n) {
    return t === void 0 || ER(t) ? e : Y({}, e, {
        ownerState: Y({}, e.ownerState, n)
    })
}
const wMe = {
        disableDefaultClasses: !1
    },
    EMe = P.createContext(wMe);

function AMe(t) {
    const {
        disableDefaultClasses: e
    } = P.useContext(EMe);
    return n => e ? "" : t(n)
}

function kJ(t, e = []) {
    if (t === void 0) return {};
    const n = {};
    return Object.keys(t).filter(r => r.match(/^on[A-Z]/) && typeof t[r] == "function" && !e.includes(r)).forEach(r => {
        n[r] = t[r]
    }), n
}

function BJ(t, e, n) {
    return typeof t == "function" ? t(e, n) : t
}

function Az(t) {
    if (t === void 0) return {};
    const e = {};
    return Object.keys(t).filter(n => !(n.match(/^on[A-Z]/) && typeof t[n] == "function")).forEach(n => {
        e[n] = t[n]
    }), e
}

function FJ(t) {
    const {
        getSlotProps: e,
        additionalProps: n,
        externalSlotProps: r,
        externalForwardedProps: i,
        className: s
    } = t;
    if (!e) {
        const p = Nt(n == null ? void 0 : n.className, s, i == null ? void 0 : i.className, r == null ? void 0 : r.className),
            m = Y({}, n == null ? void 0 : n.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style),
            y = Y({}, n, i, r);
        return p.length > 0 && (y.className = p), Object.keys(m).length > 0 && (y.style = m), {
            props: y,
            internalRef: void 0
        }
    }
    const o = kJ(Y({}, i, r)),
        a = Az(r),
        l = Az(i),
        u = e(o),
        c = Nt(u == null ? void 0 : u.className, n == null ? void 0 : n.className, s, i == null ? void 0 : i.className, r == null ? void 0 : r.className),
        f = Y({}, u == null ? void 0 : u.style, n == null ? void 0 : n.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style),
        d = Y({}, u, n, l, a);
    return c.length > 0 && (d.className = c), Object.keys(f).length > 0 && (d.style = f), {
        props: d,
        internalRef: u.ref
    }
}
const CMe = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];

function AR(t) {
    var e;
    const {
        elementType: n,
        externalSlotProps: r,
        ownerState: i,
        skipResolvingSlotProps: s = !1
    } = t, o = Rt(t, CMe), a = s ? {} : BJ(r, i), {
        props: l,
        internalRef: u
    } = FJ(Y({}, o, {
        externalSlotProps: a
    })), c = ls(u, a == null ? void 0 : a.ref, (e = t.additionalProps) == null ? void 0 : e.ref);
    return Kh(n, Y({}, l, {
        ref: c
    }), i)
}
const Cz = {
        disabled: !1
    },
    a2 = Bt.createContext(null);
var MMe = function(e) {
        return e.scrollTop
    },
    ev = "unmounted",
    id = "exited",
    sd = "entering",
    gh = "entered",
    CR = "exiting",
    Xu = function(t) {
        uq(e, t);

        function e(r, i) {
            var s;
            s = t.call(this, r, i) || this;
            var o = i,
                a = o && !o.isMounting ? r.enter : r.appear,
                l;
            return s.appearStatus = null, r.in ? a ? (l = id, s.appearStatus = sd) : l = gh : r.unmountOnExit || r.mountOnEnter ? l = ev : l = id, s.state = {
                status: l
            }, s.nextCallback = null, s
        }
        e.getDerivedStateFromProps = function(i, s) {
            var o = i.in;
            return o && s.status === ev ? {
                status: id
            } : null
        };
        var n = e.prototype;
        return n.componentDidMount = function() {
            this.updateStatus(!0, this.appearStatus)
        }, n.componentDidUpdate = function(i) {
            var s = null;
            if (i !== this.props) {
                var o = this.state.status;
                this.props.in ? o !== sd && o !== gh && (s = sd) : (o === sd || o === gh) && (s = CR)
            }
            this.updateStatus(!1, s)
        }, n.componentWillUnmount = function() {
            this.cancelNextCallback()
        }, n.getTimeouts = function() {
            var i = this.props.timeout,
                s, o, a;
            return s = o = a = i, i != null && typeof i != "number" && (s = i.exit, o = i.enter, a = i.appear !== void 0 ? i.appear : o), {
                exit: s,
                enter: o,
                appear: a
            }
        }, n.updateStatus = function(i, s) {
            if (i === void 0 && (i = !1), s !== null)
                if (this.cancelNextCallback(), s === sd) {
                    if (this.props.unmountOnExit || this.props.mountOnEnter) {
                        var o = this.props.nodeRef ? this.props.nodeRef.current : kh.findDOMNode(this);
                        o && MMe(o)
                    }
                    this.performEnter(i)
                } else this.performExit();
            else this.props.unmountOnExit && this.state.status === id && this.setState({
                status: ev
            })
        }, n.performEnter = function(i) {
            var s = this,
                o = this.props.enter,
                a = this.context ? this.context.isMounting : i,
                l = this.props.nodeRef ? [a] : [kh.findDOMNode(this), a],
                u = l[0],
                c = l[1],
                f = this.getTimeouts(),
                d = a ? f.appear : f.enter;
            if (!i && !o || Cz.disabled) {
                this.safeSetState({
                    status: gh
                }, function() {
                    s.props.onEntered(u)
                });
                return
            }
            this.props.onEnter(u, c), this.safeSetState({
                status: sd
            }, function() {
                s.props.onEntering(u, c), s.onTransitionEnd(d, function() {
                    s.safeSetState({
                        status: gh
                    }, function() {
                        s.props.onEntered(u, c)
                    })
                })
            })
        }, n.performExit = function() {
            var i = this,
                s = this.props.exit,
                o = this.getTimeouts(),
                a = this.props.nodeRef ? void 0 : kh.findDOMNode(this);
            if (!s || Cz.disabled) {
                this.safeSetState({
                    status: id
                }, function() {
                    i.props.onExited(a)
                });
                return
            }
            this.props.onExit(a), this.safeSetState({
                status: CR
            }, function() {
                i.props.onExiting(a), i.onTransitionEnd(o.exit, function() {
                    i.safeSetState({
                        status: id
                    }, function() {
                        i.props.onExited(a)
                    })
                })
            })
        }, n.cancelNextCallback = function() {
            this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null)
        }, n.safeSetState = function(i, s) {
            s = this.setNextCallback(s), this.setState(i, s)
        }, n.setNextCallback = function(i) {
            var s = this,
                o = !0;
            return this.nextCallback = function(a) {
                o && (o = !1, s.nextCallback = null, i(a))
            }, this.nextCallback.cancel = function() {
                o = !1
            }, this.nextCallback
        }, n.onTransitionEnd = function(i, s) {
            this.setNextCallback(s);
            var o = this.props.nodeRef ? this.props.nodeRef.current : kh.findDOMNode(this),
                a = i == null && !this.props.addEndListener;
            if (!o || a) {
                setTimeout(this.nextCallback, 0);
                return
            }
            if (this.props.addEndListener) {
                var l = this.props.nodeRef ? [this.nextCallback] : [o, this.nextCallback],
                    u = l[0],
                    c = l[1];
                this.props.addEndListener(u, c)
            }
            i != null && setTimeout(this.nextCallback, i)
        }, n.render = function() {
            var i = this.state.status;
            if (i === ev) return null;
            var s = this.props,
                o = s.children;
            s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef;
            var a = Rt(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
            return Bt.createElement(a2.Provider, {
                value: null
            }, typeof o == "function" ? o(i, a) : Bt.cloneElement(Bt.Children.only(o), a))
        }, e
    }(Bt.Component);
Xu.contextType = a2;
Xu.propTypes = {};

function ah() {}
Xu.defaultProps = { in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: ah,
    onEntering: ah,
    onEntered: ah,
    onExit: ah,
    onExiting: ah,
    onExited: ah
};
Xu.UNMOUNTED = ev;
Xu.EXITED = id;
Xu.ENTERING = sd;
Xu.ENTERED = gh;
Xu.EXITING = CR;
const Sk = Xu;

function wk(t, e) {
    var n = function(s) {
            return e && P.isValidElement(s) ? e(s) : s
        },
        r = Object.create(null);
    return t && P.Children.map(t, function(i) {
        return i
    }).forEach(function(i) {
        r[i.key] = n(i)
    }), r
}

function TMe(t, e) {
    t = t || {}, e = e || {};

    function n(c) {
        return c in e ? e[c] : t[c]
    }
    var r = Object.create(null),
        i = [];
    for (var s in t) s in e ? i.length && (r[s] = i, i = []) : i.push(s);
    var o, a = {};
    for (var l in e) {
        if (r[l])
            for (o = 0; o < r[l].length; o++) {
                var u = r[l][o];
                a[r[l][o]] = n(u)
            }
        a[l] = n(l)
    }
    for (o = 0; o < i.length; o++) a[i[o]] = n(i[o]);
    return a
}

function Td(t, e, n) {
    return n[e] != null ? n[e] : t.props[e]
}

function PMe(t, e) {
    return wk(t.children, function(n) {
        return P.cloneElement(n, {
            onExited: e.bind(null, n),
            in: !0,
            appear: Td(n, "appear", t),
            enter: Td(n, "enter", t),
            exit: Td(n, "exit", t)
        })
    })
}

function IMe(t, e, n) {
    var r = wk(t.children),
        i = TMe(e, r);
    return Object.keys(i).forEach(function(s) {
        var o = i[s];
        if (P.isValidElement(o)) {
            var a = s in e,
                l = s in r,
                u = e[s],
                c = P.isValidElement(u) && !u.props.in;
            l && (!a || c) ? i[s] = P.cloneElement(o, {
                onExited: n.bind(null, o),
                in: !0,
                exit: Td(o, "exit", t),
                enter: Td(o, "enter", t)
            }) : !l && a && !c ? i[s] = P.cloneElement(o, { in: !1
            }) : l && a && P.isValidElement(u) && (i[s] = P.cloneElement(o, {
                onExited: n.bind(null, o),
                in: u.props.in,
                exit: Td(o, "exit", t),
                enter: Td(o, "enter", t)
            }))
        }
    }), i
}
var RMe = Object.values || function(t) {
        return Object.keys(t).map(function(e) {
            return t[e]
        })
    },
    OMe = {
        component: "div",
        childFactory: function(e) {
            return e
        }
    },
    Ek = function(t) {
        uq(e, t);

        function e(r, i) {
            var s;
            s = t.call(this, r, i) || this;
            var o = s.handleExited.bind(jw(s));
            return s.state = {
                contextValue: {
                    isMounting: !0
                },
                handleExited: o,
                firstRender: !0
            }, s
        }
        var n = e.prototype;
        return n.componentDidMount = function() {
            this.mounted = !0, this.setState({
                contextValue: {
                    isMounting: !1
                }
            })
        }, n.componentWillUnmount = function() {
            this.mounted = !1
        }, e.getDerivedStateFromProps = function(i, s) {
            var o = s.children,
                a = s.handleExited,
                l = s.firstRender;
            return {
                children: l ? PMe(i, a) : IMe(i, o, a),
                firstRender: !1
            }
        }, n.handleExited = function(i, s) {
            var o = wk(this.props.children);
            i.key in o || (i.props.onExited && i.props.onExited(s), this.mounted && this.setState(function(a) {
                var l = Y({}, a.children);
                return delete l[i.key], {
                    children: l
                }
            }))
        }, n.render = function() {
            var i = this.props,
                s = i.component,
                o = i.childFactory,
                a = Rt(i, ["component", "childFactory"]),
                l = this.state.contextValue,
                u = RMe(this.state.children).map(o);
            return delete a.appear, delete a.enter, delete a.exit, s === null ? Bt.createElement(a2.Provider, {
                value: l
            }, u) : Bt.createElement(a2.Provider, {
                value: l
            }, Bt.createElement(s, a, u))
        }, e
    }(Bt.Component);
Ek.propTypes = {};
Ek.defaultProps = OMe;
const DMe = Ek,
    Ak = t => t.scrollTop;

function Ym(t, e) {
    var n, r;
    const {
        timeout: i,
        easing: s,
        style: o = {}
    } = t;
    return {
        duration: (n = o.transitionDuration) != null ? n : typeof i == "number" ? i : i[e.mode] || 0,
        easing: (r = o.transitionTimingFunction) != null ? r : typeof s == "object" ? s[e.mode] : s,
        delay: o.transitionDelay
    }
}
const LMe = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function MR(t) {
    return `scale(${t}, ${t**2})`
}
const kMe = {
        entering: {
            opacity: 1,
            transform: MR(1)
        },
        entered: {
            opacity: 1,
            transform: "none"
        }
    },
    $T = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
    NJ = P.forwardRef(function(e, n) {
        const {
            addEndListener: r,
            appear: i = !0,
            children: s,
            easing: o,
            in: a,
            onEnter: l,
            onEntered: u,
            onEntering: c,
            onExit: f,
            onExited: d,
            onExiting: p,
            style: m,
            timeout: y = "auto",
            TransitionComponent: v = Sk
        } = e, b = Rt(e, LMe), _ = Wh(), x = P.useRef(), S = Rg(), E = P.useRef(null), A = ls(E, s.ref, n), T = U => q => {
            if (U) {
                const Q = E.current;
                q === void 0 ? U(Q) : U(Q, q)
            }
        }, M = T(c), I = T((U, q) => {
            Ak(U);
            const {
                duration: Q,
                delay: F,
                easing: G
            } = Ym({
                style: m,
                timeout: y,
                easing: o
            }, {
                mode: "enter"
            });
            let W;
            y === "auto" ? (W = S.transitions.getAutoHeightDuration(U.clientHeight), x.current = W) : W = Q, U.style.transition = [S.transitions.create("opacity", {
                duration: W,
                delay: F
            }), S.transitions.create("transform", {
                duration: $T ? W : W * .666,
                delay: F,
                easing: G
            })].join(","), l && l(U, q)
        }), O = T(u), k = T(p), H = T(U => {
            const {
                duration: q,
                delay: Q,
                easing: F
            } = Ym({
                style: m,
                timeout: y,
                easing: o
            }, {
                mode: "exit"
            });
            let G;
            y === "auto" ? (G = S.transitions.getAutoHeightDuration(U.clientHeight), x.current = G) : G = q, U.style.transition = [S.transitions.create("opacity", {
                duration: G,
                delay: Q
            }), S.transitions.create("transform", {
                duration: $T ? G : G * .666,
                delay: $T ? Q : Q || G * .333,
                easing: F
            })].join(","), U.style.opacity = 0, U.style.transform = MR(.75), f && f(U)
        }), N = T(d);
        return gt(v, Y({
            appear: i,
            in: a,
            nodeRef: E,
            onEnter: I,
            onEntered: O,
            onEntering: M,
            onExit: H,
            onExited: N,
            onExiting: k,
            addEndListener: U => {
                y === "auto" && _.start(x.current || 0, U), r && r(E.current, U)
            },
            timeout: y === "auto" ? null : y
        }, b, {
            children: (U, q) => P.cloneElement(s, Y({
                style: Y({
                    opacity: 0,
                    transform: MR(.75),
                    visibility: U === "exited" && !a ? "hidden" : void 0
                }, kMe[U], m, s.props.style),
                ref: A
            }, q))
        }))
    });
NJ.muiSupportAuto = !0;
const Mz = NJ;
var js = "top",
    oa = "bottom",
    aa = "right",
    Ws = "left",
    Ck = "auto",
    Q1 = [js, oa, aa, Ws],
    Qm = "start",
    k0 = "end",
    BMe = "clippingParents",
    zJ = "viewport",
    Py = "popper",
    FMe = "reference",
    Tz = Q1.reduce(function(t, e) {
        return t.concat([e + "-" + Qm, e + "-" + k0])
    }, []),
    HJ = [].concat(Q1, [Ck]).reduce(function(t, e) {
        return t.concat([e, e + "-" + Qm, e + "-" + k0])
    }, []),
    NMe = "beforeRead",
    zMe = "read",
    HMe = "afterRead",
    UMe = "beforeMain",
    $Me = "main",
    GMe = "afterMain",
    VMe = "beforeWrite",
    jMe = "write",
    WMe = "afterWrite",
    KMe = [NMe, zMe, HMe, UMe, $Me, GMe, VMe, jMe, WMe];

function Ll(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function mo(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function cp(t) {
    var e = mo(t).Element;
    return t instanceof e || t instanceof Element
}

function Qo(t) {
    var e = mo(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}

function Mk(t) {
    if (typeof ShadowRoot > "u") return !1;
    var e = mo(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}

function qMe(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {},
            i = e.attributes[n] || {},
            s = e.elements[n];
        !Qo(s) || !Ll(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
            var a = i[o];
            a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}

function XMe(t) {
    var e = t.state,
        n = {
            popper: {
                position: e.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function() {
            Object.keys(e.elements).forEach(function(r) {
                var i = e.elements[r],
                    s = e.attributes[r] || {},
                    o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
                    a = o.reduce(function(l, u) {
                        return l[u] = "", l
                    }, {});
                !Qo(i) || !Ll(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
                    i.removeAttribute(l)
                }))
            })
        }
}
const JMe = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: qMe,
    effect: XMe,
    requires: ["computeStyles"]
};

function Il(t) {
    return t.split("-")[0]
}
var Ud = Math.max,
    l2 = Math.min,
    Zm = Math.round;

function TR() {
    var t = navigator.userAgentData;
    return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
        return e.brand + "/" + e.version
    }).join(" ") : navigator.userAgent
}

function UJ() {
    return !/^((?!chrome|android).)*safari/i.test(TR())
}

function eg(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    var r = t.getBoundingClientRect(),
        i = 1,
        s = 1;
    e && Qo(t) && (i = t.offsetWidth > 0 && Zm(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && Zm(r.height) / t.offsetHeight || 1);
    var o = cp(t) ? mo(t) : window,
        a = o.visualViewport,
        l = !UJ() && n,
        u = (r.left + (l && a ? a.offsetLeft : 0)) / i,
        c = (r.top + (l && a ? a.offsetTop : 0)) / s,
        f = r.width / i,
        d = r.height / s;
    return {
        width: f,
        height: d,
        top: c,
        right: u + f,
        bottom: c + d,
        left: u,
        x: u,
        y: c
    }
}

function Tk(t) {
    var e = eg(t),
        n = t.offsetWidth,
        r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: n,
        height: r
    }
}

function $J(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (n && Mk(n)) {
        var r = e;
        do {
            if (r && t.isSameNode(r)) return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}

function Hu(t) {
    return mo(t).getComputedStyle(t)
}

function YMe(t) {
    return ["table", "td", "th"].indexOf(Ll(t)) >= 0
}

function Cf(t) {
    return ((cp(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function RA(t) {
    return Ll(t) === "html" ? t : t.assignedSlot || t.parentNode || (Mk(t) ? t.host : null) || Cf(t)
}

function Pz(t) {
    return !Qo(t) || Hu(t).position === "fixed" ? null : t.offsetParent
}

function QMe(t) {
    var e = /firefox/i.test(TR()),
        n = /Trident/i.test(TR());
    if (n && Qo(t)) {
        var r = Hu(t);
        if (r.position === "fixed") return null
    }
    var i = RA(t);
    for (Mk(i) && (i = i.host); Qo(i) && ["html", "body"].indexOf(Ll(i)) < 0;) {
        var s = Hu(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none") return i;
        i = i.parentNode
    }
    return null
}

function Z1(t) {
    for (var e = mo(t), n = Pz(t); n && YMe(n) && Hu(n).position === "static";) n = Pz(n);
    return n && (Ll(n) === "html" || Ll(n) === "body" && Hu(n).position === "static") ? e : n || QMe(t) || e
}

function Pk(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function Av(t, e, n) {
    return Ud(t, l2(e, n))
}

function ZMe(t, e, n) {
    var r = Av(t, e, n);
    return r > n ? n : r
}

function GJ() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}

function VJ(t) {
    return Object.assign({}, GJ(), t)
}

function jJ(t, e) {
    return e.reduce(function(n, r) {
        return n[r] = t, n
    }, {})
}
var eTe = function(e, n) {
    return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
        placement: n.placement
    })) : e, VJ(typeof e != "number" ? e : jJ(e, Q1))
};

function tTe(t) {
    var e, n = t.state,
        r = t.name,
        i = t.options,
        s = n.elements.arrow,
        o = n.modifiersData.popperOffsets,
        a = Il(n.placement),
        l = Pk(a),
        u = [Ws, aa].indexOf(a) >= 0,
        c = u ? "height" : "width";
    if (!(!s || !o)) {
        var f = eTe(i.padding, n),
            d = Tk(s),
            p = l === "y" ? js : Ws,
            m = l === "y" ? oa : aa,
            y = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c],
            v = o[l] - n.rects.reference[l],
            b = Z1(s),
            _ = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0,
            x = y / 2 - v / 2,
            S = f[p],
            E = _ - d[c] - f[m],
            A = _ / 2 - d[c] / 2 + x,
            T = Av(S, A, E),
            M = l;
        n.modifiersData[r] = (e = {}, e[M] = T, e.centerOffset = T - A, e)
    }
}

function nTe(t) {
    var e = t.state,
        n = t.options,
        r = n.element,
        i = r === void 0 ? "[data-popper-arrow]" : r;
    i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || $J(e.elements.popper, i) && (e.elements.arrow = i))
}
const rTe = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: tTe,
    effect: nTe,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};

function tg(t) {
    return t.split("-")[1]
}
var iTe = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};

function sTe(t, e) {
    var n = t.x,
        r = t.y,
        i = e.devicePixelRatio || 1;
    return {
        x: Zm(n * i) / i || 0,
        y: Zm(r * i) / i || 0
    }
}

function Iz(t) {
    var e, n = t.popper,
        r = t.popperRect,
        i = t.placement,
        s = t.variation,
        o = t.offsets,
        a = t.position,
        l = t.gpuAcceleration,
        u = t.adaptive,
        c = t.roundOffsets,
        f = t.isFixed,
        d = o.x,
        p = d === void 0 ? 0 : d,
        m = o.y,
        y = m === void 0 ? 0 : m,
        v = typeof c == "function" ? c({
            x: p,
            y
        }) : {
            x: p,
            y
        };
    p = v.x, y = v.y;
    var b = o.hasOwnProperty("x"),
        _ = o.hasOwnProperty("y"),
        x = Ws,
        S = js,
        E = window;
    if (u) {
        var A = Z1(n),
            T = "clientHeight",
            M = "clientWidth";
        if (A === mo(n) && (A = Cf(n), Hu(A).position !== "static" && a === "absolute" && (T = "scrollHeight", M = "scrollWidth")), A = A, i === js || (i === Ws || i === aa) && s === k0) {
            S = oa;
            var I = f && A === E && E.visualViewport ? E.visualViewport.height : A[T];
            y -= I - r.height, y *= l ? 1 : -1
        }
        if (i === Ws || (i === js || i === oa) && s === k0) {
            x = aa;
            var O = f && A === E && E.visualViewport ? E.visualViewport.width : A[M];
            p -= O - r.width, p *= l ? 1 : -1
        }
    }
    var k = Object.assign({
            position: a
        }, u && iTe),
        H = c === !0 ? sTe({
            x: p,
            y
        }, mo(n)) : {
            x: p,
            y
        };
    if (p = H.x, y = H.y, l) {
        var N;
        return Object.assign({}, k, (N = {}, N[S] = _ ? "0" : "", N[x] = b ? "0" : "", N.transform = (E.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + y + "px)" : "translate3d(" + p + "px, " + y + "px, 0)", N))
    }
    return Object.assign({}, k, (e = {}, e[S] = _ ? y + "px" : "", e[x] = b ? p + "px" : "", e.transform = "", e))
}

function oTe(t) {
    var e = t.state,
        n = t.options,
        r = n.gpuAcceleration,
        i = r === void 0 ? !0 : r,
        s = n.adaptive,
        o = s === void 0 ? !0 : s,
        a = n.roundOffsets,
        l = a === void 0 ? !0 : a,
        u = {
            placement: Il(e.placement),
            variation: tg(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: i,
            isFixed: e.options.strategy === "fixed"
        };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Iz(Object.assign({}, u, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Iz(Object.assign({}, u, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
    })
}
const aTe = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: oTe,
    data: {}
};
var C_ = {
    passive: !0
};

function lTe(t) {
    var e = t.state,
        n = t.instance,
        r = t.options,
        i = r.scroll,
        s = i === void 0 ? !0 : i,
        o = r.resize,
        a = o === void 0 ? !0 : o,
        l = mo(e.elements.popper),
        u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && u.forEach(function(c) {
            c.addEventListener("scroll", n.update, C_)
        }), a && l.addEventListener("resize", n.update, C_),
        function() {
            s && u.forEach(function(c) {
                c.removeEventListener("scroll", n.update, C_)
            }), a && l.removeEventListener("resize", n.update, C_)
        }
}
const uTe = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: lTe,
    data: {}
};
var cTe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};

function HS(t) {
    return t.replace(/left|right|bottom|top/g, function(e) {
        return cTe[e]
    })
}
var fTe = {
    start: "end",
    end: "start"
};

function Rz(t) {
    return t.replace(/start|end/g, function(e) {
        return fTe[e]
    })
}

function Ik(t) {
    var e = mo(t),
        n = e.pageXOffset,
        r = e.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}

function Rk(t) {
    return eg(Cf(t)).left + Ik(t).scrollLeft
}

function dTe(t, e) {
    var n = mo(t),
        r = Cf(t),
        i = n.visualViewport,
        s = r.clientWidth,
        o = r.clientHeight,
        a = 0,
        l = 0;
    if (i) {
        s = i.width, o = i.height;
        var u = UJ();
        (u || !u && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop)
    }
    return {
        width: s,
        height: o,
        x: a + Rk(t),
        y: l
    }
}

function pTe(t) {
    var e, n = Cf(t),
        r = Ik(t),
        i = (e = t.ownerDocument) == null ? void 0 : e.body,
        s = Ud(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = Ud(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        a = -r.scrollLeft + Rk(t),
        l = -r.scrollTop;
    return Hu(i || n).direction === "rtl" && (a += Ud(n.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: o,
        x: a,
        y: l
    }
}

function Ok(t) {
    var e = Hu(t),
        n = e.overflow,
        r = e.overflowX,
        i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}

function WJ(t) {
    return ["html", "body", "#document"].indexOf(Ll(t)) >= 0 ? t.ownerDocument.body : Qo(t) && Ok(t) ? t : WJ(RA(t))
}

function Cv(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = WJ(t),
        i = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
        s = mo(r),
        o = i ? [s].concat(s.visualViewport || [], Ok(r) ? r : []) : r,
        a = e.concat(o);
    return i ? a : a.concat(Cv(RA(o)))
}

function PR(t) {
    return Object.assign({}, t, {
        left: t.x,
        top: t.y,
        right: t.x + t.width,
        bottom: t.y + t.height
    })
}

function hTe(t, e) {
    var n = eg(t, !1, e === "fixed");
    return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n
}

function Oz(t, e, n) {
    return e === zJ ? PR(dTe(t, n)) : cp(e) ? hTe(e, n) : PR(pTe(Cf(t)))
}

function mTe(t) {
    var e = Cv(RA(t)),
        n = ["absolute", "fixed"].indexOf(Hu(t).position) >= 0,
        r = n && Qo(t) ? Z1(t) : t;
    return cp(r) ? e.filter(function(i) {
        return cp(i) && $J(i, r) && Ll(i) !== "body"
    }) : []
}

function gTe(t, e, n, r) {
    var i = e === "clippingParents" ? mTe(t) : [].concat(e),
        s = [].concat(i, [n]),
        o = s[0],
        a = s.reduce(function(l, u) {
            var c = Oz(t, u, r);
            return l.top = Ud(c.top, l.top), l.right = l2(c.right, l.right), l.bottom = l2(c.bottom, l.bottom), l.left = Ud(c.left, l.left), l
        }, Oz(t, o, r));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
}

function KJ(t) {
    var e = t.reference,
        n = t.element,
        r = t.placement,
        i = r ? Il(r) : null,
        s = r ? tg(r) : null,
        o = e.x + e.width / 2 - n.width / 2,
        a = e.y + e.height / 2 - n.height / 2,
        l;
    switch (i) {
        case js:
            l = {
                x: o,
                y: e.y - n.height
            };
            break;
        case oa:
            l = {
                x: o,
                y: e.y + e.height
            };
            break;
        case aa:
            l = {
                x: e.x + e.width,
                y: a
            };
            break;
        case Ws:
            l = {
                x: e.x - n.width,
                y: a
            };
            break;
        default:
            l = {
                x: e.x,
                y: e.y
            }
    }
    var u = i ? Pk(i) : null;
    if (u != null) {
        var c = u === "y" ? "height" : "width";
        switch (s) {
            case Qm:
                l[u] = l[u] - (e[c] / 2 - n[c] / 2);
                break;
            case k0:
                l[u] = l[u] + (e[c] / 2 - n[c] / 2);
                break
        }
    }
    return l
}

function B0(t, e) {
    e === void 0 && (e = {});
    var n = e,
        r = n.placement,
        i = r === void 0 ? t.placement : r,
        s = n.strategy,
        o = s === void 0 ? t.strategy : s,
        a = n.boundary,
        l = a === void 0 ? BMe : a,
        u = n.rootBoundary,
        c = u === void 0 ? zJ : u,
        f = n.elementContext,
        d = f === void 0 ? Py : f,
        p = n.altBoundary,
        m = p === void 0 ? !1 : p,
        y = n.padding,
        v = y === void 0 ? 0 : y,
        b = VJ(typeof v != "number" ? v : jJ(v, Q1)),
        _ = d === Py ? FMe : Py,
        x = t.rects.popper,
        S = t.elements[m ? _ : d],
        E = gTe(cp(S) ? S : S.contextElement || Cf(t.elements.popper), l, c, o),
        A = eg(t.elements.reference),
        T = KJ({
            reference: A,
            element: x,
            strategy: "absolute",
            placement: i
        }),
        M = PR(Object.assign({}, x, T)),
        I = d === Py ? M : A,
        O = {
            top: E.top - I.top + b.top,
            bottom: I.bottom - E.bottom + b.bottom,
            left: E.left - I.left + b.left,
            right: I.right - E.right + b.right
        },
        k = t.modifiersData.offset;
    if (d === Py && k) {
        var H = k[i];
        Object.keys(O).forEach(function(N) {
            var B = [aa, oa].indexOf(N) >= 0 ? 1 : -1,
                U = [js, oa].indexOf(N) >= 0 ? "y" : "x";
            O[N] += H[U] * B
        })
    }
    return O
}

function yTe(t, e) {
    e === void 0 && (e = {});
    var n = e,
        r = n.placement,
        i = n.boundary,
        s = n.rootBoundary,
        o = n.padding,
        a = n.flipVariations,
        l = n.allowedAutoPlacements,
        u = l === void 0 ? HJ : l,
        c = tg(r),
        f = c ? a ? Tz : Tz.filter(function(m) {
            return tg(m) === c
        }) : Q1,
        d = f.filter(function(m) {
            return u.indexOf(m) >= 0
        });
    d.length === 0 && (d = f);
    var p = d.reduce(function(m, y) {
        return m[y] = B0(t, {
            placement: y,
            boundary: i,
            rootBoundary: s,
            padding: o
        })[Il(y)], m
    }, {});
    return Object.keys(p).sort(function(m, y) {
        return p[m] - p[y]
    })
}

function vTe(t) {
    if (Il(t) === Ck) return [];
    var e = HS(t);
    return [Rz(t), e, Rz(e)]
}

function bTe(t) {
    var e = t.state,
        n = t.options,
        r = t.name;
    if (!e.modifiersData[r]._skip) {
        for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, u = n.padding, c = n.boundary, f = n.rootBoundary, d = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, y = n.allowedAutoPlacements, v = e.options.placement, b = Il(v), _ = b === v, x = l || (_ || !m ? [HS(v)] : vTe(v)), S = [v].concat(x).reduce(function(de, re) {
                return de.concat(Il(re) === Ck ? yTe(e, {
                    placement: re,
                    boundary: c,
                    rootBoundary: f,
                    padding: u,
                    flipVariations: m,
                    allowedAutoPlacements: y
                }) : re)
            }, []), E = e.rects.reference, A = e.rects.popper, T = new Map, M = !0, I = S[0], O = 0; O < S.length; O++) {
            var k = S[O],
                H = Il(k),
                N = tg(k) === Qm,
                B = [js, oa].indexOf(H) >= 0,
                U = B ? "width" : "height",
                q = B0(e, {
                    placement: k,
                    boundary: c,
                    rootBoundary: f,
                    altBoundary: d,
                    padding: u
                }),
                Q = B ? N ? aa : Ws : N ? oa : js;
            E[U] > A[U] && (Q = HS(Q));
            var F = HS(Q),
                G = [];
            if (s && G.push(q[H] <= 0), a && G.push(q[Q] <= 0, q[F] <= 0), G.every(function(de) {
                    return de
                })) {
                I = k, M = !1;
                break
            }
            T.set(k, G)
        }
        if (M)
            for (var W = m ? 3 : 1, se = function(re) {
                    var _e = S.find(function(fe) {
                        var ue = T.get(fe);
                        if (ue) return ue.slice(0, re).every(function(ve) {
                            return ve
                        })
                    });
                    if (_e) return I = _e, "break"
                }, ee = W; ee > 0; ee--) {
                var ae = se(ee);
                if (ae === "break") break
            }
        e.placement !== I && (e.modifiersData[r]._skip = !0, e.placement = I, e.reset = !0)
    }
}
const xTe = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: bTe,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};

function Dz(t, e, n) {
    return n === void 0 && (n = {
        x: 0,
        y: 0
    }), {
        top: t.top - e.height - n.y,
        right: t.right - e.width + n.x,
        bottom: t.bottom - e.height + n.y,
        left: t.left - e.width - n.x
    }
}

function Lz(t) {
    return [js, aa, oa, Ws].some(function(e) {
        return t[e] >= 0
    })
}

function _Te(t) {
    var e = t.state,
        n = t.name,
        r = e.rects.reference,
        i = e.rects.popper,
        s = e.modifiersData.preventOverflow,
        o = B0(e, {
            elementContext: "reference"
        }),
        a = B0(e, {
            altBoundary: !0
        }),
        l = Dz(o, r),
        u = Dz(a, i, s),
        c = Lz(l),
        f = Lz(u);
    e.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: u,
        isReferenceHidden: c,
        hasPopperEscaped: f
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": c,
        "data-popper-escaped": f
    })
}
const STe = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: _Te
};

function wTe(t, e, n) {
    var r = Il(t),
        i = [Ws, js].indexOf(r) >= 0 ? -1 : 1,
        s = typeof n == "function" ? n(Object.assign({}, e, {
            placement: t
        })) : n,
        o = s[0],
        a = s[1];
    return o = o || 0, a = (a || 0) * i, [Ws, aa].indexOf(r) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}

function ETe(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.offset,
        s = i === void 0 ? [0, 0] : i,
        o = HJ.reduce(function(c, f) {
            return c[f] = wTe(f, e.rects, s), c
        }, {}),
        a = o[e.placement],
        l = a.x,
        u = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = o
}
const ATe = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: ETe
};

function CTe(t) {
    var e = t.state,
        n = t.name;
    e.modifiersData[n] = KJ({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
const MTe = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: CTe,
    data: {}
};

function TTe(t) {
    return t === "x" ? "y" : "x"
}

function PTe(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.mainAxis,
        s = i === void 0 ? !0 : i,
        o = n.altAxis,
        a = o === void 0 ? !1 : o,
        l = n.boundary,
        u = n.rootBoundary,
        c = n.altBoundary,
        f = n.padding,
        d = n.tether,
        p = d === void 0 ? !0 : d,
        m = n.tetherOffset,
        y = m === void 0 ? 0 : m,
        v = B0(e, {
            boundary: l,
            rootBoundary: u,
            padding: f,
            altBoundary: c
        }),
        b = Il(e.placement),
        _ = tg(e.placement),
        x = !_,
        S = Pk(b),
        E = TTe(S),
        A = e.modifiersData.popperOffsets,
        T = e.rects.reference,
        M = e.rects.popper,
        I = typeof y == "function" ? y(Object.assign({}, e.rects, {
            placement: e.placement
        })) : y,
        O = typeof I == "number" ? {
            mainAxis: I,
            altAxis: I
        } : Object.assign({
            mainAxis: 0,
            altAxis: 0
        }, I),
        k = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
        H = {
            x: 0,
            y: 0
        };
    if (A) {
        if (s) {
            var N, B = S === "y" ? js : Ws,
                U = S === "y" ? oa : aa,
                q = S === "y" ? "height" : "width",
                Q = A[S],
                F = Q + v[B],
                G = Q - v[U],
                W = p ? -M[q] / 2 : 0,
                se = _ === Qm ? T[q] : M[q],
                ee = _ === Qm ? -M[q] : -T[q],
                ae = e.elements.arrow,
                de = p && ae ? Tk(ae) : {
                    width: 0,
                    height: 0
                },
                re = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : GJ(),
                _e = re[B],
                fe = re[U],
                ue = Av(0, T[q], de[q]),
                ve = x ? T[q] / 2 - W - ue - _e - O.mainAxis : se - ue - _e - O.mainAxis,
                xe = x ? -T[q] / 2 + W + ue + fe + O.mainAxis : ee + ue + fe + O.mainAxis,
                be = e.elements.arrow && Z1(e.elements.arrow),
                he = be ? S === "y" ? be.clientTop || 0 : be.clientLeft || 0 : 0,
                me = (N = k == null ? void 0 : k[S]) != null ? N : 0,
                Ce = Q + ve - me - he,
                Ne = Q + xe - me,
                De = Av(p ? l2(F, Ce) : F, Q, p ? Ud(G, Ne) : G);
            A[S] = De, H[S] = De - Q
        }
        if (a) {
            var je, Ke = S === "x" ? js : Ws,
                He = S === "x" ? oa : aa,
                qe = A[E],
                Xe = E === "y" ? "height" : "width",
                K = qe + v[Ke],
                V = qe - v[He],
                ge = [js, Ws].indexOf(b) !== -1,
                Be = (je = k == null ? void 0 : k[E]) != null ? je : 0,
                ze = ge ? K : qe - T[Xe] - M[Xe] - Be + O.altAxis,
                Ue = ge ? qe + T[Xe] + M[Xe] - Be - O.altAxis : V,
                Ye = p && ge ? ZMe(ze, qe, Ue) : Av(p ? ze : K, qe, p ? Ue : V);
            A[E] = Ye, H[E] = Ye - qe
        }
        e.modifiersData[r] = H
    }
}
const ITe = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: PTe,
    requiresIfExists: ["offset"]
};

function RTe(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}

function OTe(t) {
    return t === mo(t) || !Qo(t) ? Ik(t) : RTe(t)
}

function DTe(t) {
    var e = t.getBoundingClientRect(),
        n = Zm(e.width) / t.offsetWidth || 1,
        r = Zm(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1
}

function LTe(t, e, n) {
    n === void 0 && (n = !1);
    var r = Qo(e),
        i = Qo(e) && DTe(e),
        s = Cf(e),
        o = eg(t, i, n),
        a = {
            scrollLeft: 0,
            scrollTop: 0
        },
        l = {
            x: 0,
            y: 0
        };
    return (r || !r && !n) && ((Ll(e) !== "body" || Ok(s)) && (a = OTe(e)), Qo(e) ? (l = eg(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = Rk(s))), {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}

function kTe(t) {
    var e = new Map,
        n = new Set,
        r = [];
    t.forEach(function(s) {
        e.set(s.name, s)
    });

    function i(s) {
        n.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function(a) {
            if (!n.has(a)) {
                var l = e.get(a);
                l && i(l)
            }
        }), r.push(s)
    }
    return t.forEach(function(s) {
        n.has(s.name) || i(s)
    }), r
}

function BTe(t) {
    var e = kTe(t);
    return KMe.reduce(function(n, r) {
        return n.concat(e.filter(function(i) {
            return i.phase === r
        }))
    }, [])
}

function FTe(t) {
    var e;
    return function() {
        return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
                e = void 0, n(t())
            })
        })), e
    }
}

function NTe(t) {
    var e = t.reduce(function(n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r, n
    }, {});
    return Object.keys(e).map(function(n) {
        return e[n]
    })
}
var kz = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};

function Bz() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}

function zTe(t) {
    t === void 0 && (t = {});
    var e = t,
        n = e.defaultModifiers,
        r = n === void 0 ? [] : n,
        i = e.defaultOptions,
        s = i === void 0 ? kz : i;
    return function(a, l, u) {
        u === void 0 && (u = s);
        var c = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, kz, s),
                modifiersData: {},
                elements: {
                    reference: a,
                    popper: l
                },
                attributes: {},
                styles: {}
            },
            f = [],
            d = !1,
            p = {
                state: c,
                setOptions: function(b) {
                    var _ = typeof b == "function" ? b(c.options) : b;
                    y(), c.options = Object.assign({}, s, c.options, _), c.scrollParents = {
                        reference: cp(a) ? Cv(a) : a.contextElement ? Cv(a.contextElement) : [],
                        popper: Cv(l)
                    };
                    var x = BTe(NTe([].concat(r, c.options.modifiers)));
                    return c.orderedModifiers = x.filter(function(S) {
                        return S.enabled
                    }), m(), p.update()
                },
                forceUpdate: function() {
                    if (!d) {
                        var b = c.elements,
                            _ = b.reference,
                            x = b.popper;
                        if (Bz(_, x)) {
                            c.rects = {
                                reference: LTe(_, Z1(x), c.options.strategy === "fixed"),
                                popper: Tk(x)
                            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(O) {
                                return c.modifiersData[O.name] = Object.assign({}, O.data)
                            });
                            for (var S = 0; S < c.orderedModifiers.length; S++) {
                                if (c.reset === !0) {
                                    c.reset = !1, S = -1;
                                    continue
                                }
                                var E = c.orderedModifiers[S],
                                    A = E.fn,
                                    T = E.options,
                                    M = T === void 0 ? {} : T,
                                    I = E.name;
                                typeof A == "function" && (c = A({
                                    state: c,
                                    options: M,
                                    name: I,
                                    instance: p
                                }) || c)
                            }
                        }
                    }
                },
                update: FTe(function() {
                    return new Promise(function(v) {
                        p.forceUpdate(), v(c)
                    })
                }),
                destroy: function() {
                    y(), d = !0
                }
            };
        if (!Bz(a, l)) return p;
        p.setOptions(u).then(function(v) {
            !d && u.onFirstUpdate && u.onFirstUpdate(v)
        });

        function m() {
            c.orderedModifiers.forEach(function(v) {
                var b = v.name,
                    _ = v.options,
                    x = _ === void 0 ? {} : _,
                    S = v.effect;
                if (typeof S == "function") {
                    var E = S({
                            state: c,
                            name: b,
                            instance: p,
                            options: x
                        }),
                        A = function() {};
                    f.push(E || A)
                }
            })
        }

        function y() {
            f.forEach(function(v) {
                return v()
            }), f = []
        }
        return p
    }
}
var HTe = [uTe, MTe, aTe, JMe, ATe, xTe, ITe, rTe, STe],
    UTe = zTe({
        defaultModifiers: HTe
    });

function $Te(t) {
    return typeof t == "function" ? t() : t
}
const qJ = P.forwardRef(function(e, n) {
        const {
            children: r,
            container: i,
            disablePortal: s = !1
        } = e, [o, a] = P.useState(null), l = ls(P.isValidElement(r) ? r.ref : null, n);
        if (gf(() => {
                s || a($Te(i) || document.body)
            }, [i, s]), gf(() => {
                if (o && !s) return s2(n, o), () => {
                    s2(n, null)
                }
            }, [n, o, s]), s) {
            if (P.isValidElement(r)) {
                const u = {
                    ref: l
                };
                return P.cloneElement(r, u)
            }
            return gt(P.Fragment, {
                children: r
            })
        }
        return gt(P.Fragment, {
            children: o && r1.createPortal(r, o)
        })
    }),
    XJ = "base";

function GTe(t) {
    return `${XJ}--${t}`
}

function VTe(t, e) {
    return `${XJ}-${t}-${e}`
}

function JJ(t, e) {
    const n = yJ[e];
    return n ? GTe(n) : VTe(t, e)
}

function jTe(t, e) {
    const n = {};
    return e.forEach(r => {
        n[r] = JJ(t, r)
    }), n
}
const YJ = "Popper";

function WTe(t) {
    return JJ(YJ, t)
}
jTe(YJ, ["root"]);
const KTe = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"],
    qTe = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];

function XTe(t, e) {
    if (e === "ltr") return t;
    switch (t) {
        case "bottom-end":
            return "bottom-start";
        case "bottom-start":
            return "bottom-end";
        case "top-end":
            return "top-start";
        case "top-start":
            return "top-end";
        default:
            return t
    }
}

function IR(t) {
    return typeof t == "function" ? t() : t
}

function JTe(t) {
    return t.nodeType !== void 0
}
const YTe = () => Yn({
        root: ["root"]
    }, AMe(WTe)),
    QTe = {},
    ZTe = P.forwardRef(function(e, n) {
        var r;
        const {
            anchorEl: i,
            children: s,
            direction: o,
            disablePortal: a,
            modifiers: l,
            open: u,
            placement: c,
            popperOptions: f,
            popperRef: d,
            slotProps: p = {},
            slots: m = {},
            TransitionProps: y
        } = e, v = Rt(e, KTe), b = P.useRef(null), _ = ls(b, n), x = P.useRef(null), S = ls(x, d), E = P.useRef(S);
        gf(() => {
            E.current = S
        }, [S]), P.useImperativeHandle(d, () => x.current, []);
        const A = XTe(c, o),
            [T, M] = P.useState(A),
            [I, O] = P.useState(IR(i));
        P.useEffect(() => {
            x.current && x.current.forceUpdate()
        }), P.useEffect(() => {
            i && O(IR(i))
        }, [i]), gf(() => {
            if (!I || !u) return;
            const U = F => {
                M(F.placement)
            };
            let q = [{
                name: "preventOverflow",
                options: {
                    altBoundary: a
                }
            }, {
                name: "flip",
                options: {
                    altBoundary: a
                }
            }, {
                name: "onUpdate",
                enabled: !0,
                phase: "afterWrite",
                fn: ({
                    state: F
                }) => {
                    U(F)
                }
            }];
            l != null && (q = q.concat(l)), f && f.modifiers != null && (q = q.concat(f.modifiers));
            const Q = UTe(I, b.current, Y({
                placement: A
            }, f, {
                modifiers: q
            }));
            return E.current(Q), () => {
                Q.destroy(), E.current(null)
            }
        }, [I, a, l, u, f, A]);
        const k = {
            placement: T
        };
        y !== null && (k.TransitionProps = y);
        const H = YTe(),
            N = (r = m.root) != null ? r : "div",
            B = AR({
                elementType: N,
                externalSlotProps: p.root,
                externalForwardedProps: v,
                additionalProps: {
                    role: "tooltip",
                    ref: _
                },
                ownerState: e,
                className: H.root
            });
        return gt(N, Y({}, B, {
            children: typeof s == "function" ? s(k) : s
        }))
    }),
    ePe = P.forwardRef(function(e, n) {
        const {
            anchorEl: r,
            children: i,
            container: s,
            direction: o = "ltr",
            disablePortal: a = !1,
            keepMounted: l = !1,
            modifiers: u,
            open: c,
            placement: f = "bottom",
            popperOptions: d = QTe,
            popperRef: p,
            style: m,
            transition: y = !1,
            slotProps: v = {},
            slots: b = {}
        } = e, _ = Rt(e, qTe), [x, S] = P.useState(!0), E = () => {
            S(!1)
        }, A = () => {
            S(!0)
        };
        if (!l && !c && (!y || x)) return null;
        let T;
        if (s) T = s;
        else if (r) {
            const O = IR(r);
            T = O && JTe(O) ? Ga(O).body : Ga(null).body
        }
        const M = !c && l && (!y || x) ? "none" : void 0,
            I = y ? { in: c,
                onEnter: E,
                onExited: A
            } : void 0;
        return gt(qJ, {
            disablePortal: a,
            container: T,
            children: gt(ZTe, Y({
                anchorEl: r,
                direction: o,
                disablePortal: a,
                modifiers: u,
                ref: n,
                open: y ? !x : c,
                placement: f,
                popperOptions: d,
                popperRef: p,
                slotProps: v,
                slots: b
            }, _, {
                style: Y({
                    position: "fixed",
                    top: 0,
                    left: 0,
                    display: M
                }, m),
                TransitionProps: I,
                children: i
            }))
        })
    });
var Dk = {};
Object.defineProperty(Dk, "__esModule", {
    value: !0
});
var QJ = Dk.default = void 0,
    tPe = rPe(P),
    nPe = DJ;

function ZJ(t) {
    if (typeof WeakMap != "function") return null;
    var e = new WeakMap,
        n = new WeakMap;
    return (ZJ = function(r) {
        return r ? n : e
    })(t)
}

function rPe(t, e) {
    if (!e && t && t.__esModule) return t;
    if (t === null || typeof t != "object" && typeof t != "function") return {
        default: t
    };
    var n = ZJ(e);
    if (n && n.has(t)) return n.get(t);
    var r = {
            __proto__: null
        },
        i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var s in t)
        if (s !== "default" && Object.prototype.hasOwnProperty.call(t, s)) {
            var o = i ? Object.getOwnPropertyDescriptor(t, s) : null;
            o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = t[s]
        }
    return r.default = t, n && n.set(t, r), r
}

function iPe(t) {
    return Object.keys(t).length === 0
}

function sPe(t = null) {
    const e = tPe.useContext(nPe.ThemeContext);
    return !e || iPe(e) ? t : e
}
QJ = Dk.default = sPe;
const oPe = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"],
    aPe = en(ePe, {
        name: "MuiPopper",
        slot: "Root",
        overridesResolver: (t, e) => e.root
    })({}),
    lPe = P.forwardRef(function(e, n) {
        var r;
        const i = QJ(),
            s = Kn({
                props: e,
                name: "MuiPopper"
            }),
            {
                anchorEl: o,
                component: a,
                components: l,
                componentsProps: u,
                container: c,
                disablePortal: f,
                keepMounted: d,
                modifiers: p,
                open: m,
                placement: y,
                popperOptions: v,
                popperRef: b,
                transition: _,
                slots: x,
                slotProps: S
            } = s,
            E = Rt(s, oPe),
            A = (r = x == null ? void 0 : x.root) != null ? r : l == null ? void 0 : l.Root,
            T = Y({
                anchorEl: o,
                container: c,
                disablePortal: f,
                keepMounted: d,
                modifiers: p,
                open: m,
                placement: y,
                popperOptions: v,
                popperRef: b,
                transition: _
            }, E);
        return gt(aPe, Y({
            as: a,
            direction: i == null ? void 0 : i.direction,
            slots: {
                root: A
            },
            slotProps: S ? ? u
        }, T, {
            ref: n
        }))
    }),
    eY = lPe;

function uPe(t) {
    return Jn("MuiTooltip", t)
}
const cPe = tr("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]),
    kc = cPe,
    fPe = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];

function dPe(t) {
    return Math.round(t * 1e5) / 1e5
}
const pPe = t => {
        const {
            classes: e,
            disableInteractive: n,
            arrow: r,
            touch: i,
            placement: s
        } = t, o = {
            popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
            tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${Wt(s.split("-")[0])}`],
            arrow: ["arrow"]
        };
        return Yn(o, uPe, e)
    },
    hPe = en(eY, {
        name: "MuiTooltip",
        slot: "Popper",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.popper, !n.disableInteractive && e.popperInteractive, n.arrow && e.popperArrow, !n.open && e.popperClose]
        }
    })(({
        theme: t,
        ownerState: e,
        open: n
    }) => Y({
        zIndex: (t.vars || t).zIndex.tooltip,
        pointerEvents: "none"
    }, !e.disableInteractive && {
        pointerEvents: "auto"
    }, !n && {
        pointerEvents: "none"
    }, e.arrow && {
        [`&[data-popper-placement*="bottom"] .${kc.arrow}`]: {
            top: 0,
            marginTop: "-0.71em",
            "&::before": {
                transformOrigin: "0 100%"
            }
        },
        [`&[data-popper-placement*="top"] .${kc.arrow}`]: {
            bottom: 0,
            marginBottom: "-0.71em",
            "&::before": {
                transformOrigin: "100% 0"
            }
        },
        [`&[data-popper-placement*="right"] .${kc.arrow}`]: Y({}, e.isRtl ? {
            right: 0,
            marginRight: "-0.71em"
        } : {
            left: 0,
            marginLeft: "-0.71em"
        }, {
            height: "1em",
            width: "0.71em",
            "&::before": {
                transformOrigin: "100% 100%"
            }
        }),
        [`&[data-popper-placement*="left"] .${kc.arrow}`]: Y({}, e.isRtl ? {
            left: 0,
            marginLeft: "-0.71em"
        } : {
            right: 0,
            marginRight: "-0.71em"
        }, {
            height: "1em",
            width: "0.71em",
            "&::before": {
                transformOrigin: "0 0"
            }
        })
    })),
    mPe = en("div", {
        name: "MuiTooltip",
        slot: "Tooltip",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.tooltip, n.touch && e.touch, n.arrow && e.tooltipArrow, e[`tooltipPlacement${Wt(n.placement.split("-")[0])}`]]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        backgroundColor: t.vars ? t.vars.palette.Tooltip.bg : gi(t.palette.grey[700], .92),
        borderRadius: (t.vars || t).shape.borderRadius,
        color: (t.vars || t).palette.common.white,
        fontFamily: t.typography.fontFamily,
        padding: "4px 8px",
        fontSize: t.typography.pxToRem(11),
        maxWidth: 300,
        margin: 2,
        wordWrap: "break-word",
        fontWeight: t.typography.fontWeightMedium
    }, e.arrow && {
        position: "relative",
        margin: 0
    }, e.touch && {
        padding: "8px 16px",
        fontSize: t.typography.pxToRem(14),
        lineHeight: `${dPe(16/14)}em`,
        fontWeight: t.typography.fontWeightRegular
    }, {
        [`.${kc.popper}[data-popper-placement*="left"] &`]: Y({
            transformOrigin: "right center"
        }, e.isRtl ? Y({
            marginLeft: "14px"
        }, e.touch && {
            marginLeft: "24px"
        }) : Y({
            marginRight: "14px"
        }, e.touch && {
            marginRight: "24px"
        })),
        [`.${kc.popper}[data-popper-placement*="right"] &`]: Y({
            transformOrigin: "left center"
        }, e.isRtl ? Y({
            marginRight: "14px"
        }, e.touch && {
            marginRight: "24px"
        }) : Y({
            marginLeft: "14px"
        }, e.touch && {
            marginLeft: "24px"
        })),
        [`.${kc.popper}[data-popper-placement*="top"] &`]: Y({
            transformOrigin: "center bottom",
            marginBottom: "14px"
        }, e.touch && {
            marginBottom: "24px"
        }),
        [`.${kc.popper}[data-popper-placement*="bottom"] &`]: Y({
            transformOrigin: "center top",
            marginTop: "14px"
        }, e.touch && {
            marginTop: "24px"
        })
    })),
    gPe = en("span", {
        name: "MuiTooltip",
        slot: "Arrow",
        overridesResolver: (t, e) => e.arrow
    })(({
        theme: t
    }) => ({
        overflow: "hidden",
        position: "absolute",
        width: "1em",
        height: "0.71em",
        boxSizing: "border-box",
        color: t.vars ? t.vars.palette.Tooltip.bg : gi(t.palette.grey[700], .9),
        "&::before": {
            content: '""',
            margin: "auto",
            display: "block",
            width: "100%",
            height: "100%",
            backgroundColor: "currentColor",
            transform: "rotate(45deg)"
        }
    }));
let M_ = !1;
const Fz = new X1;
let Iy = {
    x: 0,
    y: 0
};

function T_(t, e) {
    return (n, ...r) => {
        e && e(n, ...r), t(n, ...r)
    }
}
const yPe = P.forwardRef(function(e, n) {
        var r, i, s, o, a, l, u, c, f, d, p, m, y, v, b, _, x, S, E;
        const A = Kn({
                props: e,
                name: "MuiTooltip"
            }),
            {
                arrow: T = !1,
                children: M,
                components: I = {},
                componentsProps: O = {},
                describeChild: k = !1,
                disableFocusListener: H = !1,
                disableHoverListener: N = !1,
                disableInteractive: B = !1,
                disableTouchListener: U = !1,
                enterDelay: q = 100,
                enterNextDelay: Q = 0,
                enterTouchDelay: F = 700,
                followCursor: G = !1,
                id: W,
                leaveDelay: se = 0,
                leaveTouchDelay: ee = 1500,
                onClose: ae,
                onOpen: de,
                open: re,
                placement: _e = "bottom",
                PopperComponent: fe,
                PopperProps: ue = {},
                slotProps: ve = {},
                slots: xe = {},
                title: be,
                TransitionComponent: he = Mz,
                TransitionProps: me
            } = A,
            Ce = Rt(A, fPe),
            Ne = P.isValidElement(M) ? M : gt("span", {
                children: M
            }),
            De = Rg(),
            je = EJ(),
            [Ke, He] = P.useState(),
            [qe, Xe] = P.useState(null),
            K = P.useRef(!1),
            V = B || G,
            ge = Wh(),
            Be = Wh(),
            ze = Wh(),
            Ue = Wh(),
            [Ye, Te] = wJ({
                controlled: re,
                default: !1,
                name: "Tooltip",
                state: "open"
            });
        let we = Ye;
        const lt = gk(W),
            nt = P.useRef(),
            vt = wu(() => {
                nt.current !== void 0 && (document.body.style.WebkitUserSelect = nt.current, nt.current = void 0), Ue.clear()
            });
        P.useEffect(() => vt, [vt]);
        const ht = Qe => {
                Fz.clear(), M_ = !0, Te(!0), de && !we && de(Qe)
            },
            pt = wu(Qe => {
                Fz.start(800 + se, () => {
                    M_ = !1
                }), Te(!1), ae && we && ae(Qe), ge.start(De.transitions.duration.shortest, () => {
                    K.current = !1
                })
            }),
            le = Qe => {
                K.current && Qe.type !== "touchstart" || (Ke && Ke.removeAttribute("title"), Be.clear(), ze.clear(), q || M_ && Q ? Be.start(M_ ? Q : q, () => {
                    ht(Qe)
                }) : ht(Qe))
            },
            Ie = Qe => {
                Be.clear(), ze.start(se, () => {
                    pt(Qe)
                })
            },
            {
                isFocusVisibleRef: tt,
                onBlur: oe,
                onFocus: Ee,
                ref: Fe
            } = yk(),
            [, Ve] = P.useState(!1),
            ct = Qe => {
                oe(Qe), tt.current === !1 && (Ve(!1), Ie(Qe))
            },
            bt = Qe => {
                Ke || He(Qe.currentTarget), Ee(Qe), tt.current === !0 && (Ve(!0), le(Qe))
            },
            Kt = Qe => {
                K.current = !0;
                const ft = Ne.props;
                ft.onTouchStart && ft.onTouchStart(Qe)
            },
            un = Qe => {
                Kt(Qe), ze.clear(), ge.clear(), vt(), nt.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", Ue.start(F, () => {
                    document.body.style.WebkitUserSelect = nt.current, le(Qe)
                })
            },
            zt = Qe => {
                Ne.props.onTouchEnd && Ne.props.onTouchEnd(Qe), vt(), ze.start(ee, () => {
                    pt(Qe)
                })
            };
        P.useEffect(() => {
            if (!we) return;

            function Qe(ft) {
                (ft.key === "Escape" || ft.key === "Esc") && pt(ft)
            }
            return document.addEventListener("keydown", Qe), () => {
                document.removeEventListener("keydown", Qe)
            }
        }, [pt, we]);
        const Ot = ls(Ne.ref, Fe, He, n);
        !be && be !== 0 && (we = !1);
        const tn = P.useRef(),
            Xt = Qe => {
                const ft = Ne.props;
                ft.onMouseMove && ft.onMouseMove(Qe), Iy = {
                    x: Qe.clientX,
                    y: Qe.clientY
                }, tn.current && tn.current.update()
            },
            Hr = {},
            cs = typeof be == "string";
        k ? (Hr.title = !we && cs && !N ? be : null, Hr["aria-describedby"] = we ? lt : null) : (Hr["aria-label"] = cs ? be : null, Hr["aria-labelledby"] = we && !cs ? lt : null);
        const Gn = Y({}, Hr, Ce, Ne.props, {
                className: Nt(Ce.className, Ne.props.className),
                onTouchStart: Kt,
                ref: Ot
            }, G ? {
                onMouseMove: Xt
            } : {}),
            D = {};
        U || (Gn.onTouchStart = un, Gn.onTouchEnd = zt), N || (Gn.onMouseOver = T_(le, Gn.onMouseOver), Gn.onMouseLeave = T_(Ie, Gn.onMouseLeave), V || (D.onMouseOver = le, D.onMouseLeave = Ie)), H || (Gn.onFocus = T_(bt, Gn.onFocus), Gn.onBlur = T_(ct, Gn.onBlur), V || (D.onFocus = bt, D.onBlur = ct));
        const z = P.useMemo(() => {
                var Qe;
                let ft = [{
                    name: "arrow",
                    enabled: !!qe,
                    options: {
                        element: qe,
                        padding: 4
                    }
                }];
                return (Qe = ue.popperOptions) != null && Qe.modifiers && (ft = ft.concat(ue.popperOptions.modifiers)), Y({}, ue.popperOptions, {
                    modifiers: ft
                })
            }, [qe, ue]),
            j = Y({}, A, {
                isRtl: je,
                arrow: T,
                disableInteractive: V,
                placement: _e,
                PopperComponentProp: fe,
                touch: K.current
            }),
            X = pPe(j),
            te = (r = (i = xe.popper) != null ? i : I.Popper) != null ? r : hPe,
            Oe = (s = (o = (a = xe.transition) != null ? a : I.Transition) != null ? o : he) != null ? s : Mz,
            $e = (l = (u = xe.tooltip) != null ? u : I.Tooltip) != null ? l : mPe,
            rt = (c = (f = xe.arrow) != null ? f : I.Arrow) != null ? c : gPe,
            Ze = Kh(te, Y({}, ue, (d = ve.popper) != null ? d : O.popper, {
                className: Nt(X.popper, ue == null ? void 0 : ue.className, (p = (m = ve.popper) != null ? m : O.popper) == null ? void 0 : p.className)
            }), j),
            Tt = Kh(Oe, Y({}, me, (y = ve.transition) != null ? y : O.transition), j),
            st = Kh($e, Y({}, (v = ve.tooltip) != null ? v : O.tooltip, {
                className: Nt(X.tooltip, (b = (_ = ve.tooltip) != null ? _ : O.tooltip) == null ? void 0 : b.className)
            }), j),
            St = Kh(rt, Y({}, (x = ve.arrow) != null ? x : O.arrow, {
                className: Nt(X.arrow, (S = (E = ve.arrow) != null ? E : O.arrow) == null ? void 0 : S.className)
            }), j);
        return Zo(P.Fragment, {
            children: [P.cloneElement(Ne, Gn), gt(te, Y({
                as: fe ? ? eY,
                placement: _e,
                anchorEl: G ? {
                    getBoundingClientRect: () => ({
                        top: Iy.y,
                        left: Iy.x,
                        right: Iy.x,
                        bottom: Iy.y,
                        width: 0,
                        height: 0
                    })
                } : Ke,
                popperRef: tn,
                open: Ke ? we : !1,
                id: lt,
                transition: !0
            }, D, Ze, {
                popperOptions: z,
                children: ({
                    TransitionProps: Qe
                }) => gt(Oe, Y({
                    timeout: De.transitions.duration.shorter
                }, Qe, Tt, {
                    children: Zo($e, Y({}, st, {
                        children: [be, T ? gt(rt, Y({}, St, {
                            ref: Xe
                        })) : null]
                    }))
                }))
            }))]
        })
    }),
    cUe = yPe,
    vPe = /("(?:[^\\"]|\\.)*")|[:,]/g;

function fUe(t, e = {}) {
    const n = JSON.stringify([1], void 0, e.indent === void 0 ? 2 : e.indent).slice(2, -3),
        r = n === "" ? 1 / 0 : e.maxLength === void 0 ? 80 : e.maxLength;
    let {
        replacer: i
    } = e;
    return function s(o, a, l) {
        o && typeof o.toJSON == "function" && (o = o.toJSON());
        const u = JSON.stringify(o, i);
        if (u === void 0) return u;
        const c = r - a.length - l;
        if (u.length <= c) {
            const f = u.replace(vPe, (d, p) => p || `${d} `);
            if (f.length <= c) return f
        }
        if (i != null && (o = JSON.parse(u), i = void 0), typeof o == "object" && o !== null) {
            const f = a + n,
                d = [];
            let p = 0,
                m, y;
            if (Array.isArray(o)) {
                m = "[", y = "]";
                const {
                    length: v
                } = o;
                for (; p < v; p++) d.push(s(o[p], f, p === v - 1 ? 0 : 1) || "null")
            } else {
                m = "{", y = "}";
                const v = Object.keys(o),
                    {
                        length: b
                    } = v;
                for (; p < b; p++) {
                    const _ = v[p],
                        x = `${JSON.stringify(_)}: `,
                        S = s(o[_], f, x.length + (p === b - 1 ? 0 : 1));
                    S !== void 0 && d.push(x + S)
                }
            }
            if (d.length > 0) return [m, n + d.join(`,
${f}`), y].join(`
${a}`)
        }
        return u
    }(t, "", 0)
}
const bPe = tCe({
        createStyledComponent: en("div", {
            name: "MuiStack",
            slot: "Root",
            overridesResolver: (t, e) => e.root
        }),
        useThemeProps: t => Kn({
            props: t,
            name: "MuiStack"
        })
    }),
    dUe = bPe;

function xPe(t) {
    return Jn("MuiSvgIcon", t)
}
tr("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _Pe = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"],
    SPe = t => {
        const {
            color: e,
            fontSize: n,
            classes: r
        } = t, i = {
            root: ["root", e !== "inherit" && `color${Wt(e)}`, `fontSize${Wt(n)}`]
        };
        return Yn(i, xPe, r)
    },
    wPe = en("svg", {
        name: "MuiSvgIcon",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.color !== "inherit" && e[`color${Wt(n.color)}`], e[`fontSize${Wt(n.fontSize)}`]]
        }
    })(({
        theme: t,
        ownerState: e
    }) => {
        var n, r, i, s, o, a, l, u, c, f, d, p, m;
        return {
            userSelect: "none",
            width: "1em",
            height: "1em",
            display: "inline-block",
            fill: e.hasSvgAsChild ? void 0 : "currentColor",
            flexShrink: 0,
            transition: (n = t.transitions) == null || (r = n.create) == null ? void 0 : r.call(n, "fill", {
                duration: (i = t.transitions) == null || (i = i.duration) == null ? void 0 : i.shorter
            }),
            fontSize: {
                inherit: "inherit",
                small: ((s = t.typography) == null || (o = s.pxToRem) == null ? void 0 : o.call(s, 20)) || "1.25rem",
                medium: ((a = t.typography) == null || (l = a.pxToRem) == null ? void 0 : l.call(a, 24)) || "1.5rem",
                large: ((u = t.typography) == null || (c = u.pxToRem) == null ? void 0 : c.call(u, 35)) || "2.1875rem"
            }[e.fontSize],
            color: (f = (d = (t.vars || t).palette) == null || (d = d[e.color]) == null ? void 0 : d.main) != null ? f : {
                action: (p = (t.vars || t).palette) == null || (p = p.action) == null ? void 0 : p.active,
                disabled: (m = (t.vars || t).palette) == null || (m = m.action) == null ? void 0 : m.disabled,
                inherit: void 0
            }[e.color]
        }
    }),
    tY = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiSvgIcon"
            }),
            {
                children: i,
                className: s,
                color: o = "inherit",
                component: a = "svg",
                fontSize: l = "medium",
                htmlColor: u,
                inheritViewBox: c = !1,
                titleAccess: f,
                viewBox: d = "0 0 24 24"
            } = r,
            p = Rt(r, _Pe),
            m = P.isValidElement(i) && i.type === "svg",
            y = Y({}, r, {
                color: o,
                component: a,
                fontSize: l,
                instanceFontSize: e.fontSize,
                inheritViewBox: c,
                viewBox: d,
                hasSvgAsChild: m
            }),
            v = {};
        c || (v.viewBox = d);
        const b = SPe(y);
        return Zo(wPe, Y({
            as: a,
            className: Nt(b.root, s),
            focusable: "false",
            color: u,
            "aria-hidden": f ? void 0 : !0,
            role: f ? "img" : void 0,
            ref: n
        }, v, p, m && i.props, {
            ownerState: y,
            children: [m ? i.props.children : i, f ? gt("title", {
                children: f
            }) : null]
        }))
    });
tY.muiName = "SvgIcon";
const Nz = tY;

function nY(t, e) {
    function n(r, i) {
        return gt(Nz, Y({
            "data-testid": `${e}Icon`,
            ref: i
        }, r, {
            children: t
        }))
    }
    return n.muiName = Nz.muiName, P.memo(P.forwardRef(n))
}
const EPe = {
        configure: t => {
            pk.configure(t)
        }
    },
    APe = Object.freeze(Object.defineProperty({
        __proto__: null,
        capitalize: Wt,
        createChainedFunction: _R,
        createSvgIcon: nY,
        debounce: _J,
        deprecatedPropType: CAe,
        isMuiElement: SJ,
        ownerDocument: Ga,
        ownerWindow: Pg,
        requirePropFactory: MAe,
        setRef: s2,
        unstable_ClassNameGenerator: EPe,
        unstable_useEnhancedEffect: gf,
        unstable_useId: gk,
        unsupportedProp: PAe,
        useControlled: wJ,
        useEventCallback: wu,
        useForkRef: ls,
        useIsFocusVisible: yk
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function CPe(t) {
    return Kn
}

function MPe(t) {
    return Jn("MuiPaper", t)
}
tr("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const TPe = ["className", "component", "elevation", "square", "variant"],
    PPe = t => {
        const {
            square: e,
            elevation: n,
            variant: r,
            classes: i
        } = t, s = {
            root: ["root", r, !e && "rounded", r === "elevation" && `elevation${n}`]
        };
        return Yn(s, MPe, i)
    },
    IPe = en("div", {
        name: "MuiPaper",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, e[n.variant], !n.square && e.rounded, n.variant === "elevation" && e[`elevation${n.elevation}`]]
        }
    })(({
        theme: t,
        ownerState: e
    }) => {
        var n;
        return Y({
            backgroundColor: (t.vars || t).palette.background.paper,
            color: (t.vars || t).palette.text.primary,
            transition: t.transitions.create("box-shadow")
        }, !e.square && {
            borderRadius: t.shape.borderRadius
        }, e.variant === "outlined" && {
            border: `1px solid ${(t.vars||t).palette.divider}`
        }, e.variant === "elevation" && Y({
            boxShadow: (t.vars || t).shadows[e.elevation]
        }, !t.vars && t.palette.mode === "dark" && {
            backgroundImage: `linear-gradient(${gi("#fff",Ez(e.elevation))}, ${gi("#fff",Ez(e.elevation))})`
        }, t.vars && {
            backgroundImage: (n = t.vars.overlays) == null ? void 0 : n[e.elevation]
        }))
    }),
    RPe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiPaper"
            }),
            {
                className: i,
                component: s = "div",
                elevation: o = 1,
                square: a = !1,
                variant: l = "elevation"
            } = r,
            u = Rt(r, TPe),
            c = Y({}, r, {
                component: s,
                elevation: o,
                square: a,
                variant: l
            }),
            f = PPe(c);
        return gt(IPe, Y({
            as: s,
            ownerState: c,
            className: Nt(f.root, i),
            ref: n
        }, u))
    }),
    Lk = RPe,
    OPe = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"],
    DPe = ["component", "slots", "slotProps"],
    LPe = ["component"];

function kPe(t, e) {
    const {
        className: n,
        elementType: r,
        ownerState: i,
        externalForwardedProps: s,
        getSlotOwnerState: o,
        internalForwardedProps: a
    } = e, l = Rt(e, OPe), {
        component: u,
        slots: c = {
            [t]: void 0
        },
        slotProps: f = {
            [t]: void 0
        }
    } = s, d = Rt(s, DPe), p = c[t] || r, m = BJ(f[t], i), y = FJ(Y({
        className: n
    }, l, {
        externalForwardedProps: t === "root" ? d : void 0,
        externalSlotProps: m
    })), {
        props: {
            component: v
        },
        internalRef: b
    } = y, _ = Rt(y.props, LPe), x = ls(b, m == null ? void 0 : m.ref, e.ref), S = o ? o(_) : {}, E = Y({}, i, S), A = t === "root" ? v || u : v, T = Kh(p, Y({}, t === "root" && !u && !c[t] && a, t !== "root" && !c[t] && a, _, A && {
        as: A
    }, {
        ref: x
    }), E);
    return Object.keys(S).forEach(M => {
        delete T[M]
    }), [p, T]
}

function BPe(t) {
    const {
        className: e,
        classes: n,
        pulsate: r = !1,
        rippleX: i,
        rippleY: s,
        rippleSize: o,
        in: a,
        onExited: l,
        timeout: u
    } = t, [c, f] = P.useState(!1), d = Nt(e, n.ripple, n.rippleVisible, r && n.ripplePulsate), p = {
        width: o,
        height: o,
        top: -(o / 2) + s,
        left: -(o / 2) + i
    }, m = Nt(n.child, c && n.childLeaving, r && n.childPulsate);
    return !a && !c && f(!0), P.useEffect(() => {
        if (!a && l != null) {
            const y = setTimeout(l, u);
            return () => {
                clearTimeout(y)
            }
        }
    }, [l, a, u]), gt("span", {
        className: d,
        style: p,
        children: gt("span", {
            className: m
        })
    })
}
const FPe = tr("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]),
    ko = FPe,
    NPe = ["center", "classes", "className"];
let OA = t => t,
    zz, Hz, Uz, $z;
const RR = 550,
    zPe = 80,
    HPe = G1(zz || (zz = OA `
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)),
    UPe = G1(Hz || (Hz = OA `
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)),
    $Pe = G1(Uz || (Uz = OA `
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)),
    GPe = en("span", {
        name: "MuiTouchRipple",
        slot: "Root"
    })({
        overflow: "hidden",
        pointerEvents: "none",
        position: "absolute",
        zIndex: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        borderRadius: "inherit"
    }),
    VPe = en(BPe, {
        name: "MuiTouchRipple",
        slot: "Ripple"
    })($z || ($z = OA `
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), ko.rippleVisible, HPe, RR, ({
        theme: t
    }) => t.transitions.easing.easeInOut, ko.ripplePulsate, ({
        theme: t
    }) => t.transitions.duration.shorter, ko.child, ko.childLeaving, UPe, RR, ({
        theme: t
    }) => t.transitions.easing.easeInOut, ko.childPulsate, $Pe, ({
        theme: t
    }) => t.transitions.easing.easeInOut),
    jPe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiTouchRipple"
            }),
            {
                center: i = !1,
                classes: s = {},
                className: o
            } = r,
            a = Rt(r, NPe),
            [l, u] = P.useState([]),
            c = P.useRef(0),
            f = P.useRef(null);
        P.useEffect(() => {
            f.current && (f.current(), f.current = null)
        }, [l]);
        const d = P.useRef(!1),
            p = Wh(),
            m = P.useRef(null),
            y = P.useRef(null),
            v = P.useCallback(S => {
                const {
                    pulsate: E,
                    rippleX: A,
                    rippleY: T,
                    rippleSize: M,
                    cb: I
                } = S;
                u(O => [...O, gt(VPe, {
                    classes: {
                        ripple: Nt(s.ripple, ko.ripple),
                        rippleVisible: Nt(s.rippleVisible, ko.rippleVisible),
                        ripplePulsate: Nt(s.ripplePulsate, ko.ripplePulsate),
                        child: Nt(s.child, ko.child),
                        childLeaving: Nt(s.childLeaving, ko.childLeaving),
                        childPulsate: Nt(s.childPulsate, ko.childPulsate)
                    },
                    timeout: RR,
                    pulsate: E,
                    rippleX: A,
                    rippleY: T,
                    rippleSize: M
                }, c.current)]), c.current += 1, f.current = I
            }, [s]),
            b = P.useCallback((S = {}, E = {}, A = () => {}) => {
                const {
                    pulsate: T = !1,
                    center: M = i || E.pulsate,
                    fakeElement: I = !1
                } = E;
                if ((S == null ? void 0 : S.type) === "mousedown" && d.current) {
                    d.current = !1;
                    return
                }(S == null ? void 0 : S.type) === "touchstart" && (d.current = !0);
                const O = I ? null : y.current,
                    k = O ? O.getBoundingClientRect() : {
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    };
                let H, N, B;
                if (M || S === void 0 || S.clientX === 0 && S.clientY === 0 || !S.clientX && !S.touches) H = Math.round(k.width / 2), N = Math.round(k.height / 2);
                else {
                    const {
                        clientX: U,
                        clientY: q
                    } = S.touches && S.touches.length > 0 ? S.touches[0] : S;
                    H = Math.round(U - k.left), N = Math.round(q - k.top)
                }
                if (M) B = Math.sqrt((2 * k.width ** 2 + k.height ** 2) / 3), B % 2 === 0 && (B += 1);
                else {
                    const U = Math.max(Math.abs((O ? O.clientWidth : 0) - H), H) * 2 + 2,
                        q = Math.max(Math.abs((O ? O.clientHeight : 0) - N), N) * 2 + 2;
                    B = Math.sqrt(U ** 2 + q ** 2)
                }
                S != null && S.touches ? m.current === null && (m.current = () => {
                    v({
                        pulsate: T,
                        rippleX: H,
                        rippleY: N,
                        rippleSize: B,
                        cb: A
                    })
                }, p.start(zPe, () => {
                    m.current && (m.current(), m.current = null)
                })) : v({
                    pulsate: T,
                    rippleX: H,
                    rippleY: N,
                    rippleSize: B,
                    cb: A
                })
            }, [i, v, p]),
            _ = P.useCallback(() => {
                b({}, {
                    pulsate: !0
                })
            }, [b]),
            x = P.useCallback((S, E) => {
                if (p.clear(), (S == null ? void 0 : S.type) === "touchend" && m.current) {
                    m.current(), m.current = null, p.start(0, () => {
                        x(S, E)
                    });
                    return
                }
                m.current = null, u(A => A.length > 0 ? A.slice(1) : A), f.current = E
            }, [p]);
        return P.useImperativeHandle(n, () => ({
            pulsate: _,
            start: b,
            stop: x
        }), [_, b, x]), gt(GPe, Y({
            className: Nt(ko.root, s.root, o),
            ref: y
        }, a, {
            children: gt(DMe, {
                component: null,
                exit: !0,
                children: l
            })
        }))
    }),
    WPe = jPe;

function KPe(t) {
    return Jn("MuiButtonBase", t)
}
const qPe = tr("MuiButtonBase", ["root", "disabled", "focusVisible"]),
    XPe = qPe,
    JPe = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"],
    YPe = t => {
        const {
            disabled: e,
            focusVisible: n,
            focusVisibleClassName: r,
            classes: i
        } = t, o = Yn({
            root: ["root", e && "disabled", n && "focusVisible"]
        }, KPe, i);
        return n && r && (o.root += ` ${r}`), o
    },
    QPe = en("button", {
        name: "MuiButtonBase",
        slot: "Root",
        overridesResolver: (t, e) => e.root
    })({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative",
        boxSizing: "border-box",
        WebkitTapHighlightColor: "transparent",
        backgroundColor: "transparent",
        outline: 0,
        border: 0,
        margin: 0,
        borderRadius: 0,
        padding: 0,
        cursor: "pointer",
        userSelect: "none",
        verticalAlign: "middle",
        MozAppearance: "none",
        WebkitAppearance: "none",
        textDecoration: "none",
        color: "inherit",
        "&::-moz-focus-inner": {
            borderStyle: "none"
        },
        [`&.${XPe.disabled}`]: {
            pointerEvents: "none",
            cursor: "default"
        },
        "@media print": {
            colorAdjust: "exact"
        }
    }),
    ZPe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiButtonBase"
            }),
            {
                action: i,
                centerRipple: s = !1,
                children: o,
                className: a,
                component: l = "button",
                disabled: u = !1,
                disableRipple: c = !1,
                disableTouchRipple: f = !1,
                focusRipple: d = !1,
                LinkComponent: p = "a",
                onBlur: m,
                onClick: y,
                onContextMenu: v,
                onDragLeave: b,
                onFocus: _,
                onFocusVisible: x,
                onKeyDown: S,
                onKeyUp: E,
                onMouseDown: A,
                onMouseLeave: T,
                onMouseUp: M,
                onTouchEnd: I,
                onTouchMove: O,
                onTouchStart: k,
                tabIndex: H = 0,
                TouchRippleProps: N,
                touchRippleRef: B,
                type: U
            } = r,
            q = Rt(r, JPe),
            Q = P.useRef(null),
            F = P.useRef(null),
            G = ls(F, B),
            {
                isFocusVisibleRef: W,
                onFocus: se,
                onBlur: ee,
                ref: ae
            } = yk(),
            [de, re] = P.useState(!1);
        u && de && re(!1), P.useImperativeHandle(i, () => ({
            focusVisible: () => {
                re(!0), Q.current.focus()
            }
        }), []);
        const [_e, fe] = P.useState(!1);
        P.useEffect(() => {
            fe(!0)
        }, []);
        const ue = _e && !c && !u;
        P.useEffect(() => {
            de && d && !c && _e && F.current.pulsate()
        }, [c, d, de, _e]);

        function ve(Te, we, lt = f) {
            return wu(nt => (we && we(nt), !lt && F.current && F.current[Te](nt), !0))
        }
        const xe = ve("start", A),
            be = ve("stop", v),
            he = ve("stop", b),
            me = ve("stop", M),
            Ce = ve("stop", Te => {
                de && Te.preventDefault(), T && T(Te)
            }),
            Ne = ve("start", k),
            De = ve("stop", I),
            je = ve("stop", O),
            Ke = ve("stop", Te => {
                ee(Te), W.current === !1 && re(!1), m && m(Te)
            }, !1),
            He = wu(Te => {
                Q.current || (Q.current = Te.currentTarget), se(Te), W.current === !0 && (re(!0), x && x(Te)), _ && _(Te)
            }),
            qe = () => {
                const Te = Q.current;
                return l && l !== "button" && !(Te.tagName === "A" && Te.href)
            },
            Xe = P.useRef(!1),
            K = wu(Te => {
                d && !Xe.current && de && F.current && Te.key === " " && (Xe.current = !0, F.current.stop(Te, () => {
                    F.current.start(Te)
                })), Te.target === Te.currentTarget && qe() && Te.key === " " && Te.preventDefault(), S && S(Te), Te.target === Te.currentTarget && qe() && Te.key === "Enter" && !u && (Te.preventDefault(), y && y(Te))
            }),
            V = wu(Te => {
                d && Te.key === " " && F.current && de && !Te.defaultPrevented && (Xe.current = !1, F.current.stop(Te, () => {
                    F.current.pulsate(Te)
                })), E && E(Te), y && Te.target === Te.currentTarget && qe() && Te.key === " " && !Te.defaultPrevented && y(Te)
            });
        let ge = l;
        ge === "button" && (q.href || q.to) && (ge = p);
        const Be = {};
        ge === "button" ? (Be.type = U === void 0 ? "button" : U, Be.disabled = u) : (!q.href && !q.to && (Be.role = "button"), u && (Be["aria-disabled"] = u));
        const ze = ls(n, ae, Q),
            Ue = Y({}, r, {
                centerRipple: s,
                component: l,
                disabled: u,
                disableRipple: c,
                disableTouchRipple: f,
                focusRipple: d,
                tabIndex: H,
                focusVisible: de
            }),
            Ye = YPe(Ue);
        return Zo(QPe, Y({
            as: ge,
            className: Nt(Ye.root, a),
            ownerState: Ue,
            onBlur: Ke,
            onClick: y,
            onContextMenu: be,
            onFocus: He,
            onKeyDown: K,
            onKeyUp: V,
            onMouseDown: xe,
            onMouseLeave: Ce,
            onMouseUp: me,
            onDragLeave: he,
            onTouchEnd: De,
            onTouchMove: je,
            onTouchStart: Ne,
            ref: ze,
            tabIndex: u ? -1 : H,
            type: U
        }, Be, q, {
            children: [o, ue ? gt(WPe, Y({
                ref: G,
                center: s
            }, N)) : null]
        }))
    }),
    DA = ZPe;

function eIe(t) {
    return Jn("MuiIconButton", t)
}
const tIe = tr("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]),
    nIe = tIe,
    rIe = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"],
    iIe = t => {
        const {
            classes: e,
            disabled: n,
            color: r,
            edge: i,
            size: s
        } = t, o = {
            root: ["root", n && "disabled", r !== "default" && `color${Wt(r)}`, i && `edge${Wt(i)}`, `size${Wt(s)}`]
        };
        return Yn(o, eIe, e)
    },
    sIe = en(DA, {
        name: "MuiIconButton",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.color !== "default" && e[`color${Wt(n.color)}`], n.edge && e[`edge${Wt(n.edge)}`], e[`size${Wt(n.size)}`]]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        textAlign: "center",
        flex: "0 0 auto",
        fontSize: t.typography.pxToRem(24),
        padding: 8,
        borderRadius: "50%",
        overflow: "visible",
        color: (t.vars || t).palette.action.active,
        transition: t.transitions.create("background-color", {
            duration: t.transitions.duration.shortest
        })
    }, !e.disableRipple && {
        "&:hover": {
            backgroundColor: t.vars ? `rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})` : gi(t.palette.action.active, t.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        }
    }, e.edge === "start" && {
        marginLeft: e.size === "small" ? -3 : -12
    }, e.edge === "end" && {
        marginRight: e.size === "small" ? -3 : -12
    }), ({
        theme: t,
        ownerState: e
    }) => {
        var n;
        const r = (n = (t.vars || t).palette) == null ? void 0 : n[e.color];
        return Y({}, e.color === "inherit" && {
            color: "inherit"
        }, e.color !== "inherit" && e.color !== "default" && Y({
            color: r == null ? void 0 : r.main
        }, !e.disableRipple && {
            "&:hover": Y({}, r && {
                backgroundColor: t.vars ? `rgba(${r.mainChannel} / ${t.vars.palette.action.hoverOpacity})` : gi(r.main, t.palette.action.hoverOpacity)
            }, {
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            })
        }), e.size === "small" && {
            padding: 5,
            fontSize: t.typography.pxToRem(18)
        }, e.size === "large" && {
            padding: 12,
            fontSize: t.typography.pxToRem(28)
        }, {
            [`&.${nIe.disabled}`]: {
                backgroundColor: "transparent",
                color: (t.vars || t).palette.action.disabled
            }
        })
    }),
    oIe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiIconButton"
            }),
            {
                edge: i = !1,
                children: s,
                className: o,
                color: a = "default",
                disabled: l = !1,
                disableFocusRipple: u = !1,
                size: c = "medium"
            } = r,
            f = Rt(r, rIe),
            d = Y({}, r, {
                edge: i,
                color: a,
                disabled: l,
                disableFocusRipple: u,
                size: c
            }),
            p = iIe(d);
        return gt(sIe, Y({
            className: Nt(p.root, o),
            centerRipple: !0,
            focusRipple: !u,
            disabled: l,
            ref: n
        }, f, {
            ownerState: d,
            children: s
        }))
    }),
    pUe = oIe;

function aIe(t) {
    return Jn("MuiTypography", t)
}
tr("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const lIe = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"],
    uIe = t => {
        const {
            align: e,
            gutterBottom: n,
            noWrap: r,
            paragraph: i,
            variant: s,
            classes: o
        } = t, a = {
            root: ["root", s, t.align !== "inherit" && `align${Wt(e)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
        };
        return Yn(a, aIe, o)
    },
    cIe = en("span", {
        name: "MuiTypography",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.variant && e[n.variant], n.align !== "inherit" && e[`align${Wt(n.align)}`], n.noWrap && e.noWrap, n.gutterBottom && e.gutterBottom, n.paragraph && e.paragraph]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        margin: 0
    }, e.variant === "inherit" && {
        font: "inherit"
    }, e.variant !== "inherit" && t.typography[e.variant], e.align !== "inherit" && {
        textAlign: e.align
    }, e.noWrap && {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
    }, e.gutterBottom && {
        marginBottom: "0.35em"
    }, e.paragraph && {
        marginBottom: 16
    })),
    Gz = {
        h1: "h1",
        h2: "h2",
        h3: "h3",
        h4: "h4",
        h5: "h5",
        h6: "h6",
        subtitle1: "h6",
        subtitle2: "h6",
        body1: "p",
        body2: "p",
        inherit: "p"
    },
    fIe = {
        primary: "primary.main",
        textPrimary: "text.primary",
        secondary: "secondary.main",
        textSecondary: "text.secondary",
        error: "error.main"
    },
    dIe = t => fIe[t] || t,
    pIe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiTypography"
            }),
            i = dIe(r.color),
            s = PA(Y({}, r, {
                color: i
            })),
            {
                align: o = "inherit",
                className: a,
                component: l,
                gutterBottom: u = !1,
                noWrap: c = !1,
                paragraph: f = !1,
                variant: d = "body1",
                variantMapping: p = Gz
            } = s,
            m = Rt(s, lIe),
            y = Y({}, s, {
                align: o,
                color: i,
                className: a,
                component: l,
                gutterBottom: u,
                noWrap: c,
                paragraph: f,
                variant: d,
                variantMapping: p
            }),
            v = l || (f ? "p" : p[d] || Gz[d]) || "span",
            b = uIe(y);
        return gt(cIe, Y({
            as: v,
            ref: n,
            ownerState: y,
            className: Nt(b.root, a)
        }, m))
    }),
    qh = pIe,
    hIe = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");

function mIe(t) {
    const e = parseInt(t.getAttribute("tabindex") || "", 10);
    return Number.isNaN(e) ? t.contentEditable === "true" || (t.nodeName === "AUDIO" || t.nodeName === "VIDEO" || t.nodeName === "DETAILS") && t.getAttribute("tabindex") === null ? 0 : t.tabIndex : e
}

function gIe(t) {
    if (t.tagName !== "INPUT" || t.type !== "radio" || !t.name) return !1;
    const e = r => t.ownerDocument.querySelector(`input[type="radio"]${r}`);
    let n = e(`[name="${t.name}"]:checked`);
    return n || (n = e(`[name="${t.name}"]`)), n !== t
}

function yIe(t) {
    return !(t.disabled || t.tagName === "INPUT" && t.type === "hidden" || gIe(t))
}

function vIe(t) {
    const e = [],
        n = [];
    return Array.from(t.querySelectorAll(hIe)).forEach((r, i) => {
        const s = mIe(r);
        s === -1 || !yIe(r) || (s === 0 ? e.push(r) : n.push({
            documentOrder: i,
            tabIndex: s,
            node: r
        }))
    }), n.sort((r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map(r => r.node).concat(e)
}

function bIe() {
    return !0
}

function xIe(t) {
    const {
        children: e,
        disableAutoFocus: n = !1,
        disableEnforceFocus: r = !1,
        disableRestoreFocus: i = !1,
        getTabbable: s = vIe,
        isEnabled: o = bIe,
        open: a
    } = t, l = P.useRef(!1), u = P.useRef(null), c = P.useRef(null), f = P.useRef(null), d = P.useRef(null), p = P.useRef(!1), m = P.useRef(null), y = ls(e.ref, m), v = P.useRef(null);
    P.useEffect(() => {
        !a || !m.current || (p.current = !n)
    }, [n, a]), P.useEffect(() => {
        if (!a || !m.current) return;
        const x = Ga(m.current);
        return m.current.contains(x.activeElement) || (m.current.hasAttribute("tabIndex") || m.current.setAttribute("tabIndex", "-1"), p.current && m.current.focus()), () => {
            i || (f.current && f.current.focus && (l.current = !0, f.current.focus()), f.current = null)
        }
    }, [a]), P.useEffect(() => {
        if (!a || !m.current) return;
        const x = Ga(m.current),
            S = T => {
                v.current = T, !(r || !o() || T.key !== "Tab") && x.activeElement === m.current && T.shiftKey && (l.current = !0, c.current && c.current.focus())
            },
            E = () => {
                const T = m.current;
                if (T === null) return;
                if (!x.hasFocus() || !o() || l.current) {
                    l.current = !1;
                    return
                }
                if (T.contains(x.activeElement) || r && x.activeElement !== u.current && x.activeElement !== c.current) return;
                if (x.activeElement !== d.current) d.current = null;
                else if (d.current !== null) return;
                if (!p.current) return;
                let M = [];
                if ((x.activeElement === u.current || x.activeElement === c.current) && (M = s(m.current)), M.length > 0) {
                    var I, O;
                    const k = !!((I = v.current) != null && I.shiftKey && ((O = v.current) == null ? void 0 : O.key) === "Tab"),
                        H = M[0],
                        N = M[M.length - 1];
                    typeof H != "string" && typeof N != "string" && (k ? N.focus() : H.focus())
                } else T.focus()
            };
        x.addEventListener("focusin", E), x.addEventListener("keydown", S, !0);
        const A = setInterval(() => {
            x.activeElement && x.activeElement.tagName === "BODY" && E()
        }, 50);
        return () => {
            clearInterval(A), x.removeEventListener("focusin", E), x.removeEventListener("keydown", S, !0)
        }
    }, [n, r, i, o, a, s]);
    const b = x => {
            f.current === null && (f.current = x.relatedTarget), p.current = !0, d.current = x.target;
            const S = e.props.onFocus;
            S && S(x)
        },
        _ = x => {
            f.current === null && (f.current = x.relatedTarget), p.current = !0
        };
    return Zo(P.Fragment, {
        children: [gt("div", {
            tabIndex: a ? 0 : -1,
            onFocus: _,
            ref: u,
            "data-testid": "sentinelStart"
        }), P.cloneElement(e, {
            ref: y,
            onFocus: b
        }), gt("div", {
            tabIndex: a ? 0 : -1,
            onFocus: _,
            ref: c,
            "data-testid": "sentinelEnd"
        })]
    })
}

function _Ie(t) {
    const e = Ga(t);
    return e.body === t ? Pg(t).innerWidth > e.documentElement.clientWidth : t.scrollHeight > t.clientHeight
}

function Mv(t, e) {
    e ? t.setAttribute("aria-hidden", "true") : t.removeAttribute("aria-hidden")
}

function Vz(t) {
    return parseInt(Pg(t).getComputedStyle(t).paddingRight, 10) || 0
}

function SIe(t) {
    const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(t.tagName) !== -1,
        r = t.tagName === "INPUT" && t.getAttribute("type") === "hidden";
    return n || r
}

function jz(t, e, n, r, i) {
    const s = [e, n, ...r];
    [].forEach.call(t.children, o => {
        const a = s.indexOf(o) === -1,
            l = !SIe(o);
        a && l && Mv(o, i)
    })
}

function GT(t, e) {
    let n = -1;
    return t.some((r, i) => e(r) ? (n = i, !0) : !1), n
}

function wIe(t, e) {
    const n = [],
        r = t.container;
    if (!e.disableScrollLock) {
        if (_Ie(r)) {
            const o = HAe(Ga(r));
            n.push({
                value: r.style.paddingRight,
                property: "padding-right",
                el: r
            }), r.style.paddingRight = `${Vz(r)+o}px`;
            const a = Ga(r).querySelectorAll(".mui-fixed");
            [].forEach.call(a, l => {
                n.push({
                    value: l.style.paddingRight,
                    property: "padding-right",
                    el: l
                }), l.style.paddingRight = `${Vz(l)+o}px`
            })
        }
        let s;
        if (r.parentNode instanceof DocumentFragment) s = Ga(r).body;
        else {
            const o = r.parentElement,
                a = Pg(r);
            s = (o == null ? void 0 : o.nodeName) === "HTML" && a.getComputedStyle(o).overflowY === "scroll" ? o : r
        }
        n.push({
            value: s.style.overflow,
            property: "overflow",
            el: s
        }, {
            value: s.style.overflowX,
            property: "overflow-x",
            el: s
        }, {
            value: s.style.overflowY,
            property: "overflow-y",
            el: s
        }), s.style.overflow = "hidden"
    }
    return () => {
        n.forEach(({
            value: s,
            el: o,
            property: a
        }) => {
            s ? o.style.setProperty(a, s) : o.style.removeProperty(a)
        })
    }
}

function EIe(t) {
    const e = [];
    return [].forEach.call(t.children, n => {
        n.getAttribute("aria-hidden") === "true" && e.push(n)
    }), e
}
class AIe {
    constructor() {
        this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = []
    }
    add(e, n) {
        let r = this.modals.indexOf(e);
        if (r !== -1) return r;
        r = this.modals.length, this.modals.push(e), e.modalRef && Mv(e.modalRef, !1);
        const i = EIe(n);
        jz(n, e.mount, e.modalRef, i, !0);
        const s = GT(this.containers, o => o.container === n);
        return s !== -1 ? (this.containers[s].modals.push(e), r) : (this.containers.push({
            modals: [e],
            container: n,
            restore: null,
            hiddenSiblings: i
        }), r)
    }
    mount(e, n) {
        const r = GT(this.containers, s => s.modals.indexOf(e) !== -1),
            i = this.containers[r];
        i.restore || (i.restore = wIe(i, n))
    }
    remove(e, n = !0) {
        const r = this.modals.indexOf(e);
        if (r === -1) return r;
        const i = GT(this.containers, o => o.modals.indexOf(e) !== -1),
            s = this.containers[i];
        if (s.modals.splice(s.modals.indexOf(e), 1), this.modals.splice(r, 1), s.modals.length === 0) s.restore && s.restore(), e.modalRef && Mv(e.modalRef, n), jz(s.container, e.mount, e.modalRef, s.hiddenSiblings, !1), this.containers.splice(i, 1);
        else {
            const o = s.modals[s.modals.length - 1];
            o.modalRef && Mv(o.modalRef, !1)
        }
        return r
    }
    isTopModal(e) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === e
    }
}

function CIe(t) {
    return typeof t == "function" ? t() : t
}

function MIe(t) {
    return t ? t.props.hasOwnProperty("in") : !1
}
const TIe = new AIe;

function PIe(t) {
    const {
        container: e,
        disableEscapeKeyDown: n = !1,
        disableScrollLock: r = !1,
        manager: i = TIe,
        closeAfterTransition: s = !1,
        onTransitionEnter: o,
        onTransitionExited: a,
        children: l,
        onClose: u,
        open: c,
        rootRef: f
    } = t, d = P.useRef({}), p = P.useRef(null), m = P.useRef(null), y = ls(m, f), [v, b] = P.useState(!c), _ = MIe(l);
    let x = !0;
    (t["aria-hidden"] === "false" || t["aria-hidden"] === !1) && (x = !1);
    const S = () => Ga(p.current),
        E = () => (d.current.modalRef = m.current, d.current.mount = p.current, d.current),
        A = () => {
            i.mount(E(), {
                disableScrollLock: r
            }), m.current && (m.current.scrollTop = 0)
        },
        T = wu(() => {
            const q = CIe(e) || S().body;
            i.add(E(), q), m.current && A()
        }),
        M = P.useCallback(() => i.isTopModal(E()), [i]),
        I = wu(q => {
            p.current = q, q && (c && M() ? A() : m.current && Mv(m.current, x))
        }),
        O = P.useCallback(() => {
            i.remove(E(), x)
        }, [x, i]);
    P.useEffect(() => () => {
        O()
    }, [O]), P.useEffect(() => {
        c ? T() : (!_ || !s) && O()
    }, [c, O, _, s, T]);
    const k = q => Q => {
            var F;
            (F = q.onKeyDown) == null || F.call(q, Q), !(Q.key !== "Escape" || Q.which === 229 || !M()) && (n || (Q.stopPropagation(), u && u(Q, "escapeKeyDown")))
        },
        H = q => Q => {
            var F;
            (F = q.onClick) == null || F.call(q, Q), Q.target === Q.currentTarget && u && u(Q, "backdropClick")
        };
    return {
        getRootProps: (q = {}) => {
            const Q = kJ(t);
            delete Q.onTransitionEnter, delete Q.onTransitionExited;
            const F = Y({}, Q, q);
            return Y({
                role: "presentation"
            }, F, {
                onKeyDown: k(F),
                ref: y
            })
        },
        getBackdropProps: (q = {}) => {
            const Q = q;
            return Y({
                "aria-hidden": !0
            }, Q, {
                onClick: H(Q),
                open: c
            })
        },
        getTransitionProps: () => {
            const q = () => {
                    b(!1), o && o()
                },
                Q = () => {
                    b(!0), a && a(), s && O()
                };
            return {
                onEnter: _R(q, l == null ? void 0 : l.props.onEnter),
                onExited: _R(Q, l == null ? void 0 : l.props.onExited)
            }
        },
        rootRef: y,
        portalRef: I,
        isTopModal: M,
        exited: v,
        hasTransition: _
    }
}
const IIe = nY(gt("path", {
    d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");

function RIe(t) {
    return Jn("MuiAvatar", t)
}
tr("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const OIe = ["alt", "children", "className", "component", "slots", "slotProps", "imgProps", "sizes", "src", "srcSet", "variant"],
    DIe = CPe(),
    LIe = t => {
        const {
            classes: e,
            variant: n,
            colorDefault: r
        } = t;
        return Yn({
            root: ["root", n, r && "colorDefault"],
            img: ["img"],
            fallback: ["fallback"]
        }, RIe, e)
    },
    kIe = en("div", {
        name: "MuiAvatar",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, e[n.variant], n.colorDefault && e.colorDefault]
        }
    })(({
        theme: t
    }) => ({
        position: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0,
        width: 40,
        height: 40,
        fontFamily: t.typography.fontFamily,
        fontSize: t.typography.pxToRem(20),
        lineHeight: 1,
        borderRadius: "50%",
        overflow: "hidden",
        userSelect: "none",
        variants: [{
            props: {
                variant: "rounded"
            },
            style: {
                borderRadius: (t.vars || t).shape.borderRadius
            }
        }, {
            props: {
                variant: "square"
            },
            style: {
                borderRadius: 0
            }
        }, {
            props: {
                colorDefault: !0
            },
            style: Y({
                color: (t.vars || t).palette.background.default
            }, t.vars ? {
                backgroundColor: t.vars.palette.Avatar.defaultBg
            } : Y({
                backgroundColor: t.palette.grey[400]
            }, t.applyStyles("dark", {
                backgroundColor: t.palette.grey[600]
            })))
        }]
    })),
    BIe = en("img", {
        name: "MuiAvatar",
        slot: "Img",
        overridesResolver: (t, e) => e.img
    })({
        width: "100%",
        height: "100%",
        textAlign: "center",
        objectFit: "cover",
        color: "transparent",
        textIndent: 1e4
    }),
    FIe = en(IIe, {
        name: "MuiAvatar",
        slot: "Fallback",
        overridesResolver: (t, e) => e.fallback
    })({
        width: "75%",
        height: "75%"
    });

function NIe({
    crossOrigin: t,
    referrerPolicy: e,
    src: n,
    srcSet: r
}) {
    const [i, s] = P.useState(!1);
    return P.useEffect(() => {
        if (!n && !r) return;
        s(!1);
        let o = !0;
        const a = new Image;
        return a.onload = () => {
            o && s("loaded")
        }, a.onerror = () => {
            o && s("error")
        }, a.crossOrigin = t, a.referrerPolicy = e, a.src = n, r && (a.srcset = r), () => {
            o = !1
        }
    }, [t, e, n, r]), i
}
const zIe = P.forwardRef(function(e, n) {
        const r = DIe({
                props: e,
                name: "MuiAvatar"
            }),
            {
                alt: i,
                children: s,
                className: o,
                component: a = "div",
                slots: l = {},
                slotProps: u = {},
                imgProps: c,
                sizes: f,
                src: d,
                srcSet: p,
                variant: m = "circular"
            } = r,
            y = Rt(r, OIe);
        let v = null;
        const b = NIe(Y({}, c, {
                src: d,
                srcSet: p
            })),
            _ = d || p,
            x = _ && b !== "error",
            S = Y({}, r, {
                colorDefault: !x,
                component: a,
                variant: m
            }),
            E = LIe(S),
            [A, T] = kPe("img", {
                className: E.img,
                elementType: BIe,
                externalForwardedProps: {
                    slots: l,
                    slotProps: {
                        img: Y({}, c, u.img)
                    }
                },
                additionalProps: {
                    alt: i,
                    src: d,
                    srcSet: p,
                    sizes: f
                },
                ownerState: S
            });
        return x ? v = gt(A, Y({}, T)) : s || s === 0 ? v = s : _ && i ? v = i[0] : v = gt(FIe, {
            ownerState: S,
            className: E.fallback
        }), gt(kIe, Y({
            as: a,
            ownerState: S,
            className: Nt(E.root, o),
            ref: n
        }, y, {
            children: v
        }))
    }),
    hUe = zIe,
    HIe = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"],
    UIe = {
        entering: {
            opacity: 1
        },
        entered: {
            opacity: 1
        }
    },
    $Ie = P.forwardRef(function(e, n) {
        const r = Rg(),
            i = {
                enter: r.transitions.duration.enteringScreen,
                exit: r.transitions.duration.leavingScreen
            },
            {
                addEndListener: s,
                appear: o = !0,
                children: a,
                easing: l,
                in: u,
                onEnter: c,
                onEntered: f,
                onEntering: d,
                onExit: p,
                onExited: m,
                onExiting: y,
                style: v,
                timeout: b = i,
                TransitionComponent: _ = Sk
            } = e,
            x = Rt(e, HIe),
            S = P.useRef(null),
            E = ls(S, a.ref, n),
            A = B => U => {
                if (B) {
                    const q = S.current;
                    U === void 0 ? B(q) : B(q, U)
                }
            },
            T = A(d),
            M = A((B, U) => {
                Ak(B);
                const q = Ym({
                    style: v,
                    timeout: b,
                    easing: l
                }, {
                    mode: "enter"
                });
                B.style.webkitTransition = r.transitions.create("opacity", q), B.style.transition = r.transitions.create("opacity", q), c && c(B, U)
            }),
            I = A(f),
            O = A(y),
            k = A(B => {
                const U = Ym({
                    style: v,
                    timeout: b,
                    easing: l
                }, {
                    mode: "exit"
                });
                B.style.webkitTransition = r.transitions.create("opacity", U), B.style.transition = r.transitions.create("opacity", U), p && p(B)
            }),
            H = A(m);
        return gt(_, Y({
            appear: o,
            in: u,
            nodeRef: S,
            onEnter: M,
            onEntered: I,
            onEntering: T,
            onExit: k,
            onExited: H,
            onExiting: O,
            addEndListener: B => {
                s && s(S.current, B)
            },
            timeout: b
        }, x, {
            children: (B, U) => P.cloneElement(a, Y({
                style: Y({
                    opacity: 0,
                    visibility: B === "exited" && !u ? "hidden" : void 0
                }, UIe[B], v, a.props.style),
                ref: E
            }, U))
        }))
    }),
    rY = $Ie;

function GIe(t) {
    return Jn("MuiBackdrop", t)
}
tr("MuiBackdrop", ["root", "invisible"]);
const VIe = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"],
    jIe = t => {
        const {
            classes: e,
            invisible: n
        } = t;
        return Yn({
            root: ["root", n && "invisible"]
        }, GIe, e)
    },
    WIe = en("div", {
        name: "MuiBackdrop",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.invisible && e.invisible]
        }
    })(({
        ownerState: t
    }) => Y({
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent"
    }, t.invisible && {
        backgroundColor: "transparent"
    })),
    KIe = P.forwardRef(function(e, n) {
        var r, i, s;
        const o = Kn({
                props: e,
                name: "MuiBackdrop"
            }),
            {
                children: a,
                className: l,
                component: u = "div",
                components: c = {},
                componentsProps: f = {},
                invisible: d = !1,
                open: p,
                slotProps: m = {},
                slots: y = {},
                TransitionComponent: v = rY,
                transitionDuration: b
            } = o,
            _ = Rt(o, VIe),
            x = Y({}, o, {
                component: u,
                invisible: d
            }),
            S = jIe(x),
            E = (r = m.root) != null ? r : f.root;
        return gt(v, Y({ in: p,
            timeout: b
        }, _, {
            children: gt(WIe, Y({
                "aria-hidden": !0
            }, E, {
                as: (i = (s = y.root) != null ? s : c.Root) != null ? i : u,
                className: Nt(S.root, l, E == null ? void 0 : E.className),
                ownerState: Y({}, x, E == null ? void 0 : E.ownerState),
                classes: S,
                ref: n,
                children: a
            }))
        }))
    }),
    iY = KIe,
    qIe = tr("MuiBox", ["root"]),
    XIe = qIe,
    JIe = OJ(),
    YIe = lAe({
        themeId: SA,
        defaultTheme: JIe,
        defaultClassName: XIe.root,
        generateClassName: pk.generate
    }),
    mUe = YIe;

function QIe(t) {
    return Jn("MuiButton", t)
}
const ZIe = tr("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]),
    P_ = ZIe,
    e3e = P.createContext({}),
    t3e = e3e,
    n3e = P.createContext(void 0),
    r3e = n3e,
    i3e = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"],
    s3e = t => {
        const {
            color: e,
            disableElevation: n,
            fullWidth: r,
            size: i,
            variant: s,
            classes: o
        } = t, a = {
            root: ["root", s, `${s}${Wt(e)}`, `size${Wt(i)}`, `${s}Size${Wt(i)}`, `color${Wt(e)}`, n && "disableElevation", r && "fullWidth"],
            label: ["label"],
            startIcon: ["icon", "startIcon", `iconSize${Wt(i)}`],
            endIcon: ["icon", "endIcon", `iconSize${Wt(i)}`]
        }, l = Yn(a, QIe, o);
        return Y({}, o, l)
    },
    sY = t => Y({}, t.size === "small" && {
        "& > *:nth-of-type(1)": {
            fontSize: 18
        }
    }, t.size === "medium" && {
        "& > *:nth-of-type(1)": {
            fontSize: 20
        }
    }, t.size === "large" && {
        "& > *:nth-of-type(1)": {
            fontSize: 22
        }
    }),
    o3e = en(DA, {
        shouldForwardProp: t => Y1(t) || t === "classes",
        name: "MuiButton",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, e[n.variant], e[`${n.variant}${Wt(n.color)}`], e[`size${Wt(n.size)}`], e[`${n.variant}Size${Wt(n.size)}`], n.color === "inherit" && e.colorInherit, n.disableElevation && e.disableElevation, n.fullWidth && e.fullWidth]
        }
    })(({
        theme: t,
        ownerState: e
    }) => {
        var n, r;
        const i = t.palette.mode === "light" ? t.palette.grey[300] : t.palette.grey[800],
            s = t.palette.mode === "light" ? t.palette.grey.A100 : t.palette.grey[700];
        return Y({}, t.typography.button, {
            minWidth: 64,
            padding: "6px 16px",
            borderRadius: (t.vars || t).shape.borderRadius,
            transition: t.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
                duration: t.transitions.duration.short
            }),
            "&:hover": Y({
                textDecoration: "none",
                backgroundColor: t.vars ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})` : gi(t.palette.text.primary, t.palette.action.hoverOpacity),
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }, e.variant === "text" && e.color !== "inherit" && {
                backgroundColor: t.vars ? `rgba(${t.vars.palette[e.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})` : gi(t.palette[e.color].main, t.palette.action.hoverOpacity),
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }, e.variant === "outlined" && e.color !== "inherit" && {
                border: `1px solid ${(t.vars||t).palette[e.color].main}`,
                backgroundColor: t.vars ? `rgba(${t.vars.palette[e.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})` : gi(t.palette[e.color].main, t.palette.action.hoverOpacity),
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }, e.variant === "contained" && {
                backgroundColor: t.vars ? t.vars.palette.Button.inheritContainedHoverBg : s,
                boxShadow: (t.vars || t).shadows[4],
                "@media (hover: none)": {
                    boxShadow: (t.vars || t).shadows[2],
                    backgroundColor: (t.vars || t).palette.grey[300]
                }
            }, e.variant === "contained" && e.color !== "inherit" && {
                backgroundColor: (t.vars || t).palette[e.color].dark,
                "@media (hover: none)": {
                    backgroundColor: (t.vars || t).palette[e.color].main
                }
            }),
            "&:active": Y({}, e.variant === "contained" && {
                boxShadow: (t.vars || t).shadows[8]
            }),
            [`&.${P_.focusVisible}`]: Y({}, e.variant === "contained" && {
                boxShadow: (t.vars || t).shadows[6]
            }),
            [`&.${P_.disabled}`]: Y({
                color: (t.vars || t).palette.action.disabled
            }, e.variant === "outlined" && {
                border: `1px solid ${(t.vars||t).palette.action.disabledBackground}`
            }, e.variant === "contained" && {
                color: (t.vars || t).palette.action.disabled,
                boxShadow: (t.vars || t).shadows[0],
                backgroundColor: (t.vars || t).palette.action.disabledBackground
            })
        }, e.variant === "text" && {
            padding: "6px 8px"
        }, e.variant === "text" && e.color !== "inherit" && {
            color: (t.vars || t).palette[e.color].main
        }, e.variant === "outlined" && {
            padding: "5px 15px",
            border: "1px solid currentColor"
        }, e.variant === "outlined" && e.color !== "inherit" && {
            color: (t.vars || t).palette[e.color].main,
            border: t.vars ? `1px solid rgba(${t.vars.palette[e.color].mainChannel} / 0.5)` : `1px solid ${gi(t.palette[e.color].main,.5)}`
        }, e.variant === "contained" && {
            color: t.vars ? t.vars.palette.text.primary : (n = (r = t.palette).getContrastText) == null ? void 0 : n.call(r, t.palette.grey[300]),
            backgroundColor: t.vars ? t.vars.palette.Button.inheritContainedBg : i,
            boxShadow: (t.vars || t).shadows[2]
        }, e.variant === "contained" && e.color !== "inherit" && {
            color: (t.vars || t).palette[e.color].contrastText,
            backgroundColor: (t.vars || t).palette[e.color].main
        }, e.color === "inherit" && {
            color: "inherit",
            borderColor: "currentColor"
        }, e.size === "small" && e.variant === "text" && {
            padding: "4px 5px",
            fontSize: t.typography.pxToRem(13)
        }, e.size === "large" && e.variant === "text" && {
            padding: "8px 11px",
            fontSize: t.typography.pxToRem(15)
        }, e.size === "small" && e.variant === "outlined" && {
            padding: "3px 9px",
            fontSize: t.typography.pxToRem(13)
        }, e.size === "large" && e.variant === "outlined" && {
            padding: "7px 21px",
            fontSize: t.typography.pxToRem(15)
        }, e.size === "small" && e.variant === "contained" && {
            padding: "4px 10px",
            fontSize: t.typography.pxToRem(13)
        }, e.size === "large" && e.variant === "contained" && {
            padding: "8px 22px",
            fontSize: t.typography.pxToRem(15)
        }, e.fullWidth && {
            width: "100%"
        })
    }, ({
        ownerState: t
    }) => t.disableElevation && {
        boxShadow: "none",
        "&:hover": {
            boxShadow: "none"
        },
        [`&.${P_.focusVisible}`]: {
            boxShadow: "none"
        },
        "&:active": {
            boxShadow: "none"
        },
        [`&.${P_.disabled}`]: {
            boxShadow: "none"
        }
    }),
    a3e = en("span", {
        name: "MuiButton",
        slot: "StartIcon",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.startIcon, e[`iconSize${Wt(n.size)}`]]
        }
    })(({
        ownerState: t
    }) => Y({
        display: "inherit",
        marginRight: 8,
        marginLeft: -4
    }, t.size === "small" && {
        marginLeft: -2
    }, sY(t))),
    l3e = en("span", {
        name: "MuiButton",
        slot: "EndIcon",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.endIcon, e[`iconSize${Wt(n.size)}`]]
        }
    })(({
        ownerState: t
    }) => Y({
        display: "inherit",
        marginRight: -4,
        marginLeft: 8
    }, t.size === "small" && {
        marginRight: -2
    }, sY(t))),
    u3e = P.forwardRef(function(e, n) {
        const r = P.useContext(t3e),
            i = P.useContext(r3e),
            s = hk(r, e),
            o = Kn({
                props: s,
                name: "MuiButton"
            }),
            {
                children: a,
                color: l = "primary",
                component: u = "button",
                className: c,
                disabled: f = !1,
                disableElevation: d = !1,
                disableFocusRipple: p = !1,
                endIcon: m,
                focusVisibleClassName: y,
                fullWidth: v = !1,
                size: b = "medium",
                startIcon: _,
                type: x,
                variant: S = "text"
            } = o,
            E = Rt(o, i3e),
            A = Y({}, o, {
                color: l,
                component: u,
                disabled: f,
                disableElevation: d,
                disableFocusRipple: p,
                fullWidth: v,
                size: b,
                type: x,
                variant: S
            }),
            T = s3e(A),
            M = _ && gt(a3e, {
                className: T.startIcon,
                ownerState: A,
                children: _
            }),
            I = m && gt(l3e, {
                className: T.endIcon,
                ownerState: A,
                children: m
            }),
            O = i || "";
        return Zo(o3e, Y({
            ownerState: A,
            className: Nt(r.className, T.root, c, O),
            component: u,
            disabled: f,
            focusRipple: !p,
            focusVisibleClassName: Nt(T.focusVisible, y),
            ref: n,
            type: x
        }, E, {
            classes: T,
            children: [M, a, I]
        }))
    }),
    gUe = u3e,
    c3e = KAe({
        createStyledComponent: en("div", {
            name: "MuiContainer",
            slot: "Root",
            overridesResolver: (t, e) => {
                const {
                    ownerState: n
                } = t;
                return [e.root, e[`maxWidth${Wt(String(n.maxWidth))}`], n.fixed && e.fixed, n.disableGutters && e.disableGutters]
            }
        }),
        useThemeProps: t => Kn({
            props: t,
            name: "MuiContainer"
        })
    }),
    yUe = c3e;

function f3e(t) {
    return Jn("MuiModal", t)
}
tr("MuiModal", ["root", "hidden", "backdrop"]);
const d3e = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"],
    p3e = t => {
        const {
            open: e,
            exited: n,
            classes: r
        } = t;
        return Yn({
            root: ["root", !e && n && "hidden"],
            backdrop: ["backdrop"]
        }, f3e, r)
    },
    h3e = en("div", {
        name: "MuiModal",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, !n.open && n.exited && e.hidden]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        position: "fixed",
        zIndex: (t.vars || t).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0
    }, !e.open && e.exited && {
        visibility: "hidden"
    })),
    m3e = en(iY, {
        name: "MuiModal",
        slot: "Backdrop",
        overridesResolver: (t, e) => e.backdrop
    })({
        zIndex: -1
    }),
    g3e = P.forwardRef(function(e, n) {
        var r, i, s, o, a, l;
        const u = Kn({
                name: "MuiModal",
                props: e
            }),
            {
                BackdropComponent: c = m3e,
                BackdropProps: f,
                className: d,
                closeAfterTransition: p = !1,
                children: m,
                container: y,
                component: v,
                components: b = {},
                componentsProps: _ = {},
                disableAutoFocus: x = !1,
                disableEnforceFocus: S = !1,
                disableEscapeKeyDown: E = !1,
                disablePortal: A = !1,
                disableRestoreFocus: T = !1,
                disableScrollLock: M = !1,
                hideBackdrop: I = !1,
                keepMounted: O = !1,
                onBackdropClick: k,
                open: H,
                slotProps: N,
                slots: B
            } = u,
            U = Rt(u, d3e),
            q = Y({}, u, {
                closeAfterTransition: p,
                disableAutoFocus: x,
                disableEnforceFocus: S,
                disableEscapeKeyDown: E,
                disablePortal: A,
                disableRestoreFocus: T,
                disableScrollLock: M,
                hideBackdrop: I,
                keepMounted: O
            }),
            {
                getRootProps: Q,
                getBackdropProps: F,
                getTransitionProps: G,
                portalRef: W,
                isTopModal: se,
                exited: ee,
                hasTransition: ae
            } = PIe(Y({}, q, {
                rootRef: n
            })),
            de = Y({}, q, {
                exited: ee
            }),
            re = p3e(de),
            _e = {};
        if (m.props.tabIndex === void 0 && (_e.tabIndex = "-1"), ae) {
            const {
                onEnter: me,
                onExited: Ce
            } = G();
            _e.onEnter = me, _e.onExited = Ce
        }
        const fe = (r = (i = B == null ? void 0 : B.root) != null ? i : b.Root) != null ? r : h3e,
            ue = (s = (o = B == null ? void 0 : B.backdrop) != null ? o : b.Backdrop) != null ? s : c,
            ve = (a = N == null ? void 0 : N.root) != null ? a : _.root,
            xe = (l = N == null ? void 0 : N.backdrop) != null ? l : _.backdrop,
            be = AR({
                elementType: fe,
                externalSlotProps: ve,
                externalForwardedProps: U,
                getSlotProps: Q,
                additionalProps: {
                    ref: n,
                    as: v
                },
                ownerState: de,
                className: Nt(d, ve == null ? void 0 : ve.className, re == null ? void 0 : re.root, !de.open && de.exited && (re == null ? void 0 : re.hidden))
            }),
            he = AR({
                elementType: ue,
                externalSlotProps: xe,
                additionalProps: f,
                getSlotProps: me => F(Y({}, me, {
                    onClick: Ce => {
                        k && k(Ce), me != null && me.onClick && me.onClick(Ce)
                    }
                })),
                className: Nt(xe == null ? void 0 : xe.className, f == null ? void 0 : f.className, re == null ? void 0 : re.backdrop),
                ownerState: de
            });
        return !O && !H && (!ae || ee) ? null : gt(qJ, {
            ref: W,
            container: y,
            disablePortal: A,
            children: Zo(fe, Y({}, be, {
                children: [!I && c ? gt(ue, Y({}, he)) : null, gt(xIe, {
                    disableEnforceFocus: S,
                    disableAutoFocus: x,
                    disableRestoreFocus: T,
                    isEnabled: se,
                    open: H,
                    children: P.cloneElement(m, _e)
                })]
            }))
        })
    }),
    oY = g3e;

function y3e(t) {
    return Jn("MuiDialog", t)
}
const v3e = tr("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]),
    VT = v3e,
    b3e = P.createContext({}),
    aY = b3e,
    x3e = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"],
    _3e = en(iY, {
        name: "MuiDialog",
        slot: "Backdrop",
        overrides: (t, e) => e.backdrop
    })({
        zIndex: -1
    }),
    S3e = t => {
        const {
            classes: e,
            scroll: n,
            maxWidth: r,
            fullWidth: i,
            fullScreen: s
        } = t, o = {
            root: ["root"],
            container: ["container", `scroll${Wt(n)}`],
            paper: ["paper", `paperScroll${Wt(n)}`, `paperWidth${Wt(String(r))}`, i && "paperFullWidth", s && "paperFullScreen"]
        };
        return Yn(o, y3e, e)
    },
    w3e = en(oY, {
        name: "MuiDialog",
        slot: "Root",
        overridesResolver: (t, e) => e.root
    })({
        "@media print": {
            position: "absolute !important"
        }
    }),
    E3e = en("div", {
        name: "MuiDialog",
        slot: "Container",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.container, e[`scroll${Wt(n.scroll)}`]]
        }
    })(({
        ownerState: t
    }) => Y({
        height: "100%",
        "@media print": {
            height: "auto"
        },
        outline: 0
    }, t.scroll === "paper" && {
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
    }, t.scroll === "body" && {
        overflowY: "auto",
        overflowX: "hidden",
        textAlign: "center",
        "&::after": {
            content: '""',
            display: "inline-block",
            verticalAlign: "middle",
            height: "100%",
            width: "0"
        }
    })),
    A3e = en(Lk, {
        name: "MuiDialog",
        slot: "Paper",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.paper, e[`scrollPaper${Wt(n.scroll)}`], e[`paperWidth${Wt(String(n.maxWidth))}`], n.fullWidth && e.paperFullWidth, n.fullScreen && e.paperFullScreen]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        margin: 32,
        position: "relative",
        overflowY: "auto",
        "@media print": {
            overflowY: "visible",
            boxShadow: "none"
        }
    }, e.scroll === "paper" && {
        display: "flex",
        flexDirection: "column",
        maxHeight: "calc(100% - 64px)"
    }, e.scroll === "body" && {
        display: "inline-block",
        verticalAlign: "middle",
        textAlign: "left"
    }, !e.maxWidth && {
        maxWidth: "calc(100% - 64px)"
    }, e.maxWidth === "xs" && {
        maxWidth: t.breakpoints.unit === "px" ? Math.max(t.breakpoints.values.xs, 444) : `max(${t.breakpoints.values.xs}${t.breakpoints.unit}, 444px)`,
        [`&.${VT.paperScrollBody}`]: {
            [t.breakpoints.down(Math.max(t.breakpoints.values.xs, 444) + 32 * 2)]: {
                maxWidth: "calc(100% - 64px)"
            }
        }
    }, e.maxWidth && e.maxWidth !== "xs" && {
        maxWidth: `${t.breakpoints.values[e.maxWidth]}${t.breakpoints.unit}`,
        [`&.${VT.paperScrollBody}`]: {
            [t.breakpoints.down(t.breakpoints.values[e.maxWidth] + 32 * 2)]: {
                maxWidth: "calc(100% - 64px)"
            }
        }
    }, e.fullWidth && {
        width: "calc(100% - 64px)"
    }, e.fullScreen && {
        margin: 0,
        width: "100%",
        maxWidth: "100%",
        height: "100%",
        maxHeight: "none",
        borderRadius: 0,
        [`&.${VT.paperScrollBody}`]: {
            margin: 0,
            maxWidth: "100%"
        }
    })),
    C3e = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDialog"
            }),
            i = Rg(),
            s = {
                enter: i.transitions.duration.enteringScreen,
                exit: i.transitions.duration.leavingScreen
            },
            {
                "aria-describedby": o,
                "aria-labelledby": a,
                BackdropComponent: l,
                BackdropProps: u,
                children: c,
                className: f,
                disableEscapeKeyDown: d = !1,
                fullScreen: p = !1,
                fullWidth: m = !1,
                maxWidth: y = "sm",
                onBackdropClick: v,
                onClose: b,
                open: _,
                PaperComponent: x = Lk,
                PaperProps: S = {},
                scroll: E = "paper",
                TransitionComponent: A = rY,
                transitionDuration: T = s,
                TransitionProps: M
            } = r,
            I = Rt(r, x3e),
            O = Y({}, r, {
                disableEscapeKeyDown: d,
                fullScreen: p,
                fullWidth: m,
                maxWidth: y,
                scroll: E
            }),
            k = S3e(O),
            H = P.useRef(),
            N = Q => {
                H.current = Q.target === Q.currentTarget
            },
            B = Q => {
                H.current && (H.current = null, v && v(Q), b && b(Q, "backdropClick"))
            },
            U = gk(a),
            q = P.useMemo(() => ({
                titleId: U
            }), [U]);
        return gt(w3e, Y({
            className: Nt(k.root, f),
            closeAfterTransition: !0,
            components: {
                Backdrop: _3e
            },
            componentsProps: {
                backdrop: Y({
                    transitionDuration: T,
                    as: l
                }, u)
            },
            disableEscapeKeyDown: d,
            onClose: b,
            open: _,
            ref: n,
            onClick: B,
            ownerState: O
        }, I, {
            children: gt(A, Y({
                appear: !0,
                in: _,
                timeout: T,
                role: "presentation"
            }, M, {
                children: gt(E3e, {
                    className: Nt(k.container),
                    onMouseDown: N,
                    ownerState: O,
                    children: gt(A3e, Y({
                        as: x,
                        elevation: 24,
                        role: "dialog",
                        "aria-describedby": o,
                        "aria-labelledby": U
                    }, S, {
                        className: Nt(k.paper, S.className),
                        ownerState: O,
                        children: gt(aY.Provider, {
                            value: q,
                            children: c
                        })
                    }))
                })
            }))
        }))
    }),
    vUe = C3e;

function M3e(t) {
    return Jn("MuiDialogActions", t)
}
tr("MuiDialogActions", ["root", "spacing"]);
const T3e = ["className", "disableSpacing"],
    P3e = t => {
        const {
            classes: e,
            disableSpacing: n
        } = t;
        return Yn({
            root: ["root", !n && "spacing"]
        }, M3e, e)
    },
    I3e = en("div", {
        name: "MuiDialogActions",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, !n.disableSpacing && e.spacing]
        }
    })(({
        ownerState: t
    }) => Y({
        display: "flex",
        alignItems: "center",
        padding: 8,
        justifyContent: "flex-end",
        flex: "0 0 auto"
    }, !t.disableSpacing && {
        "& > :not(style) ~ :not(style)": {
            marginLeft: 8
        }
    })),
    R3e = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDialogActions"
            }),
            {
                className: i,
                disableSpacing: s = !1
            } = r,
            o = Rt(r, T3e),
            a = Y({}, r, {
                disableSpacing: s
            }),
            l = P3e(a);
        return gt(I3e, Y({
            className: Nt(l.root, i),
            ownerState: a,
            ref: n
        }, o))
    }),
    bUe = R3e;

function O3e(t) {
    return Jn("MuiDialogContent", t)
}
tr("MuiDialogContent", ["root", "dividers"]);

function D3e(t) {
    return Jn("MuiDialogTitle", t)
}
const L3e = tr("MuiDialogTitle", ["root"]),
    k3e = L3e,
    B3e = ["className", "dividers"],
    F3e = t => {
        const {
            classes: e,
            dividers: n
        } = t;
        return Yn({
            root: ["root", n && "dividers"]
        }, O3e, e)
    },
    N3e = en("div", {
        name: "MuiDialogContent",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.dividers && e.dividers]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        flex: "1 1 auto",
        WebkitOverflowScrolling: "touch",
        overflowY: "auto",
        padding: "20px 24px"
    }, e.dividers ? {
        padding: "16px 24px",
        borderTop: `1px solid ${(t.vars||t).palette.divider}`,
        borderBottom: `1px solid ${(t.vars||t).palette.divider}`
    } : {
        [`.${k3e.root} + &`]: {
            paddingTop: 0
        }
    })),
    z3e = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDialogContent"
            }),
            {
                className: i,
                dividers: s = !1
            } = r,
            o = Rt(r, B3e),
            a = Y({}, r, {
                dividers: s
            }),
            l = F3e(a);
        return gt(N3e, Y({
            className: Nt(l.root, i),
            ownerState: a,
            ref: n
        }, o))
    }),
    xUe = z3e;

function H3e(t) {
    return Jn("MuiDialogContentText", t)
}
tr("MuiDialogContentText", ["root"]);
const U3e = ["children", "className"],
    $3e = t => {
        const {
            classes: e
        } = t, r = Yn({
            root: ["root"]
        }, H3e, e);
        return Y({}, e, r)
    },
    G3e = en(qh, {
        shouldForwardProp: t => Y1(t) || t === "classes",
        name: "MuiDialogContentText",
        slot: "Root",
        overridesResolver: (t, e) => e.root
    })({}),
    V3e = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDialogContentText"
            }),
            {
                className: i
            } = r,
            s = Rt(r, U3e),
            o = $3e(s);
        return gt(G3e, Y({
            component: "p",
            variant: "body1",
            color: "text.secondary",
            ref: n,
            ownerState: s,
            className: Nt(o.root, i)
        }, r, {
            classes: o
        }))
    }),
    _Ue = V3e,
    j3e = ["className", "id"],
    W3e = t => {
        const {
            classes: e
        } = t;
        return Yn({
            root: ["root"]
        }, D3e, e)
    },
    K3e = en(qh, {
        name: "MuiDialogTitle",
        slot: "Root",
        overridesResolver: (t, e) => e.root
    })({
        padding: "16px 24px",
        flex: "0 0 auto"
    }),
    q3e = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDialogTitle"
            }),
            {
                className: i,
                id: s
            } = r,
            o = Rt(r, j3e),
            a = r,
            l = W3e(a),
            {
                titleId: u = s
            } = P.useContext(aY);
        return gt(K3e, Y({
            component: "h2",
            className: Nt(l.root, i),
            ownerState: a,
            ref: n,
            variant: "h6",
            id: s ? ? u
        }, o))
    }),
    SUe = q3e;

function X3e(t) {
    return Jn("MuiDivider", t)
}
tr("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const J3e = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"],
    Y3e = t => {
        const {
            absolute: e,
            children: n,
            classes: r,
            flexItem: i,
            light: s,
            orientation: o,
            textAlign: a,
            variant: l
        } = t;
        return Yn({
            root: ["root", e && "absolute", l, s && "light", o === "vertical" && "vertical", i && "flexItem", n && "withChildren", n && o === "vertical" && "withChildrenVertical", a === "right" && o !== "vertical" && "textAlignRight", a === "left" && o !== "vertical" && "textAlignLeft"],
            wrapper: ["wrapper", o === "vertical" && "wrapperVertical"]
        }, X3e, r)
    },
    Q3e = en("div", {
        name: "MuiDivider",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.absolute && e.absolute, e[n.variant], n.light && e.light, n.orientation === "vertical" && e.vertical, n.flexItem && e.flexItem, n.children && e.withChildren, n.children && n.orientation === "vertical" && e.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && e.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && e.textAlignLeft]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        margin: 0,
        flexShrink: 0,
        borderWidth: 0,
        borderStyle: "solid",
        borderColor: (t.vars || t).palette.divider,
        borderBottomWidth: "thin"
    }, e.absolute && {
        position: "absolute",
        bottom: 0,
        left: 0,
        width: "100%"
    }, e.light && {
        borderColor: t.vars ? `rgba(${t.vars.palette.dividerChannel} / 0.08)` : gi(t.palette.divider, .08)
    }, e.variant === "inset" && {
        marginLeft: 72
    }, e.variant === "middle" && e.orientation === "horizontal" && {
        marginLeft: t.spacing(2),
        marginRight: t.spacing(2)
    }, e.variant === "middle" && e.orientation === "vertical" && {
        marginTop: t.spacing(1),
        marginBottom: t.spacing(1)
    }, e.orientation === "vertical" && {
        height: "100%",
        borderBottomWidth: 0,
        borderRightWidth: "thin"
    }, e.flexItem && {
        alignSelf: "stretch",
        height: "auto"
    }), ({
        ownerState: t
    }) => Y({}, t.children && {
        display: "flex",
        whiteSpace: "nowrap",
        textAlign: "center",
        border: 0,
        "&::before, &::after": {
            content: '""',
            alignSelf: "center"
        }
    }), ({
        theme: t,
        ownerState: e
    }) => Y({}, e.children && e.orientation !== "vertical" && {
        "&::before, &::after": {
            width: "100%",
            borderTop: `thin solid ${(t.vars||t).palette.divider}`
        }
    }), ({
        theme: t,
        ownerState: e
    }) => Y({}, e.children && e.orientation === "vertical" && {
        flexDirection: "column",
        "&::before, &::after": {
            height: "100%",
            borderLeft: `thin solid ${(t.vars||t).palette.divider}`
        }
    }), ({
        ownerState: t
    }) => Y({}, t.textAlign === "right" && t.orientation !== "vertical" && {
        "&::before": {
            width: "90%"
        },
        "&::after": {
            width: "10%"
        }
    }, t.textAlign === "left" && t.orientation !== "vertical" && {
        "&::before": {
            width: "10%"
        },
        "&::after": {
            width: "90%"
        }
    })),
    Z3e = en("span", {
        name: "MuiDivider",
        slot: "Wrapper",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.wrapper, n.orientation === "vertical" && e.wrapperVertical]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        display: "inline-block",
        paddingLeft: `calc(${t.spacing(1)} * 1.2)`,
        paddingRight: `calc(${t.spacing(1)} * 1.2)`
    }, e.orientation === "vertical" && {
        paddingTop: `calc(${t.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${t.spacing(1)} * 1.2)`
    })),
    lY = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDivider"
            }),
            {
                absolute: i = !1,
                children: s,
                className: o,
                component: a = s ? "div" : "hr",
                flexItem: l = !1,
                light: u = !1,
                orientation: c = "horizontal",
                role: f = a !== "hr" ? "separator" : void 0,
                textAlign: d = "center",
                variant: p = "fullWidth"
            } = r,
            m = Rt(r, J3e),
            y = Y({}, r, {
                absolute: i,
                component: a,
                flexItem: l,
                light: u,
                orientation: c,
                role: f,
                textAlign: d,
                variant: p
            }),
            v = Y3e(y);
        return gt(Q3e, Y({
            as: a,
            className: Nt(v.root, o),
            role: f,
            ref: n,
            ownerState: y
        }, m, {
            children: s ? gt(Z3e, {
                className: v.wrapper,
                ownerState: y,
                children: s
            }) : null
        }))
    });
lY.muiSkipListHighlight = !0;
const wUe = lY,
    eRe = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function tRe(t, e, n) {
    const r = e.getBoundingClientRect(),
        i = n && n.getBoundingClientRect(),
        s = Pg(e);
    let o;
    if (e.fakeTransform) o = e.fakeTransform;
    else {
        const u = s.getComputedStyle(e);
        o = u.getPropertyValue("-webkit-transform") || u.getPropertyValue("transform")
    }
    let a = 0,
        l = 0;
    if (o && o !== "none" && typeof o == "string") {
        const u = o.split("(")[1].split(")")[0].split(",");
        a = parseInt(u[4], 10), l = parseInt(u[5], 10)
    }
    return t === "left" ? i ? `translateX(${i.right+a-r.left}px)` : `translateX(${s.innerWidth+a-r.left}px)` : t === "right" ? i ? `translateX(-${r.right-i.left-a}px)` : `translateX(-${r.left+r.width-a}px)` : t === "up" ? i ? `translateY(${i.bottom+l-r.top}px)` : `translateY(${s.innerHeight+l-r.top}px)` : i ? `translateY(-${r.top-i.top+r.height-l}px)` : `translateY(-${r.top+r.height-l}px)`
}

function nRe(t) {
    return typeof t == "function" ? t() : t
}

function I_(t, e, n) {
    const r = nRe(n),
        i = tRe(t, e, r);
    i && (e.style.webkitTransform = i, e.style.transform = i)
}
const rRe = P.forwardRef(function(e, n) {
        const r = Rg(),
            i = {
                enter: r.transitions.easing.easeOut,
                exit: r.transitions.easing.sharp
            },
            s = {
                enter: r.transitions.duration.enteringScreen,
                exit: r.transitions.duration.leavingScreen
            },
            {
                addEndListener: o,
                appear: a = !0,
                children: l,
                container: u,
                direction: c = "down",
                easing: f = i,
                in: d,
                onEnter: p,
                onEntered: m,
                onEntering: y,
                onExit: v,
                onExited: b,
                onExiting: _,
                style: x,
                timeout: S = s,
                TransitionComponent: E = Sk
            } = e,
            A = Rt(e, eRe),
            T = P.useRef(null),
            M = ls(l.ref, T, n),
            I = F => G => {
                F && (G === void 0 ? F(T.current) : F(T.current, G))
            },
            O = I((F, G) => {
                I_(c, F, u), Ak(F), p && p(F, G)
            }),
            k = I((F, G) => {
                const W = Ym({
                    timeout: S,
                    style: x,
                    easing: f
                }, {
                    mode: "enter"
                });
                F.style.webkitTransition = r.transitions.create("-webkit-transform", Y({}, W)), F.style.transition = r.transitions.create("transform", Y({}, W)), F.style.webkitTransform = "none", F.style.transform = "none", y && y(F, G)
            }),
            H = I(m),
            N = I(_),
            B = I(F => {
                const G = Ym({
                    timeout: S,
                    style: x,
                    easing: f
                }, {
                    mode: "exit"
                });
                F.style.webkitTransition = r.transitions.create("-webkit-transform", G), F.style.transition = r.transitions.create("transform", G), I_(c, F, u), v && v(F)
            }),
            U = I(F => {
                F.style.webkitTransition = "", F.style.transition = "", b && b(F)
            }),
            q = F => {
                o && o(T.current, F)
            },
            Q = P.useCallback(() => {
                T.current && I_(c, T.current, u)
            }, [c, u]);
        return P.useEffect(() => {
            if (d || c === "down" || c === "right") return;
            const F = _J(() => {
                    T.current && I_(c, T.current, u)
                }),
                G = Pg(T.current);
            return G.addEventListener("resize", F), () => {
                F.clear(), G.removeEventListener("resize", F)
            }
        }, [c, d, u]), P.useEffect(() => {
            d || Q()
        }, [d, Q]), gt(E, Y({
            nodeRef: T,
            onEnter: O,
            onEntered: H,
            onEntering: k,
            onExit: B,
            onExited: U,
            onExiting: N,
            addEndListener: q,
            appear: a,
            in: d,
            timeout: S
        }, A, {
            children: (F, G) => P.cloneElement(l, Y({
                ref: M,
                style: Y({
                    visibility: F === "exited" && !d ? "hidden" : void 0
                }, x, l.props.style)
            }, G))
        }))
    }),
    iRe = rRe;

function sRe(t) {
    return Jn("MuiDrawer", t)
}
tr("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const oRe = ["BackdropProps"],
    aRe = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"],
    uY = (t, e) => {
        const {
            ownerState: n
        } = t;
        return [e.root, (n.variant === "permanent" || n.variant === "persistent") && e.docked, e.modal]
    },
    lRe = t => {
        const {
            classes: e,
            anchor: n,
            variant: r
        } = t, i = {
            root: ["root"],
            docked: [(r === "permanent" || r === "persistent") && "docked"],
            modal: ["modal"],
            paper: ["paper", `paperAnchor${Wt(n)}`, r !== "temporary" && `paperAnchorDocked${Wt(n)}`]
        };
        return Yn(i, sRe, e)
    },
    uRe = en(oY, {
        name: "MuiDrawer",
        slot: "Root",
        overridesResolver: uY
    })(({
        theme: t
    }) => ({
        zIndex: (t.vars || t).zIndex.drawer
    })),
    Wz = en("div", {
        shouldForwardProp: Y1,
        name: "MuiDrawer",
        slot: "Docked",
        skipVariantsResolver: !1,
        overridesResolver: uY
    })({
        flex: "0 0 auto"
    }),
    cRe = en(Lk, {
        name: "MuiDrawer",
        slot: "Paper",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.paper, e[`paperAnchor${Wt(n.anchor)}`], n.variant !== "temporary" && e[`paperAnchorDocked${Wt(n.anchor)}`]]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        overflowY: "auto",
        display: "flex",
        flexDirection: "column",
        height: "100%",
        flex: "1 0 auto",
        zIndex: (t.vars || t).zIndex.drawer,
        WebkitOverflowScrolling: "touch",
        position: "fixed",
        top: 0,
        outline: 0
    }, e.anchor === "left" && {
        left: 0
    }, e.anchor === "top" && {
        top: 0,
        left: 0,
        right: 0,
        height: "auto",
        maxHeight: "100%"
    }, e.anchor === "right" && {
        right: 0
    }, e.anchor === "bottom" && {
        top: "auto",
        left: 0,
        bottom: 0,
        right: 0,
        height: "auto",
        maxHeight: "100%"
    }, e.anchor === "left" && e.variant !== "temporary" && {
        borderRight: `1px solid ${(t.vars||t).palette.divider}`
    }, e.anchor === "top" && e.variant !== "temporary" && {
        borderBottom: `1px solid ${(t.vars||t).palette.divider}`
    }, e.anchor === "right" && e.variant !== "temporary" && {
        borderLeft: `1px solid ${(t.vars||t).palette.divider}`
    }, e.anchor === "bottom" && e.variant !== "temporary" && {
        borderTop: `1px solid ${(t.vars||t).palette.divider}`
    })),
    cY = {
        left: "right",
        right: "left",
        top: "down",
        bottom: "up"
    };

function fRe(t) {
    return ["left", "right"].indexOf(t) !== -1
}

function dRe({
    direction: t
}, e) {
    return t === "rtl" && fRe(e) ? cY[e] : e
}
const pRe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiDrawer"
            }),
            i = Rg(),
            s = EJ(),
            o = {
                enter: i.transitions.duration.enteringScreen,
                exit: i.transitions.duration.leavingScreen
            },
            {
                anchor: a = "left",
                BackdropProps: l,
                children: u,
                className: c,
                elevation: f = 16,
                hideBackdrop: d = !1,
                ModalProps: {
                    BackdropProps: p
                } = {},
                onClose: m,
                open: y = !1,
                PaperProps: v = {},
                SlideProps: b,
                TransitionComponent: _ = iRe,
                transitionDuration: x = o,
                variant: S = "temporary"
            } = r,
            E = Rt(r.ModalProps, oRe),
            A = Rt(r, aRe),
            T = P.useRef(!1);
        P.useEffect(() => {
            T.current = !0
        }, []);
        const M = dRe({
                direction: s ? "rtl" : "ltr"
            }, a),
            O = Y({}, r, {
                anchor: a,
                elevation: f,
                open: y,
                variant: S
            }, A),
            k = lRe(O),
            H = gt(cRe, Y({
                elevation: S === "temporary" ? f : 0,
                square: !0
            }, v, {
                className: Nt(k.paper, v.className),
                ownerState: O,
                children: u
            }));
        if (S === "permanent") return gt(Wz, Y({
            className: Nt(k.root, k.docked, c),
            ownerState: O,
            ref: n
        }, A, {
            children: H
        }));
        const N = gt(_, Y({ in: y,
            direction: cY[M],
            timeout: x,
            appear: T.current
        }, b, {
            children: H
        }));
        return S === "persistent" ? gt(Wz, Y({
            className: Nt(k.root, k.docked, c),
            ownerState: O,
            ref: n
        }, A, {
            children: N
        })) : gt(uRe, Y({
            BackdropProps: Y({}, l, p, {
                transitionDuration: x
            }),
            className: Nt(k.root, k.modal, c),
            open: y,
            ownerState: O,
            onClose: m,
            hideBackdrop: d,
            ref: n
        }, A, E, {
            children: N
        }))
    }),
    EUe = pRe;

function hRe(t) {
    return Jn("MuiIcon", t)
}
tr("MuiIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const mRe = ["baseClassName", "className", "color", "component", "fontSize"],
    gRe = t => {
        const {
            color: e,
            fontSize: n,
            classes: r
        } = t, i = {
            root: ["root", e !== "inherit" && `color${Wt(e)}`, `fontSize${Wt(n)}`]
        };
        return Yn(i, hRe, r)
    },
    yRe = en("span", {
        name: "MuiIcon",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.color !== "inherit" && e[`color${Wt(n.color)}`], e[`fontSize${Wt(n.fontSize)}`]]
        }
    })(({
        theme: t,
        ownerState: e
    }) => ({
        userSelect: "none",
        width: "1em",
        height: "1em",
        overflow: "hidden",
        display: "inline-block",
        textAlign: "center",
        flexShrink: 0,
        fontSize: {
            inherit: "inherit",
            small: t.typography.pxToRem(20),
            medium: t.typography.pxToRem(24),
            large: t.typography.pxToRem(36)
        }[e.fontSize],
        color: {
            primary: (t.vars || t).palette.primary.main,
            secondary: (t.vars || t).palette.secondary.main,
            info: (t.vars || t).palette.info.main,
            success: (t.vars || t).palette.success.main,
            warning: (t.vars || t).palette.warning.main,
            action: (t.vars || t).palette.action.active,
            error: (t.vars || t).palette.error.main,
            disabled: (t.vars || t).palette.action.disabled,
            inherit: void 0
        }[e.color]
    })),
    fY = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiIcon"
            }),
            {
                baseClassName: i = "material-icons",
                className: s,
                color: o = "inherit",
                component: a = "span",
                fontSize: l = "medium"
            } = r,
            u = Rt(r, mRe),
            c = Y({}, r, {
                baseClassName: i,
                color: o,
                component: a,
                fontSize: l
            }),
            f = gRe(c);
        return gt(yRe, Y({
            as: a,
            className: Nt(i, "notranslate", f.root, s),
            ownerState: c,
            "aria-hidden": !0,
            ref: n
        }, u))
    });
fY.muiName = "Icon";
const AUe = fY,
    vRe = P.createContext({}),
    Rl = vRe;

function bRe(t) {
    return Jn("MuiList", t)
}
tr("MuiList", ["root", "padding", "dense", "subheader"]);
const xRe = ["children", "className", "component", "dense", "disablePadding", "subheader"],
    _Re = t => {
        const {
            classes: e,
            disablePadding: n,
            dense: r,
            subheader: i
        } = t;
        return Yn({
            root: ["root", !n && "padding", r && "dense", i && "subheader"]
        }, bRe, e)
    },
    SRe = en("ul", {
        name: "MuiList",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, !n.disablePadding && e.padding, n.dense && e.dense, n.subheader && e.subheader]
        }
    })(({
        ownerState: t
    }) => Y({
        listStyle: "none",
        margin: 0,
        padding: 0,
        position: "relative"
    }, !t.disablePadding && {
        paddingTop: 8,
        paddingBottom: 8
    }, t.subheader && {
        paddingTop: 0
    })),
    wRe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiList"
            }),
            {
                children: i,
                className: s,
                component: o = "ul",
                dense: a = !1,
                disablePadding: l = !1,
                subheader: u
            } = r,
            c = Rt(r, xRe),
            f = P.useMemo(() => ({
                dense: a
            }), [a]),
            d = Y({}, r, {
                component: o,
                dense: a,
                disablePadding: l
            }),
            p = _Re(d);
        return gt(Rl.Provider, {
            value: f,
            children: Zo(SRe, Y({
                as: o,
                className: Nt(p.root, s),
                ref: n,
                ownerState: d
            }, c, {
                children: [u, i]
            }))
        })
    }),
    CUe = wRe;

function ERe(t) {
    return Jn("MuiListItem", t)
}
const ARe = tr("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]),
    yh = ARe;

function CRe(t) {
    return Jn("MuiListItemButton", t)
}
const MRe = tr("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]),
    vh = MRe,
    TRe = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"],
    PRe = (t, e) => {
        const {
            ownerState: n
        } = t;
        return [e.root, n.dense && e.dense, n.alignItems === "flex-start" && e.alignItemsFlexStart, n.divider && e.divider, !n.disableGutters && e.gutters]
    },
    IRe = t => {
        const {
            alignItems: e,
            classes: n,
            dense: r,
            disabled: i,
            disableGutters: s,
            divider: o,
            selected: a
        } = t, u = Yn({
            root: ["root", r && "dense", !s && "gutters", o && "divider", i && "disabled", e === "flex-start" && "alignItemsFlexStart", a && "selected"]
        }, CRe, n);
        return Y({}, n, u)
    },
    RRe = en(DA, {
        shouldForwardProp: t => Y1(t) || t === "classes",
        name: "MuiListItemButton",
        slot: "Root",
        overridesResolver: PRe
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        display: "flex",
        flexGrow: 1,
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        minWidth: 0,
        boxSizing: "border-box",
        textAlign: "left",
        paddingTop: 8,
        paddingBottom: 8,
        transition: t.transitions.create("background-color", {
            duration: t.transitions.duration.shortest
        }),
        "&:hover": {
            textDecoration: "none",
            backgroundColor: (t.vars || t).palette.action.hover,
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        },
        [`&.${vh.selected}`]: {
            backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.selectedOpacity})` : gi(t.palette.primary.main, t.palette.action.selectedOpacity),
            [`&.${vh.focusVisible}`]: {
                backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))` : gi(t.palette.primary.main, t.palette.action.selectedOpacity + t.palette.action.focusOpacity)
            }
        },
        [`&.${vh.selected}:hover`]: {
            backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))` : gi(t.palette.primary.main, t.palette.action.selectedOpacity + t.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.selectedOpacity})` : gi(t.palette.primary.main, t.palette.action.selectedOpacity)
            }
        },
        [`&.${vh.focusVisible}`]: {
            backgroundColor: (t.vars || t).palette.action.focus
        },
        [`&.${vh.disabled}`]: {
            opacity: (t.vars || t).palette.action.disabledOpacity
        }
    }, e.divider && {
        borderBottom: `1px solid ${(t.vars||t).palette.divider}`,
        backgroundClip: "padding-box"
    }, e.alignItems === "flex-start" && {
        alignItems: "flex-start"
    }, !e.disableGutters && {
        paddingLeft: 16,
        paddingRight: 16
    }, e.dense && {
        paddingTop: 4,
        paddingBottom: 4
    })),
    ORe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiListItemButton"
            }),
            {
                alignItems: i = "center",
                autoFocus: s = !1,
                component: o = "div",
                children: a,
                dense: l = !1,
                disableGutters: u = !1,
                divider: c = !1,
                focusVisibleClassName: f,
                selected: d = !1,
                className: p
            } = r,
            m = Rt(r, TRe),
            y = P.useContext(Rl),
            v = P.useMemo(() => ({
                dense: l || y.dense || !1,
                alignItems: i,
                disableGutters: u
            }), [i, y.dense, l, u]),
            b = P.useRef(null);
        gf(() => {
            s && b.current && b.current.focus()
        }, [s]);
        const _ = Y({}, r, {
                alignItems: i,
                dense: v.dense,
                disableGutters: u,
                divider: c,
                selected: d
            }),
            x = IRe(_),
            S = ls(b, n);
        return gt(Rl.Provider, {
            value: v,
            children: gt(RRe, Y({
                ref: S,
                href: m.href || m.to,
                component: (m.href || m.to) && o === "div" ? "button" : o,
                focusVisibleClassName: Nt(x.focusVisible, f),
                ownerState: _,
                className: Nt(x.root, p)
            }, m, {
                classes: x,
                children: a
            }))
        })
    }),
    MUe = ORe;

function DRe(t) {
    return Jn("MuiListItemSecondaryAction", t)
}
tr("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const LRe = ["className"],
    kRe = t => {
        const {
            disableGutters: e,
            classes: n
        } = t;
        return Yn({
            root: ["root", e && "disableGutters"]
        }, DRe, n)
    },
    BRe = en("div", {
        name: "MuiListItemSecondaryAction",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.disableGutters && e.disableGutters]
        }
    })(({
        ownerState: t
    }) => Y({
        position: "absolute",
        right: 16,
        top: "50%",
        transform: "translateY(-50%)"
    }, t.disableGutters && {
        right: 0
    })),
    dY = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiListItemSecondaryAction"
            }),
            {
                className: i
            } = r,
            s = Rt(r, LRe),
            o = P.useContext(Rl),
            a = Y({}, r, {
                disableGutters: o.disableGutters
            }),
            l = kRe(a);
        return gt(BRe, Y({
            className: Nt(l.root, i),
            ownerState: a,
            ref: n
        }, s))
    });
dY.muiName = "ListItemSecondaryAction";
const FRe = dY,
    NRe = ["className"],
    zRe = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"],
    HRe = (t, e) => {
        const {
            ownerState: n
        } = t;
        return [e.root, n.dense && e.dense, n.alignItems === "flex-start" && e.alignItemsFlexStart, n.divider && e.divider, !n.disableGutters && e.gutters, !n.disablePadding && e.padding, n.button && e.button, n.hasSecondaryAction && e.secondaryAction]
    },
    URe = t => {
        const {
            alignItems: e,
            button: n,
            classes: r,
            dense: i,
            disabled: s,
            disableGutters: o,
            disablePadding: a,
            divider: l,
            hasSecondaryAction: u,
            selected: c
        } = t;
        return Yn({
            root: ["root", i && "dense", !o && "gutters", !a && "padding", l && "divider", s && "disabled", n && "button", e === "flex-start" && "alignItemsFlexStart", u && "secondaryAction", c && "selected"],
            container: ["container"]
        }, ERe, r)
    },
    $Re = en("div", {
        name: "MuiListItem",
        slot: "Root",
        overridesResolver: HRe
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        display: "flex",
        justifyContent: "flex-start",
        alignItems: "center",
        position: "relative",
        textDecoration: "none",
        width: "100%",
        boxSizing: "border-box",
        textAlign: "left"
    }, !e.disablePadding && Y({
        paddingTop: 8,
        paddingBottom: 8
    }, e.dense && {
        paddingTop: 4,
        paddingBottom: 4
    }, !e.disableGutters && {
        paddingLeft: 16,
        paddingRight: 16
    }, !!e.secondaryAction && {
        paddingRight: 48
    }), !!e.secondaryAction && {
        [`& > .${vh.root}`]: {
            paddingRight: 48
        }
    }, {
        [`&.${yh.focusVisible}`]: {
            backgroundColor: (t.vars || t).palette.action.focus
        },
        [`&.${yh.selected}`]: {
            backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.selectedOpacity})` : gi(t.palette.primary.main, t.palette.action.selectedOpacity),
            [`&.${yh.focusVisible}`]: {
                backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))` : gi(t.palette.primary.main, t.palette.action.selectedOpacity + t.palette.action.focusOpacity)
            }
        },
        [`&.${yh.disabled}`]: {
            opacity: (t.vars || t).palette.action.disabledOpacity
        }
    }, e.alignItems === "flex-start" && {
        alignItems: "flex-start"
    }, e.divider && {
        borderBottom: `1px solid ${(t.vars||t).palette.divider}`,
        backgroundClip: "padding-box"
    }, e.button && {
        transition: t.transitions.create("background-color", {
            duration: t.transitions.duration.shortest
        }),
        "&:hover": {
            textDecoration: "none",
            backgroundColor: (t.vars || t).palette.action.hover,
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        },
        [`&.${yh.selected}:hover`]: {
            backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))` : gi(t.palette.primary.main, t.palette.action.selectedOpacity + t.palette.action.hoverOpacity),
            "@media (hover: none)": {
                backgroundColor: t.vars ? `rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.selectedOpacity})` : gi(t.palette.primary.main, t.palette.action.selectedOpacity)
            }
        }
    }, e.hasSecondaryAction && {
        paddingRight: 48
    })),
    GRe = en("li", {
        name: "MuiListItem",
        slot: "Container",
        overridesResolver: (t, e) => e.container
    })({
        position: "relative"
    }),
    VRe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiListItem"
            }),
            {
                alignItems: i = "center",
                autoFocus: s = !1,
                button: o = !1,
                children: a,
                className: l,
                component: u,
                components: c = {},
                componentsProps: f = {},
                ContainerComponent: d = "li",
                ContainerProps: {
                    className: p
                } = {},
                dense: m = !1,
                disabled: y = !1,
                disableGutters: v = !1,
                disablePadding: b = !1,
                divider: _ = !1,
                focusVisibleClassName: x,
                secondaryAction: S,
                selected: E = !1,
                slotProps: A = {},
                slots: T = {}
            } = r,
            M = Rt(r.ContainerProps, NRe),
            I = Rt(r, zRe),
            O = P.useContext(Rl),
            k = P.useMemo(() => ({
                dense: m || O.dense || !1,
                alignItems: i,
                disableGutters: v
            }), [i, O.dense, m, v]),
            H = P.useRef(null);
        gf(() => {
            s && H.current && H.current.focus()
        }, [s]);
        const N = P.Children.toArray(a),
            B = N.length && SJ(N[N.length - 1], ["ListItemSecondaryAction"]),
            U = Y({}, r, {
                alignItems: i,
                autoFocus: s,
                button: o,
                dense: k.dense,
                disabled: y,
                disableGutters: v,
                disablePadding: b,
                divider: _,
                hasSecondaryAction: B,
                selected: E
            }),
            q = URe(U),
            Q = ls(H, n),
            F = T.root || c.Root || $Re,
            G = A.root || f.root || {},
            W = Y({
                className: Nt(q.root, G.className, l),
                disabled: y
            }, I);
        let se = u || "li";
        return o && (W.component = u || "div", W.focusVisibleClassName = Nt(yh.focusVisible, x), se = DA), B ? (se = !W.component && !u ? "div" : se, d === "li" && (se === "li" ? se = "div" : W.component === "li" && (W.component = "div")), gt(Rl.Provider, {
            value: k,
            children: Zo(GRe, Y({
                as: d,
                className: Nt(q.container, p),
                ref: Q,
                ownerState: U
            }, M, {
                children: [gt(F, Y({}, G, !ER(F) && {
                    as: se,
                    ownerState: Y({}, U, G.ownerState)
                }, W, {
                    children: N
                })), N.pop()]
            }))
        })) : gt(Rl.Provider, {
            value: k,
            children: Zo(F, Y({}, G, {
                as: se,
                ref: Q
            }, !ER(F) && {
                ownerState: Y({}, U, G.ownerState)
            }, W, {
                children: [N, S && gt(FRe, {
                    children: S
                })]
            }))
        })
    }),
    TUe = VRe;

function jRe(t) {
    return Jn("MuiListItemAvatar", t)
}
tr("MuiListItemAvatar", ["root", "alignItemsFlexStart"]);
const WRe = ["className"],
    KRe = t => {
        const {
            alignItems: e,
            classes: n
        } = t;
        return Yn({
            root: ["root", e === "flex-start" && "alignItemsFlexStart"]
        }, jRe, n)
    },
    qRe = en("div", {
        name: "MuiListItemAvatar",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.alignItems === "flex-start" && e.alignItemsFlexStart]
        }
    })(({
        ownerState: t
    }) => Y({
        minWidth: 56,
        flexShrink: 0
    }, t.alignItems === "flex-start" && {
        marginTop: 8
    })),
    XRe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiListItemAvatar"
            }),
            {
                className: i
            } = r,
            s = Rt(r, WRe),
            o = P.useContext(Rl),
            a = Y({}, r, {
                alignItems: o.alignItems
            }),
            l = KRe(a);
        return gt(qRe, Y({
            className: Nt(l.root, i),
            ownerState: a,
            ref: n
        }, s))
    }),
    PUe = XRe;

function JRe(t) {
    return Jn("MuiListItemIcon", t)
}
tr("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const YRe = ["className"],
    QRe = t => {
        const {
            alignItems: e,
            classes: n
        } = t;
        return Yn({
            root: ["root", e === "flex-start" && "alignItemsFlexStart"]
        }, JRe, n)
    },
    ZRe = en("div", {
        name: "MuiListItemIcon",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [e.root, n.alignItems === "flex-start" && e.alignItemsFlexStart]
        }
    })(({
        theme: t,
        ownerState: e
    }) => Y({
        minWidth: 56,
        color: (t.vars || t).palette.action.active,
        flexShrink: 0,
        display: "inline-flex"
    }, e.alignItems === "flex-start" && {
        marginTop: 8
    })),
    eOe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiListItemIcon"
            }),
            {
                className: i
            } = r,
            s = Rt(r, YRe),
            o = P.useContext(Rl),
            a = Y({}, r, {
                alignItems: o.alignItems
            }),
            l = QRe(a);
        return gt(ZRe, Y({
            className: Nt(l.root, i),
            ownerState: a,
            ref: n
        }, s))
    }),
    IUe = eOe;

function tOe(t) {
    return Jn("MuiListItemText", t)
}
const nOe = tr("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]),
    Kz = nOe,
    rOe = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"],
    iOe = t => {
        const {
            classes: e,
            inset: n,
            primary: r,
            secondary: i,
            dense: s
        } = t;
        return Yn({
            root: ["root", n && "inset", s && "dense", r && i && "multiline"],
            primary: ["primary"],
            secondary: ["secondary"]
        }, tOe, e)
    },
    sOe = en("div", {
        name: "MuiListItemText",
        slot: "Root",
        overridesResolver: (t, e) => {
            const {
                ownerState: n
            } = t;
            return [{
                [`& .${Kz.primary}`]: e.primary
            }, {
                [`& .${Kz.secondary}`]: e.secondary
            }, e.root, n.inset && e.inset, n.primary && n.secondary && e.multiline, n.dense && e.dense]
        }
    })(({
        ownerState: t
    }) => Y({
        flex: "1 1 auto",
        minWidth: 0,
        marginTop: 4,
        marginBottom: 4
    }, t.primary && t.secondary && {
        marginTop: 6,
        marginBottom: 6
    }, t.inset && {
        paddingLeft: 56
    })),
    oOe = P.forwardRef(function(e, n) {
        const r = Kn({
                props: e,
                name: "MuiListItemText"
            }),
            {
                children: i,
                className: s,
                disableTypography: o = !1,
                inset: a = !1,
                primary: l,
                primaryTypographyProps: u,
                secondary: c,
                secondaryTypographyProps: f
            } = r,
            d = Rt(r, rOe),
            {
                dense: p
            } = P.useContext(Rl);
        let m = l ? ? i,
            y = c;
        const v = Y({}, r, {
                disableTypography: o,
                inset: a,
                primary: !!m,
                secondary: !!y,
                dense: p
            }),
            b = iOe(v);
        return m != null && m.type !== qh && !o && (m = gt(qh, Y({
            variant: p ? "body2" : "body1",
            className: b.primary,
            component: u != null && u.variant ? void 0 : "span",
            display: "block"
        }, u, {
            children: m
        }))), y != null && y.type !== qh && !o && (y = gt(qh, Y({
            variant: "body2",
            className: b.secondary,
            color: "text.secondary",
            display: "block"
        }, f, {
            children: y
        }))), Zo(sOe, Y({
            className: Nt(b.root, s),
            ownerState: v,
            ref: n
        }, d, {
            children: [m, y]
        }))
    }),
    RUe = oOe;
var kk = {},
    jT = {};
const aOe = qa(APe);
var qz;

function _p() {
    return qz || (qz = 1, function(t) {
        "use client";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), Object.defineProperty(t, "default", {
            enumerable: !0,
            get: function() {
                return e.createSvgIcon
            }
        });
        var e = aOe
    }(jT)), jT
}
const Sp = qa(Rte);
var lOe = qu;
Object.defineProperty(kk, "__esModule", {
    value: !0
});
var uOe = kk.default = void 0,
    cOe = lOe(_p()),
    fOe = Sp;
uOe = kk.default = (0, cOe.default)((0, fOe.jsx)("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete");
var Bk = {},
    dOe = qu;
Object.defineProperty(Bk, "__esModule", {
    value: !0
});
var pOe = Bk.default = void 0,
    hOe = dOe(_p()),
    mOe = Sp;
pOe = Bk.default = (0, hOe.default)((0, mOe.jsx)("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const pY = P.createContext({
    dragDropManager: void 0
});

function sn(t, e, ...n) {
    if (gOe() && e === void 0) throw new Error("invariant requires an error message argument");
    if (!t) {
        let r;
        if (e === void 0) r = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
            let i = 0;
            r = new Error(e.replace(/%s/g, function() {
                return n[i++]
            })), r.name = "Invariant Violation"
        }
        throw r.framesToPop = 1, r
    }
}

function gOe() {
    return typeof process < "u" && process.env.NODE_ENV === "production"
}

function yOe(t, e, n) {
    return e.split(".").reduce((r, i) => r && r[i] ? r[i] : n || null, t)
}

function vOe(t, e) {
    return t.filter(n => n !== e)
}

function hY(t) {
    return typeof t == "object"
}

function bOe(t, e) {
    const n = new Map,
        r = s => {
            n.set(s, n.has(s) ? n.get(s) + 1 : 1)
        };
    t.forEach(r), e.forEach(r);
    const i = [];
    return n.forEach((s, o) => {
        s === 1 && i.push(o)
    }), i
}

function xOe(t, e) {
    return t.filter(n => e.indexOf(n) > -1)
}
const Fk = "dnd-core/INIT_COORDS",
    LA = "dnd-core/BEGIN_DRAG",
    Nk = "dnd-core/PUBLISH_DRAG_SOURCE",
    kA = "dnd-core/HOVER",
    BA = "dnd-core/DROP",
    FA = "dnd-core/END_DRAG";

function Xz(t, e) {
    return {
        type: Fk,
        payload: {
            sourceClientOffset: e || null,
            clientOffset: t || null
        }
    }
}
const _Oe = {
    type: Fk,
    payload: {
        clientOffset: null,
        sourceClientOffset: null
    }
};

function SOe(t) {
    return function(n = [], r = {
        publishSource: !0
    }) {
        const {
            publishSource: i = !0,
            clientOffset: s,
            getSourceClientOffset: o
        } = r, a = t.getMonitor(), l = t.getRegistry();
        t.dispatch(Xz(s)), wOe(n, a, l);
        const u = COe(n, a);
        if (u == null) {
            t.dispatch(_Oe);
            return
        }
        let c = null;
        if (s) {
            if (!o) throw new Error("getSourceClientOffset must be defined");
            EOe(o), c = o(u)
        }
        t.dispatch(Xz(s, c));
        const d = l.getSource(u).beginDrag(a, u);
        if (d == null) return;
        AOe(d), l.pinSource(u);
        const p = l.getSourceType(u);
        return {
            type: LA,
            payload: {
                itemType: p,
                item: d,
                sourceId: u,
                clientOffset: s || null,
                sourceClientOffset: c || null,
                isSourcePublic: !!i
            }
        }
    }
}

function wOe(t, e, n) {
    sn(!e.isDragging(), "Cannot call beginDrag while dragging."), t.forEach(function(r) {
        sn(n.getSource(r), "Expected sourceIds to be registered.")
    })
}

function EOe(t) {
    sn(typeof t == "function", "When clientOffset is provided, getSourceClientOffset must be a function.")
}

function AOe(t) {
    sn(hY(t), "Item must be an object.")
}

function COe(t, e) {
    let n = null;
    for (let r = t.length - 1; r >= 0; r--)
        if (e.canDragSource(t[r])) {
            n = t[r];
            break
        }
    return n
}

function MOe(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function TOe(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {},
            r = Object.keys(n);
        typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        }))), r.forEach(function(i) {
            MOe(t, i, n[i])
        })
    }
    return t
}

function POe(t) {
    return function(n = {}) {
        const r = t.getMonitor(),
            i = t.getRegistry();
        IOe(r), DOe(r).forEach((o, a) => {
            const l = ROe(o, a, i, r),
                u = {
                    type: BA,
                    payload: {
                        dropResult: TOe({}, n, l)
                    }
                };
            t.dispatch(u)
        })
    }
}

function IOe(t) {
    sn(t.isDragging(), "Cannot call drop while not dragging."), sn(!t.didDrop(), "Cannot call drop twice during one drag operation.")
}

function ROe(t, e, n, r) {
    const i = n.getTarget(t);
    let s = i ? i.drop(r, t) : void 0;
    return OOe(s), typeof s > "u" && (s = e === 0 ? {} : r.getDropResult()), s
}

function OOe(t) {
    sn(typeof t > "u" || hY(t), "Drop result must either be an object or undefined.")
}

function DOe(t) {
    const e = t.getTargetIds().filter(t.canDropOnTarget, t);
    return e.reverse(), e
}

function LOe(t) {
    return function() {
        const n = t.getMonitor(),
            r = t.getRegistry();
        kOe(n);
        const i = n.getSourceId();
        return i != null && (r.getSource(i, !0).endDrag(n, i), r.unpinSource()), {
            type: FA
        }
    }
}

function kOe(t) {
    sn(t.isDragging(), "Cannot call endDrag while not dragging.")
}

function OR(t, e) {
    return e === null ? t === null : Array.isArray(t) ? t.some(n => n === e) : t === e
}

function BOe(t) {
    return function(n, {
        clientOffset: r
    } = {}) {
        FOe(n);
        const i = n.slice(0),
            s = t.getMonitor(),
            o = t.getRegistry(),
            a = s.getItemType();
        return zOe(i, o, a), NOe(i, s, o), HOe(i, s, o), {
            type: kA,
            payload: {
                targetIds: i,
                clientOffset: r || null
            }
        }
    }
}

function FOe(t) {
    sn(Array.isArray(t), "Expected targetIds to be an array.")
}

function NOe(t, e, n) {
    sn(e.isDragging(), "Cannot call hover while not dragging."), sn(!e.didDrop(), "Cannot call hover after drop.");
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        sn(t.lastIndexOf(i) === r, "Expected targetIds to be unique in the passed array.");
        const s = n.getTarget(i);
        sn(s, "Expected targetIds to be registered.")
    }
}

function zOe(t, e, n) {
    for (let r = t.length - 1; r >= 0; r--) {
        const i = t[r],
            s = e.getTargetType(i);
        OR(s, n) || t.splice(r, 1)
    }
}

function HOe(t, e, n) {
    t.forEach(function(r) {
        n.getTarget(r).hover(e, r)
    })
}

function UOe(t) {
    return function() {
        if (t.getMonitor().isDragging()) return {
            type: Nk
        }
    }
}

function $Oe(t) {
    return {
        beginDrag: SOe(t),
        publishDragSource: UOe(t),
        hover: BOe(t),
        drop: POe(t),
        endDrag: LOe(t)
    }
}
class GOe {
    receiveBackend(e) {
        this.backend = e
    }
    getMonitor() {
        return this.monitor
    }
    getBackend() {
        return this.backend
    }
    getRegistry() {
        return this.monitor.registry
    }
    getActions() {
        const e = this,
            {
                dispatch: n
            } = this.store;

        function r(s) {
            return (...o) => {
                const a = s.apply(e, o);
                typeof a < "u" && n(a)
            }
        }
        const i = $Oe(this);
        return Object.keys(i).reduce((s, o) => {
            const a = i[o];
            return s[o] = r(a), s
        }, {})
    }
    dispatch(e) {
        this.store.dispatch(e)
    }
    constructor(e, n) {
        this.isSetUp = !1, this.handleRefCountChange = () => {
            const r = this.store.getState().refCount > 0;
            this.backend && (r && !this.isSetUp ? (this.backend.setup(), this.isSetUp = !0) : !r && this.isSetUp && (this.backend.teardown(), this.isSetUp = !1))
        }, this.store = e, this.monitor = n, e.subscribe(this.handleRefCountChange)
    }
}

function VOe(t, e) {
    return {
        x: t.x + e.x,
        y: t.y + e.y
    }
}

function mY(t, e) {
    return {
        x: t.x - e.x,
        y: t.y - e.y
    }
}

function jOe(t) {
    const {
        clientOffset: e,
        initialClientOffset: n,
        initialSourceClientOffset: r
    } = t;
    return !e || !n || !r ? null : mY(VOe(e, r), n)
}

function WOe(t) {
    const {
        clientOffset: e,
        initialClientOffset: n
    } = t;
    return !e || !n ? null : mY(e, n)
}
const Tv = [],
    zk = [];
Tv.__IS_NONE__ = !0;
zk.__IS_ALL__ = !0;

function KOe(t, e) {
    return t === Tv ? !1 : t === zk || typeof e > "u" ? !0 : xOe(e, t).length > 0
}
class qOe {
    subscribeToStateChange(e, n = {}) {
        const {
            handlerIds: r
        } = n;
        sn(typeof e == "function", "listener must be a function."), sn(typeof r > "u" || Array.isArray(r), "handlerIds, when specified, must be an array of strings.");
        let i = this.store.getState().stateId;
        const s = () => {
            const o = this.store.getState(),
                a = o.stateId;
            try {
                a === i || a === i + 1 && !KOe(o.dirtyHandlerIds, r) || e()
            } finally {
                i = a
            }
        };
        return this.store.subscribe(s)
    }
    subscribeToOffsetChange(e) {
        sn(typeof e == "function", "listener must be a function.");
        let n = this.store.getState().dragOffset;
        const r = () => {
            const i = this.store.getState().dragOffset;
            i !== n && (n = i, e())
        };
        return this.store.subscribe(r)
    }
    canDragSource(e) {
        if (!e) return !1;
        const n = this.registry.getSource(e);
        return sn(n, `Expected to find a valid source. sourceId=${e}`), this.isDragging() ? !1 : n.canDrag(this, e)
    }
    canDropOnTarget(e) {
        if (!e) return !1;
        const n = this.registry.getTarget(e);
        if (sn(n, `Expected to find a valid target. targetId=${e}`), !this.isDragging() || this.didDrop()) return !1;
        const r = this.registry.getTargetType(e),
            i = this.getItemType();
        return OR(r, i) && n.canDrop(this, e)
    }
    isDragging() {
        return !!this.getItemType()
    }
    isDraggingSource(e) {
        if (!e) return !1;
        const n = this.registry.getSource(e, !0);
        if (sn(n, `Expected to find a valid source. sourceId=${e}`), !this.isDragging() || !this.isSourcePublic()) return !1;
        const r = this.registry.getSourceType(e),
            i = this.getItemType();
        return r !== i ? !1 : n.isDragging(this, e)
    }
    isOverTarget(e, n = {
        shallow: !1
    }) {
        if (!e) return !1;
        const {
            shallow: r
        } = n;
        if (!this.isDragging()) return !1;
        const i = this.registry.getTargetType(e),
            s = this.getItemType();
        if (s && !OR(i, s)) return !1;
        const o = this.getTargetIds();
        if (!o.length) return !1;
        const a = o.indexOf(e);
        return r ? a === o.length - 1 : a > -1
    }
    getItemType() {
        return this.store.getState().dragOperation.itemType
    }
    getItem() {
        return this.store.getState().dragOperation.item
    }
    getSourceId() {
        return this.store.getState().dragOperation.sourceId
    }
    getTargetIds() {
        return this.store.getState().dragOperation.targetIds
    }
    getDropResult() {
        return this.store.getState().dragOperation.dropResult
    }
    didDrop() {
        return this.store.getState().dragOperation.didDrop
    }
    isSourcePublic() {
        return !!this.store.getState().dragOperation.isSourcePublic
    }
    getInitialClientOffset() {
        return this.store.getState().dragOffset.initialClientOffset
    }
    getInitialSourceClientOffset() {
        return this.store.getState().dragOffset.initialSourceClientOffset
    }
    getClientOffset() {
        return this.store.getState().dragOffset.clientOffset
    }
    getSourceClientOffset() {
        return jOe(this.store.getState().dragOffset)
    }
    getDifferenceFromInitialOffset() {
        return WOe(this.store.getState().dragOffset)
    }
    constructor(e, n) {
        this.store = e, this.registry = n
    }
}
const Jz = typeof global < "u" ? global : self,
    gY = Jz.MutationObserver || Jz.WebKitMutationObserver;

function yY(t) {
    return function() {
        const n = setTimeout(i, 0),
            r = setInterval(i, 50);

        function i() {
            clearTimeout(n), clearInterval(r), t()
        }
    }
}

function XOe(t) {
    let e = 1;
    const n = new gY(t),
        r = document.createTextNode("");
    return n.observe(r, {
            characterData: !0
        }),
        function() {
            e = -e, r.data = e
        }
}
const JOe = typeof gY == "function" ? XOe : yY;
class YOe {
    enqueueTask(e) {
        const {
            queue: n,
            requestFlush: r
        } = this;
        n.length || (r(), this.flushing = !0), n[n.length] = e
    }
    constructor() {
        this.queue = [], this.pendingErrors = [], this.flushing = !1, this.index = 0, this.capacity = 1024, this.flush = () => {
            const {
                queue: e
            } = this;
            for (; this.index < e.length;) {
                const n = this.index;
                if (this.index++, e[n].call(), this.index > this.capacity) {
                    for (let r = 0, i = e.length - this.index; r < i; r++) e[r] = e[r + this.index];
                    e.length -= this.index, this.index = 0
                }
            }
            e.length = 0, this.index = 0, this.flushing = !1
        }, this.registerPendingError = e => {
            this.pendingErrors.push(e), this.requestErrorThrow()
        }, this.requestFlush = JOe(this.flush), this.requestErrorThrow = yY(() => {
            if (this.pendingErrors.length) throw this.pendingErrors.shift()
        })
    }
}
class QOe {
    call() {
        try {
            this.task && this.task()
        } catch (e) {
            this.onError(e)
        } finally {
            this.task = null, this.release(this)
        }
    }
    constructor(e, n) {
        this.onError = e, this.release = n, this.task = null
    }
}
class ZOe {
    create(e) {
        const n = this.freeTasks,
            r = n.length ? n.pop() : new QOe(this.onError, i => n[n.length] = i);
        return r.task = e, r
    }
    constructor(e) {
        this.onError = e, this.freeTasks = []
    }
}
const vY = new YOe,
    eDe = new ZOe(vY.registerPendingError);

function tDe(t) {
    vY.enqueueTask(eDe.create(t))
}
const Hk = "dnd-core/ADD_SOURCE",
    Uk = "dnd-core/ADD_TARGET",
    $k = "dnd-core/REMOVE_SOURCE",
    NA = "dnd-core/REMOVE_TARGET";

function nDe(t) {
    return {
        type: Hk,
        payload: {
            sourceId: t
        }
    }
}

function rDe(t) {
    return {
        type: Uk,
        payload: {
            targetId: t
        }
    }
}

function iDe(t) {
    return {
        type: $k,
        payload: {
            sourceId: t
        }
    }
}

function sDe(t) {
    return {
        type: NA,
        payload: {
            targetId: t
        }
    }
}

function oDe(t) {
    sn(typeof t.canDrag == "function", "Expected canDrag to be a function."), sn(typeof t.beginDrag == "function", "Expected beginDrag to be a function."), sn(typeof t.endDrag == "function", "Expected endDrag to be a function.")
}

function aDe(t) {
    sn(typeof t.canDrop == "function", "Expected canDrop to be a function."), sn(typeof t.hover == "function", "Expected hover to be a function."), sn(typeof t.drop == "function", "Expected beginDrag to be a function.")
}

function DR(t, e) {
    if (e && Array.isArray(t)) {
        t.forEach(n => DR(n, !1));
        return
    }
    sn(typeof t == "string" || typeof t == "symbol", e ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.")
}
var Uo;
(function(t) {
    t.SOURCE = "SOURCE", t.TARGET = "TARGET"
})(Uo || (Uo = {}));
let lDe = 0;

function uDe() {
    return lDe++
}

function cDe(t) {
    const e = uDe().toString();
    switch (t) {
        case Uo.SOURCE:
            return `S${e}`;
        case Uo.TARGET:
            return `T${e}`;
        default:
            throw new Error(`Unknown Handler Role: ${t}`)
    }
}

function Yz(t) {
    switch (t[0]) {
        case "S":
            return Uo.SOURCE;
        case "T":
            return Uo.TARGET;
        default:
            throw new Error(`Cannot parse handler ID: ${t}`)
    }
}

function Qz(t, e) {
    const n = t.entries();
    let r = !1;
    do {
        const {
            done: i,
            value: [, s]
        } = n.next();
        if (s === e) return !0;
        r = !!i
    } while (!r);
    return !1
}
class fDe {
    addSource(e, n) {
        DR(e), oDe(n);
        const r = this.addHandler(Uo.SOURCE, e, n);
        return this.store.dispatch(nDe(r)), r
    }
    addTarget(e, n) {
        DR(e, !0), aDe(n);
        const r = this.addHandler(Uo.TARGET, e, n);
        return this.store.dispatch(rDe(r)), r
    }
    containsHandler(e) {
        return Qz(this.dragSources, e) || Qz(this.dropTargets, e)
    }
    getSource(e, n = !1) {
        return sn(this.isSourceId(e), "Expected a valid source ID."), n && e === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(e)
    }
    getTarget(e) {
        return sn(this.isTargetId(e), "Expected a valid target ID."), this.dropTargets.get(e)
    }
    getSourceType(e) {
        return sn(this.isSourceId(e), "Expected a valid source ID."), this.types.get(e)
    }
    getTargetType(e) {
        return sn(this.isTargetId(e), "Expected a valid target ID."), this.types.get(e)
    }
    isSourceId(e) {
        return Yz(e) === Uo.SOURCE
    }
    isTargetId(e) {
        return Yz(e) === Uo.TARGET
    }
    removeSource(e) {
        sn(this.getSource(e), "Expected an existing source."), this.store.dispatch(iDe(e)), tDe(() => {
            this.dragSources.delete(e), this.types.delete(e)
        })
    }
    removeTarget(e) {
        sn(this.getTarget(e), "Expected an existing target."), this.store.dispatch(sDe(e)), this.dropTargets.delete(e), this.types.delete(e)
    }
    pinSource(e) {
        const n = this.getSource(e);
        sn(n, "Expected an existing source."), this.pinnedSourceId = e, this.pinnedSource = n
    }
    unpinSource() {
        sn(this.pinnedSource, "No source is pinned at the time."), this.pinnedSourceId = null, this.pinnedSource = null
    }
    addHandler(e, n, r) {
        const i = cDe(e);
        return this.types.set(i, n), e === Uo.SOURCE ? this.dragSources.set(i, r) : e === Uo.TARGET && this.dropTargets.set(i, r), i
    }
    constructor(e) {
        this.types = new Map, this.dragSources = new Map, this.dropTargets = new Map, this.pinnedSourceId = null, this.pinnedSource = null, this.store = e
    }
}
const dDe = (t, e) => t === e;

function pDe(t, e) {
    return !t && !e ? !0 : !t || !e ? !1 : t.x === e.x && t.y === e.y
}

function hDe(t, e, n = dDe) {
    if (t.length !== e.length) return !1;
    for (let r = 0; r < t.length; ++r)
        if (!n(t[r], e[r])) return !1;
    return !0
}

function mDe(t = Tv, e) {
    switch (e.type) {
        case kA:
            break;
        case Hk:
        case Uk:
        case NA:
        case $k:
            return Tv;
        case LA:
        case Nk:
        case FA:
        case BA:
        default:
            return zk
    }
    const {
        targetIds: n = [],
        prevTargetIds: r = []
    } = e.payload, i = bOe(n, r);
    if (!(i.length > 0 || !hDe(n, r))) return Tv;
    const o = r[r.length - 1],
        a = n[n.length - 1];
    return o !== a && (o && i.push(o), a && i.push(a)), i
}

function gDe(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function yDe(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {},
            r = Object.keys(n);
        typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        }))), r.forEach(function(i) {
            gDe(t, i, n[i])
        })
    }
    return t
}
const Zz = {
    initialSourceClientOffset: null,
    initialClientOffset: null,
    clientOffset: null
};

function vDe(t = Zz, e) {
    const {
        payload: n
    } = e;
    switch (e.type) {
        case Fk:
        case LA:
            return {
                initialSourceClientOffset: n.sourceClientOffset,
                initialClientOffset: n.clientOffset,
                clientOffset: n.clientOffset
            };
        case kA:
            return pDe(t.clientOffset, n.clientOffset) ? t : yDe({}, t, {
                clientOffset: n.clientOffset
            });
        case FA:
        case BA:
            return Zz;
        default:
            return t
    }
}

function bDe(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function lh(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {},
            r = Object.keys(n);
        typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        }))), r.forEach(function(i) {
            bDe(t, i, n[i])
        })
    }
    return t
}
const xDe = {
    itemType: null,
    item: null,
    sourceId: null,
    targetIds: [],
    dropResult: null,
    didDrop: !1,
    isSourcePublic: null
};

function _De(t = xDe, e) {
    const {
        payload: n
    } = e;
    switch (e.type) {
        case LA:
            return lh({}, t, {
                itemType: n.itemType,
                item: n.item,
                sourceId: n.sourceId,
                isSourcePublic: n.isSourcePublic,
                dropResult: null,
                didDrop: !1
            });
        case Nk:
            return lh({}, t, {
                isSourcePublic: !0
            });
        case kA:
            return lh({}, t, {
                targetIds: n.targetIds
            });
        case NA:
            return t.targetIds.indexOf(n.targetId) === -1 ? t : lh({}, t, {
                targetIds: vOe(t.targetIds, n.targetId)
            });
        case BA:
            return lh({}, t, {
                dropResult: n.dropResult,
                didDrop: !0,
                targetIds: []
            });
        case FA:
            return lh({}, t, {
                itemType: null,
                item: null,
                sourceId: null,
                dropResult: null,
                didDrop: !1,
                isSourcePublic: null,
                targetIds: []
            });
        default:
            return t
    }
}

function SDe(t = 0, e) {
    switch (e.type) {
        case Hk:
        case Uk:
            return t + 1;
        case $k:
        case NA:
            return t - 1;
        default:
            return t
    }
}

function wDe(t = 0) {
    return t + 1
}

function EDe(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function ADe(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {},
            r = Object.keys(n);
        typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        }))), r.forEach(function(i) {
            EDe(t, i, n[i])
        })
    }
    return t
}

function CDe(t = {}, e) {
    return {
        dirtyHandlerIds: mDe(t.dirtyHandlerIds, {
            type: e.type,
            payload: ADe({}, e.payload, {
                prevTargetIds: yOe(t, "dragOperation.targetIds", [])
            })
        }),
        dragOffset: vDe(t.dragOffset, e),
        refCount: SDe(t.refCount, e),
        dragOperation: _De(t.dragOperation, e),
        stateId: wDe(t.stateId)
    }
}

function MDe(t, e = void 0, n = {}, r = !1) {
    const i = TDe(r),
        s = new qOe(i, new fDe(i)),
        o = new GOe(i, s),
        a = t(o, e, n);
    return o.receiveBackend(a), o
}

function TDe(t) {
    const e = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION__;
    return jD(CDe, t && e && e({
        name: "dnd-core",
        instanceId: "dnd-core"
    }))
}

function PDe(t, e) {
    if (t == null) return {};
    var n = IDe(t, e),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (i = 0; i < s.length; i++) r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
    }
    return n
}

function IDe(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}
let eH = 0;
const US = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var OUe = P.memo(function(e) {
    var {
        children: n
    } = e, r = PDe(e, ["children"]);
    const [i, s] = RDe(r);
    return P.useEffect(() => {
        if (s) {
            const o = bY();
            return ++eH, () => {
                --eH === 0 && (o[US] = null)
            }
        }
    }, []), gt(pY.Provider, {
        value: i,
        children: n
    })
});

function RDe(t) {
    if ("manager" in t) return [{
        dragDropManager: t.manager
    }, !1];
    const e = ODe(t.backend, t.context, t.options, t.debugMode),
        n = !t.context;
    return [e, n]
}

function ODe(t, e = bY(), n, r) {
    const i = e;
    return i[US] || (i[US] = {
        dragDropManager: MDe(t, e, n, r)
    }), i[US]
}

function bY() {
    return typeof global < "u" ? global : window
}
const fp = typeof window < "u" ? P.useLayoutEffect : P.useEffect;

function DDe(t, e, n) {
    const [r, i] = P.useState(() => e(t)), s = P.useCallback(() => {
        const o = e(t);
        Tse(r, o) || (i(o), n && n())
    }, [r, t, n]);
    return fp(s), [r, s]
}

function LDe(t, e, n) {
    const [r, i] = DDe(t, e, n);
    return fp(function() {
        const o = t.getHandlerId();
        if (o != null) return t.subscribeToStateChange(i, {
            handlerIds: [o]
        })
    }, [t, i]), r
}

function xY(t, e, n) {
    return LDe(e, t || (() => ({})), () => n.reconnect())
}

function _Y(t, e) {
    const n = [...e || []];
    return e == null && typeof t != "function" && n.push(t), P.useMemo(() => typeof t == "function" ? t() : t, n)
}

function kDe(t) {
    return P.useMemo(() => t.hooks.dragSource(), [t])
}

function BDe(t) {
    return P.useMemo(() => t.hooks.dragPreview(), [t])
}
let WT = !1,
    KT = !1;
class FDe {
    receiveHandlerId(e) {
        this.sourceId = e
    }
    getHandlerId() {
        return this.sourceId
    }
    canDrag() {
        sn(!WT, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
        try {
            return WT = !0, this.internalMonitor.canDragSource(this.sourceId)
        } finally {
            WT = !1
        }
    }
    isDragging() {
        if (!this.sourceId) return !1;
        sn(!KT, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
        try {
            return KT = !0, this.internalMonitor.isDraggingSource(this.sourceId)
        } finally {
            KT = !1
        }
    }
    subscribeToStateChange(e, n) {
        return this.internalMonitor.subscribeToStateChange(e, n)
    }
    isDraggingSource(e) {
        return this.internalMonitor.isDraggingSource(e)
    }
    isOverTarget(e, n) {
        return this.internalMonitor.isOverTarget(e, n)
    }
    getTargetIds() {
        return this.internalMonitor.getTargetIds()
    }
    isSourcePublic() {
        return this.internalMonitor.isSourcePublic()
    }
    getSourceId() {
        return this.internalMonitor.getSourceId()
    }
    subscribeToOffsetChange(e) {
        return this.internalMonitor.subscribeToOffsetChange(e)
    }
    canDragSource(e) {
        return this.internalMonitor.canDragSource(e)
    }
    canDropOnTarget(e) {
        return this.internalMonitor.canDropOnTarget(e)
    }
    getItemType() {
        return this.internalMonitor.getItemType()
    }
    getItem() {
        return this.internalMonitor.getItem()
    }
    getDropResult() {
        return this.internalMonitor.getDropResult()
    }
    didDrop() {
        return this.internalMonitor.didDrop()
    }
    getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset()
    }
    getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset()
    }
    getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset()
    }
    getClientOffset() {
        return this.internalMonitor.getClientOffset()
    }
    getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset()
    }
    constructor(e) {
        this.sourceId = null, this.internalMonitor = e.getMonitor()
    }
}
let qT = !1;
class NDe {
    receiveHandlerId(e) {
        this.targetId = e
    }
    getHandlerId() {
        return this.targetId
    }
    subscribeToStateChange(e, n) {
        return this.internalMonitor.subscribeToStateChange(e, n)
    }
    canDrop() {
        if (!this.targetId) return !1;
        sn(!qT, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
        try {
            return qT = !0, this.internalMonitor.canDropOnTarget(this.targetId)
        } finally {
            qT = !1
        }
    }
    isOver(e) {
        return this.targetId ? this.internalMonitor.isOverTarget(this.targetId, e) : !1
    }
    getItemType() {
        return this.internalMonitor.getItemType()
    }
    getItem() {
        return this.internalMonitor.getItem()
    }
    getDropResult() {
        return this.internalMonitor.getDropResult()
    }
    didDrop() {
        return this.internalMonitor.didDrop()
    }
    getInitialClientOffset() {
        return this.internalMonitor.getInitialClientOffset()
    }
    getInitialSourceClientOffset() {
        return this.internalMonitor.getInitialSourceClientOffset()
    }
    getSourceClientOffset() {
        return this.internalMonitor.getSourceClientOffset()
    }
    getClientOffset() {
        return this.internalMonitor.getClientOffset()
    }
    getDifferenceFromInitialOffset() {
        return this.internalMonitor.getDifferenceFromInitialOffset()
    }
    constructor(e) {
        this.targetId = null, this.internalMonitor = e.getMonitor()
    }
}

function zDe(t, e, n) {
    const r = n.getRegistry(),
        i = r.addTarget(t, e);
    return [i, () => r.removeTarget(i)]
}

function HDe(t, e, n) {
    const r = n.getRegistry(),
        i = r.addSource(t, e);
    return [i, () => r.removeSource(i)]
}

function LR(t, e, n, r) {
    let i = n ? n.call(r, t, e) : void 0;
    if (i !== void 0) return !!i;
    if (t === e) return !0;
    if (typeof t != "object" || !t || typeof e != "object" || !e) return !1;
    const s = Object.keys(t),
        o = Object.keys(e);
    if (s.length !== o.length) return !1;
    const a = Object.prototype.hasOwnProperty.bind(e);
    for (let l = 0; l < s.length; l++) {
        const u = s[l];
        if (!a(u)) return !1;
        const c = t[u],
            f = e[u];
        if (i = n ? n.call(r, c, f, u) : void 0, i === !1 || i === void 0 && c !== f) return !1
    }
    return !0
}

function kR(t) {
    return t !== null && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
}

function UDe(t) {
    if (typeof t.type == "string") return;
    const e = t.type.displayName || t.type.name || "the component";
    throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${e} into a <div>, or turn it into a drag source or a drop target itself.`)
}

function $De(t) {
    return (e = null, n = null) => {
        if (!P.isValidElement(e)) {
            const s = e;
            return t(s, n), s
        }
        const r = e;
        return UDe(r), GDe(r, n ? s => t(s, n) : t)
    }
}

function SY(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        const r = t[n];
        if (n.endsWith("Ref")) e[n] = t[n];
        else {
            const i = $De(r);
            e[n] = () => i
        }
    }), e
}

function tH(t, e) {
    typeof t == "function" ? t(e) : t.current = e
}

function GDe(t, e) {
    const n = t.ref;
    return sn(typeof n != "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"), n ? P.cloneElement(t, {
        ref: r => {
            tH(n, r), tH(e, r)
        }
    }) : P.cloneElement(t, {
        ref: e
    })
}
class VDe {
    receiveHandlerId(e) {
        this.handlerId !== e && (this.handlerId = e, this.reconnect())
    }
    get connectTarget() {
        return this.dragSource
    }
    get dragSourceOptions() {
        return this.dragSourceOptionsInternal
    }
    set dragSourceOptions(e) {
        this.dragSourceOptionsInternal = e
    }
    get dragPreviewOptions() {
        return this.dragPreviewOptionsInternal
    }
    set dragPreviewOptions(e) {
        this.dragPreviewOptionsInternal = e
    }
    reconnect() {
        const e = this.reconnectDragSource();
        this.reconnectDragPreview(e)
    }
    reconnectDragSource() {
        const e = this.dragSource,
            n = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
        return n && this.disconnectDragSource(), this.handlerId ? e ? (n && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragSource = e, this.lastConnectedDragSourceOptions = this.dragSourceOptions, this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, e, this.dragSourceOptions)), n) : (this.lastConnectedDragSource = e, n) : n
    }
    reconnectDragPreview(e = !1) {
        const n = this.dragPreview,
            r = e || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
        if (r && this.disconnectDragPreview(), !!this.handlerId) {
            if (!n) {
                this.lastConnectedDragPreview = n;
                return
            }
            r && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragPreview = n, this.lastConnectedDragPreviewOptions = this.dragPreviewOptions, this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, n, this.dragPreviewOptions))
        }
    }
    didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId
    }
    didConnectedDragSourceChange() {
        return this.lastConnectedDragSource !== this.dragSource
    }
    didConnectedDragPreviewChange() {
        return this.lastConnectedDragPreview !== this.dragPreview
    }
    didDragSourceOptionsChange() {
        return !LR(this.lastConnectedDragSourceOptions, this.dragSourceOptions)
    }
    didDragPreviewOptionsChange() {
        return !LR(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions)
    }
    disconnectDragSource() {
        this.dragSourceUnsubscribe && (this.dragSourceUnsubscribe(), this.dragSourceUnsubscribe = void 0)
    }
    disconnectDragPreview() {
        this.dragPreviewUnsubscribe && (this.dragPreviewUnsubscribe(), this.dragPreviewUnsubscribe = void 0, this.dragPreviewNode = null, this.dragPreviewRef = null)
    }
    get dragSource() {
        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current
    }
    get dragPreview() {
        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current
    }
    clearDragSource() {
        this.dragSourceNode = null, this.dragSourceRef = null
    }
    clearDragPreview() {
        this.dragPreviewNode = null, this.dragPreviewRef = null
    }
    constructor(e) {
        this.hooks = SY({
            dragSource: (n, r) => {
                this.clearDragSource(), this.dragSourceOptions = r || null, kR(n) ? this.dragSourceRef = n : this.dragSourceNode = n, this.reconnectDragSource()
            },
            dragPreview: (n, r) => {
                this.clearDragPreview(), this.dragPreviewOptions = r || null, kR(n) ? this.dragPreviewRef = n : this.dragPreviewNode = n, this.reconnectDragPreview()
            }
        }), this.handlerId = null, this.dragSourceRef = null, this.dragSourceOptionsInternal = null, this.dragPreviewRef = null, this.dragPreviewOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDragSource = null, this.lastConnectedDragSourceOptions = null, this.lastConnectedDragPreview = null, this.lastConnectedDragPreviewOptions = null, this.backend = e
    }
}
class jDe {
    get connectTarget() {
        return this.dropTarget
    }
    reconnect() {
        const e = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
        e && this.disconnectDropTarget();
        const n = this.dropTarget;
        if (this.handlerId) {
            if (!n) {
                this.lastConnectedDropTarget = n;
                return
            }
            e && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDropTarget = n, this.lastConnectedDropTargetOptions = this.dropTargetOptions, this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, n, this.dropTargetOptions))
        }
    }
    receiveHandlerId(e) {
        e !== this.handlerId && (this.handlerId = e, this.reconnect())
    }
    get dropTargetOptions() {
        return this.dropTargetOptionsInternal
    }
    set dropTargetOptions(e) {
        this.dropTargetOptionsInternal = e
    }
    didHandlerIdChange() {
        return this.lastConnectedHandlerId !== this.handlerId
    }
    didDropTargetChange() {
        return this.lastConnectedDropTarget !== this.dropTarget
    }
    didOptionsChange() {
        return !LR(this.lastConnectedDropTargetOptions, this.dropTargetOptions)
    }
    disconnectDropTarget() {
        this.unsubscribeDropTarget && (this.unsubscribeDropTarget(), this.unsubscribeDropTarget = void 0)
    }
    get dropTarget() {
        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current
    }
    clearDropTarget() {
        this.dropTargetRef = null, this.dropTargetNode = null
    }
    constructor(e) {
        this.hooks = SY({
            dropTarget: (n, r) => {
                this.clearDropTarget(), this.dropTargetOptions = r, kR(n) ? this.dropTargetRef = n : this.dropTargetNode = n, this.reconnect()
            }
        }), this.handlerId = null, this.dropTargetRef = null, this.dropTargetOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDropTarget = null, this.lastConnectedDropTargetOptions = null, this.backend = e
    }
}

function Dg() {
    const {
        dragDropManager: t
    } = P.useContext(pY);
    return sn(t != null, "Expected drag drop context"), t
}

function WDe(t, e) {
    const n = Dg(),
        r = P.useMemo(() => new VDe(n.getBackend()), [n]);
    return fp(() => (r.dragSourceOptions = t || null, r.reconnect(), () => r.disconnectDragSource()), [r, t]), fp(() => (r.dragPreviewOptions = e || null, r.reconnect(), () => r.disconnectDragPreview()), [r, e]), r
}

function KDe() {
    const t = Dg();
    return P.useMemo(() => new FDe(t), [t])
}
class qDe {
    beginDrag() {
        const e = this.spec,
            n = this.monitor;
        let r = null;
        return typeof e.item == "object" ? r = e.item : typeof e.item == "function" ? r = e.item(n) : r = {}, r ? ? null
    }
    canDrag() {
        const e = this.spec,
            n = this.monitor;
        return typeof e.canDrag == "boolean" ? e.canDrag : typeof e.canDrag == "function" ? e.canDrag(n) : !0
    }
    isDragging(e, n) {
        const r = this.spec,
            i = this.monitor,
            {
                isDragging: s
            } = r;
        return s ? s(i) : n === e.getSourceId()
    }
    endDrag() {
        const e = this.spec,
            n = this.monitor,
            r = this.connector,
            {
                end: i
            } = e;
        i && i(n.getItem(), n), r.reconnect()
    }
    constructor(e, n, r) {
        this.spec = e, this.monitor = n, this.connector = r
    }
}

function XDe(t, e, n) {
    const r = P.useMemo(() => new qDe(t, e, n), [e, n]);
    return P.useEffect(() => {
        r.spec = t
    }, [t]), r
}

function JDe(t) {
    return P.useMemo(() => {
        const e = t.type;
        return sn(e != null, "spec.type must be defined"), e
    }, [t])
}

function YDe(t, e, n) {
    const r = Dg(),
        i = XDe(t, e, n),
        s = JDe(t);
    fp(function() {
        if (s != null) {
            const [a, l] = HDe(s, i, r);
            return e.receiveHandlerId(a), n.receiveHandlerId(a), l
        }
    }, [r, e, n, i, s])
}

function DUe(t, e) {
    const n = _Y(t, e);
    sn(!n.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");
    const r = KDe(),
        i = WDe(n.options, n.previewOptions);
    return YDe(n, r, i), [xY(n.collect, r, i), kDe(i), BDe(i)]
}

function QDe(t) {
    return P.useMemo(() => t.hooks.dropTarget(), [t])
}

function ZDe(t) {
    const e = Dg(),
        n = P.useMemo(() => new jDe(e.getBackend()), [e]);
    return fp(() => (n.dropTargetOptions = t || null, n.reconnect(), () => n.disconnectDropTarget()), [t]), n
}

function eLe() {
    const t = Dg();
    return P.useMemo(() => new NDe(t), [t])
}

function tLe(t) {
    const {
        accept: e
    } = t;
    return P.useMemo(() => (sn(t.accept != null, "accept must be defined"), Array.isArray(e) ? e : [e]), [e])
}
class nLe {
    canDrop() {
        const e = this.spec,
            n = this.monitor;
        return e.canDrop ? e.canDrop(n.getItem(), n) : !0
    }
    hover() {
        const e = this.spec,
            n = this.monitor;
        e.hover && e.hover(n.getItem(), n)
    }
    drop() {
        const e = this.spec,
            n = this.monitor;
        if (e.drop) return e.drop(n.getItem(), n)
    }
    constructor(e, n) {
        this.spec = e, this.monitor = n
    }
}

function rLe(t, e) {
    const n = P.useMemo(() => new nLe(t, e), [e]);
    return P.useEffect(() => {
        n.spec = t
    }, [t]), n
}

function iLe(t, e, n) {
    const r = Dg(),
        i = rLe(t, e),
        s = tLe(t);
    fp(function() {
        const [a, l] = zDe(s, i, r);
        return e.receiveHandlerId(a), n.receiveHandlerId(a), l
    }, [r, e, i, n, s.map(o => o.toString()).join("|")])
}

function LUe(t, e) {
    const n = _Y(t, e),
        r = eLe(),
        i = ZDe(n.options);
    return iLe(n, r, i), [xY(n.collect, r, i), QDe(i)]
}
var wY = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
    (function() {
        var e = {}.hasOwnProperty;

        function n() {
            for (var s = "", o = 0; o < arguments.length; o++) {
                var a = arguments[o];
                a && (s = i(s, r(a)))
            }
            return s
        }

        function r(s) {
            if (typeof s == "string" || typeof s == "number") return s;
            if (typeof s != "object") return "";
            if (Array.isArray(s)) return n.apply(null, s);
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString();
            var o = "";
            for (var a in s) e.call(s, a) && s[a] && (o = i(o, a));
            return o
        }

        function i(s, o) {
            return o ? s ? s + " " + o : s + o : s
        }
        t.exports ? (n.default = n, t.exports = n) : window.classNames = n
    })()
})(wY);
var sLe = wY.exports;
const Gk = la(sLe);
var BR = {},
    oLe = function(e) {};

function aLe(t, e) {}

function lLe(t, e) {}

function uLe() {
    BR = {}
}

function EY(t, e, n) {
    !e && !BR[n] && (t(!1, n), BR[n] = !0)
}

function zA(t, e) {
    EY(aLe, t, e)
}

function cLe(t, e) {
    EY(lLe, t, e)
}
zA.preMessage = oLe;
zA.resetWarned = uLe;
zA.noteOnce = cLe;

function fLe(t) {
    return t instanceof HTMLElement || t instanceof SVGElement
}

function dLe(t) {
    return fLe(t) ? t : t instanceof Bt.Component ? kh.findDOMNode(t) : null
}

function AY(t, e, n) {
    var r = P.useRef({});
    return (!("value" in r.current) || n(r.current.condition, e)) && (r.current.value = t(), r.current.condition = e), r.current.value
}

function pLe(t, e) {
    typeof t == "function" ? t(e) : yi(t) === "object" && t && "current" in t && (t.current = e)
}

function hLe(t) {
    var e, n, r = dv.isMemo(t) ? t.type.type : t.type;
    return !(typeof r == "function" && !((e = r.prototype) !== null && e !== void 0 && e.render) && r.$$typeof !== dv.ForwardRef || typeof t == "function" && !((n = t.prototype) !== null && n !== void 0 && n.render) && t.$$typeof !== dv.ForwardRef)
}
var CY = function(e) {
        return +setTimeout(e, 16)
    },
    MY = function(e) {
        return clearTimeout(e)
    };
typeof window < "u" && "requestAnimationFrame" in window && (CY = function(e) {
    return window.requestAnimationFrame(e)
}, MY = function(e) {
    return window.cancelAnimationFrame(e)
});
var nH = 0,
    Vk = new Map;

function TY(t) {
    Vk.delete(t)
}
var FR = function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    nH += 1;
    var r = nH;

    function i(s) {
        if (s === 0) TY(r), e();
        else {
            var o = CY(function() {
                i(s - 1)
            });
            Vk.set(r, o)
        }
    }
    return i(n), r
};
FR.cancel = function(t) {
    var e = Vk.get(t);
    return TY(t), MY(e)
};

function u2(t) {
    for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4) n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, e = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
        case 3:
            e ^= (t.charCodeAt(r + 2) & 255) << 16;
        case 2:
            e ^= (t.charCodeAt(r + 1) & 255) << 8;
        case 1:
            e ^= t.charCodeAt(r) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16)
    }
    return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36)
}

function Hl() {
    return !!(typeof window < "u" && window.document && window.document.createElement)
}

function mLe(t, e) {
    if (!t) return !1;
    if (t.contains) return t.contains(e);
    for (var n = e; n;) {
        if (n === t) return !0;
        n = n.parentNode
    }
    return !1
}
var rH = "data-rc-order",
    iH = "data-rc-priority",
    gLe = "rc-util-key",
    NR = new Map;

function PY() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        e = t.mark;
    return e ? e.startsWith("data-") ? e : "data-".concat(e) : gLe
}

function HA(t) {
    if (t.attachTo) return t.attachTo;
    var e = document.querySelector("head");
    return e || document.body
}

function yLe(t) {
    return t === "queue" ? "prependQueue" : t ? "prepend" : "append"
}

function jk(t) {
    return Array.from((NR.get(t) || t).children).filter(function(e) {
        return e.tagName === "STYLE"
    })
}

function IY(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!Hl()) return null;
    var n = e.csp,
        r = e.prepend,
        i = e.priority,
        s = i === void 0 ? 0 : i,
        o = yLe(r),
        a = o === "prependQueue",
        l = document.createElement("style");
    l.setAttribute(rH, o), a && s && l.setAttribute(iH, "".concat(s)), n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce), l.innerHTML = t;
    var u = HA(e),
        c = u.firstChild;
    if (r) {
        if (a) {
            var f = (e.styles || jk(u)).filter(function(d) {
                if (!["prepend", "prependQueue"].includes(d.getAttribute(rH))) return !1;
                var p = Number(d.getAttribute(iH) || 0);
                return s >= p
            });
            if (f.length) return u.insertBefore(l, f[f.length - 1].nextSibling), l
        }
        u.insertBefore(l, c)
    } else u.appendChild(l);
    return l
}

function RY(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = HA(e);
    return (e.styles || jk(n)).find(function(r) {
        return r.getAttribute(PY(e)) === t
    })
}

function Wk(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = RY(t, e);
    if (n) {
        var r = HA(e);
        r.removeChild(n)
    }
}

function vLe(t, e) {
    var n = NR.get(t);
    if (!n || !mLe(document, n)) {
        var r = IY("", e),
            i = r.parentNode;
        NR.set(t, i), t.removeChild(r)
    }
}

function ng(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        r = HA(n),
        i = jk(r),
        s = et(et({}, n), {}, {
            styles: i
        });
    vLe(r, s);
    var o = RY(e, s);
    if (o) {
        var a, l;
        if ((a = s.csp) !== null && a !== void 0 && a.nonce && o.nonce !== ((l = s.csp) === null || l === void 0 ? void 0 : l.nonce)) {
            var u;
            o.nonce = (u = s.csp) === null || u === void 0 ? void 0 : u.nonce
        }
        return o.innerHTML !== t && (o.innerHTML = t), o
    }
    var c = IY(t, s);
    return c.setAttribute(PY(s), e), c
}

function bLe(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        r = new Set;

    function i(s, o) {
        var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
            l = r.has(s);
        if (zA(!l, "Warning: There may be circular references"), l) return !1;
        if (s === o) return !0;
        if (n && a > 1) return !1;
        r.add(s);
        var u = a + 1;
        if (Array.isArray(s)) {
            if (!Array.isArray(o) || s.length !== o.length) return !1;
            for (var c = 0; c < s.length; c++)
                if (!i(s[c], o[c], u)) return !1;
            return !0
        }
        if (s && o && yi(s) === "object" && yi(o) === "object") {
            var f = Object.keys(s);
            return f.length !== Object.keys(o).length ? !1 : f.every(function(d) {
                return i(s[d], o[d], u)
            })
        }
        return !1
    }
    return i(t, e)
}
var xLe = "%";

function zR(t) {
    return t.join(xLe)
}
var _Le = function() {
        function t(e) {
            Wu(this, t), En(this, "instanceId", void 0), En(this, "cache", new Map), this.instanceId = e
        }
        return Ku(t, [{
            key: "get",
            value: function(n) {
                return this.opGet(zR(n))
            }
        }, {
            key: "opGet",
            value: function(n) {
                return this.cache.get(n) || null
            }
        }, {
            key: "update",
            value: function(n, r) {
                return this.opUpdate(zR(n), r)
            }
        }, {
            key: "opUpdate",
            value: function(n, r) {
                var i = this.cache.get(n),
                    s = r(i);
                s === null ? this.cache.delete(n) : this.cache.set(n, s)
            }
        }]), t
    }(),
    rg = "data-token-hash",
    Va = "data-css-hash",
    Bc = "__cssinjs_instance__";

function SLe() {
    var t = Math.random().toString(12).slice(2);
    if (typeof document < "u" && document.head && document.body) {
        var e = document.body.querySelectorAll("style[".concat(Va, "]")) || [],
            n = document.head.firstChild;
        Array.from(e).forEach(function(i) {
            i[Bc] = i[Bc] || t, i[Bc] === t && document.head.insertBefore(i, n)
        });
        var r = {};
        Array.from(document.querySelectorAll("style[".concat(Va, "]"))).forEach(function(i) {
            var s = i.getAttribute(Va);
            if (r[s]) {
                if (i[Bc] === t) {
                    var o;
                    (o = i.parentNode) === null || o === void 0 || o.removeChild(i)
                }
            } else r[s] = !0
        })
    }
    return new _Le(t)
}
var wLe = P.createContext({
    hashPriority: "low",
    cache: SLe(),
    defaultCache: !0
});
const UA = wLe;

function ELe(t, e) {
    if (t.length !== e.length) return !1;
    for (var n = 0; n < t.length; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}
var Kk = function() {
    function t() {
        Wu(this, t), En(this, "cache", void 0), En(this, "keys", void 0), En(this, "cacheCallTimes", void 0), this.cache = new Map, this.keys = [], this.cacheCallTimes = 0
    }
    return Ku(t, [{
        key: "size",
        value: function() {
            return this.keys.length
        }
    }, {
        key: "internalGet",
        value: function(n) {
            var r, i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
                o = {
                    map: this.cache
                };
            return n.forEach(function(a) {
                if (!o) o = void 0;
                else {
                    var l;
                    o = (l = o) === null || l === void 0 || (l = l.map) === null || l === void 0 ? void 0 : l.get(a)
                }
            }), (r = o) !== null && r !== void 0 && r.value && s && (o.value[1] = this.cacheCallTimes++), (i = o) === null || i === void 0 ? void 0 : i.value
        }
    }, {
        key: "get",
        value: function(n) {
            var r;
            return (r = this.internalGet(n, !0)) === null || r === void 0 ? void 0 : r[0]
        }
    }, {
        key: "has",
        value: function(n) {
            return !!this.internalGet(n)
        }
    }, {
        key: "set",
        value: function(n, r) {
            var i = this;
            if (!this.has(n)) {
                if (this.size() + 1 > t.MAX_CACHE_SIZE + t.MAX_CACHE_OFFSET) {
                    var s = this.keys.reduce(function(u, c) {
                            var f = ln(u, 2),
                                d = f[1];
                            return i.internalGet(c)[1] < d ? [c, i.internalGet(c)[1]] : u
                        }, [this.keys[0], this.cacheCallTimes]),
                        o = ln(s, 1),
                        a = o[0];
                    this.delete(a)
                }
                this.keys.push(n)
            }
            var l = this.cache;
            n.forEach(function(u, c) {
                if (c === n.length - 1) l.set(u, {
                    value: [r, i.cacheCallTimes++]
                });
                else {
                    var f = l.get(u);
                    f ? f.map || (f.map = new Map) : l.set(u, {
                        map: new Map
                    }), l = l.get(u).map
                }
            })
        }
    }, {
        key: "deleteByPath",
        value: function(n, r) {
            var i = n.get(r[0]);
            if (r.length === 1) {
                var s;
                return i.map ? n.set(r[0], {
                    map: i.map
                }) : n.delete(r[0]), (s = i.value) === null || s === void 0 ? void 0 : s[0]
            }
            var o = this.deleteByPath(i.map, r.slice(1));
            return (!i.map || i.map.size === 0) && !i.value && n.delete(r[0]), o
        }
    }, {
        key: "delete",
        value: function(n) {
            if (this.has(n)) return this.keys = this.keys.filter(function(r) {
                return !ELe(r, n)
            }), this.deleteByPath(this.cache, n)
        }
    }]), t
}();
En(Kk, "MAX_CACHE_SIZE", 20);
En(Kk, "MAX_CACHE_OFFSET", 5);
var sH = 0,
    OY = function() {
        function t(e) {
            Wu(this, t), En(this, "derivatives", void 0), En(this, "id", void 0), this.derivatives = Array.isArray(e) ? e : [e], this.id = sH, e.length === 0 && (e.length > 0, void 0), sH += 1
        }
        return Ku(t, [{
            key: "getDerivativeToken",
            value: function(n) {
                return this.derivatives.reduce(function(r, i) {
                    return i(n, r)
                }, void 0)
            }
        }]), t
    }(),
    XT = new Kk;

function HR(t) {
    var e = Array.isArray(t) ? t : [t];
    return XT.has(e) || XT.set(e, new OY(e)), XT.get(e)
}
var ALe = new WeakMap,
    JT = {};

function CLe(t, e) {
    for (var n = ALe, r = 0; r < e.length; r += 1) {
        var i = e[r];
        n.has(i) || n.set(i, new WeakMap), n = n.get(i)
    }
    return n.has(JT) || n.set(JT, t()), n.get(JT)
}
var oH = new WeakMap;

function Pv(t) {
    var e = oH.get(t) || "";
    return e || (Object.keys(t).forEach(function(n) {
        var r = t[n];
        e += n, r instanceof OY ? e += r.id : r && yi(r) === "object" ? e += Pv(r) : e += r
    }), oH.set(t, e)), e
}

function aH(t, e) {
    return u2("".concat(e, "_").concat(Pv(t)))
}
var Iv = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, ""),
    DY = "_bAmBoO_";

function MLe(t, e, n) {
    if (Hl()) {
        var r, i;
        ng(t, Iv);
        var s = document.createElement("div");
        s.style.position = "fixed", s.style.left = "0", s.style.top = "0", e == null || e(s), document.body.appendChild(s);
        var o = n ? n(s) : (r = getComputedStyle(s).content) === null || r === void 0 ? void 0 : r.includes(DY);
        return (i = s.parentNode) === null || i === void 0 || i.removeChild(s), Wk(Iv), o
    }
    return !1
}
var YT = void 0;

function TLe() {
    return YT === void 0 && (YT = MLe("@layer ".concat(Iv, " { .").concat(Iv, ' { content: "').concat(DY, '"!important; } }'), function(t) {
        t.className = Iv
    })), YT
}
var UR = Hl();

function $R(t) {
    return typeof t == "number" ? "".concat(t, "px") : t
}

function c2(t, e, n) {
    var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
        i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    if (i) return t;
    var s = et(et({}, r), {}, En(En({}, rg, e), Va, n)),
        o = Object.keys(s).map(function(a) {
            var l = s[a];
            return l ? "".concat(a, '="').concat(l, '"') : null
        }).filter(function(a) {
            return a
        }).join(" ");
    return "<style ".concat(o, ">").concat(t, "</style>")
}
var LY = function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        return "--".concat(n ? "".concat(n, "-") : "").concat(e).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase()
    },
    PLe = function(e, n, r) {
        return Object.keys(e).length ? ".".concat(n).concat(r != null && r.scope ? ".".concat(r.scope) : "", "{").concat(Object.entries(e).map(function(i) {
            var s = ln(i, 2),
                o = s[0],
                a = s[1];
            return "".concat(o, ":").concat(a, ";")
        }).join(""), "}") : ""
    },
    kY = function(e, n, r) {
        var i = {},
            s = {};
        return Object.entries(e).forEach(function(o) {
            var a, l, u = ln(o, 2),
                c = u[0],
                f = u[1];
            if (r != null && (a = r.preserve) !== null && a !== void 0 && a[c]) s[c] = f;
            else if ((typeof f == "string" || typeof f == "number") && !(r != null && (l = r.ignore) !== null && l !== void 0 && l[c])) {
                var d, p = LY(c, r == null ? void 0 : r.prefix);
                i[p] = typeof f == "number" && !(r != null && (d = r.unitless) !== null && d !== void 0 && d[c]) ? "".concat(f, "px") : String(f), s[c] = "var(".concat(p, ")")
            }
        }), [s, PLe(i, n, {
            scope: r == null ? void 0 : r.scope
        })]
    },
    lH = Hl() ? P.useLayoutEffect : P.useEffect,
    ILe = function(e, n) {
        var r = P.useRef(!0);
        lH(function() {
            return e(r.current)
        }, n), lH(function() {
            return r.current = !1,
                function() {
                    r.current = !0
                }
        }, [])
    },
    RLe = et({}, Am),
    uH = RLe.useInsertionEffect,
    OLe = function(e, n, r) {
        P.useMemo(e, r), ILe(function() {
            return n(!0)
        }, r)
    },
    DLe = uH ? function(t, e, n) {
        return uH(function() {
            return t(), e()
        }, n)
    } : OLe;
const LLe = DLe;
var kLe = et({}, Am),
    BLe = kLe.useInsertionEffect,
    FLe = function(e) {
        var n = [],
            r = !1;

        function i(s) {
            r || n.push(s)
        }
        return P.useEffect(function() {
            return r = !1,
                function() {
                    r = !0, n.length && n.forEach(function(s) {
                        return s()
                    })
                }
        }, e), i
    },
    NLe = function() {
        return function(e) {
            e()
        }
    },
    zLe = typeof BLe < "u" ? FLe : NLe;
const HLe = zLe;

function qk(t, e, n, r, i) {
    var s = P.useContext(UA),
        o = s.cache,
        a = [t].concat(zl(e)),
        l = zR(a),
        u = HLe([l]),
        c = function(m) {
            o.opUpdate(l, function(y) {
                var v = y || [void 0, void 0],
                    b = ln(v, 2),
                    _ = b[0],
                    x = _ === void 0 ? 0 : _,
                    S = b[1],
                    E = S,
                    A = E || n(),
                    T = [x, A];
                return m ? m(T) : T
            })
        };
    P.useMemo(function() {
        c()
    }, [l]);
    var f = o.opGet(l),
        d = f[1];
    return LLe(function() {
        i == null || i(d)
    }, function(p) {
        return c(function(m) {
                var y = ln(m, 2),
                    v = y[0],
                    b = y[1];
                return p && v === 0 && (i == null || i(d)), [v + 1, b]
            }),
            function() {
                o.opUpdate(l, function(m) {
                    var y = m || [],
                        v = ln(y, 2),
                        b = v[0],
                        _ = b === void 0 ? 0 : b,
                        x = v[1],
                        S = _ - 1;
                    return S === 0 ? (u(function() {
                        (p || !o.opGet(l)) && (r == null || r(x, !1))
                    }), null) : [_ - 1, x]
                })
            }
    }, [l]), d
}
var ULe = {},
    $Le = "css",
    cd = new Map;

function GLe(t) {
    cd.set(t, (cd.get(t) || 0) + 1)
}

function VLe(t, e) {
    if (typeof document < "u") {
        var n = document.querySelectorAll("style[".concat(rg, '="').concat(t, '"]'));
        n.forEach(function(r) {
            if (r[Bc] === e) {
                var i;
                (i = r.parentNode) === null || i === void 0 || i.removeChild(r)
            }
        })
    }
}
var jLe = 0;

function WLe(t, e) {
    cd.set(t, (cd.get(t) || 0) - 1);
    var n = Array.from(cd.keys()),
        r = n.filter(function(i) {
            var s = cd.get(i) || 0;
            return s <= 0
        });
    n.length - r.length > jLe && r.forEach(function(i) {
        VLe(i, e), cd.delete(i)
    })
}
var KLe = function(e, n, r, i) {
        var s = r.getDerivativeToken(e),
            o = et(et({}, s), n);
        return i && (o = i(o)), o
    },
    BY = "token";

function qLe(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        r = P.useContext(UA),
        i = r.cache.instanceId,
        s = r.container,
        o = n.salt,
        a = o === void 0 ? "" : o,
        l = n.override,
        u = l === void 0 ? ULe : l,
        c = n.formatToken,
        f = n.getComputedToken,
        d = n.cssVar,
        p = CLe(function() {
            return Object.assign.apply(Object, [{}].concat(zl(e)))
        }, e),
        m = Pv(p),
        y = Pv(u),
        v = d ? Pv(d) : "",
        b = qk(BY, [a, t.id, m, y, v], function() {
            var _, x = f ? f(p, u, t) : KLe(p, u, t, c),
                S = et({}, x),
                E = "";
            if (d) {
                var A = kY(x, d.key, {
                        prefix: d.prefix,
                        ignore: d.ignore,
                        unitless: d.unitless,
                        preserve: d.preserve
                    }),
                    T = ln(A, 2);
                x = T[0], E = T[1]
            }
            var M = aH(x, a);
            x._tokenKey = M, S._tokenKey = aH(S, a);
            var I = (_ = d == null ? void 0 : d.key) !== null && _ !== void 0 ? _ : M;
            x._themeKey = I, GLe(I);
            var O = "".concat($Le, "-").concat(u2(M));
            return x._hashId = O, [x, O, S, E, (d == null ? void 0 : d.key) || ""]
        }, function(_) {
            WLe(_[0]._themeKey, i)
        }, function(_) {
            var x = ln(_, 4),
                S = x[0],
                E = x[3];
            if (d && E) {
                var A = ng(E, u2("css-variables-".concat(S._themeKey)), {
                    mark: Va,
                    prepend: "queue",
                    attachTo: s,
                    priority: -999
                });
                A[Bc] = i, A.setAttribute(rg, S._themeKey)
            }
        });
    return b
}
var XLe = function(e, n, r) {
        var i = ln(e, 5),
            s = i[2],
            o = i[3],
            a = i[4],
            l = r || {},
            u = l.plain;
        if (!o) return null;
        var c = s._tokenKey,
            f = -999,
            d = {
                "data-rc-order": "prependQueue",
                "data-rc-priority": "".concat(f)
            },
            p = c2(o, a, c, d, u);
        return [f, c, p]
    },
    JLe = {
        animationIterationCount: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    },
    cH = "data-ant-cssinjs-cache-path",
    FY = "_FILE_STYLE__",
    $d, NY = !0;

function YLe() {
    if (!$d && ($d = {}, Hl())) {
        var t = document.createElement("div");
        t.className = cH, t.style.position = "fixed", t.style.visibility = "hidden", t.style.top = "-9999px", document.body.appendChild(t);
        var e = getComputedStyle(t).content || "";
        e = e.replace(/^"/, "").replace(/"$/, ""), e.split(";").forEach(function(i) {
            var s = i.split(":"),
                o = ln(s, 2),
                a = o[0],
                l = o[1];
            $d[a] = l
        });
        var n = document.querySelector("style[".concat(cH, "]"));
        if (n) {
            var r;
            NY = !1, (r = n.parentNode) === null || r === void 0 || r.removeChild(n)
        }
        document.body.removeChild(t)
    }
}

function QLe(t) {
    return YLe(), !!$d[t]
}

function ZLe(t) {
    var e = $d[t],
        n = null;
    if (e && Hl())
        if (NY) n = FY;
        else {
            var r = document.querySelector("style[".concat(Va, '="').concat($d[t], '"]'));
            r ? n = r.innerHTML : delete $d[t]
        }
    return [n, e]
}
var e4e = "_skip_check_",
    zY = "_multi_value_";

function GR(t) {
    var e = zd(Hq(t), Uq);
    return e.replace(/\{%%%\:[^;];}/g, ";")
}

function t4e(t) {
    return yi(t) === "object" && t && (e4e in t || zY in t)
}

function n4e(t, e, n) {
    if (!e) return t;
    var r = ".".concat(e),
        i = n === "low" ? ":where(".concat(r, ")") : r,
        s = t.split(",").map(function(o) {
            var a, l = o.trim().split(/\s+/),
                u = l[0] || "",
                c = ((a = u.match(/^\w+/)) === null || a === void 0 ? void 0 : a[0]) || "";
            return u = "".concat(c).concat(i).concat(u.slice(c.length)), [u].concat(zl(l.slice(1))).join(" ")
        });
    return s.join(",")
}
var r4e = function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            root: !0,
            parentSelectors: []
        },
        i = r.root,
        s = r.injectHash,
        o = r.parentSelectors,
        a = n.hashId,
        l = n.layer;
    n.path;
    var u = n.hashPriority,
        c = n.transformers,
        f = c === void 0 ? [] : c;
    n.linters;
    var d = "",
        p = {};

    function m(x) {
        var S = x.getName(a);
        if (!p[S]) {
            var E = t(x.style, n, {
                    root: !1,
                    parentSelectors: o
                }),
                A = ln(E, 1),
                T = A[0];
            p[S] = "@keyframes ".concat(x.getName(a)).concat(T)
        }
    }

    function y(x) {
        var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        return x.forEach(function(E) {
            Array.isArray(E) ? y(E, S) : E && S.push(E)
        }), S
    }
    var v = y(Array.isArray(e) ? e : [e]);
    if (v.forEach(function(x) {
            var S = typeof x == "string" && !i ? {} : x;
            if (typeof S == "string") d += "".concat(S, `
`);
            else if (S._keyframe) m(S);
            else {
                var E = f.reduce(function(A, T) {
                    var M;
                    return (T == null || (M = T.visit) === null || M === void 0 ? void 0 : M.call(T, A)) || A
                }, S);
                Object.keys(E).forEach(function(A) {
                    var T = E[A];
                    if (yi(T) === "object" && T && (A !== "animationName" || !T._keyframe) && !t4e(T)) {
                        var M = !1,
                            I = A.trim(),
                            O = !1;
                        (i || s) && a ? I.startsWith("@") ? M = !0 : I = n4e(A, a, u) : i && !a && (I === "&" || I === "") && (I = "", O = !0);
                        var k = t(T, n, {
                                root: O,
                                injectHash: M,
                                parentSelectors: [].concat(zl(o), [I])
                            }),
                            H = ln(k, 2),
                            N = H[0],
                            B = H[1];
                        p = et(et({}, p), B), d += "".concat(I).concat(N)
                    } else {
                        let Q = function(F, G) {
                            var W = F.replace(/[A-Z]/g, function(ee) {
                                    return "-".concat(ee.toLowerCase())
                                }),
                                se = G;
                            !JLe[F] && typeof se == "number" && se !== 0 && (se = "".concat(se, "px")), F === "animationName" && G !== null && G !== void 0 && G._keyframe && (m(G), se = G.getName(a)), d += "".concat(W, ":").concat(se, ";")
                        };
                        var U, q = (U = T == null ? void 0 : T.value) !== null && U !== void 0 ? U : T;
                        yi(T) === "object" && T !== null && T !== void 0 && T[zY] && Array.isArray(q) ? q.forEach(function(F) {
                            Q(A, F)
                        }) : Q(A, q)
                    }
                })
            }
        }), !i) d = "{".concat(d, "}");
    else if (l && TLe()) {
        var b = l.split(","),
            _ = b[b.length - 1].trim();
        d = "@layer ".concat(_, " {").concat(d, "}"), b.length > 1 && (d = "@layer ".concat(l, "{%%%:%}").concat(d))
    }
    return [d, p]
};

function HY(t, e) {
    return u2("".concat(t.join("%")).concat(e))
}

function i4e() {
    return null
}
var UY = "style";

function VR(t, e) {
    var n = t.token,
        r = t.path,
        i = t.hashId,
        s = t.layer,
        o = t.nonce,
        a = t.clientOnly,
        l = t.order,
        u = l === void 0 ? 0 : l,
        c = P.useContext(UA),
        f = c.autoClear;
    c.mock;
    var d = c.defaultCache,
        p = c.hashPriority,
        m = c.container,
        y = c.ssrInline,
        v = c.transformers,
        b = c.linters,
        _ = c.cache,
        x = n._tokenKey,
        S = [x].concat(zl(r)),
        E = UR,
        A = qk(UY, S, function() {
            var k = S.join("|");
            if (QLe(k)) {
                var H = ZLe(k),
                    N = ln(H, 2),
                    B = N[0],
                    U = N[1];
                if (B) return [B, x, U, {}, a, u]
            }
            var q = e(),
                Q = r4e(q, {
                    hashId: i,
                    hashPriority: p,
                    layer: s,
                    path: r.join("-"),
                    transformers: v,
                    linters: b
                }),
                F = ln(Q, 2),
                G = F[0],
                W = F[1],
                se = GR(G),
                ee = HY(S, se);
            return [se, x, ee, W, a, u]
        }, function(k, H) {
            var N = ln(k, 3),
                B = N[2];
            (H || f) && UR && Wk(B, {
                mark: Va
            })
        }, function(k) {
            var H = ln(k, 4),
                N = H[0];
            H[1];
            var B = H[2],
                U = H[3];
            if (E && N !== FY) {
                var q = {
                        mark: Va,
                        prepend: "queue",
                        attachTo: m,
                        priority: u
                    },
                    Q = typeof o == "function" ? o() : o;
                Q && (q.csp = {
                    nonce: Q
                });
                var F = ng(N, B, q);
                F[Bc] = _.instanceId, F.setAttribute(rg, x), Object.keys(U).forEach(function(G) {
                    ng(GR(U[G]), "_effect-".concat(G), q)
                })
            }
        }),
        T = ln(A, 3),
        M = T[0],
        I = T[1],
        O = T[2];
    return function(k) {
        var H;
        return !y || E || !d ? H = P.createElement(i4e, null) : H = P.createElement("style", Y({}, En(En({}, rg, I), Va, O), {
            dangerouslySetInnerHTML: {
                __html: M
            }
        })), P.createElement(P.Fragment, null, H, k)
    }
}
var s4e = function(e, n, r) {
        var i = ln(e, 6),
            s = i[0],
            o = i[1],
            a = i[2],
            l = i[3],
            u = i[4],
            c = i[5],
            f = r || {},
            d = f.plain;
        if (u) return null;
        var p = s,
            m = {
                "data-rc-order": "prependQueue",
                "data-rc-priority": "".concat(c)
            };
        return p = c2(s, o, a, m, d), l && Object.keys(l).forEach(function(y) {
            if (!n[y]) {
                n[y] = !0;
                var v = GR(l[y]);
                p += c2(v, o, "_effect-".concat(y), m, d)
            }
        }), [c, a, p]
    },
    $Y = "cssVar",
    o4e = function(e, n) {
        var r = e.key,
            i = e.prefix,
            s = e.unitless,
            o = e.ignore,
            a = e.token,
            l = e.scope,
            u = l === void 0 ? "" : l,
            c = P.useContext(UA),
            f = c.cache.instanceId,
            d = c.container,
            p = a._tokenKey,
            m = [].concat(zl(e.path), [r, u, p]),
            y = qk($Y, m, function() {
                var v = n(),
                    b = kY(v, r, {
                        prefix: i,
                        unitless: s,
                        ignore: o,
                        scope: u
                    }),
                    _ = ln(b, 2),
                    x = _[0],
                    S = _[1],
                    E = HY(m, S);
                return [x, S, E, r]
            }, function(v) {
                var b = ln(v, 3),
                    _ = b[2];
                UR && Wk(_, {
                    mark: Va
                })
            }, function(v) {
                var b = ln(v, 3),
                    _ = b[1],
                    x = b[2];
                if (_) {
                    var S = ng(_, x, {
                        mark: Va,
                        prepend: "queue",
                        attachTo: d,
                        priority: -999
                    });
                    S[Bc] = f, S.setAttribute(rg, r)
                }
            });
        return y
    },
    a4e = function(e, n, r) {
        var i = ln(e, 4),
            s = i[1],
            o = i[2],
            a = i[3],
            l = r || {},
            u = l.plain;
        if (!s) return null;
        var c = -999,
            f = {
                "data-rc-order": "prependQueue",
                "data-rc-priority": "".concat(c)
            },
            d = c2(s, a, o, f, u);
        return [c, o, d]
    };
En(En(En({}, UY, s4e), BY, XLe), $Y, a4e);

function uh(t) {
    return t.notSplit = !0, t
}
uh(["borderTop", "borderBottom"]), uh(["borderTop"]), uh(["borderBottom"]), uh(["borderLeft", "borderRight"]), uh(["borderLeft"]), uh(["borderRight"]);
var l4e = P.createContext({});
const u4e = l4e;

function c4e(t) {
    return Iq(t) || Dq(t) || O4(t) || Rq()
}

function jR(t, e) {
    for (var n = t, r = 0; r < e.length; r += 1) {
        if (n == null) return;
        n = n[e[r]]
    }
    return n
}

function GY(t, e, n, r) {
    if (!e.length) return n;
    var i = c4e(e),
        s = i[0],
        o = i.slice(1),
        a;
    return !t && typeof s == "number" ? a = [] : Array.isArray(t) ? a = zl(t) : a = et({}, t), r && n === void 0 && o.length === 1 ? delete a[s][o[0]] : a[s] = GY(a[s], o, n, r), a
}

function QT(t, e, n) {
    var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return e.length && r && n === void 0 && !jR(t, e.slice(0, -1)) ? t : GY(t, e, n, r)
}

function f4e(t) {
    return yi(t) === "object" && t !== null && Object.getPrototypeOf(t) === Object.prototype
}

function fH(t) {
    return Array.isArray(t) ? [] : {}
}
var d4e = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;

function p4e() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    var r = fH(e[0]);
    return e.forEach(function(i) {
        function s(o, a) {
            var l = new Set(a),
                u = jR(i, o),
                c = Array.isArray(u);
            if (c || f4e(u)) {
                if (!l.has(u)) {
                    l.add(u);
                    var f = jR(r, o);
                    c ? r = QT(r, o, []) : (!f || yi(f) !== "object") && (r = QT(r, o, fH(u))), d4e(u).forEach(function(d) {
                        s([].concat(zl(o), [d]), l)
                    })
                }
            } else r = QT(r, o, u)
        }
        s([])
    }), r
}
const h4e = P.createContext({}),
    m4e = P.createContext(void 0);
var g4e = {
        items_per_page: "/ page",
        jump_to: "Go to",
        jump_to_confirm: "confirm",
        page: "Page",
        prev_page: "Previous Page",
        next_page: "Next Page",
        prev_5: "Previous 5 Pages",
        next_5: "Next 5 Pages",
        prev_3: "Previous 3 Pages",
        next_3: "Next 3 Pages",
        page_size: "Page Size"
    },
    y4e = {
        locale: "en_US",
        today: "Today",
        now: "Now",
        backToToday: "Back to today",
        ok: "OK",
        clear: "Clear",
        month: "Month",
        year: "Year",
        timeSelect: "select time",
        dateSelect: "select date",
        weekSelect: "Choose a week",
        monthSelect: "Choose a month",
        yearSelect: "Choose a year",
        decadeSelect: "Choose a decade",
        yearFormat: "YYYY",
        dateFormat: "M/D/YYYY",
        dayFormat: "D",
        dateTimeFormat: "M/D/YYYY HH:mm:ss",
        monthBeforeYear: !0,
        previousMonth: "Previous month (PageUp)",
        nextMonth: "Next month (PageDown)",
        previousYear: "Last year (Control + left)",
        nextYear: "Next year (Control + right)",
        previousDecade: "Last decade",
        nextDecade: "Next decade",
        previousCentury: "Last century",
        nextCentury: "Next century"
    };
const v4e = {
        placeholder: "Select time",
        rangePlaceholder: ["Start time", "End time"]
    },
    VY = v4e,
    b4e = {
        lang: Object.assign({
            placeholder: "Select date",
            yearPlaceholder: "Select year",
            quarterPlaceholder: "Select quarter",
            monthPlaceholder: "Select month",
            weekPlaceholder: "Select week",
            rangePlaceholder: ["Start date", "End date"],
            rangeYearPlaceholder: ["Start year", "End year"],
            rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
            rangeMonthPlaceholder: ["Start month", "End month"],
            rangeWeekPlaceholder: ["Start week", "End week"]
        }, y4e),
        timePickerLocale: Object.assign({}, VY)
    },
    dH = b4e,
    eo = "${label} is not a valid ${type}",
    x4e = {
        locale: "en",
        Pagination: g4e,
        DatePicker: dH,
        TimePicker: VY,
        Calendar: dH,
        global: {
            placeholder: "Please select"
        },
        Table: {
            filterTitle: "Filter menu",
            filterConfirm: "OK",
            filterReset: "Reset",
            filterEmptyText: "No filters",
            filterCheckall: "Select all items",
            filterSearchPlaceholder: "Search in filters",
            emptyText: "No data",
            selectAll: "Select current page",
            selectInvert: "Invert current page",
            selectNone: "Clear all data",
            selectionAll: "Select all data",
            sortTitle: "Sort",
            expand: "Expand row",
            collapse: "Collapse row",
            triggerDesc: "Click to sort descending",
            triggerAsc: "Click to sort ascending",
            cancelSort: "Click to cancel sorting"
        },
        Tour: {
            Next: "Next",
            Previous: "Previous",
            Finish: "Finish"
        },
        Modal: {
            okText: "OK",
            cancelText: "Cancel",
            justOkText: "OK"
        },
        Popconfirm: {
            okText: "OK",
            cancelText: "Cancel"
        },
        Transfer: {
            titles: ["", ""],
            searchPlaceholder: "Search here",
            itemUnit: "item",
            itemsUnit: "items",
            remove: "Remove",
            selectCurrent: "Select current page",
            removeCurrent: "Remove current page",
            selectAll: "Select all data",
            removeAll: "Remove all data",
            selectInvert: "Invert current page"
        },
        Upload: {
            uploading: "Uploading...",
            removeFile: "Remove file",
            uploadError: "Upload error",
            previewFile: "Preview file",
            downloadFile: "Download file"
        },
        Empty: {
            description: "No data"
        },
        Icon: {
            icon: "icon"
        },
        Text: {
            edit: "Edit",
            copy: "Copy",
            copied: "Copied",
            expand: "Expand"
        },
        Form: {
            optional: "(optional)",
            defaultValidateMessages: {
                default: "Field validation error for ${label}",
                required: "Please enter ${label}",
                enum: "${label} must be one of [${enum}]",
                whitespace: "${label} cannot be a blank character",
                date: {
                    format: "${label} date format is invalid",
                    parse: "${label} cannot be converted to a date",
                    invalid: "${label} is an invalid date"
                },
                types: {
                    string: eo,
                    method: eo,
                    array: eo,
                    object: eo,
                    number: eo,
                    date: eo,
                    boolean: eo,
                    integer: eo,
                    float: eo,
                    regexp: eo,
                    email: eo,
                    url: eo,
                    hex: eo
                },
                string: {
                    len: "${label} must be ${len} characters",
                    min: "${label} must be at least ${min} characters",
                    max: "${label} must be up to ${max} characters",
                    range: "${label} must be between ${min}-${max} characters"
                },
                number: {
                    len: "${label} must be equal to ${len}",
                    min: "${label} must be minimum ${min}",
                    max: "${label} must be maximum ${max}",
                    range: "${label} must be between ${min}-${max}"
                },
                array: {
                    len: "Must be ${len} ${label}",
                    min: "At least ${min} ${label}",
                    max: "At most ${max} ${label}",
                    range: "The amount of ${label} must be between ${min}-${max}"
                },
                pattern: {
                    mismatch: "${label} does not match the pattern ${pattern}"
                }
            }
        },
        Image: {
            preview: "Preview"
        },
        QRCode: {
            expired: "QR code expired",
            refresh: "Refresh",
            scanned: "Scanned"
        },
        ColorPicker: {
            presetEmpty: "Empty"
        }
    },
    $A = x4e;
Object.assign({}, $A.Modal);
let $S = [];
const pH = () => $S.reduce((t, e) => Object.assign(Object.assign({}, t), e), $A.Modal);

function _4e(t) {
    if (t) {
        const e = Object.assign({}, t);
        return $S.push(e), pH(), () => {
            $S = $S.filter(n => n !== e), pH()
        }
    }
    Object.assign({}, $A.Modal)
}
const S4e = P.createContext(void 0),
    jY = S4e,
    w4e = "internalMark",
    E4e = t => {
        const {
            locale: e = {},
            children: n,
            _ANT_MARK__: r
        } = t;
        P.useEffect(() => _4e(e && e.Modal), [e]);
        const i = P.useMemo(() => Object.assign(Object.assign({}, e), {
            exist: !0
        }), [e]);
        return P.createElement(jY.Provider, {
            value: i
        }, n)
    },
    A4e = E4e;

function $i(t, e) {
    C4e(t) && (t = "100%");
    var n = M4e(t);
    return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)), t)
}

function R_(t) {
    return Math.min(1, Math.max(0, t))
}

function C4e(t) {
    return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1
}

function M4e(t) {
    return typeof t == "string" && t.indexOf("%") !== -1
}

function WY(t) {
    return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
}

function O_(t) {
    return t <= 1 ? "".concat(Number(t) * 100, "%") : t
}

function Pd(t) {
    return t.length === 1 ? "0" + t : String(t)
}

function T4e(t, e, n) {
    return {
        r: $i(t, 255) * 255,
        g: $i(e, 255) * 255,
        b: $i(n, 255) * 255
    }
}

function hH(t, e, n) {
    t = $i(t, 255), e = $i(e, 255), n = $i(n, 255);
    var r = Math.max(t, e, n),
        i = Math.min(t, e, n),
        s = 0,
        o = 0,
        a = (r + i) / 2;
    if (r === i) o = 0, s = 0;
    else {
        var l = r - i;
        switch (o = a > .5 ? l / (2 - r - i) : l / (r + i), r) {
            case t:
                s = (e - n) / l + (e < n ? 6 : 0);
                break;
            case e:
                s = (n - t) / l + 2;
                break;
            case n:
                s = (t - e) / l + 4;
                break
        }
        s /= 6
    }
    return {
        h: s,
        s: o,
        l: a
    }
}

function ZT(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}

function P4e(t, e, n) {
    var r, i, s;
    if (t = $i(t, 360), e = $i(e, 100), n = $i(n, 100), e === 0) i = n, s = n, r = n;
    else {
        var o = n < .5 ? n * (1 + e) : n + e - n * e,
            a = 2 * n - o;
        r = ZT(a, o, t + 1 / 3), i = ZT(a, o, t), s = ZT(a, o, t - 1 / 3)
    }
    return {
        r: r * 255,
        g: i * 255,
        b: s * 255
    }
}

function WR(t, e, n) {
    t = $i(t, 255), e = $i(e, 255), n = $i(n, 255);
    var r = Math.max(t, e, n),
        i = Math.min(t, e, n),
        s = 0,
        o = r,
        a = r - i,
        l = r === 0 ? 0 : a / r;
    if (r === i) s = 0;
    else {
        switch (r) {
            case t:
                s = (e - n) / a + (e < n ? 6 : 0);
                break;
            case e:
                s = (n - t) / a + 2;
                break;
            case n:
                s = (t - e) / a + 4;
                break
        }
        s /= 6
    }
    return {
        h: s,
        s: l,
        v: o
    }
}

function I4e(t, e, n) {
    t = $i(t, 360) * 6, e = $i(e, 100), n = $i(n, 100);
    var r = Math.floor(t),
        i = t - r,
        s = n * (1 - e),
        o = n * (1 - i * e),
        a = n * (1 - (1 - i) * e),
        l = r % 6,
        u = [n, o, s, s, a, n][l],
        c = [a, n, n, o, s, s][l],
        f = [s, s, a, n, n, o][l];
    return {
        r: u * 255,
        g: c * 255,
        b: f * 255
    }
}

function KR(t, e, n, r) {
    var i = [Pd(Math.round(t).toString(16)), Pd(Math.round(e).toString(16)), Pd(Math.round(n).toString(16))];
    return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
}

function R4e(t, e, n, r, i) {
    var s = [Pd(Math.round(t).toString(16)), Pd(Math.round(e).toString(16)), Pd(Math.round(n).toString(16)), Pd(O4e(r))];
    return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
}

function O4e(t) {
    return Math.round(parseFloat(t) * 255).toString(16)
}

function mH(t) {
    return to(t) / 255
}

function to(t) {
    return parseInt(t, 16)
}

function D4e(t) {
    return {
        r: t >> 16,
        g: (t & 65280) >> 8,
        b: t & 255
    }
}
var qR = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};

function bh(t) {
    var e = {
            r: 0,
            g: 0,
            b: 0
        },
        n = 1,
        r = null,
        i = null,
        s = null,
        o = !1,
        a = !1;
    return typeof t == "string" && (t = B4e(t)), typeof t == "object" && (au(t.r) && au(t.g) && au(t.b) ? (e = T4e(t.r, t.g, t.b), o = !0, a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : au(t.h) && au(t.s) && au(t.v) ? (r = O_(t.s), i = O_(t.v), e = I4e(t.h, r, i), o = !0, a = "hsv") : au(t.h) && au(t.s) && au(t.l) && (r = O_(t.s), s = O_(t.l), e = P4e(t.h, r, s), o = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)), n = WY(n), {
        ok: o,
        format: t.format || a,
        r: Math.min(255, Math.max(e.r, 0)),
        g: Math.min(255, Math.max(e.g, 0)),
        b: Math.min(255, Math.max(e.b, 0)),
        a: n
    }
}
var L4e = "[-\\+]?\\d+%?",
    k4e = "[-\\+]?\\d*\\.\\d+%?",
    Fc = "(?:".concat(k4e, ")|(?:").concat(L4e, ")"),
    eP = "[\\s|\\(]+(".concat(Fc, ")[,|\\s]+(").concat(Fc, ")[,|\\s]+(").concat(Fc, ")\\s*\\)?"),
    tP = "[\\s|\\(]+(".concat(Fc, ")[,|\\s]+(").concat(Fc, ")[,|\\s]+(").concat(Fc, ")[,|\\s]+(").concat(Fc, ")\\s*\\)?"),
    _a = {
        CSS_UNIT: new RegExp(Fc),
        rgb: new RegExp("rgb" + eP),
        rgba: new RegExp("rgba" + tP),
        hsl: new RegExp("hsl" + eP),
        hsla: new RegExp("hsla" + tP),
        hsv: new RegExp("hsv" + eP),
        hsva: new RegExp("hsva" + tP),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };

function B4e(t) {
    if (t = t.trim().toLowerCase(), t.length === 0) return !1;
    var e = !1;
    if (qR[t]) t = qR[t], e = !0;
    else if (t === "transparent") return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
    };
    var n = _a.rgb.exec(t);
    return n ? {
        r: n[1],
        g: n[2],
        b: n[3]
    } : (n = _a.rgba.exec(t), n ? {
        r: n[1],
        g: n[2],
        b: n[3],
        a: n[4]
    } : (n = _a.hsl.exec(t), n ? {
        h: n[1],
        s: n[2],
        l: n[3]
    } : (n = _a.hsla.exec(t), n ? {
        h: n[1],
        s: n[2],
        l: n[3],
        a: n[4]
    } : (n = _a.hsv.exec(t), n ? {
        h: n[1],
        s: n[2],
        v: n[3]
    } : (n = _a.hsva.exec(t), n ? {
        h: n[1],
        s: n[2],
        v: n[3],
        a: n[4]
    } : (n = _a.hex8.exec(t), n ? {
        r: to(n[1]),
        g: to(n[2]),
        b: to(n[3]),
        a: mH(n[4]),
        format: e ? "name" : "hex8"
    } : (n = _a.hex6.exec(t), n ? {
        r: to(n[1]),
        g: to(n[2]),
        b: to(n[3]),
        format: e ? "name" : "hex"
    } : (n = _a.hex4.exec(t), n ? {
        r: to(n[1] + n[1]),
        g: to(n[2] + n[2]),
        b: to(n[3] + n[3]),
        a: mH(n[4] + n[4]),
        format: e ? "name" : "hex8"
    } : (n = _a.hex3.exec(t), n ? {
        r: to(n[1] + n[1]),
        g: to(n[2] + n[2]),
        b: to(n[3] + n[3]),
        format: e ? "name" : "hex"
    } : !1)))))))))
}

function au(t) {
    return !!_a.CSS_UNIT.exec(String(t))
}
var ao = function() {
        function t(e, n) {
            e === void 0 && (e = ""), n === void 0 && (n = {});
            var r;
            if (e instanceof t) return e;
            typeof e == "number" && (e = D4e(e)), this.originalInput = e;
            var i = bh(e);
            this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = n.format) !== null && r !== void 0 ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok
        }
        return t.prototype.isDark = function() {
            return this.getBrightness() < 128
        }, t.prototype.isLight = function() {
            return !this.isDark()
        }, t.prototype.getBrightness = function() {
            var e = this.toRgb();
            return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3
        }, t.prototype.getLuminance = function() {
            var e = this.toRgb(),
                n, r, i, s = e.r / 255,
                o = e.g / 255,
                a = e.b / 255;
            return s <= .03928 ? n = s / 12.92 : n = Math.pow((s + .055) / 1.055, 2.4), o <= .03928 ? r = o / 12.92 : r = Math.pow((o + .055) / 1.055, 2.4), a <= .03928 ? i = a / 12.92 : i = Math.pow((a + .055) / 1.055, 2.4), .2126 * n + .7152 * r + .0722 * i
        }, t.prototype.getAlpha = function() {
            return this.a
        }, t.prototype.setAlpha = function(e) {
            return this.a = WY(e), this.roundA = Math.round(100 * this.a) / 100, this
        }, t.prototype.isMonochrome = function() {
            var e = this.toHsl().s;
            return e === 0
        }, t.prototype.toHsv = function() {
            var e = WR(this.r, this.g, this.b);
            return {
                h: e.h * 360,
                s: e.s,
                v: e.v,
                a: this.a
            }
        }, t.prototype.toHsvString = function() {
            var e = WR(this.r, this.g, this.b),
                n = Math.round(e.h * 360),
                r = Math.round(e.s * 100),
                i = Math.round(e.v * 100);
            return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")")
        }, t.prototype.toHsl = function() {
            var e = hH(this.r, this.g, this.b);
            return {
                h: e.h * 360,
                s: e.s,
                l: e.l,
                a: this.a
            }
        }, t.prototype.toHslString = function() {
            var e = hH(this.r, this.g, this.b),
                n = Math.round(e.h * 360),
                r = Math.round(e.s * 100),
                i = Math.round(e.l * 100);
            return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")")
        }, t.prototype.toHex = function(e) {
            return e === void 0 && (e = !1), KR(this.r, this.g, this.b, e)
        }, t.prototype.toHexString = function(e) {
            return e === void 0 && (e = !1), "#" + this.toHex(e)
        }, t.prototype.toHex8 = function(e) {
            return e === void 0 && (e = !1), R4e(this.r, this.g, this.b, this.a, e)
        }, t.prototype.toHex8String = function(e) {
            return e === void 0 && (e = !1), "#" + this.toHex8(e)
        }, t.prototype.toHexShortString = function(e) {
            return e === void 0 && (e = !1), this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
        }, t.prototype.toRgb = function() {
            return {
                r: Math.round(this.r),
                g: Math.round(this.g),
                b: Math.round(this.b),
                a: this.a
            }
        }, t.prototype.toRgbString = function() {
            var e = Math.round(this.r),
                n = Math.round(this.g),
                r = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")")
        }, t.prototype.toPercentageRgb = function() {
            var e = function(n) {
                return "".concat(Math.round($i(n, 255) * 100), "%")
            };
            return {
                r: e(this.r),
                g: e(this.g),
                b: e(this.b),
                a: this.a
            }
        }, t.prototype.toPercentageRgbString = function() {
            var e = function(n) {
                return Math.round($i(n, 255) * 100)
            };
            return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")")
        }, t.prototype.toName = function() {
            if (this.a === 0) return "transparent";
            if (this.a < 1) return !1;
            for (var e = "#" + KR(this.r, this.g, this.b, !1), n = 0, r = Object.entries(qR); n < r.length; n++) {
                var i = r[n],
                    s = i[0],
                    o = i[1];
                if (e === o) return s
            }
            return !1
        }, t.prototype.toString = function(e) {
            var n = !!e;
            e = e ? ? this.format;
            var r = !1,
                i = this.a < 1 && this.a >= 0,
                s = !n && i && (e.startsWith("hex") || e === "name");
            return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()), e === "prgb" && (r = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (r = this.toHexString()), e === "hex3" && (r = this.toHexString(!0)), e === "hex4" && (r = this.toHex8String(!0)), e === "hex8" && (r = this.toHex8String()), e === "name" && (r = this.toName()), e === "hsl" && (r = this.toHslString()), e === "hsv" && (r = this.toHsvString()), r || this.toHexString())
        }, t.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
        }, t.prototype.clone = function() {
            return new t(this.toString())
        }, t.prototype.lighten = function(e) {
            e === void 0 && (e = 10);
            var n = this.toHsl();
            return n.l += e / 100, n.l = R_(n.l), new t(n)
        }, t.prototype.brighten = function(e) {
            e === void 0 && (e = 10);
            var n = this.toRgb();
            return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))), new t(n)
        }, t.prototype.darken = function(e) {
            e === void 0 && (e = 10);
            var n = this.toHsl();
            return n.l -= e / 100, n.l = R_(n.l), new t(n)
        }, t.prototype.tint = function(e) {
            return e === void 0 && (e = 10), this.mix("white", e)
        }, t.prototype.shade = function(e) {
            return e === void 0 && (e = 10), this.mix("black", e)
        }, t.prototype.desaturate = function(e) {
            e === void 0 && (e = 10);
            var n = this.toHsl();
            return n.s -= e / 100, n.s = R_(n.s), new t(n)
        }, t.prototype.saturate = function(e) {
            e === void 0 && (e = 10);
            var n = this.toHsl();
            return n.s += e / 100, n.s = R_(n.s), new t(n)
        }, t.prototype.greyscale = function() {
            return this.desaturate(100)
        }, t.prototype.spin = function(e) {
            var n = this.toHsl(),
                r = (n.h + e) % 360;
            return n.h = r < 0 ? 360 + r : r, new t(n)
        }, t.prototype.mix = function(e, n) {
            n === void 0 && (n = 50);
            var r = this.toRgb(),
                i = new t(e).toRgb(),
                s = n / 100,
                o = {
                    r: (i.r - r.r) * s + r.r,
                    g: (i.g - r.g) * s + r.g,
                    b: (i.b - r.b) * s + r.b,
                    a: (i.a - r.a) * s + r.a
                };
            return new t(o)
        }, t.prototype.analogous = function(e, n) {
            e === void 0 && (e = 6), n === void 0 && (n = 30);
            var r = this.toHsl(),
                i = 360 / n,
                s = [this];
            for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e;) r.h = (r.h + i) % 360, s.push(new t(r));
            return s
        }, t.prototype.complement = function() {
            var e = this.toHsl();
            return e.h = (e.h + 180) % 360, new t(e)
        }, t.prototype.monochromatic = function(e) {
            e === void 0 && (e = 6);
            for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / e; e--;) o.push(new t({
                h: r,
                s: i,
                v: s
            })), s = (s + a) % 1;
            return o
        }, t.prototype.splitcomplement = function() {
            var e = this.toHsl(),
                n = e.h;
            return [this, new t({
                h: (n + 72) % 360,
                s: e.s,
                l: e.l
            }), new t({
                h: (n + 216) % 360,
                s: e.s,
                l: e.l
            })]
        }, t.prototype.onBackground = function(e) {
            var n = this.toRgb(),
                r = new t(e).toRgb(),
                i = n.a + r.a * (1 - n.a);
            return new t({
                r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
                g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
                b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
                a: i
            })
        }, t.prototype.triad = function() {
            return this.polyad(3)
        }, t.prototype.tetrad = function() {
            return this.polyad(4)
        }, t.prototype.polyad = function(e) {
            for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / e, o = 1; o < e; o++) i.push(new t({
                h: (r + o * s) % 360,
                s: n.s,
                l: n.l
            }));
            return i
        }, t.prototype.equals = function(e) {
            return this.toRgbString() === new t(e).toRgbString()
        }, t
    }(),
    D_ = 2,
    gH = .16,
    F4e = .05,
    N4e = .05,
    z4e = .15,
    KY = 5,
    qY = 4,
    H4e = [{
        index: 7,
        opacity: .15
    }, {
        index: 6,
        opacity: .25
    }, {
        index: 5,
        opacity: .3
    }, {
        index: 5,
        opacity: .45
    }, {
        index: 5,
        opacity: .65
    }, {
        index: 5,
        opacity: .85
    }, {
        index: 4,
        opacity: .9
    }, {
        index: 3,
        opacity: .95
    }, {
        index: 2,
        opacity: .97
    }, {
        index: 1,
        opacity: .98
    }];

function yH(t) {
    var e = t.r,
        n = t.g,
        r = t.b,
        i = WR(e, n, r);
    return {
        h: i.h * 360,
        s: i.s,
        v: i.v
    }
}

function L_(t) {
    var e = t.r,
        n = t.g,
        r = t.b;
    return "#".concat(KR(e, n, r, !1))
}

function U4e(t, e, n) {
    var r = n / 100,
        i = {
            r: (e.r - t.r) * r + t.r,
            g: (e.g - t.g) * r + t.g,
            b: (e.b - t.b) * r + t.b
        };
    return i
}

function vH(t, e, n) {
    var r;
    return Math.round(t.h) >= 60 && Math.round(t.h) <= 240 ? r = n ? Math.round(t.h) - D_ * e : Math.round(t.h) + D_ * e : r = n ? Math.round(t.h) + D_ * e : Math.round(t.h) - D_ * e, r < 0 ? r += 360 : r >= 360 && (r -= 360), r
}

function bH(t, e, n) {
    if (t.h === 0 && t.s === 0) return t.s;
    var r;
    return n ? r = t.s - gH * e : e === qY ? r = t.s + gH : r = t.s + F4e * e, r > 1 && (r = 1), n && e === KY && r > .1 && (r = .1), r < .06 && (r = .06), Number(r.toFixed(2))
}

function xH(t, e, n) {
    var r;
    return n ? r = t.v + N4e * e : r = t.v - z4e * e, r > 1 && (r = 1), Number(r.toFixed(2))
}

function ig(t) {
    for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], r = bh(t), i = KY; i > 0; i -= 1) {
        var s = yH(r),
            o = L_(bh({
                h: vH(s, i, !0),
                s: bH(s, i, !0),
                v: xH(s, i, !0)
            }));
        n.push(o)
    }
    n.push(L_(r));
    for (var a = 1; a <= qY; a += 1) {
        var l = yH(r),
            u = L_(bh({
                h: vH(l, a),
                s: bH(l, a),
                v: xH(l, a)
            }));
        n.push(u)
    }
    return e.theme === "dark" ? H4e.map(function(c) {
        var f = c.index,
            d = c.opacity,
            p = L_(U4e(bh(e.backgroundColor || "#141414"), bh(n[f]), d * 100));
        return p
    }) : n
}
var nP = {
        red: "#F5222D",
        volcano: "#FA541C",
        orange: "#FA8C16",
        gold: "#FAAD14",
        yellow: "#FADB14",
        lime: "#A0D911",
        green: "#52C41A",
        cyan: "#13C2C2",
        blue: "#1677FF",
        geekblue: "#2F54EB",
        purple: "#722ED1",
        magenta: "#EB2F96",
        grey: "#666666"
    },
    rP = {},
    iP = {};
Object.keys(nP).forEach(function(t) {
    rP[t] = ig(nP[t]), rP[t].primary = rP[t][5], iP[t] = ig(nP[t], {
        theme: "dark",
        backgroundColor: "#141414"
    }), iP[t].primary = iP[t][5]
});
const $4e = t => {
        const {
            controlHeight: e
        } = t;
        return {
            controlHeightSM: e * .75,
            controlHeightXS: e * .5,
            controlHeightLG: e * 1.25
        }
    },
    G4e = $4e;

function V4e(t) {
    const {
        sizeUnit: e,
        sizeStep: n
    } = t;
    return {
        sizeXXL: e * (n + 8),
        sizeXL: e * (n + 4),
        sizeLG: e * (n + 2),
        sizeMD: e * (n + 1),
        sizeMS: e * n,
        size: e * n,
        sizeSM: e * (n - 1),
        sizeXS: e * (n - 2),
        sizeXXS: e * (n - 3)
    }
}
const XY = {
        blue: "#1677ff",
        purple: "#722ED1",
        cyan: "#13C2C2",
        green: "#52C41A",
        magenta: "#EB2F96",
        pink: "#eb2f96",
        red: "#F5222D",
        orange: "#FA8C16",
        yellow: "#FADB14",
        volcano: "#FA541C",
        geekblue: "#2F54EB",
        gold: "#FAAD14",
        lime: "#A0D911"
    },
    j4e = Object.assign(Object.assign({}, XY), {
        colorPrimary: "#1677ff",
        colorSuccess: "#52c41a",
        colorWarning: "#faad14",
        colorError: "#ff4d4f",
        colorInfo: "#1677ff",
        colorLink: "",
        colorTextBase: "",
        colorBgBase: "",
        fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
        fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
        fontSize: 14,
        lineWidth: 1,
        lineType: "solid",
        motionUnit: .1,
        motionBase: 0,
        motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
        motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
        motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
        motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
        motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
        motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
        motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
        motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
        borderRadius: 6,
        sizeUnit: 4,
        sizeStep: 4,
        sizePopupArrow: 16,
        controlHeight: 32,
        zIndexBase: 0,
        zIndexPopupBase: 1e3,
        opacityImage: 1,
        wireframe: !1,
        motion: !0
    }),
    F0 = j4e;

function W4e(t, e) {
    let {
        generateColorPalettes: n,
        generateNeutralColorPalettes: r
    } = e;
    const {
        colorSuccess: i,
        colorWarning: s,
        colorError: o,
        colorInfo: a,
        colorPrimary: l,
        colorBgBase: u,
        colorTextBase: c
    } = t, f = n(l), d = n(i), p = n(s), m = n(o), y = n(a), v = r(u, c), b = t.colorLink || t.colorInfo, _ = n(b);
    return Object.assign(Object.assign({}, v), {
        colorPrimaryBg: f[1],
        colorPrimaryBgHover: f[2],
        colorPrimaryBorder: f[3],
        colorPrimaryBorderHover: f[4],
        colorPrimaryHover: f[5],
        colorPrimary: f[6],
        colorPrimaryActive: f[7],
        colorPrimaryTextHover: f[8],
        colorPrimaryText: f[9],
        colorPrimaryTextActive: f[10],
        colorSuccessBg: d[1],
        colorSuccessBgHover: d[2],
        colorSuccessBorder: d[3],
        colorSuccessBorderHover: d[4],
        colorSuccessHover: d[4],
        colorSuccess: d[6],
        colorSuccessActive: d[7],
        colorSuccessTextHover: d[8],
        colorSuccessText: d[9],
        colorSuccessTextActive: d[10],
        colorErrorBg: m[1],
        colorErrorBgHover: m[2],
        colorErrorBorder: m[3],
        colorErrorBorderHover: m[4],
        colorErrorHover: m[5],
        colorError: m[6],
        colorErrorActive: m[7],
        colorErrorTextHover: m[8],
        colorErrorText: m[9],
        colorErrorTextActive: m[10],
        colorWarningBg: p[1],
        colorWarningBgHover: p[2],
        colorWarningBorder: p[3],
        colorWarningBorderHover: p[4],
        colorWarningHover: p[4],
        colorWarning: p[6],
        colorWarningActive: p[7],
        colorWarningTextHover: p[8],
        colorWarningText: p[9],
        colorWarningTextActive: p[10],
        colorInfoBg: y[1],
        colorInfoBgHover: y[2],
        colorInfoBorder: y[3],
        colorInfoBorderHover: y[4],
        colorInfoHover: y[4],
        colorInfo: y[6],
        colorInfoActive: y[7],
        colorInfoTextHover: y[8],
        colorInfoText: y[9],
        colorInfoTextActive: y[10],
        colorLinkHover: _[4],
        colorLink: _[6],
        colorLinkActive: _[7],
        colorBgMask: new ao("#000").setAlpha(.45).toRgbString(),
        colorWhite: "#fff"
    })
}
const K4e = t => {
        let e = t,
            n = t,
            r = t,
            i = t;
        return t < 6 && t >= 5 ? e = t + 1 : t < 16 && t >= 6 ? e = t + 2 : t >= 16 && (e = 16), t < 7 && t >= 5 ? n = 4 : t < 8 && t >= 7 ? n = 5 : t < 14 && t >= 8 ? n = 6 : t < 16 && t >= 14 ? n = 7 : t >= 16 && (n = 8), t < 6 && t >= 2 ? r = 1 : t >= 6 && (r = 2), t > 4 && t < 8 ? i = 4 : t >= 8 && (i = 6), {
            borderRadius: t,
            borderRadiusXS: r,
            borderRadiusSM: n,
            borderRadiusLG: e,
            borderRadiusOuter: i
        }
    },
    q4e = K4e;

function X4e(t) {
    const {
        motionUnit: e,
        motionBase: n,
        borderRadius: r,
        lineWidth: i
    } = t;
    return Object.assign({
        motionDurationFast: `${(n+e).toFixed(1)}s`,
        motionDurationMid: `${(n+e*2).toFixed(1)}s`,
        motionDurationSlow: `${(n+e*3).toFixed(1)}s`,
        lineWidthBold: i + 1
    }, q4e(r))
}
const lu = (t, e) => new ao(t).setAlpha(e).toRgbString(),
    Ry = (t, e) => new ao(t).darken(e).toHexString(),
    J4e = t => {
        const e = ig(t);
        return {
            1: e[0],
            2: e[1],
            3: e[2],
            4: e[3],
            5: e[4],
            6: e[5],
            7: e[6],
            8: e[4],
            9: e[5],
            10: e[6]
        }
    },
    Y4e = (t, e) => {
        const n = t || "#fff",
            r = e || "#000";
        return {
            colorBgBase: n,
            colorTextBase: r,
            colorText: lu(r, .88),
            colorTextSecondary: lu(r, .65),
            colorTextTertiary: lu(r, .45),
            colorTextQuaternary: lu(r, .25),
            colorFill: lu(r, .15),
            colorFillSecondary: lu(r, .06),
            colorFillTertiary: lu(r, .04),
            colorFillQuaternary: lu(r, .02),
            colorBgLayout: Ry(n, 4),
            colorBgContainer: Ry(n, 0),
            colorBgElevated: Ry(n, 0),
            colorBgSpotlight: lu(r, .85),
            colorBgBlur: "transparent",
            colorBorder: Ry(n, 15),
            colorBorderSecondary: Ry(n, 6)
        }
    };

function Q4e(t) {
    return (t + 8) / t
}

function Z4e(t) {
    const e = new Array(10).fill(null).map((n, r) => {
        const i = r - 1,
            s = t * Math.pow(2.71828, i / 5),
            o = r > 1 ? Math.floor(s) : Math.ceil(s);
        return Math.floor(o / 2) * 2
    });
    return e[1] = t, e.map(n => ({
        size: n,
        lineHeight: Q4e(n)
    }))
}
const eke = t => {
        const e = Z4e(t),
            n = e.map(c => c.size),
            r = e.map(c => c.lineHeight),
            i = n[1],
            s = n[0],
            o = n[2],
            a = r[1],
            l = r[0],
            u = r[2];
        return {
            fontSizeSM: s,
            fontSize: i,
            fontSizeLG: o,
            fontSizeXL: n[3],
            fontSizeHeading1: n[6],
            fontSizeHeading2: n[5],
            fontSizeHeading3: n[4],
            fontSizeHeading4: n[3],
            fontSizeHeading5: n[2],
            lineHeight: a,
            lineHeightLG: u,
            lineHeightSM: l,
            fontHeight: Math.round(a * i),
            fontHeightLG: Math.round(u * o),
            fontHeightSM: Math.round(l * s),
            lineHeightHeading1: r[6],
            lineHeightHeading2: r[5],
            lineHeightHeading3: r[4],
            lineHeightHeading4: r[3],
            lineHeightHeading5: r[2]
        }
    },
    tke = eke;

function nke(t) {
    const e = Object.keys(XY).map(n => {
        const r = ig(t[n]);
        return new Array(10).fill(1).reduce((i, s, o) => (i[`${n}-${o+1}`] = r[o], i[`${n}${o+1}`] = r[o], i), {})
    }).reduce((n, r) => (n = Object.assign(Object.assign({}, n), r), n), {});
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, t), e), W4e(t, {
        generateColorPalettes: J4e,
        generateNeutralColorPalettes: Y4e
    })), tke(t.fontSize)), V4e(t)), G4e(t)), X4e(t))
}
const JY = HR(nke),
    XR = {
        token: F0,
        override: {
            override: F0
        },
        hashed: !0
    },
    YY = Bt.createContext(XR),
    QY = "anticon",
    rke = (t, e) => e || (t ? `ant-${t}` : "ant"),
    Lg = P.createContext({
        getPrefixCls: rke,
        iconPrefixCls: QY
    }),
    ike = `-ant-${Date.now()}-${Math.random()}`;

function ske(t, e) {
    const n = {},
        r = (o, a) => {
            let l = o.clone();
            return l = (a == null ? void 0 : a(l)) || l, l.toRgbString()
        },
        i = (o, a) => {
            const l = new ao(o),
                u = ig(l.toRgbString());
            n[`${a}-color`] = r(l), n[`${a}-color-disabled`] = u[1], n[`${a}-color-hover`] = u[4], n[`${a}-color-active`] = u[6], n[`${a}-color-outline`] = l.clone().setAlpha(.2).toRgbString(), n[`${a}-color-deprecated-bg`] = u[0], n[`${a}-color-deprecated-border`] = u[2]
        };
    if (e.primaryColor) {
        i(e.primaryColor, "primary");
        const o = new ao(e.primaryColor),
            a = ig(o.toRgbString());
        a.forEach((u, c) => {
            n[`primary-${c+1}`] = u
        }), n["primary-color-deprecated-l-35"] = r(o, u => u.lighten(35)), n["primary-color-deprecated-l-20"] = r(o, u => u.lighten(20)), n["primary-color-deprecated-t-20"] = r(o, u => u.tint(20)), n["primary-color-deprecated-t-50"] = r(o, u => u.tint(50)), n["primary-color-deprecated-f-12"] = r(o, u => u.setAlpha(u.getAlpha() * .12));
        const l = new ao(a[0]);
        n["primary-color-active-deprecated-f-30"] = r(l, u => u.setAlpha(u.getAlpha() * .3)), n["primary-color-active-deprecated-d-02"] = r(l, u => u.darken(2))
    }
    return e.successColor && i(e.successColor, "success"), e.warningColor && i(e.warningColor, "warning"), e.errorColor && i(e.errorColor, "error"), e.infoColor && i(e.infoColor, "info"), `
  :root {
    ${Object.keys(n).map(o=>`--${t}-${o}: ${n[o]};`).join(`
`)}
  }
  `.trim()
}

function oke(t, e) {
    const n = ske(t, e);
    Hl() && ng(n, `${ike}-dynamic-theme`)
}
const JR = P.createContext(!1),
    ake = t => {
        let {
            children: e,
            disabled: n
        } = t;
        const r = P.useContext(JR);
        return P.createElement(JR.Provider, {
            value: n ? ? r
        }, e)
    },
    lke = JR,
    YR = P.createContext(void 0),
    uke = t => {
        let {
            children: e,
            size: n
        } = t;
        const r = P.useContext(YR);
        return P.createElement(YR.Provider, {
            value: n || r
        }, e)
    },
    Xk = YR;

function cke() {
    const t = P.useContext(lke),
        e = P.useContext(Xk);
    return {
        componentDisabled: t,
        componentSize: e
    }
}
const fke = "5.15.4";

function sP(t) {
    return t >= 0 && t <= 255
}

function k_(t, e) {
    const {
        r: n,
        g: r,
        b: i,
        a: s
    } = new ao(t).toRgb();
    if (s < 1) return t;
    const {
        r: o,
        g: a,
        b: l
    } = new ao(e).toRgb();
    for (let u = .01; u <= 1; u += .01) {
        const c = Math.round((n - o * (1 - u)) / u),
            f = Math.round((r - a * (1 - u)) / u),
            d = Math.round((i - l * (1 - u)) / u);
        if (sP(c) && sP(f) && sP(d)) return new ao({
            r: c,
            g: f,
            b: d,
            a: Math.round(u * 100) / 100
        }).toRgbString()
    }
    return new ao({
        r: n,
        g: r,
        b: i,
        a: 1
    }).toRgbString()
}
var dke = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
};

function ZY(t) {
    const {
        override: e
    } = t, n = dke(t, ["override"]), r = Object.assign({}, e);
    Object.keys(F0).forEach(d => {
        delete r[d]
    });
    const i = Object.assign(Object.assign({}, n), r),
        s = 480,
        o = 576,
        a = 768,
        l = 992,
        u = 1200,
        c = 1600;
    if (i.motion === !1) {
        const d = "0s";
        i.motionDurationFast = d, i.motionDurationMid = d, i.motionDurationSlow = d
    }
    return Object.assign(Object.assign(Object.assign({}, i), {
        colorFillContent: i.colorFillSecondary,
        colorFillContentHover: i.colorFill,
        colorFillAlter: i.colorFillQuaternary,
        colorBgContainerDisabled: i.colorFillTertiary,
        colorBorderBg: i.colorBgContainer,
        colorSplit: k_(i.colorBorderSecondary, i.colorBgContainer),
        colorTextPlaceholder: i.colorTextQuaternary,
        colorTextDisabled: i.colorTextQuaternary,
        colorTextHeading: i.colorText,
        colorTextLabel: i.colorTextSecondary,
        colorTextDescription: i.colorTextTertiary,
        colorTextLightSolid: i.colorWhite,
        colorHighlight: i.colorError,
        colorBgTextHover: i.colorFillSecondary,
        colorBgTextActive: i.colorFill,
        colorIcon: i.colorTextTertiary,
        colorIconHover: i.colorText,
        colorErrorOutline: k_(i.colorErrorBg, i.colorBgContainer),
        colorWarningOutline: k_(i.colorWarningBg, i.colorBgContainer),
        fontSizeIcon: i.fontSizeSM,
        lineWidthFocus: i.lineWidth * 4,
        lineWidth: i.lineWidth,
        controlOutlineWidth: i.lineWidth * 2,
        controlInteractiveSize: i.controlHeight / 2,
        controlItemBgHover: i.colorFillTertiary,
        controlItemBgActive: i.colorPrimaryBg,
        controlItemBgActiveHover: i.colorPrimaryBgHover,
        controlItemBgActiveDisabled: i.colorFill,
        controlTmpOutline: i.colorFillQuaternary,
        controlOutline: k_(i.colorPrimaryBg, i.colorBgContainer),
        lineType: i.lineType,
        borderRadius: i.borderRadius,
        borderRadiusXS: i.borderRadiusXS,
        borderRadiusSM: i.borderRadiusSM,
        borderRadiusLG: i.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: .65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: i.sizeXXS,
        paddingXS: i.sizeXS,
        paddingSM: i.sizeSM,
        padding: i.size,
        paddingMD: i.sizeMD,
        paddingLG: i.sizeLG,
        paddingXL: i.sizeXL,
        paddingContentHorizontalLG: i.sizeLG,
        paddingContentVerticalLG: i.sizeMS,
        paddingContentHorizontal: i.sizeMS,
        paddingContentVertical: i.sizeSM,
        paddingContentHorizontalSM: i.size,
        paddingContentVerticalSM: i.sizeXS,
        marginXXS: i.sizeXXS,
        marginXS: i.sizeXS,
        marginSM: i.sizeSM,
        margin: i.size,
        marginMD: i.sizeMD,
        marginLG: i.sizeLG,
        marginXL: i.sizeXL,
        marginXXL: i.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS: s,
        screenXSMin: s,
        screenXSMax: o - 1,
        screenSM: o,
        screenSMMin: o,
        screenSMMax: a - 1,
        screenMD: a,
        screenMDMin: a,
        screenMDMax: l - 1,
        screenLG: l,
        screenLGMin: l,
        screenLGMax: u - 1,
        screenXL: u,
        screenXLMin: u,
        screenXLMax: c - 1,
        screenXXL: c,
        screenXXLMin: c,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new ao("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new ao("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new ao("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), r)
}
var _H = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
};
const eQ = {
        lineHeight: !0,
        lineHeightSM: !0,
        lineHeightLG: !0,
        lineHeightHeading1: !0,
        lineHeightHeading2: !0,
        lineHeightHeading3: !0,
        lineHeightHeading4: !0,
        lineHeightHeading5: !0,
        opacityLoading: !0,
        fontWeightStrong: !0,
        zIndexPopupBase: !0,
        zIndexBase: !0
    },
    tQ = {
        size: !0,
        sizeSM: !0,
        sizeLG: !0,
        sizeMD: !0,
        sizeXS: !0,
        sizeXXS: !0,
        sizeMS: !0,
        sizeXL: !0,
        sizeXXL: !0,
        sizeUnit: !0,
        sizeStep: !0,
        motionBase: !0,
        motionUnit: !0
    },
    pke = {
        screenXS: !0,
        screenXSMin: !0,
        screenXSMax: !0,
        screenSM: !0,
        screenSMMin: !0,
        screenSMMax: !0,
        screenMD: !0,
        screenMDMin: !0,
        screenMDMax: !0,
        screenLG: !0,
        screenLGMin: !0,
        screenLGMax: !0,
        screenXL: !0,
        screenXLMin: !0,
        screenXLMax: !0,
        screenXXL: !0,
        screenXXLMin: !0
    },
    nQ = (t, e, n) => {
        const r = n.getDerivativeToken(t),
            {
                override: i
            } = e,
            s = _H(e, ["override"]);
        let o = Object.assign(Object.assign({}, r), {
            override: i
        });
        return o = ZY(o), s && Object.entries(s).forEach(a => {
            let [l, u] = a;
            const {
                theme: c
            } = u, f = _H(u, ["theme"]);
            let d = f;
            c && (d = nQ(Object.assign(Object.assign({}, o), f), {
                override: f
            }, c)), o[l] = d
        }), o
    };

function sg() {
    const {
        token: t,
        hashed: e,
        theme: n,
        override: r,
        cssVar: i
    } = Bt.useContext(YY), s = `${fke}-${e||""}`, o = n || JY, [a, l, u] = qLe(o, [F0, t], {
        salt: s,
        override: r,
        getComputedToken: nQ,
        formatToken: ZY,
        cssVar: i && {
            prefix: i.prefix,
            key: i.key,
            unitless: eQ,
            ignore: tQ,
            preserve: pke
        }
    });
    return [o, u, e ? l : "", a, i]
}

function GS(t) {
    var e = P.useRef(!1),
        n = P.useState(t),
        r = ln(n, 2),
        i = r[0],
        s = r[1];
    P.useEffect(function() {
        return e.current = !1,
            function() {
                e.current = !0
            }
    }, []);

    function o(a, l) {
        l && e.current || s(a)
    }
    return [i, o]
}
const hke = () => ({
        display: "inline-flex",
        alignItems: "center",
        color: "inherit",
        fontStyle: "normal",
        lineHeight: 0,
        textAlign: "center",
        textTransform: "none",
        verticalAlign: "-0.125em",
        textRendering: "optimizeLegibility",
        "-webkit-font-smoothing": "antialiased",
        "-moz-osx-font-smoothing": "grayscale",
        "> *": {
            lineHeight: 1
        },
        svg: {
            display: "inline-block"
        }
    }),
    mke = t => ({
        a: {
            color: t.colorLink,
            textDecoration: t.linkDecoration,
            backgroundColor: "transparent",
            outline: "none",
            cursor: "pointer",
            transition: `color ${t.motionDurationSlow}`,
            "-webkit-text-decoration-skip": "objects",
            "&:hover": {
                color: t.colorLinkHover
            },
            "&:active": {
                color: t.colorLinkActive
            },
            "&:active,\n  &:hover": {
                textDecoration: t.linkHoverDecoration,
                outline: 0
            },
            "&:focus": {
                textDecoration: t.linkFocusDecoration,
                outline: 0
            },
            "&[disabled]": {
                color: t.colorTextDisabled,
                cursor: "not-allowed"
            }
        }
    }),
    gke = (t, e, n) => {
        const {
            fontFamily: r,
            fontSize: i
        } = t, s = `[class^="${e}"], [class*=" ${e}"]`;
        return {
            [n ? `.${n}` : s]: {
                fontFamily: r,
                fontSize: i,
                boxSizing: "border-box",
                "&::before, &::after": {
                    boxSizing: "border-box"
                },
                [s]: {
                    boxSizing: "border-box",
                    "&::before, &::after": {
                        boxSizing: "border-box"
                    }
                }
            }
        }
    };

function rQ(t, e, n) {
    return e = Km(e), Oq(t, D4() ? Reflect.construct(e, n || [], Km(t).constructor) : e.apply(t, n))
}
let yke = Ku(function t() {
    Wu(this, t)
});
const iQ = yke;
let vke = function(t) {
    function e(n) {
        var r;
        return Wu(this, e), r = rQ(this, e), r.result = 0, n instanceof e ? r.result = n.result : typeof n == "number" && (r.result = n), r
    }
    return H1(e, t), Ku(e, [{
        key: "add",
        value: function(r) {
            return r instanceof e ? this.result += r.result : typeof r == "number" && (this.result += r), this
        }
    }, {
        key: "sub",
        value: function(r) {
            return r instanceof e ? this.result -= r.result : typeof r == "number" && (this.result -= r), this
        }
    }, {
        key: "mul",
        value: function(r) {
            return r instanceof e ? this.result *= r.result : typeof r == "number" && (this.result *= r), this
        }
    }, {
        key: "div",
        value: function(r) {
            return r instanceof e ? this.result /= r.result : typeof r == "number" && (this.result /= r), this
        }
    }, {
        key: "equal",
        value: function() {
            return this.result
        }
    }])
}(iQ);
const sQ = "CALC_UNIT";

function oP(t) {
    return typeof t == "number" ? `${t}${sQ}` : t
}
let bke = function(t) {
    function e(n) {
        var r;
        return Wu(this, e), r = rQ(this, e), r.result = "", n instanceof e ? r.result = `(${n.result})` : typeof n == "number" ? r.result = oP(n) : typeof n == "string" && (r.result = n), r
    }
    return H1(e, t), Ku(e, [{
        key: "add",
        value: function(r) {
            return r instanceof e ? this.result = `${this.result} + ${r.getResult()}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} + ${oP(r)}`), this.lowPriority = !0, this
        }
    }, {
        key: "sub",
        value: function(r) {
            return r instanceof e ? this.result = `${this.result} - ${r.getResult()}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} - ${oP(r)}`), this.lowPriority = !0, this
        }
    }, {
        key: "mul",
        value: function(r) {
            return this.lowPriority && (this.result = `(${this.result})`), r instanceof e ? this.result = `${this.result} * ${r.getResult(!0)}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} * ${r}`), this.lowPriority = !1, this
        }
    }, {
        key: "div",
        value: function(r) {
            return this.lowPriority && (this.result = `(${this.result})`), r instanceof e ? this.result = `${this.result} / ${r.getResult(!0)}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} / ${r}`), this.lowPriority = !1, this
        }
    }, {
        key: "getResult",
        value: function(r) {
            return this.lowPriority || r ? `(${this.result})` : this.result
        }
    }, {
        key: "equal",
        value: function(r) {
            const {
                unit: i = !0
            } = r || {}, s = new RegExp(`${sQ}`, "g");
            return this.result = this.result.replace(s, i ? "px" : ""), typeof this.lowPriority < "u" ? `calc(${this.result})` : this.result
        }
    }])
}(iQ);
const xke = t => {
        const e = t === "css" ? bke : vke;
        return n => new e(n)
    },
    _ke = xke;

function Ske(t) {
    return t === "js" ? {
        max: Math.max,
        min: Math.min
    } : {
        max: function() {
            for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
            return `max(${n.map(i=>$R(i)).join(",")})`
        },
        min: function() {
            for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
            return `min(${n.map(i=>$R(i)).join(",")})`
        }
    }
}
const oQ = typeof CSSINJS_STATISTIC < "u";
let QR = !0;

function Jk() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    if (!oQ) return Object.assign.apply(Object, [{}].concat(e));
    QR = !1;
    const r = {};
    return e.forEach(i => {
        Object.keys(i).forEach(o => {
            Object.defineProperty(r, o, {
                configurable: !0,
                enumerable: !0,
                get: () => i[o]
            })
        })
    }), QR = !0, r
}
const SH = {};

function wke() {}
const Eke = t => {
        let e, n = t,
            r = wke;
        return oQ && typeof Proxy < "u" && (e = new Set, n = new Proxy(t, {
            get(i, s) {
                return QR && e.add(s), i[s]
            }
        }), r = (i, s) => {
            var o;
            SH[i] = {
                global: Array.from(e),
                component: Object.assign(Object.assign({}, (o = SH[i]) === null || o === void 0 ? void 0 : o.component), s)
            }
        }), {
            token: n,
            keys: e,
            flush: r
        }
    },
    Ake = Eke,
    Cke = (t, e) => {
        const [n, r] = sg();
        return VR({
            theme: n,
            token: r,
            hashId: "",
            path: ["ant-design-icons", t],
            nonce: () => e == null ? void 0 : e.nonce
        }, () => [{
            [`.${t}`]: Object.assign(Object.assign({}, hke()), {
                [`.${t} .${t}-icon`]: {
                    display: "block"
                }
            })
        }])
    },
    aQ = Cke,
    lQ = (t, e, n) => {
        var r;
        return typeof n == "function" ? n(Jk(e, (r = e[t]) !== null && r !== void 0 ? r : {})) : n ? ? {}
    },
    uQ = (t, e, n, r) => {
        const i = Object.assign({}, e[t]);
        if (r != null && r.deprecatedTokens) {
            const {
                deprecatedTokens: o
            } = r;
            o.forEach(a => {
                let [l, u] = a;
                var c;
                (i != null && i[l] || i != null && i[u]) && ((c = i[u]) !== null && c !== void 0 || (i[u] = i == null ? void 0 : i[l]))
            })
        }
        const s = Object.assign(Object.assign({}, n), i);
        return Object.keys(s).forEach(o => {
            s[o] === e[o] && delete s[o]
        }), s
    },
    Mke = (t, e) => `${[e,t.replace(/([A-Z]+)([A-Z][a-z]+)/g,"$1-$2").replace(/([a-z])([A-Z])/g,"$1-$2")].filter(Boolean).join("-")}`;

function Tke(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const i = Array.isArray(t) ? t : [t, t],
        [s] = i,
        o = i.join("-");
    return function(a) {
        let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : a;
        const [u, c, f, d, p] = sg(), {
            getPrefixCls: m,
            iconPrefixCls: y,
            csp: v
        } = P.useContext(Lg), b = m(), _ = p ? "css" : "js", x = _ke(_), {
            max: S,
            min: E
        } = Ske(_), A = {
            theme: u,
            token: d,
            hashId: f,
            nonce: () => v == null ? void 0 : v.nonce,
            clientOnly: r.clientOnly,
            order: r.order || -999
        };
        return VR(Object.assign(Object.assign({}, A), {
            clientOnly: !1,
            path: ["Shared", b]
        }), () => [{
            "&": mke(d)
        }]), aQ(y, v), [VR(Object.assign(Object.assign({}, A), {
            path: [o, a, y]
        }), () => {
            if (r.injectStyle === !1) return [];
            const {
                token: M,
                flush: I
            } = Ake(d), O = lQ(s, c, n), k = `.${a}`, H = uQ(s, c, O, {
                deprecatedTokens: r.deprecatedTokens
            });
            p && Object.keys(O).forEach(U => {
                O[U] = `var(${LY(U,Mke(s,p.prefix))})`
            });
            const N = Jk(M, {
                    componentCls: k,
                    prefixCls: a,
                    iconCls: `.${y}`,
                    antCls: `.${b}`,
                    calc: x,
                    max: S,
                    min: E
                }, p ? O : H),
                B = e(N, {
                    hashId: f,
                    prefixCls: a,
                    rootPrefixCls: b,
                    iconPrefixCls: y
                });
            return I(s, H), [r.resetStyle === !1 ? null : gke(N, a, l), B]
        }), f]
    }
}
const Pke = (t, e, n) => {
        function r(u) {
            return `${t}${u.slice(0,1).toUpperCase()}${u.slice(1)}`
        }
        const {
            unitless: i = {},
            injectStyle: s = !0
        } = n ? ? {}, o = {
            [r("zIndexPopup")]: !0
        };
        Object.keys(i).forEach(u => {
            o[r(u)] = i[u]
        });
        const a = u => {
            let {
                rootCls: c,
                cssVar: f
            } = u;
            const [, d] = sg();
            return o4e({
                path: [t],
                prefix: f.prefix,
                key: f == null ? void 0 : f.key,
                unitless: Object.assign(Object.assign({}, eQ), o),
                ignore: tQ,
                token: d,
                scope: c
            }, () => {
                const p = lQ(t, d, e),
                    m = uQ(t, d, p, {
                        deprecatedTokens: n == null ? void 0 : n.deprecatedTokens
                    });
                return Object.keys(p).forEach(y => {
                    m[r(y)] = m[y], delete m[y]
                }), m
            }), null
        };
        return u => {
            const [, , , , c] = sg();
            return [f => s && c ? Bt.createElement(Bt.Fragment, null, Bt.createElement(a, {
                rootCls: u,
                cssVar: c,
                component: t
            }), f) : f, c == null ? void 0 : c.key]
        }
    },
    cQ = (t, e, n, r) => {
        const i = Tke(t, e, n, r),
            s = Pke(Array.isArray(t) ? t[0] : t, n, r);
        return function(o) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : o;
            const [, l] = i(o, a), [u, c] = s(a);
            return [u, l, c]
        }
    },
    Ike = Object.assign({}, Am),
    {
        useId: wH
    } = Ike,
    Rke = () => "",
    Oke = typeof wH > "u" ? Rke : wH,
    Dke = Oke;

function Lke(t, e, n) {
    var r;
    const i = t || {},
        s = i.inherit === !1 || !e ? Object.assign(Object.assign({}, XR), {
            hashed: (r = e == null ? void 0 : e.hashed) !== null && r !== void 0 ? r : XR.hashed,
            cssVar: e == null ? void 0 : e.cssVar
        }) : e,
        o = Dke();
    return AY(() => {
        var a, l;
        if (!t) return e;
        const u = Object.assign({}, s.components);
        Object.keys(t.components || {}).forEach(d => {
            u[d] = Object.assign(Object.assign({}, u[d]), t.components[d])
        });
        const c = `css-var-${o.replace(/:/g,"")}`,
            f = ((a = i.cssVar) !== null && a !== void 0 ? a : s.cssVar) && Object.assign(Object.assign(Object.assign({
                prefix: n == null ? void 0 : n.prefixCls
            }, typeof s.cssVar == "object" ? s.cssVar : {}), typeof i.cssVar == "object" ? i.cssVar : {}), {
                key: typeof i.cssVar == "object" && ((l = i.cssVar) === null || l === void 0 ? void 0 : l.key) || c
            });
        return Object.assign(Object.assign(Object.assign({}, s), i), {
            token: Object.assign(Object.assign({}, s.token), i.token),
            components: u,
            cssVar: f
        })
    }, [i, s], (a, l) => a.some((u, c) => {
        const f = l[c];
        return !bLe(u, f, !0)
    }))
}
var kke = ["children"],
    fQ = P.createContext({});

function Bke(t) {
    var e = t.children,
        n = zu(t, kke);
    return P.createElement(fQ.Provider, {
        value: n
    }, e)
}
var Fke = function(t) {
        H1(n, t);
        var e = L4(n);

        function n() {
            return Wu(this, n), e.apply(this, arguments)
        }
        return Ku(n, [{
            key: "render",
            value: function() {
                return this.props.children
            }
        }]), n
    }(P.Component),
    od = "none",
    B_ = "appear",
    F_ = "enter",
    N_ = "leave",
    EH = "none",
    Aa = "prepare",
    Xh = "start",
    Jh = "active",
    Yk = "end",
    dQ = "prepared";

function AH(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit".concat(t)] = "webkit".concat(e), n["Moz".concat(t)] = "moz".concat(e), n["ms".concat(t)] = "MS".concat(e), n["O".concat(t)] = "o".concat(e.toLowerCase()), n
}

function Nke(t, e) {
    var n = {
        animationend: AH("Animation", "AnimationEnd"),
        transitionend: AH("Transition", "TransitionEnd")
    };
    return t && ("AnimationEvent" in e || delete n.animationend.animation, "TransitionEvent" in e || delete n.transitionend.transition), n
}
var zke = Nke(Hl(), typeof window < "u" ? window : {}),
    pQ = {};
if (Hl()) {
    var Hke = document.createElement("div");
    pQ = Hke.style
}
var z_ = {};

function hQ(t) {
    if (z_[t]) return z_[t];
    var e = zke[t];
    if (e)
        for (var n = Object.keys(e), r = n.length, i = 0; i < r; i += 1) {
            var s = n[i];
            if (Object.prototype.hasOwnProperty.call(e, s) && s in pQ) return z_[t] = e[s], z_[t]
        }
    return ""
}
var mQ = hQ("animationend"),
    gQ = hQ("transitionend"),
    yQ = !!(mQ && gQ),
    CH = mQ || "animationend",
    MH = gQ || "transitionend";

function TH(t, e) {
    if (!t) return null;
    if (yi(t) === "object") {
        var n = e.replace(/-\w/g, function(r) {
            return r[1].toUpperCase()
        });
        return t[n]
    }
    return "".concat(t, "-").concat(e)
}
const Uke = function(t) {
    var e = P.useRef(),
        n = P.useRef(t);
    n.current = t;
    var r = P.useCallback(function(o) {
        n.current(o)
    }, []);

    function i(o) {
        o && (o.removeEventListener(MH, r), o.removeEventListener(CH, r))
    }

    function s(o) {
        e.current && e.current !== o && i(e.current), o && o !== e.current && (o.addEventListener(MH, r), o.addEventListener(CH, r), e.current = o)
    }
    return P.useEffect(function() {
        return function() {
            i(e.current)
        }
    }, []), [s, i]
};
var vQ = Hl() ? P.useLayoutEffect : P.useEffect;
const $ke = function() {
    var t = P.useRef(null);

    function e() {
        FR.cancel(t.current)
    }

    function n(r) {
        var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        e();
        var s = FR(function() {
            i <= 1 ? r({
                isCanceled: function() {
                    return s !== t.current
                }
            }) : n(r, i - 1)
        });
        t.current = s
    }
    return P.useEffect(function() {
        return function() {
            e()
        }
    }, []), [n, e]
};
var Gke = [Aa, Xh, Jh, Yk],
    Vke = [Aa, dQ],
    bQ = !1,
    jke = !0;

function xQ(t) {
    return t === Jh || t === Yk
}
const Wke = function(t, e, n) {
    var r = GS(EH),
        i = ln(r, 2),
        s = i[0],
        o = i[1],
        a = $ke(),
        l = ln(a, 2),
        u = l[0],
        c = l[1];

    function f() {
        o(Aa, !0)
    }
    var d = e ? Vke : Gke;
    return vQ(function() {
        if (s !== EH && s !== Yk) {
            var p = d.indexOf(s),
                m = d[p + 1],
                y = n(s);
            y === bQ ? o(m, !0) : m && u(function(v) {
                function b() {
                    v.isCanceled() || o(m, !0)
                }
                y === !0 ? b() : Promise.resolve(y).then(b)
            })
        }
    }, [t, s]), P.useEffect(function() {
        return function() {
            c()
        }
    }, []), [f, s]
};

function Kke(t, e, n, r) {
    var i = r.motionEnter,
        s = i === void 0 ? !0 : i,
        o = r.motionAppear,
        a = o === void 0 ? !0 : o,
        l = r.motionLeave,
        u = l === void 0 ? !0 : l,
        c = r.motionDeadline,
        f = r.motionLeaveImmediately,
        d = r.onAppearPrepare,
        p = r.onEnterPrepare,
        m = r.onLeavePrepare,
        y = r.onAppearStart,
        v = r.onEnterStart,
        b = r.onLeaveStart,
        _ = r.onAppearActive,
        x = r.onEnterActive,
        S = r.onLeaveActive,
        E = r.onAppearEnd,
        A = r.onEnterEnd,
        T = r.onLeaveEnd,
        M = r.onVisibleChanged,
        I = GS(),
        O = ln(I, 2),
        k = O[0],
        H = O[1],
        N = GS(od),
        B = ln(N, 2),
        U = B[0],
        q = B[1],
        Q = GS(null),
        F = ln(Q, 2),
        G = F[0],
        W = F[1],
        se = P.useRef(!1),
        ee = P.useRef(null);

    function ae() {
        return n()
    }
    var de = P.useRef(!1);

    function re() {
        q(od, !0), W(null, !0)
    }

    function _e(He) {
        var qe = ae();
        if (!(He && !He.deadline && He.target !== qe)) {
            var Xe = de.current,
                K;
            U === B_ && Xe ? K = E == null ? void 0 : E(qe, He) : U === F_ && Xe ? K = A == null ? void 0 : A(qe, He) : U === N_ && Xe && (K = T == null ? void 0 : T(qe, He)), U !== od && Xe && K !== !1 && re()
        }
    }
    var fe = Uke(_e),
        ue = ln(fe, 1),
        ve = ue[0],
        xe = function(qe) {
            var Xe, K, V;
            switch (qe) {
                case B_:
                    return Xe = {}, En(Xe, Aa, d), En(Xe, Xh, y), En(Xe, Jh, _), Xe;
                case F_:
                    return K = {}, En(K, Aa, p), En(K, Xh, v), En(K, Jh, x), K;
                case N_:
                    return V = {}, En(V, Aa, m), En(V, Xh, b), En(V, Jh, S), V;
                default:
                    return {}
            }
        },
        be = P.useMemo(function() {
            return xe(U)
        }, [U]),
        he = Wke(U, !t, function(He) {
            if (He === Aa) {
                var qe = be[Aa];
                return qe ? qe(ae()) : bQ
            }
            if (Ne in be) {
                var Xe;
                W(((Xe = be[Ne]) === null || Xe === void 0 ? void 0 : Xe.call(be, ae(), null)) || null)
            }
            return Ne === Jh && (ve(ae()), c > 0 && (clearTimeout(ee.current), ee.current = setTimeout(function() {
                _e({
                    deadline: !0
                })
            }, c))), Ne === dQ && re(), jke
        }),
        me = ln(he, 2),
        Ce = me[0],
        Ne = me[1],
        De = xQ(Ne);
    de.current = De, vQ(function() {
        H(e);
        var He = se.current;
        se.current = !0;
        var qe;
        !He && e && a && (qe = B_), He && e && s && (qe = F_), (He && !e && u || !He && f && !e && u) && (qe = N_);
        var Xe = xe(qe);
        qe && (t || Xe[Aa]) ? (q(qe), Ce()) : q(od)
    }, [e]), P.useEffect(function() {
        (U === B_ && !a || U === F_ && !s || U === N_ && !u) && q(od)
    }, [a, s, u]), P.useEffect(function() {
        return function() {
            se.current = !1, clearTimeout(ee.current)
        }
    }, []);
    var je = P.useRef(!1);
    P.useEffect(function() {
        k && (je.current = !0), k !== void 0 && U === od && ((je.current || k) && (M == null || M(k)), je.current = !0)
    }, [k, U]);
    var Ke = G;
    return be[Aa] && Ne === Xh && (Ke = et({
        transition: "none"
    }, Ke)), [U, Ne, Ke, k ? ? e]
}

function qke(t) {
    var e = t;
    yi(t) === "object" && (e = t.transitionSupport);

    function n(i, s) {
        return !!(i.motionName && e && s !== !1)
    }
    var r = P.forwardRef(function(i, s) {
        var o = i.visible,
            a = o === void 0 ? !0 : o,
            l = i.removeOnLeave,
            u = l === void 0 ? !0 : l,
            c = i.forceRender,
            f = i.children,
            d = i.motionName,
            p = i.leavedClassName,
            m = i.eventProps,
            y = P.useContext(fQ),
            v = y.motion,
            b = n(i, v),
            _ = P.useRef(),
            x = P.useRef();

        function S() {
            try {
                return _.current instanceof HTMLElement ? _.current : dLe(x.current)
            } catch {
                return null
            }
        }
        var E = Kke(b, a, S, i),
            A = ln(E, 4),
            T = A[0],
            M = A[1],
            I = A[2],
            O = A[3],
            k = P.useRef(O);
        O && (k.current = !0);
        var H = P.useCallback(function(W) {
                _.current = W, pLe(s, W)
            }, [s]),
            N, B = et(et({}, m), {}, {
                visible: a
            });
        if (!f) N = null;
        else if (T === od) O ? N = f(et({}, B), H) : !u && k.current && p ? N = f(et(et({}, B), {}, {
            className: p
        }), H) : c || !u && !p ? N = f(et(et({}, B), {}, {
            style: {
                display: "none"
            }
        }), H) : N = null;
        else {
            var U, q;
            M === Aa ? q = "prepare" : xQ(M) ? q = "active" : M === Xh && (q = "start");
            var Q = TH(d, "".concat(T, "-").concat(q));
            N = f(et(et({}, B), {}, {
                className: Gk(TH(d, T), (U = {}, En(U, Q, Q && q), En(U, d, typeof d == "string"), U)),
                style: I
            }), H)
        }
        if (P.isValidElement(N) && hLe(N)) {
            var F = N,
                G = F.ref;
            G || (N = P.cloneElement(N, {
                ref: H
            }))
        }
        return P.createElement(Fke, {
            ref: x
        }, N)
    });
    return r.displayName = "CSSMotion", r
}
const Xke = qke(yQ);
var ZR = "add",
    eO = "keep",
    tO = "remove",
    aP = "removed";

function Jke(t) {
    var e;
    return t && yi(t) === "object" && "key" in t ? e = t : e = {
        key: t
    }, et(et({}, e), {}, {
        key: String(e.key)
    })
}

function nO() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return t.map(Jke)
}

function Yke() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
        n = [],
        r = 0,
        i = e.length,
        s = nO(t),
        o = nO(e);
    s.forEach(function(u) {
        for (var c = !1, f = r; f < i; f += 1) {
            var d = o[f];
            if (d.key === u.key) {
                r < f && (n = n.concat(o.slice(r, f).map(function(p) {
                    return et(et({}, p), {}, {
                        status: ZR
                    })
                })), r = f), n.push(et(et({}, d), {}, {
                    status: eO
                })), r += 1, c = !0;
                break
            }
        }
        c || n.push(et(et({}, u), {}, {
            status: tO
        }))
    }), r < i && (n = n.concat(o.slice(r).map(function(u) {
        return et(et({}, u), {}, {
            status: ZR
        })
    })));
    var a = {};
    n.forEach(function(u) {
        var c = u.key;
        a[c] = (a[c] || 0) + 1
    });
    var l = Object.keys(a).filter(function(u) {
        return a[u] > 1
    });
    return l.forEach(function(u) {
        n = n.filter(function(c) {
            var f = c.key,
                d = c.status;
            return f !== u || d !== tO
        }), n.forEach(function(c) {
            c.key === u && (c.status = eO)
        })
    }), n
}
var Qke = ["component", "children", "onVisibleChanged", "onAllRemoved"],
    Zke = ["status"],
    eBe = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];

function tBe(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Xke,
        n = function(r) {
            H1(s, r);
            var i = L4(s);

            function s() {
                var o;
                Wu(this, s);
                for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++) l[u] = arguments[u];
                return o = i.call.apply(i, [this].concat(l)), En(jw(o), "state", {
                    keyEntities: []
                }), En(jw(o), "removeKey", function(c) {
                    var f = o.state.keyEntities,
                        d = f.map(function(p) {
                            return p.key !== c ? p : et(et({}, p), {}, {
                                status: aP
                            })
                        });
                    return o.setState({
                        keyEntities: d
                    }), d.filter(function(p) {
                        var m = p.status;
                        return m !== aP
                    }).length
                }), o
            }
            return Ku(s, [{
                key: "render",
                value: function() {
                    var a = this,
                        l = this.state.keyEntities,
                        u = this.props,
                        c = u.component,
                        f = u.children,
                        d = u.onVisibleChanged,
                        p = u.onAllRemoved,
                        m = zu(u, Qke),
                        y = c || P.Fragment,
                        v = {};
                    return eBe.forEach(function(b) {
                        v[b] = m[b], delete m[b]
                    }), delete m.keys, P.createElement(y, m, l.map(function(b, _) {
                        var x = b.status,
                            S = zu(b, Zke),
                            E = x === ZR || x === eO;
                        return P.createElement(e, Y({}, v, {
                            key: S.key,
                            visible: E,
                            eventProps: S,
                            onVisibleChanged: function(T) {
                                if (d == null || d(T, {
                                        key: S.key
                                    }), !T) {
                                    var M = a.removeKey(S.key);
                                    M === 0 && p && p()
                                }
                            }
                        }), function(A, T) {
                            return f(et(et({}, A), {}, {
                                index: _
                            }), T)
                        })
                    }))
                }
            }], [{
                key: "getDerivedStateFromProps",
                value: function(a, l) {
                    var u = a.keys,
                        c = l.keyEntities,
                        f = nO(u),
                        d = Yke(c, f);
                    return {
                        keyEntities: d.filter(function(p) {
                            var m = c.find(function(y) {
                                var v = y.key;
                                return p.key === v
                            });
                            return !(m && m.status === aP && p.status === tO)
                        })
                    }
                }
            }]), s
        }(P.Component);
    return En(n, "defaultProps", {
        component: "div"
    }), n
}
tBe(yQ);

function nBe(t) {
    const {
        children: e
    } = t, [, n] = sg(), {
        motion: r
    } = n, i = P.useRef(!1);
    return i.current = i.current || r === !1, i.current ? P.createElement(Bke, {
        motion: r
    }, e) : e
}
const rBe = () => null;
var iBe = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
};
const sBe = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"],
    oBe = "ant";
let _Q;

function aBe() {
    return _Q || oBe
}

function lBe(t) {
    return Object.keys(t).some(e => e.endsWith("Color"))
}
const uBe = t => {
        const {
            prefixCls: e,
            iconPrefixCls: n,
            theme: r,
            holderRender: i
        } = t;
        e !== void 0 && (_Q = e), r && lBe(r) && oke(aBe(), r)
    },
    cBe = t => {
        const {
            children: e,
            csp: n,
            autoInsertSpaceInButton: r,
            alert: i,
            anchor: s,
            form: o,
            locale: a,
            componentSize: l,
            direction: u,
            space: c,
            virtual: f,
            dropdownMatchSelectWidth: d,
            popupMatchSelectWidth: p,
            popupOverflow: m,
            legacyLocale: y,
            parentContext: v,
            iconPrefixCls: b,
            theme: _,
            componentDisabled: x,
            segmented: S,
            statistic: E,
            spin: A,
            calendar: T,
            carousel: M,
            cascader: I,
            collapse: O,
            typography: k,
            checkbox: H,
            descriptions: N,
            divider: B,
            drawer: U,
            skeleton: q,
            steps: Q,
            image: F,
            layout: G,
            list: W,
            mentions: se,
            modal: ee,
            progress: ae,
            result: de,
            slider: re,
            breadcrumb: _e,
            menu: fe,
            pagination: ue,
            input: ve,
            textArea: xe,
            empty: be,
            badge: he,
            radio: me,
            rate: Ce,
            switch: Ne,
            transfer: De,
            avatar: je,
            message: Ke,
            tag: He,
            table: qe,
            card: Xe,
            tabs: K,
            timeline: V,
            timePicker: ge,
            upload: Be,
            notification: ze,
            tree: Ue,
            colorPicker: Ye,
            datePicker: Te,
            rangePicker: we,
            flex: lt,
            wave: nt,
            dropdown: vt,
            warning: ht,
            tour: pt
        } = t, le = P.useCallback((zt, Ot) => {
            const {
                prefixCls: tn
            } = t;
            if (Ot) return Ot;
            const Xt = tn || v.getPrefixCls("");
            return zt ? `${Xt}-${zt}` : Xt
        }, [v.getPrefixCls, t.prefixCls]), Ie = b || v.iconPrefixCls || QY, tt = n || v.csp;
        aQ(Ie, tt);
        const oe = Lke(_, v.theme, {
                prefixCls: le("")
            }),
            Ee = {
                csp: tt,
                autoInsertSpaceInButton: r,
                alert: i,
                anchor: s,
                locale: a || y,
                direction: u,
                space: c,
                virtual: f,
                popupMatchSelectWidth: p ? ? d,
                popupOverflow: m,
                getPrefixCls: le,
                iconPrefixCls: Ie,
                theme: oe,
                segmented: S,
                statistic: E,
                spin: A,
                calendar: T,
                carousel: M,
                cascader: I,
                collapse: O,
                typography: k,
                checkbox: H,
                descriptions: N,
                divider: B,
                drawer: U,
                skeleton: q,
                steps: Q,
                image: F,
                input: ve,
                textArea: xe,
                layout: G,
                list: W,
                mentions: se,
                modal: ee,
                progress: ae,
                result: de,
                slider: re,
                breadcrumb: _e,
                menu: fe,
                pagination: ue,
                empty: be,
                badge: he,
                radio: me,
                rate: Ce,
                switch: Ne,
                transfer: De,
                avatar: je,
                message: Ke,
                tag: He,
                table: qe,
                card: Xe,
                tabs: K,
                timeline: V,
                timePicker: ge,
                upload: Be,
                notification: ze,
                tree: Ue,
                colorPicker: Ye,
                datePicker: Te,
                rangePicker: we,
                flex: lt,
                wave: nt,
                dropdown: vt,
                warning: ht,
                tour: pt
            },
            Fe = Object.assign({}, v);
        Object.keys(Ee).forEach(zt => {
            Ee[zt] !== void 0 && (Fe[zt] = Ee[zt])
        }), sBe.forEach(zt => {
            const Ot = t[zt];
            Ot && (Fe[zt] = Ot)
        });
        const Ve = AY(() => Fe, Fe, (zt, Ot) => {
                const tn = Object.keys(zt),
                    Xt = Object.keys(Ot);
                return tn.length !== Xt.length || tn.some(Hr => zt[Hr] !== Ot[Hr])
            }),
            ct = P.useMemo(() => ({
                prefixCls: Ie,
                csp: tt
            }), [Ie, tt]);
        let bt = P.createElement(P.Fragment, null, P.createElement(rBe, {
            dropdownMatchSelectWidth: d
        }), e);
        const Kt = P.useMemo(() => {
            var zt, Ot, tn, Xt;
            return p4e(((zt = $A.Form) === null || zt === void 0 ? void 0 : zt.defaultValidateMessages) || {}, ((tn = (Ot = Ve.locale) === null || Ot === void 0 ? void 0 : Ot.Form) === null || tn === void 0 ? void 0 : tn.defaultValidateMessages) || {}, ((Xt = Ve.form) === null || Xt === void 0 ? void 0 : Xt.validateMessages) || {}, (o == null ? void 0 : o.validateMessages) || {})
        }, [Ve, o == null ? void 0 : o.validateMessages]);
        Object.keys(Kt).length > 0 && (bt = P.createElement(m4e.Provider, {
            value: Kt
        }, bt)), a && (bt = P.createElement(A4e, {
            locale: a,
            _ANT_MARK__: w4e
        }, bt)), (Ie || tt) && (bt = P.createElement(u4e.Provider, {
            value: ct
        }, bt)), l && (bt = P.createElement(uke, {
            size: l
        }, bt)), bt = P.createElement(nBe, null, bt);
        const un = P.useMemo(() => {
            const zt = oe || {},
                {
                    algorithm: Ot,
                    token: tn,
                    components: Xt,
                    cssVar: Hr
                } = zt,
                cs = iBe(zt, ["algorithm", "token", "components", "cssVar"]),
                Gn = Ot && (!Array.isArray(Ot) || Ot.length > 0) ? HR(Ot) : JY,
                D = {};
            Object.entries(Xt || {}).forEach(j => {
                let [X, te] = j;
                const Oe = Object.assign({}, te);
                "algorithm" in Oe && (Oe.algorithm === !0 ? Oe.theme = Gn : (Array.isArray(Oe.algorithm) || typeof Oe.algorithm == "function") && (Oe.theme = HR(Oe.algorithm)), delete Oe.algorithm), D[X] = Oe
            });
            const z = Object.assign(Object.assign({}, F0), tn);
            return Object.assign(Object.assign({}, cs), {
                theme: Gn,
                token: z,
                components: D,
                override: Object.assign({
                    override: z
                }, D),
                cssVar: Hr
            })
        }, [oe]);
        return _ && (bt = P.createElement(YY.Provider, {
            value: un
        }, bt)), Ve.warning && (bt = P.createElement(h4e.Provider, {
            value: Ve.warning
        }, bt)), x !== void 0 && (bt = P.createElement(ake, {
            disabled: x
        }, bt)), P.createElement(Lg.Provider, {
            value: Ve
        }, bt)
    },
    eb = t => {
        const e = P.useContext(Lg),
            n = P.useContext(jY);
        return P.createElement(cBe, Object.assign({
            parentContext: e,
            legacyLocale: n
        }, t))
    };
eb.ConfigContext = Lg;
eb.SizeContext = Xk;
eb.config = uBe;
eb.useConfig = cke;
Object.defineProperty(eb, "SizeContext", {
    get: () => Xk
});
const N0 = ["xxl", "xl", "lg", "md", "sm", "xs"],
    fBe = t => ({
        xs: `(max-width: ${t.screenXSMax}px)`,
        sm: `(min-width: ${t.screenSM}px)`,
        md: `(min-width: ${t.screenMD}px)`,
        lg: `(min-width: ${t.screenLG}px)`,
        xl: `(min-width: ${t.screenXL}px)`,
        xxl: `(min-width: ${t.screenXXL}px)`
    }),
    dBe = t => {
        const e = t,
            n = [].concat(N0).reverse();
        return n.forEach((r, i) => {
            const s = r.toUpperCase(),
                o = `screen${s}Min`,
                a = `screen${s}`;
            if (!(e[o] <= e[a])) throw new Error(`${o}<=${a} fails : !(${e[o]}<=${e[a]})`);
            if (i < n.length - 1) {
                const l = `screen${s}Max`;
                if (!(e[a] <= e[l])) throw new Error(`${a}<=${l} fails : !(${e[a]}<=${e[l]})`);
                const c = `screen${n[i+1].toUpperCase()}Min`;
                if (!(e[l] <= e[c])) throw new Error(`${l}<=${c} fails : !(${e[l]}<=${e[c]})`)
            }
        }), t
    };

function pBe() {
    const [, t] = sg(), e = fBe(dBe(t));
    return Bt.useMemo(() => {
        const n = new Map;
        let r = -1,
            i = {};
        return {
            matchHandlers: {},
            dispatch(s) {
                return i = s, n.forEach(o => o(i)), n.size >= 1
            },
            subscribe(s) {
                return n.size || this.register(), r += 1, n.set(r, s), s(i), r
            },
            unsubscribe(s) {
                n.delete(s), n.size || this.unregister()
            },
            unregister() {
                Object.keys(e).forEach(s => {
                    const o = e[s],
                        a = this.matchHandlers[o];
                    a == null || a.mql.removeListener(a == null ? void 0 : a.listener)
                }), n.clear()
            },
            register() {
                Object.keys(e).forEach(s => {
                    const o = e[s],
                        a = u => {
                            let {
                                matches: c
                            } = u;
                            this.dispatch(Object.assign(Object.assign({}, i), {
                                [s]: c
                            }))
                        },
                        l = window.matchMedia(o);
                    l.addListener(a), this.matchHandlers[o] = {
                        mql: l,
                        listener: a
                    }, a(l)
                })
            },
            responsiveMap: e
        }
    }, [t])
}
const hBe = P.createContext({}),
    SQ = hBe,
    mBe = t => {
        const {
            componentCls: e
        } = t;
        return {
            [e]: {
                display: "flex",
                flexFlow: "row wrap",
                minWidth: 0,
                "&::before, &::after": {
                    display: "flex"
                },
                "&-no-wrap": {
                    flexWrap: "nowrap"
                },
                "&-start": {
                    justifyContent: "flex-start"
                },
                "&-center": {
                    justifyContent: "center"
                },
                "&-end": {
                    justifyContent: "flex-end"
                },
                "&-space-between": {
                    justifyContent: "space-between"
                },
                "&-space-around": {
                    justifyContent: "space-around"
                },
                "&-space-evenly": {
                    justifyContent: "space-evenly"
                },
                "&-top": {
                    alignItems: "flex-start"
                },
                "&-middle": {
                    alignItems: "center"
                },
                "&-bottom": {
                    alignItems: "flex-end"
                }
            }
        }
    },
    gBe = t => {
        const {
            componentCls: e
        } = t;
        return {
            [e]: {
                position: "relative",
                maxWidth: "100%",
                minHeight: 1
            }
        }
    },
    yBe = (t, e) => {
        const {
            prefixCls: n,
            componentCls: r,
            gridColumns: i
        } = t, s = {};
        for (let o = i; o >= 0; o--) o === 0 ? (s[`${r}${e}-${o}`] = {
            display: "none"
        }, s[`${r}-push-${o}`] = {
            insetInlineStart: "auto"
        }, s[`${r}-pull-${o}`] = {
            insetInlineEnd: "auto"
        }, s[`${r}${e}-push-${o}`] = {
            insetInlineStart: "auto"
        }, s[`${r}${e}-pull-${o}`] = {
            insetInlineEnd: "auto"
        }, s[`${r}${e}-offset-${o}`] = {
            marginInlineStart: 0
        }, s[`${r}${e}-order-${o}`] = {
            order: 0
        }) : (s[`${r}${e}-${o}`] = [{
            "--ant-display": "block",
            display: "block"
        }, {
            display: "var(--ant-display)",
            flex: `0 0 ${o/i*100}%`,
            maxWidth: `${o/i*100}%`
        }], s[`${r}${e}-push-${o}`] = {
            insetInlineStart: `${o/i*100}%`
        }, s[`${r}${e}-pull-${o}`] = {
            insetInlineEnd: `${o/i*100}%`
        }, s[`${r}${e}-offset-${o}`] = {
            marginInlineStart: `${o/i*100}%`
        }, s[`${r}${e}-order-${o}`] = {
            order: o
        });
        return s[`${r}${e}-flex`] = {
            flex: `var(--${n}${e}-flex)`
        }, s
    },
    rO = (t, e) => yBe(t, e),
    vBe = (t, e, n) => ({
        [`@media (min-width: ${$R(e)})`]: Object.assign({}, rO(t, n))
    }),
    bBe = () => ({}),
    xBe = () => ({}),
    _Be = cQ("Grid", mBe, bBe),
    SBe = cQ("Grid", t => {
        const e = Jk(t, {
                gridColumns: 24
            }),
            n = {
                "-sm": e.screenSMMin,
                "-md": e.screenMDMin,
                "-lg": e.screenLGMin,
                "-xl": e.screenXLMin,
                "-xxl": e.screenXXLMin
            };
        return [gBe(e), rO(e, ""), rO(e, "-xs"), Object.keys(n).map(r => vBe(e, n[r], r)).reduce((r, i) => Object.assign(Object.assign({}, r), i), {})]
    }, xBe);
var wBe = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
};

function PH(t) {
    return typeof t == "number" ? `${t} ${t} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(t) ? `0 0 ${t}` : t
}
const EBe = ["xs", "sm", "md", "lg", "xl", "xxl"],
    ABe = P.forwardRef((t, e) => {
        const {
            getPrefixCls: n,
            direction: r
        } = P.useContext(Lg), {
            gutter: i,
            wrap: s
        } = P.useContext(SQ), {
            prefixCls: o,
            span: a,
            order: l,
            offset: u,
            push: c,
            pull: f,
            className: d,
            children: p,
            flex: m,
            style: y
        } = t, v = wBe(t, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]), b = n("col", o), [_, x, S] = SBe(b), E = {};
        let A = {};
        EBe.forEach(I => {
            let O = {};
            const k = t[I];
            typeof k == "number" ? O.span = k : typeof k == "object" && (O = k || {}), delete v[I], A = Object.assign(Object.assign({}, A), {
                [`${b}-${I}-${O.span}`]: O.span !== void 0,
                [`${b}-${I}-order-${O.order}`]: O.order || O.order === 0,
                [`${b}-${I}-offset-${O.offset}`]: O.offset || O.offset === 0,
                [`${b}-${I}-push-${O.push}`]: O.push || O.push === 0,
                [`${b}-${I}-pull-${O.pull}`]: O.pull || O.pull === 0,
                [`${b}-rtl`]: r === "rtl"
            }), O.flex && (A[`${b}-${I}-flex`] = !0, E[`--${b}-${I}-flex`] = PH(O.flex))
        });
        const T = Gk(b, {
                [`${b}-${a}`]: a !== void 0,
                [`${b}-order-${l}`]: l,
                [`${b}-offset-${u}`]: u,
                [`${b}-push-${c}`]: c,
                [`${b}-pull-${f}`]: f
            }, d, A, x, S),
            M = {};
        if (i && i[0] > 0) {
            const I = i[0] / 2;
            M.paddingLeft = I, M.paddingRight = I
        }
        return m && (M.flex = PH(m), s === !1 && !M.minWidth && (M.minWidth = 0)), _(P.createElement("div", Object.assign({}, v, {
            style: Object.assign(Object.assign(Object.assign({}, M), y), E),
            className: T,
            ref: e
        }), p))
    }),
    kUe = ABe;
var CBe = globalThis && globalThis.__rest || function(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
};

function IH(t, e) {
    const [n, r] = P.useState(typeof t == "string" ? t : ""), i = () => {
        if (typeof t == "string" && r(t), typeof t == "object")
            for (let s = 0; s < N0.length; s++) {
                const o = N0[s];
                if (!e[o]) continue;
                const a = t[o];
                if (a !== void 0) {
                    r(a);
                    return
                }
            }
    };
    return P.useEffect(() => {
        i()
    }, [JSON.stringify(t), e]), n
}
const MBe = P.forwardRef((t, e) => {
        const {
            prefixCls: n,
            justify: r,
            align: i,
            className: s,
            style: o,
            children: a,
            gutter: l = 0,
            wrap: u
        } = t, c = CBe(t, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]), {
            getPrefixCls: f,
            direction: d
        } = P.useContext(Lg), [p, m] = P.useState({
            xs: !0,
            sm: !0,
            md: !0,
            lg: !0,
            xl: !0,
            xxl: !0
        }), [y, v] = P.useState({
            xs: !1,
            sm: !1,
            md: !1,
            lg: !1,
            xl: !1,
            xxl: !1
        }), b = IH(i, y), _ = IH(r, y), x = P.useRef(l), S = pBe();
        P.useEffect(() => {
            const Q = S.subscribe(F => {
                v(F);
                const G = x.current || 0;
                (!Array.isArray(G) && typeof G == "object" || Array.isArray(G) && (typeof G[0] == "object" || typeof G[1] == "object")) && m(F)
            });
            return () => S.unsubscribe(Q)
        }, []);
        const E = () => {
                const Q = [void 0, void 0];
                return (Array.isArray(l) ? l : [l, void 0]).forEach((G, W) => {
                    if (typeof G == "object")
                        for (let se = 0; se < N0.length; se++) {
                            const ee = N0[se];
                            if (p[ee] && G[ee] !== void 0) {
                                Q[W] = G[ee];
                                break
                            }
                        } else Q[W] = G
                }), Q
            },
            A = f("row", n),
            [T, M, I] = _Be(A),
            O = E(),
            k = Gk(A, {
                [`${A}-no-wrap`]: u === !1,
                [`${A}-${_}`]: _,
                [`${A}-${b}`]: b,
                [`${A}-rtl`]: d === "rtl"
            }, s, M, I),
            H = {},
            N = O[0] != null && O[0] > 0 ? O[0] / -2 : void 0;
        N && (H.marginLeft = N, H.marginRight = N);
        const [B, U] = O;
        H.rowGap = U;
        const q = P.useMemo(() => ({
            gutter: [B, U],
            wrap: u
        }), [B, U, u]);
        return T(P.createElement(SQ.Provider, {
            value: q
        }, P.createElement("div", Object.assign({}, c, {
            className: k,
            style: Object.assign(Object.assign({}, H), o),
            ref: e
        }), a)))
    }),
    BUe = MBe;
var Qk = {},
    TBe = qu;
Object.defineProperty(Qk, "__esModule", {
    value: !0
});
var PBe = Qk.default = void 0,
    IBe = TBe(_p()),
    RBe = Sp;
PBe = Qk.default = (0, IBe.default)((0, RBe.jsx)("path", {
    d: "M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4zm-1-5C6.49 2 2 6.49 2 12s4.49 10 10 10 10-4.49 10-10S17.51 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8"
}), "ControlPointOutlined");
var Zk = {},
    OBe = qu;
Object.defineProperty(Zk, "__esModule", {
    value: !0
});
var DBe = Zk.default = void 0,
    LBe = OBe(_p()),
    kBe = Sp;
DBe = Zk.default = (0, LBe.default)((0, kBe.jsx)("path", {
    d: "M14.59 7.41 18.17 11H6v2h12.17l-3.59 3.59L16 18l6-6-6-6zM2 6v12h2V6z"
}), "Start");
var eB = {},
    BBe = qu;
Object.defineProperty(eB, "__esModule", {
    value: !0
});
var FBe = eB.default = void 0,
    NBe = BBe(_p()),
    zBe = Sp;
FBe = eB.default = (0, NBe.default)((0, zBe.jsx)("path", {
    d: "M16 13h-3V3h-2v10H8l4 4zM4 19v2h16v-2z"
}), "VerticalAlignBottom");
var tB = {},
    HBe = qu;
Object.defineProperty(tB, "__esModule", {
    value: !0
});
var UBe = tB.default = void 0,
    $Be = HBe(_p()),
    GBe = Sp;
UBe = tB.default = (0, $Be.default)((0, GBe.jsx)("path", {
    d: "M16 18v2H8v-2zM11 7.99V16h2V7.99h3L12 4 8 7.99z"
}), "Upgrade");
var nB = {},
    VBe = qu;
Object.defineProperty(nB, "__esModule", {
    value: !0
});
var jBe = nB.default = void 0,
    WBe = VBe(_p()),
    KBe = Sp;
jBe = nB.default = (0, WBe.default)((0, KBe.jsx)("path", {
    d: "M8 11h3v10h2V11h3l-4-4zM4 3v2h16V3z"
}), "VerticalAlignTop");
const qBe = {
    type: "logger",
    log(t) {
        this.output("log", t)
    },
    warn(t) {
        this.output("warn", t)
    },
    error(t) {
        this.output("error", t)
    },
    output(t, e) {
        console && console[t] && console[t].apply(console, e)
    }
};
class f2 {
    constructor(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.init(e, n)
    }
    init(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = n.prefix || "i18next:", this.logger = e || qBe, this.options = n, this.debug = n.debug
    }
    log() {
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
        return this.forward(n, "log", "", !0)
    }
    warn() {
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
        return this.forward(n, "warn", "", !0)
    }
    error() {
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
        return this.forward(n, "error", "")
    }
    deprecate() {
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
        return this.forward(n, "warn", "WARNING DEPRECATED: ", !0)
    }
    forward(e, n, r, i) {
        return i && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${r}${this.prefix} ${e[0]}`), this.logger[n](e))
    }
    create(e) {
        return new f2(this.logger, {
            prefix: `${this.prefix}:${e}:`,
            ...this.options
        })
    }
    clone(e) {
        return e = e || this.options, e.prefix = e.prefix || this.prefix, new f2(this.logger, e)
    }
}
var wl = new f2;
class GA {
    constructor() {
        this.observers = {}
    }
    on(e, n) {
        return e.split(" ").forEach(r => {
            this.observers[r] || (this.observers[r] = new Map);
            const i = this.observers[r].get(n) || 0;
            this.observers[r].set(n, i + 1)
        }), this
    }
    off(e, n) {
        if (this.observers[e]) {
            if (!n) {
                delete this.observers[e];
                return
            }
            this.observers[e].delete(n)
        }
    }
    emit(e) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
        this.observers[e] && Array.from(this.observers[e].entries()).forEach(o => {
            let [a, l] = o;
            for (let u = 0; u < l; u++) a(...r)
        }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(o => {
            let [a, l] = o;
            for (let u = 0; u < l; u++) a.apply(a, [e, ...r])
        })
    }
}

function Oy() {
    let t, e;
    const n = new Promise((r, i) => {
        t = r, e = i
    });
    return n.resolve = t, n.reject = e, n
}

function RH(t) {
    return t == null ? "" : "" + t
}

function XBe(t, e, n) {
    t.forEach(r => {
        e[r] && (n[r] = e[r])
    })
}
const JBe = /###/g;

function Rv(t, e, n) {
    function r(a) {
        return a && a.indexOf("###") > -1 ? a.replace(JBe, ".") : a
    }

    function i() {
        return !t || typeof t == "string"
    }
    const s = typeof e != "string" ? e : e.split(".");
    let o = 0;
    for (; o < s.length - 1;) {
        if (i()) return {};
        const a = r(s[o]);
        !t[a] && n && (t[a] = new n), Object.prototype.hasOwnProperty.call(t, a) ? t = t[a] : t = {}, ++o
    }
    return i() ? {} : {
        obj: t,
        k: r(s[o])
    }
}

function OH(t, e, n) {
    const {
        obj: r,
        k: i
    } = Rv(t, e, Object);
    if (r !== void 0 || e.length === 1) {
        r[i] = n;
        return
    }
    let s = e[e.length - 1],
        o = e.slice(0, e.length - 1),
        a = Rv(t, o, Object);
    for (; a.obj === void 0 && o.length;) s = `${o[o.length-1]}.${s}`, o = o.slice(0, o.length - 1), a = Rv(t, o, Object), a && a.obj && typeof a.obj[`${a.k}.${s}`] < "u" && (a.obj = void 0);
    a.obj[`${a.k}.${s}`] = n
}

function YBe(t, e, n, r) {
    const {
        obj: i,
        k: s
    } = Rv(t, e, Object);
    i[s] = i[s] || [], r && (i[s] = i[s].concat(n)), r || i[s].push(n)
}

function d2(t, e) {
    const {
        obj: n,
        k: r
    } = Rv(t, e);
    if (n) return n[r]
}

function QBe(t, e, n) {
    const r = d2(t, n);
    return r !== void 0 ? r : d2(e, n)
}

function wQ(t, e, n) {
    for (const r in e) r !== "__proto__" && r !== "constructor" && (r in t ? typeof t[r] == "string" || t[r] instanceof String || typeof e[r] == "string" || e[r] instanceof String ? n && (t[r] = e[r]) : wQ(t[r], e[r], n) : t[r] = e[r]);
    return t
}

function ch(t) {
    return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var ZBe = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};

function eFe(t) {
    return typeof t == "string" ? t.replace(/[&<>"'\/]/g, e => ZBe[e]) : t
}
class tFe {
    constructor(e) {
        this.capacity = e, this.regExpMap = new Map, this.regExpQueue = []
    }
    getRegExp(e) {
        const n = this.regExpMap.get(e);
        if (n !== void 0) return n;
        const r = new RegExp(e);
        return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, r), this.regExpQueue.push(e), r
    }
}
const nFe = [" ", ",", "?", "!", ";"],
    rFe = new tFe(20);

function iFe(t, e, n) {
    e = e || "", n = n || "";
    const r = nFe.filter(o => e.indexOf(o) < 0 && n.indexOf(o) < 0);
    if (r.length === 0) return !0;
    const i = rFe.getRegExp(`(${r.map(o=>o==="?"?"\\?":o).join("|")})`);
    let s = !i.test(t);
    if (!s) {
        const o = t.indexOf(n);
        o > 0 && !i.test(t.substring(0, o)) && (s = !0)
    }
    return s
}

function iO(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (!t) return;
    if (t[e]) return t[e];
    const r = e.split(n);
    let i = t;
    for (let s = 0; s < r.length;) {
        if (!i || typeof i != "object") return;
        let o, a = "";
        for (let l = s; l < r.length; ++l)
            if (l !== s && (a += n), a += r[l], o = i[a], o !== void 0) {
                if (["string", "number", "boolean"].indexOf(typeof o) > -1 && l < r.length - 1) continue;
                s += l - s + 1;
                break
            }
        i = o
    }
    return i
}

function p2(t) {
    return t && t.indexOf("_") > 0 ? t.replace("_", "-") : t
}
class DH extends GA {
    constructor(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            ns: ["translation"],
            defaultNS: "translation"
        };
        super(), this.data = e || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
    }
    addNamespaces(e) {
        this.options.ns.indexOf(e) < 0 && this.options.ns.push(e)
    }
    removeNamespaces(e) {
        const n = this.options.ns.indexOf(e);
        n > -1 && this.options.ns.splice(n, 1)
    }
    getResource(e, n, r) {
        let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator,
            o = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let a;
        e.indexOf(".") > -1 ? a = e.split(".") : (a = [e, n], r && (Array.isArray(r) ? a.push(...r) : typeof r == "string" && s ? a.push(...r.split(s)) : a.push(r)));
        const l = d2(this.data, a);
        return !l && !n && !r && e.indexOf(".") > -1 && (e = a[0], n = a[1], r = a.slice(2).join(".")), l || !o || typeof r != "string" ? l : iO(this.data && this.data[e] && this.data[e][n], r, s)
    }
    addResource(e, n, r, i) {
        let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: !1
        };
        const o = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator;
        let a = [e, n];
        r && (a = a.concat(o ? r.split(o) : r)), e.indexOf(".") > -1 && (a = e.split("."), i = n, n = a[1]), this.addNamespaces(n), OH(this.data, a, i), s.silent || this.emit("added", e, n, r, i)
    }
    addResources(e, n, r) {
        let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            silent: !1
        };
        for (const s in r)(typeof r[s] == "string" || Object.prototype.toString.apply(r[s]) === "[object Array]") && this.addResource(e, n, s, r[s], {
            silent: !0
        });
        i.silent || this.emit("added", e, n, r)
    }
    addResourceBundle(e, n, r, i, s) {
        let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
                silent: !1,
                skipCopy: !1
            },
            a = [e, n];
        e.indexOf(".") > -1 && (a = e.split("."), i = r, r = n, n = a[1]), this.addNamespaces(n);
        let l = d2(this.data, a) || {};
        o.skipCopy || (r = JSON.parse(JSON.stringify(r))), i ? wQ(l, r, s) : l = { ...l,
            ...r
        }, OH(this.data, a, l), o.silent || this.emit("added", e, n, r)
    }
    removeResourceBundle(e, n) {
        this.hasResourceBundle(e, n) && delete this.data[e][n], this.removeNamespaces(n), this.emit("removed", e, n)
    }
    hasResourceBundle(e, n) {
        return this.getResource(e, n) !== void 0
    }
    getResourceBundle(e, n) {
        return n || (n = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? { ...this.getResource(e, n)
        } : this.getResource(e, n)
    }
    getDataByLanguage(e) {
        return this.data[e]
    }
    hasLanguageSomeTranslations(e) {
        const n = this.getDataByLanguage(e);
        return !!(n && Object.keys(n) || []).find(i => n[i] && Object.keys(n[i]).length > 0)
    }
    toJSON() {
        return this.data
    }
}
var EQ = {
    processors: {},
    addPostProcessor(t) {
        this.processors[t.name] = t
    },
    handle(t, e, n, r, i) {
        return t.forEach(s => {
            this.processors[s] && (e = this.processors[s].process(e, n, r, i))
        }), e
    }
};
const LH = {};
class h2 extends GA {
    constructor(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(), XBe(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = wl.create("translator")
    }
    changeLanguage(e) {
        e && (this.language = e)
    }
    exists(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
        };
        if (e == null) return !1;
        const r = this.resolve(e, n);
        return r && r.res !== void 0
    }
    extractFromKey(e, n) {
        let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
        r === void 0 && (r = ":");
        const i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
        let s = n.ns || this.options.defaultNS || [];
        const o = r && e.indexOf(r) > -1,
            a = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !iFe(e, r, i);
        if (o && !a) {
            const l = e.match(this.interpolator.nestingRegexp);
            if (l && l.length > 0) return {
                key: e,
                namespaces: s
            };
            const u = e.split(r);
            (r !== i || r === i && this.options.ns.indexOf(u[0]) > -1) && (s = u.shift()), e = u.join(i)
        }
        return typeof s == "string" && (s = [s]), {
            key: e,
            namespaces: s
        }
    }
    translate(e, n, r) {
        if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = { ...n
            }), n || (n = {}), e == null) return "";
        Array.isArray(e) || (e = [String(e)]);
        const i = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails,
            s = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator,
            {
                key: o,
                namespaces: a
            } = this.extractFromKey(e[e.length - 1], n),
            l = a[a.length - 1],
            u = n.lng || this.language,
            c = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (u && u.toLowerCase() === "cimode") {
            if (c) {
                const S = n.nsSeparator || this.options.nsSeparator;
                return i ? {
                    res: `${l}${S}${o}`,
                    usedKey: o,
                    exactUsedKey: o,
                    usedLng: u,
                    usedNS: l,
                    usedParams: this.getUsedParamsDetails(n)
                } : `${l}${S}${o}`
            }
            return i ? {
                res: o,
                usedKey: o,
                exactUsedKey: o,
                usedLng: u,
                usedNS: l,
                usedParams: this.getUsedParamsDetails(n)
            } : o
        }
        const f = this.resolve(e, n);
        let d = f && f.res;
        const p = f && f.usedKey || o,
            m = f && f.exactUsedKey || o,
            y = Object.prototype.toString.apply(d),
            v = ["[object Number]", "[object Function]", "[object RegExp]"],
            b = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays,
            _ = !this.i18nFormat || this.i18nFormat.handleAsObject;
        if (_ && d && (typeof d != "string" && typeof d != "boolean" && typeof d != "number") && v.indexOf(y) < 0 && !(typeof b == "string" && y === "[object Array]")) {
            if (!n.returnObjects && !this.options.returnObjects) {
                this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                const S = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(p, d, { ...n,
                    ns: a
                }) : `key '${o} (${this.language})' returned an object instead of string.`;
                return i ? (f.res = S, f.usedParams = this.getUsedParamsDetails(n), f) : S
            }
            if (s) {
                const S = y === "[object Array]",
                    E = S ? [] : {},
                    A = S ? m : p;
                for (const T in d)
                    if (Object.prototype.hasOwnProperty.call(d, T)) {
                        const M = `${A}${s}${T}`;
                        E[T] = this.translate(M, { ...n,
                            joinArrays: !1,
                            ns: a
                        }), E[T] === M && (E[T] = d[T])
                    }
                d = E
            }
        } else if (_ && typeof b == "string" && y === "[object Array]") d = d.join(b), d && (d = this.extendTranslation(d, e, n, r));
        else {
            let S = !1,
                E = !1;
            const A = n.count !== void 0 && typeof n.count != "string",
                T = h2.hasDefaultValue(n),
                M = A ? this.pluralResolver.getSuffix(u, n.count, n) : "",
                I = n.ordinal && A ? this.pluralResolver.getSuffix(u, n.count, {
                    ordinal: !1
                }) : "",
                O = A && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(),
                k = O && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${M}`] || n[`defaultValue${I}`] || n.defaultValue;
            !this.isValidLookup(d) && T && (S = !0, d = k), this.isValidLookup(d) || (E = !0, d = o);
            const N = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && E ? void 0 : d,
                B = T && k !== d && this.options.updateMissing;
            if (E || S || B) {
                if (this.logger.log(B ? "updateKey" : "missingKey", u, l, o, B ? k : d), s) {
                    const F = this.resolve(o, { ...n,
                        keySeparator: !1
                    });
                    F && F.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                }
                let U = [];
                const q = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
                if (this.options.saveMissingTo === "fallback" && q && q[0])
                    for (let F = 0; F < q.length; F++) U.push(q[F]);
                else this.options.saveMissingTo === "all" ? U = this.languageUtils.toResolveHierarchy(n.lng || this.language) : U.push(n.lng || this.language);
                const Q = (F, G, W) => {
                    const se = T && W !== d ? W : N;
                    this.options.missingKeyHandler ? this.options.missingKeyHandler(F, l, G, se, B, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(F, l, G, se, B, n), this.emit("missingKey", F, l, G, d)
                };
                this.options.saveMissing && (this.options.saveMissingPlurals && A ? U.forEach(F => {
                    const G = this.pluralResolver.getSuffixes(F, n);
                    O && n[`defaultValue${this.options.pluralSeparator}zero`] && G.indexOf(`${this.options.pluralSeparator}zero`) < 0 && G.push(`${this.options.pluralSeparator}zero`), G.forEach(W => {
                        Q([F], o + W, n[`defaultValue${W}`] || k)
                    })
                }) : Q(U, o, k))
            }
            d = this.extendTranslation(d, e, n, f, r), E && d === o && this.options.appendNamespaceToMissingKey && (d = `${l}:${o}`), (E || S) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? d = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}:${o}` : o, S ? d : void 0) : d = this.options.parseMissingKeyHandler(d))
        }
        return i ? (f.res = d, f.usedParams = this.getUsedParamsDetails(n), f) : d
    }
    extendTranslation(e, n, r, i, s) {
        var o = this;
        if (this.i18nFormat && this.i18nFormat.parse) e = this.i18nFormat.parse(e, { ...this.options.interpolation.defaultVariables,
            ...r
        }, r.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
            resolved: i
        });
        else if (!r.skipInterpolation) {
            r.interpolation && this.interpolator.init({ ...r,
                interpolation: { ...this.options.interpolation,
                    ...r.interpolation
                }
            });
            const u = typeof e == "string" && (r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            let c;
            if (u) {
                const d = e.match(this.interpolator.nestingRegexp);
                c = d && d.length
            }
            let f = r.replace && typeof r.replace != "string" ? r.replace : r;
            if (this.options.interpolation.defaultVariables && (f = { ...this.options.interpolation.defaultVariables,
                    ...f
                }), e = this.interpolator.interpolate(e, f, r.lng || this.language, r), u) {
                const d = e.match(this.interpolator.nestingRegexp),
                    p = d && d.length;
                c < p && (r.nest = !1)
            }!r.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (r.lng = i.usedLng), r.nest !== !1 && (e = this.interpolator.nest(e, function() {
                for (var d = arguments.length, p = new Array(d), m = 0; m < d; m++) p[m] = arguments[m];
                return s && s[0] === p[0] && !r.context ? (o.logger.warn(`It seems you are nesting recursively key: ${p[0]} in key: ${n[0]}`), null) : o.translate(...p, n)
            }, r)), r.interpolation && this.interpolator.reset()
        }
        const a = r.postProcess || this.options.postProcess,
            l = typeof a == "string" ? [a] : a;
        return e != null && l && l.length && r.applyPostProcessor !== !1 && (e = EQ.handle(l, e, n, this.options && this.options.postProcessPassResolved ? {
            i18nResolved: { ...i,
                usedParams: this.getUsedParamsDetails(r)
            },
            ...r
        } : r, this)), e
    }
    resolve(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            r, i, s, o, a;
        return typeof e == "string" && (e = [e]), e.forEach(l => {
            if (this.isValidLookup(r)) return;
            const u = this.extractFromKey(l, n),
                c = u.key;
            i = c;
            let f = u.namespaces;
            this.options.fallbackNS && (f = f.concat(this.options.fallbackNS));
            const d = n.count !== void 0 && typeof n.count != "string",
                p = d && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(),
                m = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== "",
                y = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
            f.forEach(v => {
                this.isValidLookup(r) || (a = v, !LH[`${y[0]}-${v}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(a) && (LH[`${y[0]}-${v}`] = !0, this.logger.warn(`key "${i}" for languages "${y.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), y.forEach(b => {
                    if (this.isValidLookup(r)) return;
                    o = b;
                    const _ = [c];
                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) this.i18nFormat.addLookupKeys(_, c, b, v, n);
                    else {
                        let S;
                        d && (S = this.pluralResolver.getSuffix(b, n.count, n));
                        const E = `${this.options.pluralSeparator}zero`,
                            A = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                        if (d && (_.push(c + S), n.ordinal && S.indexOf(A) === 0 && _.push(c + S.replace(A, this.options.pluralSeparator)), p && _.push(c + E)), m) {
                            const T = `${c}${this.options.contextSeparator}${n.context}`;
                            _.push(T), d && (_.push(T + S), n.ordinal && S.indexOf(A) === 0 && _.push(T + S.replace(A, this.options.pluralSeparator)), p && _.push(T + E))
                        }
                    }
                    let x;
                    for (; x = _.pop();) this.isValidLookup(r) || (s = x, r = this.getResource(b, v, x, n))
                }))
            })
        }), {
            res: r,
            usedKey: i,
            exactUsedKey: s,
            usedLng: o,
            usedNS: a
        }
    }
    isValidLookup(e) {
        return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "")
    }
    getResource(e, n, r) {
        let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, n, r, i) : this.resourceStore.getResource(e, n, r, i)
    }
    getUsedParamsDetails() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"],
            r = e.replace && typeof e.replace != "string";
        let i = r ? e.replace : e;
        if (r && typeof e.count < "u" && (i.count = e.count), this.options.interpolation.defaultVariables && (i = { ...this.options.interpolation.defaultVariables,
                ...i
            }), !r) {
            i = { ...i
            };
            for (const s of n) delete i[s]
        }
        return i
    }
    static hasDefaultValue(e) {
        const n = "defaultValue";
        for (const r in e)
            if (Object.prototype.hasOwnProperty.call(e, r) && n === r.substring(0, n.length) && e[r] !== void 0) return !0;
        return !1
    }
}

function lP(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}
class kH {
    constructor(e) {
        this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = wl.create("languageUtils")
    }
    getScriptPartFromCode(e) {
        if (e = p2(e), !e || e.indexOf("-") < 0) return null;
        const n = e.split("-");
        return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"))
    }
    getLanguagePartFromCode(e) {
        if (e = p2(e), !e || e.indexOf("-") < 0) return e;
        const n = e.split("-");
        return this.formatLanguageCode(n[0])
    }
    formatLanguageCode(e) {
        if (typeof e == "string" && e.indexOf("-") > -1) {
            const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            let r = e.split("-");
            return this.options.lowerCaseLng ? r = r.map(i => i.toLowerCase()) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = lP(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = lP(r[1].toLowerCase())), n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = lP(r[2].toLowerCase()))), r.join("-")
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e
    }
    isSupportedCode(e) {
        return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1
    }
    getBestMatchFromCodes(e) {
        if (!e) return null;
        let n;
        return e.forEach(r => {
            if (n) return;
            const i = this.formatLanguageCode(r);
            (!this.options.supportedLngs || this.isSupportedCode(i)) && (n = i)
        }), !n && this.options.supportedLngs && e.forEach(r => {
            if (n) return;
            const i = this.getLanguagePartFromCode(r);
            if (this.isSupportedCode(i)) return n = i;
            n = this.options.supportedLngs.find(s => {
                if (s === i) return s;
                if (!(s.indexOf("-") < 0 && i.indexOf("-") < 0) && (s.indexOf("-") > 0 && i.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === i || s.indexOf(i) === 0 && i.length > 1)) return s
            })
        }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n
    }
    getFallbackCodes(e, n) {
        if (!e) return [];
        if (typeof e == "function" && (e = e(n)), typeof e == "string" && (e = [e]), Object.prototype.toString.apply(e) === "[object Array]") return e;
        if (!n) return e.default || [];
        let r = e[n];
        return r || (r = e[this.getScriptPartFromCode(n)]), r || (r = e[this.formatLanguageCode(n)]), r || (r = e[this.getLanguagePartFromCode(n)]), r || (r = e.default), r || []
    }
    toResolveHierarchy(e, n) {
        const r = this.getFallbackCodes(n || this.options.fallbackLng || [], e),
            i = [],
            s = o => {
                o && (this.isSupportedCode(o) ? i.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`))
            };
        return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && s(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && s(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && s(this.getLanguagePartFromCode(e))) : typeof e == "string" && s(this.formatLanguageCode(e)), r.forEach(o => {
            i.indexOf(o) < 0 && s(this.formatLanguageCode(o))
        }), i
    }
}
let sFe = [{
        lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
        nr: [1, 2],
        fc: 1
    }, {
        lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
        nr: [1, 2],
        fc: 2
    }, {
        lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
        nr: [1],
        fc: 3
    }, {
        lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
        nr: [1, 2, 5],
        fc: 4
    }, {
        lngs: ["ar"],
        nr: [0, 1, 2, 3, 11, 100],
        fc: 5
    }, {
        lngs: ["cs", "sk"],
        nr: [1, 2, 5],
        fc: 6
    }, {
        lngs: ["csb", "pl"],
        nr: [1, 2, 5],
        fc: 7
    }, {
        lngs: ["cy"],
        nr: [1, 2, 3, 8],
        fc: 8
    }, {
        lngs: ["fr"],
        nr: [1, 2],
        fc: 9
    }, {
        lngs: ["ga"],
        nr: [1, 2, 3, 7, 11],
        fc: 10
    }, {
        lngs: ["gd"],
        nr: [1, 2, 3, 20],
        fc: 11
    }, {
        lngs: ["is"],
        nr: [1, 2],
        fc: 12
    }, {
        lngs: ["jv"],
        nr: [0, 1],
        fc: 13
    }, {
        lngs: ["kw"],
        nr: [1, 2, 3, 4],
        fc: 14
    }, {
        lngs: ["lt"],
        nr: [1, 2, 10],
        fc: 15
    }, {
        lngs: ["lv"],
        nr: [1, 2, 0],
        fc: 16
    }, {
        lngs: ["mk"],
        nr: [1, 2],
        fc: 17
    }, {
        lngs: ["mnk"],
        nr: [0, 1, 2],
        fc: 18
    }, {
        lngs: ["mt"],
        nr: [1, 2, 11, 20],
        fc: 19
    }, {
        lngs: ["or"],
        nr: [2, 1],
        fc: 2
    }, {
        lngs: ["ro"],
        nr: [1, 2, 20],
        fc: 20
    }, {
        lngs: ["sl"],
        nr: [5, 1, 2, 3],
        fc: 21
    }, {
        lngs: ["he", "iw"],
        nr: [1, 2, 20, 21],
        fc: 22
    }],
    oFe = {
        1: function(t) {
            return +(t > 1)
        },
        2: function(t) {
            return +(t != 1)
        },
        3: function(t) {
            return 0
        },
        4: function(t) {
            return t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2
        },
        5: function(t) {
            return t == 0 ? 0 : t == 1 ? 1 : t == 2 ? 2 : t % 100 >= 3 && t % 100 <= 10 ? 3 : t % 100 >= 11 ? 4 : 5
        },
        6: function(t) {
            return t == 1 ? 0 : t >= 2 && t <= 4 ? 1 : 2
        },
        7: function(t) {
            return t == 1 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2
        },
        8: function(t) {
            return t == 1 ? 0 : t == 2 ? 1 : t != 8 && t != 11 ? 2 : 3
        },
        9: function(t) {
            return +(t >= 2)
        },
        10: function(t) {
            return t == 1 ? 0 : t == 2 ? 1 : t < 7 ? 2 : t < 11 ? 3 : 4
        },
        11: function(t) {
            return t == 1 || t == 11 ? 0 : t == 2 || t == 12 ? 1 : t > 2 && t < 20 ? 2 : 3
        },
        12: function(t) {
            return +(t % 10 != 1 || t % 100 == 11)
        },
        13: function(t) {
            return +(t !== 0)
        },
        14: function(t) {
            return t == 1 ? 0 : t == 2 ? 1 : t == 3 ? 2 : 3
        },
        15: function(t) {
            return t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2
        },
        16: function(t) {
            return t % 10 == 1 && t % 100 != 11 ? 0 : t !== 0 ? 1 : 2
        },
        17: function(t) {
            return t == 1 || t % 10 == 1 && t % 100 != 11 ? 0 : 1
        },
        18: function(t) {
            return t == 0 ? 0 : t == 1 ? 1 : 2
        },
        19: function(t) {
            return t == 1 ? 0 : t == 0 || t % 100 > 1 && t % 100 < 11 ? 1 : t % 100 > 10 && t % 100 < 20 ? 2 : 3
        },
        20: function(t) {
            return t == 1 ? 0 : t == 0 || t % 100 > 0 && t % 100 < 20 ? 1 : 2
        },
        21: function(t) {
            return t % 100 == 1 ? 1 : t % 100 == 2 ? 2 : t % 100 == 3 || t % 100 == 4 ? 3 : 0
        },
        22: function(t) {
            return t == 1 ? 0 : t == 2 ? 1 : (t < 0 || t > 10) && t % 10 == 0 ? 2 : 3
        }
    };
const aFe = ["v1", "v2", "v3"],
    lFe = ["v4"],
    BH = {
        zero: 0,
        one: 1,
        two: 2,
        few: 3,
        many: 4,
        other: 5
    };

function uFe() {
    const t = {};
    return sFe.forEach(e => {
        e.lngs.forEach(n => {
            t[n] = {
                numbers: e.nr,
                plurals: oFe[e.fc]
            }
        })
    }), t
}
class cFe {
    constructor(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.languageUtils = e, this.options = n, this.logger = wl.create("pluralResolver"), (!this.options.compatibilityJSON || lFe.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = uFe()
    }
    addRule(e, n) {
        this.rules[e] = n
    }
    getRule(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.shouldUseIntlApi()) try {
            return new Intl.PluralRules(p2(e === "dev" ? "en" : e), {
                type: n.ordinal ? "ordinal" : "cardinal"
            })
        } catch {
            return
        }
        return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)]
    }
    needsPlural(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const r = this.getRule(e, n);
        return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1
    }
    getPluralFormsOfKey(e, n) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.getSuffixes(e, r).map(i => `${n}${i}`)
    }
    getSuffixes(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const r = this.getRule(e, n);
        return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort((i, s) => BH[i] - BH[s]).map(i => `${this.options.prepend}${n.ordinal?`ordinal${this.options.prepend}`:""}${i}`) : r.numbers.map(i => this.getSuffix(e, i, n)) : []
    }
    getSuffix(e, n) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const i = this.getRule(e, r);
        return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${r.ordinal?`ordinal${this.options.prepend}`:""}${i.select(n)}` : this.getSuffixRetroCompatible(i, n) : (this.logger.warn(`no plural rule found for: ${e}`), "")
    }
    getSuffixRetroCompatible(e, n) {
        const r = e.noAbs ? e.plurals(n) : e.plurals(Math.abs(n));
        let i = e.numbers[r];
        this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
        const s = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
        return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : s() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? s() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString()
    }
    shouldUseIntlApi() {
        return !aFe.includes(this.options.compatibilityJSON)
    }
}

function FH(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".",
        i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0,
        s = QBe(t, e, n);
    return !s && i && typeof n == "string" && (s = iO(t, n, r), s === void 0 && (s = iO(e, n, r))), s
}
class fFe {
    constructor() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = wl.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || (n => n), this.init(e)
    }
    init() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        e.interpolation || (e.interpolation = {
            escapeValue: !0
        });
        const n = e.interpolation;
        this.escape = n.escape !== void 0 ? n.escape : eFe, this.escapeValue = n.escapeValue !== void 0 ? n.escapeValue : !0, this.useRawValueToEscape = n.useRawValueToEscape !== void 0 ? n.useRawValueToEscape : !1, this.prefix = n.prefix ? ch(n.prefix) : n.prefixEscaped || "{{", this.suffix = n.suffix ? ch(n.suffix) : n.suffixEscaped || "}}", this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",", this.unescapePrefix = n.unescapeSuffix ? "" : n.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : n.unescapeSuffix || "", this.nestingPrefix = n.nestingPrefix ? ch(n.nestingPrefix) : n.nestingPrefixEscaped || ch("$t("), this.nestingSuffix = n.nestingSuffix ? ch(n.nestingSuffix) : n.nestingSuffixEscaped || ch(")"), this.nestingOptionsSeparator = n.nestingOptionsSeparator ? n.nestingOptionsSeparator : n.nestingOptionsSeparator || ",", this.maxReplaces = n.maxReplaces ? n.maxReplaces : 1e3, this.alwaysFormat = n.alwaysFormat !== void 0 ? n.alwaysFormat : !1, this.resetRegExp()
    }
    reset() {
        this.options && this.init(this.options)
    }
    resetRegExp() {
        const e = (n, r) => n && n.source === r ? (n.lastIndex = 0, n) : new RegExp(r, "g");
        this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
    }
    interpolate(e, n, r, i) {
        let s, o, a;
        const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

        function u(m) {
            return m.replace(/\$/g, "$$$$")
        }
        const c = m => {
            if (m.indexOf(this.formatSeparator) < 0) {
                const _ = FH(n, l, m, this.options.keySeparator, this.options.ignoreJSONStructure);
                return this.alwaysFormat ? this.format(_, void 0, r, { ...i,
                    ...n,
                    interpolationkey: m
                }) : _
            }
            const y = m.split(this.formatSeparator),
                v = y.shift().trim(),
                b = y.join(this.formatSeparator).trim();
            return this.format(FH(n, l, v, this.options.keySeparator, this.options.ignoreJSONStructure), b, r, { ...i,
                ...n,
                interpolationkey: v
            })
        };
        this.resetRegExp();
        const f = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler,
            d = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        return [{
            regex: this.regexpUnescape,
            safeValue: m => u(m)
        }, {
            regex: this.regexp,
            safeValue: m => this.escapeValue ? u(this.escape(m)) : u(m)
        }].forEach(m => {
            for (a = 0; s = m.regex.exec(e);) {
                const y = s[1].trim();
                if (o = c(y), o === void 0)
                    if (typeof f == "function") {
                        const b = f(e, s, i);
                        o = typeof b == "string" ? b : ""
                    } else if (i && Object.prototype.hasOwnProperty.call(i, y)) o = "";
                else if (d) {
                    o = s[0];
                    continue
                } else this.logger.warn(`missed to pass in variable ${y} for interpolating ${e}`), o = "";
                else typeof o != "string" && !this.useRawValueToEscape && (o = RH(o));
                const v = m.safeValue(o);
                if (e = e.replace(s[0], v), d ? (m.regex.lastIndex += o.length, m.regex.lastIndex -= s[0].length) : m.regex.lastIndex = 0, a++, a >= this.maxReplaces) break
            }
        }), e
    }
    nest(e, n) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
            i, s, o;

        function a(l, u) {
            const c = this.nestingOptionsSeparator;
            if (l.indexOf(c) < 0) return l;
            const f = l.split(new RegExp(`${c}[ ]*{`));
            let d = `{${f[1]}`;
            l = f[0], d = this.interpolate(d, o);
            const p = d.match(/'/g),
                m = d.match(/"/g);
            (p && p.length % 2 === 0 && !m || m.length % 2 !== 0) && (d = d.replace(/'/g, '"'));
            try {
                o = JSON.parse(d), u && (o = { ...u,
                    ...o
                })
            } catch (y) {
                return this.logger.warn(`failed parsing options string in nesting for key ${l}`, y), `${l}${c}${d}`
            }
            return delete o.defaultValue, l
        }
        for (; i = this.nestingRegexp.exec(e);) {
            let l = [];
            o = { ...r
            }, o = o.replace && typeof o.replace != "string" ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
            let u = !1;
            if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
                const c = i[1].split(this.formatSeparator).map(f => f.trim());
                i[1] = c.shift(), l = c, u = !0
            }
            if (s = n(a.call(this, i[1].trim(), o), o), s && i[0] === e && typeof s != "string") return s;
            typeof s != "string" && (s = RH(s)), s || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${e}`), s = ""), u && (s = l.reduce((c, f) => this.format(c, f, r.lng, { ...r,
                interpolationkey: i[1].trim()
            }), s.trim())), e = e.replace(i[0], s), this.regexp.lastIndex = 0
        }
        return e
    }
}

function dFe(t) {
    let e = t.toLowerCase().trim();
    const n = {};
    if (t.indexOf("(") > -1) {
        const r = t.split("(");
        e = r[0].toLowerCase().trim();
        const i = r[1].substring(0, r[1].length - 1);
        e === "currency" && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : e === "relativetime" && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach(o => {
            if (!o) return;
            const [a, ...l] = o.split(":"), u = l.join(":").trim().replace(/^'+|'+$/g, "");
            n[a.trim()] || (n[a.trim()] = u), u === "false" && (n[a.trim()] = !1), u === "true" && (n[a.trim()] = !0), isNaN(u) || (n[a.trim()] = parseInt(u, 10))
        })
    }
    return {
        formatName: e,
        formatOptions: n
    }
}

function fh(t) {
    const e = {};
    return function(r, i, s) {
        const o = i + JSON.stringify(s);
        let a = e[o];
        return a || (a = t(p2(i), s), e[o] = a), a(r)
    }
}
class pFe {
    constructor() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = wl.create("formatter"), this.options = e, this.formats = {
            number: fh((n, r) => {
                const i = new Intl.NumberFormat(n, { ...r
                });
                return s => i.format(s)
            }),
            currency: fh((n, r) => {
                const i = new Intl.NumberFormat(n, { ...r,
                    style: "currency"
                });
                return s => i.format(s)
            }),
            datetime: fh((n, r) => {
                const i = new Intl.DateTimeFormat(n, { ...r
                });
                return s => i.format(s)
            }),
            relativetime: fh((n, r) => {
                const i = new Intl.RelativeTimeFormat(n, { ...r
                });
                return s => i.format(s, r.range || "day")
            }),
            list: fh((n, r) => {
                const i = new Intl.ListFormat(n, { ...r
                });
                return s => i.format(s)
            })
        }, this.init(e)
    }
    init(e) {
        const r = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
        }).interpolation;
        this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ","
    }
    add(e, n) {
        this.formats[e.toLowerCase().trim()] = n
    }
    addCached(e, n) {
        this.formats[e.toLowerCase().trim()] = fh(n)
    }
    format(e, n, r) {
        let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return n.split(this.formatSeparator).reduce((a, l) => {
            const {
                formatName: u,
                formatOptions: c
            } = dFe(l);
            if (this.formats[u]) {
                let f = a;
                try {
                    const d = i && i.formatParams && i.formatParams[i.interpolationkey] || {},
                        p = d.locale || d.lng || i.locale || i.lng || r;
                    f = this.formats[u](a, p, { ...c,
                        ...i,
                        ...d
                    })
                } catch (d) {
                    this.logger.warn(d)
                }
                return f
            } else this.logger.warn(`there was no format function for ${u}`);
            return a
        }, e)
    }
}

function hFe(t, e) {
    t.pending[e] !== void 0 && (delete t.pending[e], t.pendingCount--)
}
class mFe extends GA {
    constructor(e, n, r) {
        let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        super(), this.backend = e, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = i, this.logger = wl.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(r, i.backend, i)
    }
    queueLoad(e, n, r, i) {
        const s = {},
            o = {},
            a = {},
            l = {};
        return e.forEach(u => {
            let c = !0;
            n.forEach(f => {
                const d = `${u}|${f}`;
                !r.reload && this.store.hasResourceBundle(u, f) ? this.state[d] = 2 : this.state[d] < 0 || (this.state[d] === 1 ? o[d] === void 0 && (o[d] = !0) : (this.state[d] = 1, c = !1, o[d] === void 0 && (o[d] = !0), s[d] === void 0 && (s[d] = !0), l[f] === void 0 && (l[f] = !0)))
            }), c || (a[u] = !0)
        }), (Object.keys(s).length || Object.keys(o).length) && this.queue.push({
            pending: o,
            pendingCount: Object.keys(o).length,
            loaded: {},
            errors: [],
            callback: i
        }), {
            toLoad: Object.keys(s),
            pending: Object.keys(o),
            toLoadLanguages: Object.keys(a),
            toLoadNamespaces: Object.keys(l)
        }
    }
    loaded(e, n, r) {
        const i = e.split("|"),
            s = i[0],
            o = i[1];
        n && this.emit("failedLoading", s, o, n), r && this.store.addResourceBundle(s, o, r, void 0, void 0, {
            skipCopy: !0
        }), this.state[e] = n ? -1 : 2;
        const a = {};
        this.queue.forEach(l => {
            YBe(l.loaded, [s], o), hFe(l, e), n && l.errors.push(n), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach(u => {
                a[u] || (a[u] = {});
                const c = l.loaded[u];
                c.length && c.forEach(f => {
                    a[u][f] === void 0 && (a[u][f] = !0)
                })
            }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback())
        }), this.emit("loaded", a), this.queue = this.queue.filter(l => !l.done)
    }
    read(e, n, r) {
        let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout,
            o = arguments.length > 5 ? arguments[5] : void 0;
        if (!e.length) return o(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng: e,
                ns: n,
                fcName: r,
                tried: i,
                wait: s,
                callback: o
            });
            return
        }
        this.readingCalls++;
        const a = (u, c) => {
                if (this.readingCalls--, this.waitingReads.length > 0) {
                    const f = this.waitingReads.shift();
                    this.read(f.lng, f.ns, f.fcName, f.tried, f.wait, f.callback)
                }
                if (u && c && i < this.maxRetries) {
                    setTimeout(() => {
                        this.read.call(this, e, n, r, i + 1, s * 2, o)
                    }, s);
                    return
                }
                o(u, c)
            },
            l = this.backend[r].bind(this.backend);
        if (l.length === 2) {
            try {
                const u = l(e, n);
                u && typeof u.then == "function" ? u.then(c => a(null, c)).catch(a) : a(null, u)
            } catch (u) {
                a(u)
            }
            return
        }
        return l(e, n, a)
    }
    prepareLoading(e, n) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
            i = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
        typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof n == "string" && (n = [n]);
        const s = this.queueLoad(e, n, r, i);
        if (!s.toLoad.length) return s.pending.length || i(), null;
        s.toLoad.forEach(o => {
            this.loadOne(o)
        })
    }
    load(e, n, r) {
        this.prepareLoading(e, n, {}, r)
    }
    reload(e, n, r) {
        this.prepareLoading(e, n, {
            reload: !0
        }, r)
    }
    loadOne(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const r = e.split("|"),
            i = r[0],
            s = r[1];
        this.read(i, s, "read", void 0, void 0, (o, a) => {
            o && this.logger.warn(`${n}loading namespace ${s} for language ${i} failed`, o), !o && a && this.logger.log(`${n}loaded namespace ${s} for language ${i}`, a), this.loaded(e, o, a)
        })
    }
    saveMissing(e, n, r, i, s) {
        let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {},
            a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {};
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
            this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return
        }
        if (!(r == null || r === "")) {
            if (this.backend && this.backend.create) {
                const l = { ...o,
                        isUpdate: s
                    },
                    u = this.backend.create.bind(this.backend);
                if (u.length < 6) try {
                    let c;
                    u.length === 5 ? c = u(e, n, r, i, l) : c = u(e, n, r, i), c && typeof c.then == "function" ? c.then(f => a(null, f)).catch(a) : a(null, c)
                } catch (c) {
                    a(c)
                } else u(e, n, r, i, a, l)
            }!e || !e[0] || this.store.addResource(e[0], n, r, i)
        }
    }
}

function NH() {
    return {
        debug: !1,
        initImmediate: !0,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: "all",
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: "fallback",
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !1,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: function(e) {
            let n = {};
            if (typeof e[1] == "object" && (n = e[1]), typeof e[1] == "string" && (n.defaultValue = e[1]), typeof e[2] == "string" && (n.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
                const r = e[3] || e[2];
                Object.keys(r).forEach(i => {
                    n[i] = r[i]
                })
            }
            return n
        },
        interpolation: {
            escapeValue: !0,
            format: t => t,
            prefix: "{{",
            suffix: "}}",
            formatSeparator: ",",
            unescapePrefix: "-",
            nestingPrefix: "$t(",
            nestingSuffix: ")",
            nestingOptionsSeparator: ",",
            maxReplaces: 1e3,
            skipOnVariables: !0
        }
    }
}

function zH(t) {
    return typeof t.ns == "string" && (t.ns = [t.ns]), typeof t.fallbackLng == "string" && (t.fallbackLng = [t.fallbackLng]), typeof t.fallbackNS == "string" && (t.fallbackNS = [t.fallbackNS]), t.supportedLngs && t.supportedLngs.indexOf("cimode") < 0 && (t.supportedLngs = t.supportedLngs.concat(["cimode"])), t
}

function H_() {}

function gFe(t) {
    Object.getOwnPropertyNames(Object.getPrototypeOf(t)).forEach(n => {
        typeof t[n] == "function" && (t[n] = t[n].bind(t))
    })
}
class z0 extends GA {
    constructor() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            n = arguments.length > 1 ? arguments[1] : void 0;
        if (super(), this.options = zH(e), this.services = {}, this.logger = wl, this.modules = {
                external: []
            }, gFe(this), n && !this.isInitialized && !e.isClone) {
            if (!this.options.initImmediate) return this.init(e, n), this;
            setTimeout(() => {
                this.init(e, n)
            }, 0)
        }
    }
    init() {
        var e = this;
        let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            r = arguments.length > 1 ? arguments[1] : void 0;
        this.isInitializing = !0, typeof n == "function" && (r = n, n = {}), !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
        const i = NH();
        this.options = { ...i,
            ...this.options,
            ...zH(n)
        }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = { ...i.interpolation,
            ...this.options.interpolation
        }), n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator), n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);

        function s(c) {
            return c ? typeof c == "function" ? new c : c : null
        }
        if (!this.options.isClone) {
            this.modules.logger ? wl.init(s(this.modules.logger), this.options) : wl.init(null, this.options);
            let c;
            this.modules.formatter ? c = this.modules.formatter : typeof Intl < "u" && (c = pFe);
            const f = new kH(this.options);
            this.store = new DH(this.options.resources, this.options);
            const d = this.services;
            d.logger = wl, d.resourceStore = this.store, d.languageUtils = f, d.pluralResolver = new cFe(f, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            }), c && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (d.formatter = s(c), d.formatter.init(d, this.options), this.options.interpolation.format = d.formatter.format.bind(d.formatter)), d.interpolator = new fFe(this.options), d.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            }, d.backendConnector = new mFe(s(this.modules.backend), d.resourceStore, d, this.options), d.backendConnector.on("*", function(p) {
                for (var m = arguments.length, y = new Array(m > 1 ? m - 1 : 0), v = 1; v < m; v++) y[v - 1] = arguments[v];
                e.emit(p, ...y)
            }), this.modules.languageDetector && (d.languageDetector = s(this.modules.languageDetector), d.languageDetector.init && d.languageDetector.init(d, this.options.detection, this.options)), this.modules.i18nFormat && (d.i18nFormat = s(this.modules.i18nFormat), d.i18nFormat.init && d.i18nFormat.init(this)), this.translator = new h2(this.services, this.options), this.translator.on("*", function(p) {
                for (var m = arguments.length, y = new Array(m > 1 ? m - 1 : 0), v = 1; v < m; v++) y[v - 1] = arguments[v];
                e.emit(p, ...y)
            }), this.modules.external.forEach(p => {
                p.init && p.init(this)
            })
        }
        if (this.format = this.options.interpolation.format, r || (r = H_), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0])
        }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(c => {
            this[c] = function() {
                return e.store[c](...arguments)
            }
        }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(c => {
            this[c] = function() {
                return e.store[c](...arguments), e
            }
        });
        const l = Oy(),
            u = () => {
                const c = (f, d) => {
                    this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), l.resolve(d), r(f, d)
                };
                if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return c(null, this.t.bind(this));
                this.changeLanguage(this.options.lng, c)
            };
        return this.options.resources || !this.options.initImmediate ? u() : setTimeout(u, 0), l
    }
    loadResources(e) {
        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : H_;
        const i = typeof e == "string" ? e : this.language;
        if (typeof e == "function" && (r = e), !this.options.resources || this.options.partialBundledLanguages) {
            if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r();
            const s = [],
                o = a => {
                    if (!a || a === "cimode") return;
                    this.services.languageUtils.toResolveHierarchy(a).forEach(u => {
                        u !== "cimode" && s.indexOf(u) < 0 && s.push(u)
                    })
                };
            i ? o(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(l => o(l)), this.options.preload && this.options.preload.forEach(a => o(a)), this.services.backendConnector.load(s, this.options.ns, a => {
                !a && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(a)
            })
        } else r(null)
    }
    reloadResources(e, n, r) {
        const i = Oy();
        return e || (e = this.languages), n || (n = this.options.ns), r || (r = H_), this.services.backendConnector.reload(e, n, s => {
            i.resolve(), r(s)
        }), i
    }
    use(e) {
        if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && EQ.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this
    }
    setResolvedLanguage(e) {
        if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
            for (let n = 0; n < this.languages.length; n++) {
                const r = this.languages[n];
                if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
                    this.resolvedLanguage = r;
                    break
                }
            }
    }
    changeLanguage(e, n) {
        var r = this;
        this.isLanguageChangingTo = e;
        const i = Oy();
        this.emit("languageChanging", e);
        const s = l => {
                this.language = l, this.languages = this.services.languageUtils.toResolveHierarchy(l), this.resolvedLanguage = void 0, this.setResolvedLanguage(l)
            },
            o = (l, u) => {
                u ? (s(u), this.translator.changeLanguage(u), this.isLanguageChangingTo = void 0, this.emit("languageChanged", u), this.logger.log("languageChanged", u)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
                    return r.t(...arguments)
                }), n && n(l, function() {
                    return r.t(...arguments)
                })
            },
            a = l => {
                !e && !l && this.services.languageDetector && (l = []);
                const u = typeof l == "string" ? l : this.services.languageUtils.getBestMatchFromCodes(l);
                u && (this.language || s(u), this.translator.language || this.translator.changeLanguage(u), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(u)), this.loadResources(u, c => {
                    o(c, u)
                })
            };
        return !e && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e), i
    }
    getFixedT(e, n, r) {
        var i = this;
        const s = function(o, a) {
            let l;
            if (typeof a != "object") {
                for (var u = arguments.length, c = new Array(u > 2 ? u - 2 : 0), f = 2; f < u; f++) c[f - 2] = arguments[f];
                l = i.options.overloadTranslationOptionHandler([o, a].concat(c))
            } else l = { ...a
            };
            l.lng = l.lng || s.lng, l.lngs = l.lngs || s.lngs, l.ns = l.ns || s.ns, l.keyPrefix = l.keyPrefix || r || s.keyPrefix;
            const d = i.options.keySeparator || ".";
            let p;
            return l.keyPrefix && Array.isArray(o) ? p = o.map(m => `${l.keyPrefix}${d}${m}`) : p = l.keyPrefix ? `${l.keyPrefix}${d}${o}` : o, i.t(p, l)
        };
        return typeof e == "string" ? s.lng = e : s.lngs = e, s.ns = n, s.keyPrefix = r, s
    }
    t() {
        return this.translator && this.translator.translate(...arguments)
    }
    exists() {
        return this.translator && this.translator.exists(...arguments)
    }
    setDefaultNamespace(e) {
        this.options.defaultNS = e
    }
    hasLoadedNamespace(e) {
        let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
        if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
        const r = n.lng || this.resolvedLanguage || this.languages[0],
            i = this.options ? this.options.fallbackLng : !1,
            s = this.languages[this.languages.length - 1];
        if (r.toLowerCase() === "cimode") return !0;
        const o = (a, l) => {
            const u = this.services.backendConnector.state[`${a}|${l}`];
            return u === -1 || u === 2
        };
        if (n.precheck) {
            const a = n.precheck(this, o);
            if (a !== void 0) return a
        }
        return !!(this.hasResourceBundle(r, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(r, e) && (!i || o(s, e)))
    }
    loadNamespaces(e, n) {
        const r = Oy();
        return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach(i => {
            this.options.ns.indexOf(i) < 0 && this.options.ns.push(i)
        }), this.loadResources(i => {
            r.resolve(), n && n(i)
        }), r) : (n && n(), Promise.resolve())
    }
    loadLanguages(e, n) {
        const r = Oy();
        typeof e == "string" && (e = [e]);
        const i = this.options.preload || [],
            s = e.filter(o => i.indexOf(o) < 0);
        return s.length ? (this.options.preload = i.concat(s), this.loadResources(o => {
            r.resolve(), n && n(o)
        }), r) : (n && n(), Promise.resolve())
    }
    dir(e) {
        if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
        const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
            r = this.services && this.services.languageUtils || new kH(NH());
        return n.indexOf(r.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
    }
    static createInstance() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            n = arguments.length > 1 ? arguments[1] : void 0;
        return new z0(e, n)
    }
    cloneInstance() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : H_;
        const r = e.forkResourceStore;
        r && delete e.forkResourceStore;
        const i = { ...this.options,
                ...e,
                isClone: !0
            },
            s = new z0(i);
        return (e.debug !== void 0 || e.prefix !== void 0) && (s.logger = s.logger.clone(e)), ["store", "services", "language"].forEach(a => {
            s[a] = this[a]
        }), s.services = { ...this.services
        }, s.services.utils = {
            hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
        }, r && (s.store = new DH(this.store.data, i), s.services.resourceStore = s.store), s.translator = new h2(s.services, i), s.translator.on("*", function(a) {
            for (var l = arguments.length, u = new Array(l > 1 ? l - 1 : 0), c = 1; c < l; c++) u[c - 1] = arguments[c];
            s.emit(a, ...u)
        }), s.init(i, n), s.translator.options = i, s.translator.backendConnector.services.utils = {
            hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
        }, s
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        }
    }
}
const Cs = z0.createInstance();
Cs.createInstance = z0.createInstance;
Cs.createInstance;
Cs.dir;
Cs.init;
Cs.loadResources;
Cs.reloadResources;
Cs.use;
Cs.changeLanguage;
Cs.getFixedT;
const FUe = Cs.t;
Cs.exists;
Cs.setDefaultNamespace;
Cs.hasLoadedNamespace;
Cs.loadNamespaces;
Cs.loadLanguages;

function AQ(t) {
    let e = null;
    return () => (e == null && (e = t()), e)
}

function yFe(t, e) {
    return t.filter(n => n !== e)
}

function vFe(t, e) {
    const n = new Set,
        r = s => n.add(s);
    t.forEach(r), e.forEach(r);
    const i = [];
    return n.forEach(s => i.push(s)), i
}
class bFe {
    enter(e) {
        const n = this.entered.length,
            r = i => this.isNodeInDocument(i) && (!i.contains || i.contains(e));
        return this.entered = vFe(this.entered.filter(r), [e]), n === 0 && this.entered.length > 0
    }
    leave(e) {
        const n = this.entered.length;
        return this.entered = yFe(this.entered.filter(this.isNodeInDocument), e), n > 0 && this.entered.length === 0
    }
    reset() {
        this.entered = []
    }
    constructor(e) {
        this.entered = [], this.isNodeInDocument = e
    }
}
class xFe {
    initializeExposedProperties() {
        Object.keys(this.config.exposeProperties).forEach(e => {
            Object.defineProperty(this.item, e, {
                configurable: !0,
                enumerable: !0,
                get() {
                    return console.warn(`Browser doesn't allow reading "${e}" until the drop event.`), null
                }
            })
        })
    }
    loadDataTransfer(e) {
        if (e) {
            const n = {};
            Object.keys(this.config.exposeProperties).forEach(r => {
                const i = this.config.exposeProperties[r];
                i != null && (n[r] = {
                    value: i(e, this.config.matchesTypes),
                    configurable: !0,
                    enumerable: !0
                })
            }), Object.defineProperties(this.item, n)
        }
    }
    canDrag() {
        return !0
    }
    beginDrag() {
        return this.item
    }
    isDragging(e, n) {
        return n === e.getSourceId()
    }
    endDrag() {}
    constructor(e) {
        this.config = e, this.item = {}, this.initializeExposedProperties()
    }
}
const CQ = "__NATIVE_FILE__",
    MQ = "__NATIVE_URL__",
    TQ = "__NATIVE_TEXT__",
    PQ = "__NATIVE_HTML__",
    HH = Object.freeze(Object.defineProperty({
        __proto__: null,
        FILE: CQ,
        HTML: PQ,
        TEXT: TQ,
        URL: MQ
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function uP(t, e, n) {
    const r = e.reduce((i, s) => i || t.getData(s), "");
    return r ? ? n
}
const sO = {
    [CQ]: {
        exposeProperties: {
            files: t => Array.prototype.slice.call(t.files),
            items: t => t.items,
            dataTransfer: t => t
        },
        matchesTypes: ["Files"]
    },
    [PQ]: {
        exposeProperties: {
            html: (t, e) => uP(t, e, ""),
            dataTransfer: t => t
        },
        matchesTypes: ["Html", "text/html"]
    },
    [MQ]: {
        exposeProperties: {
            urls: (t, e) => uP(t, e, "").split(`
`),
            dataTransfer: t => t
        },
        matchesTypes: ["Url", "text/uri-list"]
    },
    [TQ]: {
        exposeProperties: {
            text: (t, e) => uP(t, e, ""),
            dataTransfer: t => t
        },
        matchesTypes: ["Text", "text/plain"]
    }
};

function _Fe(t, e) {
    const n = sO[t];
    if (!n) throw new Error(`native type ${t} has no configuration`);
    const r = new xFe(n);
    return r.loadDataTransfer(e), r
}

function cP(t) {
    if (!t) return null;
    const e = Array.prototype.slice.call(t.types || []);
    return Object.keys(sO).filter(n => {
        const r = sO[n];
        return r != null && r.matchesTypes ? r.matchesTypes.some(i => e.indexOf(i) > -1) : !1
    })[0] || null
}
const SFe = AQ(() => /firefox/i.test(navigator.userAgent)),
    IQ = AQ(() => !!window.safari);
class UH {
    interpolate(e) {
        const {
            xs: n,
            ys: r,
            c1s: i,
            c2s: s,
            c3s: o
        } = this;
        let a = n.length - 1;
        if (e === n[a]) return r[a];
        let l = 0,
            u = o.length - 1,
            c;
        for (; l <= u;) {
            c = Math.floor(.5 * (l + u));
            const p = n[c];
            if (p < e) l = c + 1;
            else if (p > e) u = c - 1;
            else return r[c]
        }
        a = Math.max(0, u);
        const f = e - n[a],
            d = f * f;
        return r[a] + i[a] * f + s[a] * d + o[a] * f * d
    }
    constructor(e, n) {
        const {
            length: r
        } = e, i = [];
        for (let p = 0; p < r; p++) i.push(p);
        i.sort((p, m) => e[p] < e[m] ? -1 : 1);
        const s = [],
            o = [];
        let a, l;
        for (let p = 0; p < r - 1; p++) a = e[p + 1] - e[p], l = n[p + 1] - n[p], s.push(a), o.push(l / a);
        const u = [o[0]];
        for (let p = 0; p < s.length - 1; p++) {
            const m = o[p],
                y = o[p + 1];
            if (m * y <= 0) u.push(0);
            else {
                a = s[p];
                const v = s[p + 1],
                    b = a + v;
                u.push(3 * b / ((b + v) / m + (b + a) / y))
            }
        }
        u.push(o[o.length - 1]);
        const c = [],
            f = [];
        let d;
        for (let p = 0; p < u.length - 1; p++) {
            d = o[p];
            const m = u[p],
                y = 1 / s[p],
                v = m + u[p + 1] - d - d;
            c.push((d - m - v) * y), f.push(v * y * y)
        }
        this.xs = e, this.ys = n, this.c1s = u, this.c2s = c, this.c3s = f
    }
}
const wFe = 1;

function RQ(t) {
    const e = t.nodeType === wFe ? t : t.parentElement;
    if (!e) return null;
    const {
        top: n,
        left: r
    } = e.getBoundingClientRect();
    return {
        x: r,
        y: n
    }
}

function U_(t) {
    return {
        x: t.clientX,
        y: t.clientY
    }
}

function EFe(t) {
    var e;
    return t.nodeName === "IMG" && (SFe() || !(!((e = document.documentElement) === null || e === void 0) && e.contains(t)))
}

function AFe(t, e, n, r) {
    let i = t ? e.width : n,
        s = t ? e.height : r;
    return IQ() && t && (s /= window.devicePixelRatio, i /= window.devicePixelRatio), {
        dragPreviewWidth: i,
        dragPreviewHeight: s
    }
}

function CFe(t, e, n, r, i) {
    const s = EFe(e),
        a = RQ(s ? t : e),
        l = {
            x: n.x - a.x,
            y: n.y - a.y
        },
        {
            offsetWidth: u,
            offsetHeight: c
        } = t,
        {
            anchorX: f,
            anchorY: d
        } = r,
        {
            dragPreviewWidth: p,
            dragPreviewHeight: m
        } = AFe(s, e, u, c),
        y = () => {
            let A = new UH([0, .5, 1], [l.y, l.y / c * m, l.y + m - c]).interpolate(d);
            return IQ() && s && (A += (window.devicePixelRatio - 1) * m), A
        },
        v = () => new UH([0, .5, 1], [l.x, l.x / u * p, l.x + p - u]).interpolate(f),
        {
            offsetX: b,
            offsetY: _
        } = i,
        x = b === 0 || b,
        S = _ === 0 || _;
    return {
        x: x ? b : v(),
        y: S ? _ : y()
    }
}
class MFe {
    get window() {
        if (this.globalContext) return this.globalContext;
        if (typeof window < "u") return window
    }
    get document() {
        var e;
        return !((e = this.globalContext) === null || e === void 0) && e.document ? this.globalContext.document : this.window ? this.window.document : void 0
    }
    get rootElement() {
        var e;
        return ((e = this.optionsArgs) === null || e === void 0 ? void 0 : e.rootElement) || this.window
    }
    constructor(e, n) {
        this.ownerDocument = null, this.globalContext = e, this.optionsArgs = n
    }
}

function TFe(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function $H(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {},
            r = Object.keys(n);
        typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        }))), r.forEach(function(i) {
            TFe(t, i, n[i])
        })
    }
    return t
}
class PFe {
    profile() {
        var e, n;
        return {
            sourcePreviewNodes: this.sourcePreviewNodes.size,
            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
            sourceNodeOptions: this.sourceNodeOptions.size,
            sourceNodes: this.sourceNodes.size,
            dragStartSourceIds: ((e = this.dragStartSourceIds) === null || e === void 0 ? void 0 : e.length) || 0,
            dropTargetIds: this.dropTargetIds.length,
            dragEnterTargetIds: this.dragEnterTargetIds.length,
            dragOverTargetIds: ((n = this.dragOverTargetIds) === null || n === void 0 ? void 0 : n.length) || 0
        }
    }
    get window() {
        return this.options.window
    }
    get document() {
        return this.options.document
    }
    get rootElement() {
        return this.options.rootElement
    }
    setup() {
        const e = this.rootElement;
        if (e !== void 0) {
            if (e.__isReactDndBackendSetUp) throw new Error("Cannot have two HTML5 backends at the same time.");
            e.__isReactDndBackendSetUp = !0, this.addEventListeners(e)
        }
    }
    teardown() {
        const e = this.rootElement;
        if (e !== void 0 && (e.__isReactDndBackendSetUp = !1, this.removeEventListeners(this.rootElement), this.clearCurrentDragSourceNode(), this.asyncEndDragFrameId)) {
            var n;
            (n = this.window) === null || n === void 0 || n.cancelAnimationFrame(this.asyncEndDragFrameId)
        }
    }
    connectDragPreview(e, n, r) {
        return this.sourcePreviewNodeOptions.set(e, r), this.sourcePreviewNodes.set(e, n), () => {
            this.sourcePreviewNodes.delete(e), this.sourcePreviewNodeOptions.delete(e)
        }
    }
    connectDragSource(e, n, r) {
        this.sourceNodes.set(e, n), this.sourceNodeOptions.set(e, r);
        const i = o => this.handleDragStart(o, e),
            s = o => this.handleSelectStart(o);
        return n.setAttribute("draggable", "true"), n.addEventListener("dragstart", i), n.addEventListener("selectstart", s), () => {
            this.sourceNodes.delete(e), this.sourceNodeOptions.delete(e), n.removeEventListener("dragstart", i), n.removeEventListener("selectstart", s), n.setAttribute("draggable", "false")
        }
    }
    connectDropTarget(e, n) {
        const r = o => this.handleDragEnter(o, e),
            i = o => this.handleDragOver(o, e),
            s = o => this.handleDrop(o, e);
        return n.addEventListener("dragenter", r), n.addEventListener("dragover", i), n.addEventListener("drop", s), () => {
            n.removeEventListener("dragenter", r), n.removeEventListener("dragover", i), n.removeEventListener("drop", s)
        }
    }
    addEventListeners(e) {
        e.addEventListener && (e.addEventListener("dragstart", this.handleTopDragStart), e.addEventListener("dragstart", this.handleTopDragStartCapture, !0), e.addEventListener("dragend", this.handleTopDragEndCapture, !0), e.addEventListener("dragenter", this.handleTopDragEnter), e.addEventListener("dragenter", this.handleTopDragEnterCapture, !0), e.addEventListener("dragleave", this.handleTopDragLeaveCapture, !0), e.addEventListener("dragover", this.handleTopDragOver), e.addEventListener("dragover", this.handleTopDragOverCapture, !0), e.addEventListener("drop", this.handleTopDrop), e.addEventListener("drop", this.handleTopDropCapture, !0))
    }
    removeEventListeners(e) {
        e.removeEventListener && (e.removeEventListener("dragstart", this.handleTopDragStart), e.removeEventListener("dragstart", this.handleTopDragStartCapture, !0), e.removeEventListener("dragend", this.handleTopDragEndCapture, !0), e.removeEventListener("dragenter", this.handleTopDragEnter), e.removeEventListener("dragenter", this.handleTopDragEnterCapture, !0), e.removeEventListener("dragleave", this.handleTopDragLeaveCapture, !0), e.removeEventListener("dragover", this.handleTopDragOver), e.removeEventListener("dragover", this.handleTopDragOverCapture, !0), e.removeEventListener("drop", this.handleTopDrop), e.removeEventListener("drop", this.handleTopDropCapture, !0))
    }
    getCurrentSourceNodeOptions() {
        const e = this.monitor.getSourceId(),
            n = this.sourceNodeOptions.get(e);
        return $H({
            dropEffect: this.altKeyPressed ? "copy" : "move"
        }, n || {})
    }
    getCurrentDropEffect() {
        return this.isDraggingNativeItem() ? "copy" : this.getCurrentSourceNodeOptions().dropEffect
    }
    getCurrentSourcePreviewNodeOptions() {
        const e = this.monitor.getSourceId(),
            n = this.sourcePreviewNodeOptions.get(e);
        return $H({
            anchorX: .5,
            anchorY: .5,
            captureDraggingState: !1
        }, n || {})
    }
    isDraggingNativeItem() {
        const e = this.monitor.getItemType();
        return Object.keys(HH).some(n => HH[n] === e)
    }
    beginDragNativeItem(e, n) {
        this.clearCurrentDragSourceNode(), this.currentNativeSource = _Fe(e, n), this.currentNativeHandle = this.registry.addSource(e, this.currentNativeSource), this.actions.beginDrag([this.currentNativeHandle])
    }
    setCurrentDragSourceNode(e) {
        this.clearCurrentDragSourceNode(), this.currentDragSourceNode = e;
        const n = 1e3;
        this.mouseMoveTimeoutTimer = setTimeout(() => {
            var r;
            return (r = this.rootElement) === null || r === void 0 ? void 0 : r.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0)
        }, n)
    }
    clearCurrentDragSourceNode() {
        if (this.currentDragSourceNode) {
            if (this.currentDragSourceNode = null, this.rootElement) {
                var e;
                (e = this.window) === null || e === void 0 || e.clearTimeout(this.mouseMoveTimeoutTimer || void 0), this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0)
            }
            return this.mouseMoveTimeoutTimer = null, !0
        }
        return !1
    }
    handleDragStart(e, n) {
        e.defaultPrevented || (this.dragStartSourceIds || (this.dragStartSourceIds = []), this.dragStartSourceIds.unshift(n))
    }
    handleDragEnter(e, n) {
        this.dragEnterTargetIds.unshift(n)
    }
    handleDragOver(e, n) {
        this.dragOverTargetIds === null && (this.dragOverTargetIds = []), this.dragOverTargetIds.unshift(n)
    }
    handleDrop(e, n) {
        this.dropTargetIds.unshift(n)
    }
    constructor(e, n, r) {
        this.sourcePreviewNodes = new Map, this.sourcePreviewNodeOptions = new Map, this.sourceNodes = new Map, this.sourceNodeOptions = new Map, this.dragStartSourceIds = null, this.dropTargetIds = [], this.dragEnterTargetIds = [], this.currentNativeSource = null, this.currentNativeHandle = null, this.currentDragSourceNode = null, this.altKeyPressed = !1, this.mouseMoveTimeoutTimer = null, this.asyncEndDragFrameId = null, this.dragOverTargetIds = null, this.lastClientOffset = null, this.hoverRafId = null, this.getSourceClientOffset = i => {
            const s = this.sourceNodes.get(i);
            return s && RQ(s) || null
        }, this.endDragNativeItem = () => {
            this.isDraggingNativeItem() && (this.actions.endDrag(), this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle), this.currentNativeHandle = null, this.currentNativeSource = null)
        }, this.isNodeInDocument = i => !!(i && this.document && this.document.body && this.document.body.contains(i)), this.endDragIfSourceWasRemovedFromDOM = () => {
            const i = this.currentDragSourceNode;
            i == null || this.isNodeInDocument(i) || (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover())
        }, this.scheduleHover = i => {
            this.hoverRafId === null && typeof requestAnimationFrame < "u" && (this.hoverRafId = requestAnimationFrame(() => {
                this.monitor.isDragging() && this.actions.hover(i || [], {
                    clientOffset: this.lastClientOffset
                }), this.hoverRafId = null
            }))
        }, this.cancelHover = () => {
            this.hoverRafId !== null && typeof cancelAnimationFrame < "u" && (cancelAnimationFrame(this.hoverRafId), this.hoverRafId = null)
        }, this.handleTopDragStartCapture = () => {
            this.clearCurrentDragSourceNode(), this.dragStartSourceIds = []
        }, this.handleTopDragStart = i => {
            if (i.defaultPrevented) return;
            const {
                dragStartSourceIds: s
            } = this;
            this.dragStartSourceIds = null;
            const o = U_(i);
            this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()), this.actions.beginDrag(s || [], {
                publishSource: !1,
                getSourceClientOffset: this.getSourceClientOffset,
                clientOffset: o
            });
            const {
                dataTransfer: a
            } = i, l = cP(a);
            if (this.monitor.isDragging()) {
                if (a && typeof a.setDragImage == "function") {
                    const c = this.monitor.getSourceId(),
                        f = this.sourceNodes.get(c),
                        d = this.sourcePreviewNodes.get(c) || f;
                    if (d) {
                        const {
                            anchorX: p,
                            anchorY: m,
                            offsetX: y,
                            offsetY: v
                        } = this.getCurrentSourcePreviewNodeOptions(), x = CFe(f, d, o, {
                            anchorX: p,
                            anchorY: m
                        }, {
                            offsetX: y,
                            offsetY: v
                        });
                        a.setDragImage(d, x.x, x.y)
                    }
                }
                try {
                    a == null || a.setData("application/json", {})
                } catch {}
                this.setCurrentDragSourceNode(i.target);
                const {
                    captureDraggingState: u
                } = this.getCurrentSourcePreviewNodeOptions();
                u ? this.actions.publishDragSource() : setTimeout(() => this.actions.publishDragSource(), 0)
            } else if (l) this.beginDragNativeItem(l);
            else {
                if (a && !a.types && (i.target && !i.target.hasAttribute || !i.target.hasAttribute("draggable"))) return;
                i.preventDefault()
            }
        }, this.handleTopDragEndCapture = () => {
            this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover()
        }, this.handleTopDragEnterCapture = i => {
            if (this.dragEnterTargetIds = [], this.isDraggingNativeItem()) {
                var s;
                (s = this.currentNativeSource) === null || s === void 0 || s.loadDataTransfer(i.dataTransfer)
            }
            if (!this.enterLeaveCounter.enter(i.target) || this.monitor.isDragging()) return;
            const {
                dataTransfer: a
            } = i, l = cP(a);
            l && this.beginDragNativeItem(l, a)
        }, this.handleTopDragEnter = i => {
            const {
                dragEnterTargetIds: s
            } = this;
            if (this.dragEnterTargetIds = [], !this.monitor.isDragging()) return;
            this.altKeyPressed = i.altKey, s.length > 0 && this.actions.hover(s, {
                clientOffset: U_(i)
            }), s.some(a => this.monitor.canDropOnTarget(a)) && (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect()))
        }, this.handleTopDragOverCapture = i => {
            if (this.dragOverTargetIds = [], this.isDraggingNativeItem()) {
                var s;
                (s = this.currentNativeSource) === null || s === void 0 || s.loadDataTransfer(i.dataTransfer)
            }
        }, this.handleTopDragOver = i => {
            const {
                dragOverTargetIds: s
            } = this;
            if (this.dragOverTargetIds = [], !this.monitor.isDragging()) {
                i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none");
                return
            }
            this.altKeyPressed = i.altKey, this.lastClientOffset = U_(i), this.scheduleHover(s), (s || []).some(a => this.monitor.canDropOnTarget(a)) ? (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect())) : this.isDraggingNativeItem() ? i.preventDefault() : (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none"))
        }, this.handleTopDragLeaveCapture = i => {
            this.isDraggingNativeItem() && i.preventDefault(), this.enterLeaveCounter.leave(i.target) && (this.isDraggingNativeItem() && setTimeout(() => this.endDragNativeItem(), 0), this.cancelHover())
        }, this.handleTopDropCapture = i => {
            if (this.dropTargetIds = [], this.isDraggingNativeItem()) {
                var s;
                i.preventDefault(), (s = this.currentNativeSource) === null || s === void 0 || s.loadDataTransfer(i.dataTransfer)
            } else cP(i.dataTransfer) && i.preventDefault();
            this.enterLeaveCounter.reset()
        }, this.handleTopDrop = i => {
            const {
                dropTargetIds: s
            } = this;
            this.dropTargetIds = [], this.actions.hover(s, {
                clientOffset: U_(i)
            }), this.actions.drop({
                dropEffect: this.getCurrentDropEffect()
            }), this.isDraggingNativeItem() ? this.endDragNativeItem() : this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover()
        }, this.handleSelectStart = i => {
            const s = i.target;
            typeof s.dragDrop == "function" && (s.tagName === "INPUT" || s.tagName === "SELECT" || s.tagName === "TEXTAREA" || s.isContentEditable || (i.preventDefault(), s.dragDrop()))
        }, this.options = new MFe(n, r), this.actions = e.getActions(), this.monitor = e.getMonitor(), this.registry = e.getRegistry(), this.enterLeaveCounter = new bFe(this.isNodeInDocument)
    }
}
const NUe = function(e, n, r) {
    return new PFe(e, n, r)
};
var OQ = {
        exports: {}
    },
    wp = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
wp.ConcurrentRoot = 1;
wp.ContinuousEventPriority = 4;
wp.DefaultEventPriority = 16;
wp.DiscreteEventPriority = 1;
wp.IdleEventPriority = 536870912;
wp.LegacyRoot = 0;
OQ.exports = wp;
var Yh = OQ.exports;

function IFe(t) {
    let e;
    const n = new Set,
        r = (u, c) => {
            const f = typeof u == "function" ? u(e) : u;
            if (f !== e) {
                const d = e;
                e = c ? f : Object.assign({}, e, f), n.forEach(p => p(e, d))
            }
        },
        i = () => e,
        s = (u, c = i, f = Object.is) => {
            console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
            let d = c(e);

            function p() {
                const m = c(e);
                if (!f(d, m)) {
                    const y = d;
                    u(d = m, y)
                }
            }
            return n.add(p), () => n.delete(p)
        },
        l = {
            setState: r,
            getState: i,
            subscribe: (u, c, f) => c || f ? s(u, c, f) : (n.add(u), () => n.delete(u)),
            destroy: () => n.clear()
        };
    return e = t(r, i, l), l
}
const RFe = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    GH = RFe ? P.useEffect : P.useLayoutEffect;

function DQ(t) {
    const e = typeof t == "function" ? IFe(t) : t,
        n = (r = e.getState, i = Object.is) => {
            const [, s] = P.useReducer(v => v + 1, 0), o = e.getState(), a = P.useRef(o), l = P.useRef(r), u = P.useRef(i), c = P.useRef(!1), f = P.useRef();
            f.current === void 0 && (f.current = r(o));
            let d, p = !1;
            (a.current !== o || l.current !== r || u.current !== i || c.current) && (d = r(o), p = !i(f.current, d)), GH(() => {
                p && (f.current = d), a.current = o, l.current = r, u.current = i, c.current = !1
            });
            const m = P.useRef(o);
            GH(() => {
                const v = () => {
                        try {
                            const _ = e.getState(),
                                x = l.current(_);
                            u.current(f.current, x) || (a.current = _, f.current = x, s())
                        } catch {
                            c.current = !0, s()
                        }
                    },
                    b = e.subscribe(v);
                return e.getState() !== m.current && v(), b
            }, []);
            const y = p ? d : f.current;
            return P.useDebugValue(y), y
        };
    return Object.assign(n, e), n[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const r = [n, e];
        return {
            next() {
                const i = r.length <= 0;
                return {
                    value: r.shift(),
                    done: i
                }
            }
        }
    }, n
}
var LQ = {
        exports: {}
    },
    kQ = {
        exports: {}
    },
    BQ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(F, G) {
        var W = F.length;
        F.push(G);
        e: for (; 0 < W;) {
            var se = W - 1 >>> 1,
                ee = F[se];
            if (0 < i(ee, G)) F[se] = G, F[W] = ee, W = se;
            else break e
        }
    }

    function n(F) {
        return F.length === 0 ? null : F[0]
    }

    function r(F) {
        if (F.length === 0) return null;
        var G = F[0],
            W = F.pop();
        if (W !== G) {
            F[0] = W;
            e: for (var se = 0, ee = F.length, ae = ee >>> 1; se < ae;) {
                var de = 2 * (se + 1) - 1,
                    re = F[de],
                    _e = de + 1,
                    fe = F[_e];
                if (0 > i(re, W)) _e < ee && 0 > i(fe, re) ? (F[se] = fe, F[_e] = W, se = _e) : (F[se] = re, F[de] = W, se = de);
                else if (_e < ee && 0 > i(fe, W)) F[se] = fe, F[_e] = W, se = _e;
                else break e
            }
        }
        return G
    }

    function i(F, G) {
        var W = F.sortIndex - G.sortIndex;
        return W !== 0 ? W : F.id - G.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        u = [],
        c = 1,
        f = null,
        d = 3,
        p = !1,
        m = !1,
        y = !1,
        v = typeof setTimeout == "function" ? setTimeout : null,
        b = typeof clearTimeout == "function" ? clearTimeout : null,
        _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function x(F) {
        for (var G = n(u); G !== null;) {
            if (G.callback === null) r(u);
            else if (G.startTime <= F) r(u), G.sortIndex = G.expirationTime, e(l, G);
            else break;
            G = n(u)
        }
    }

    function S(F) {
        if (y = !1, x(F), !m)
            if (n(l) !== null) m = !0, q(E);
            else {
                var G = n(u);
                G !== null && Q(S, G.startTime - F)
            }
    }

    function E(F, G) {
        m = !1, y && (y = !1, b(M), M = -1), p = !0;
        var W = d;
        try {
            for (x(G), f = n(l); f !== null && (!(f.expirationTime > G) || F && !k());) {
                var se = f.callback;
                if (typeof se == "function") {
                    f.callback = null, d = f.priorityLevel;
                    var ee = se(f.expirationTime <= G);
                    G = t.unstable_now(), typeof ee == "function" ? f.callback = ee : f === n(l) && r(l), x(G)
                } else r(l);
                f = n(l)
            }
            if (f !== null) var ae = !0;
            else {
                var de = n(u);
                de !== null && Q(S, de.startTime - G), ae = !1
            }
            return ae
        } finally {
            f = null, d = W, p = !1
        }
    }
    var A = !1,
        T = null,
        M = -1,
        I = 5,
        O = -1;

    function k() {
        return !(t.unstable_now() - O < I)
    }

    function H() {
        if (T !== null) {
            var F = t.unstable_now();
            O = F;
            var G = !0;
            try {
                G = T(!0, F)
            } finally {
                G ? N() : (A = !1, T = null)
            }
        } else A = !1
    }
    var N;
    if (typeof _ == "function") N = function() {
        _(H)
    };
    else if (typeof MessageChannel < "u") {
        var B = new MessageChannel,
            U = B.port2;
        B.port1.onmessage = H, N = function() {
            U.postMessage(null)
        }
    } else N = function() {
        v(H, 0)
    };

    function q(F) {
        T = F, A || (A = !0, N())
    }

    function Q(F, G) {
        M = v(function() {
            F(t.unstable_now())
        }, G)
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(F) {
        F.callback = null
    }, t.unstable_continueExecution = function() {
        m || p || (m = !0, q(E))
    }, t.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < F ? Math.floor(1e3 / F) : 5
    }, t.unstable_getCurrentPriorityLevel = function() {
        return d
    }, t.unstable_getFirstCallbackNode = function() {
        return n(l)
    }, t.unstable_next = function(F) {
        switch (d) {
            case 1:
            case 2:
            case 3:
                var G = 3;
                break;
            default:
                G = d
        }
        var W = d;
        d = G;
        try {
            return F()
        } finally {
            d = W
        }
    }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(F, G) {
        switch (F) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                F = 3
        }
        var W = d;
        d = F;
        try {
            return G()
        } finally {
            d = W
        }
    }, t.unstable_scheduleCallback = function(F, G, W) {
        var se = t.unstable_now();
        switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? se + W : se) : W = se, F) {
            case 1:
                var ee = -1;
                break;
            case 2:
                ee = 250;
                break;
            case 5:
                ee = 1073741823;
                break;
            case 4:
                ee = 1e4;
                break;
            default:
                ee = 5e3
        }
        return ee = W + ee, F = {
            id: c++,
            callback: G,
            priorityLevel: F,
            startTime: W,
            expirationTime: ee,
            sortIndex: -1
        }, W > se ? (F.sortIndex = W, e(u, F), n(l) === null && F === n(u) && (y ? (b(M), M = -1) : y = !0, Q(S, W - se))) : (F.sortIndex = ee, e(l, F), m || p || (m = !0, q(E))), F
    }, t.unstable_shouldYield = k, t.unstable_wrapCallback = function(F) {
        var G = d;
        return function() {
            var W = d;
            d = G;
            try {
                return F.apply(this, arguments)
            } finally {
                d = W
            }
        }
    }
})(BQ);
kQ.exports = BQ;
var oO = kQ.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OFe = function(e) {
    var n = {},
        r = P,
        i = oO,
        s = Object.assign;

    function o(h) {
        for (var g = "https://reactjs.org/docs/error-decoder.html?invariant=" + h, w = 1; w < arguments.length; w++) g += "&args[]=" + encodeURIComponent(arguments[w]);
        return "Minified React error #" + h + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        l = Symbol.for("react.element"),
        u = Symbol.for("react.portal"),
        c = Symbol.for("react.fragment"),
        f = Symbol.for("react.strict_mode"),
        d = Symbol.for("react.profiler"),
        p = Symbol.for("react.provider"),
        m = Symbol.for("react.context"),
        y = Symbol.for("react.forward_ref"),
        v = Symbol.for("react.suspense"),
        b = Symbol.for("react.suspense_list"),
        _ = Symbol.for("react.memo"),
        x = Symbol.for("react.lazy"),
        S = Symbol.for("react.offscreen"),
        E = Symbol.iterator;

    function A(h) {
        return h === null || typeof h != "object" ? null : (h = E && h[E] || h["@@iterator"], typeof h == "function" ? h : null)
    }

    function T(h) {
        if (h == null) return null;
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
        switch (h) {
            case c:
                return "Fragment";
            case u:
                return "Portal";
            case d:
                return "Profiler";
            case f:
                return "StrictMode";
            case v:
                return "Suspense";
            case b:
                return "SuspenseList"
        }
        if (typeof h == "object") switch (h.$$typeof) {
            case m:
                return (h.displayName || "Context") + ".Consumer";
            case p:
                return (h._context.displayName || "Context") + ".Provider";
            case y:
                var g = h.render;
                return h = h.displayName, h || (h = g.displayName || g.name || "", h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"), h;
            case _:
                return g = h.displayName || null, g !== null ? g : T(h.type) || "Memo";
            case x:
                g = h._payload, h = h._init;
                try {
                    return T(h(g))
                } catch {}
        }
        return null
    }

    function M(h) {
        var g = h.type;
        switch (h.tag) {
            case 24:
                return "Cache";
            case 9:
                return (g.displayName || "Context") + ".Consumer";
            case 10:
                return (g._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return h = g.render, h = h.displayName || h.name || "", g.displayName || (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return g;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return T(g);
            case 8:
                return g === f ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof g == "function") return g.displayName || g.name || null;
                if (typeof g == "string") return g
        }
        return null
    }

    function I(h) {
        var g = h,
            w = h;
        if (h.alternate)
            for (; g.return;) g = g.return;
        else {
            h = g;
            do g = h, g.flags & 4098 && (w = g.return), h = g.return; while (h)
        }
        return g.tag === 3 ? w : null
    }

    function O(h) {
        if (I(h) !== h) throw Error(o(188))
    }

    function k(h) {
        var g = h.alternate;
        if (!g) {
            if (g = I(h), g === null) throw Error(o(188));
            return g !== h ? null : h
        }
        for (var w = h, C = g;;) {
            var R = w.return;
            if (R === null) break;
            var L = R.alternate;
            if (L === null) {
                if (C = R.return, C !== null) {
                    w = C;
                    continue
                }
                break
            }
            if (R.child === L.child) {
                for (L = R.child; L;) {
                    if (L === w) return O(R), h;
                    if (L === C) return O(R), g;
                    L = L.sibling
                }
                throw Error(o(188))
            }
            if (w.return !== C.return) w = R, C = L;
            else {
                for (var ne = !1, pe = R.child; pe;) {
                    if (pe === w) {
                        ne = !0, w = R, C = L;
                        break
                    }
                    if (pe === C) {
                        ne = !0, C = R, w = L;
                        break
                    }
                    pe = pe.sibling
                }
                if (!ne) {
                    for (pe = L.child; pe;) {
                        if (pe === w) {
                            ne = !0, w = L, C = R;
                            break
                        }
                        if (pe === C) {
                            ne = !0, C = L, w = R;
                            break
                        }
                        pe = pe.sibling
                    }
                    if (!ne) throw Error(o(189))
                }
            }
            if (w.alternate !== C) throw Error(o(190))
        }
        if (w.tag !== 3) throw Error(o(188));
        return w.stateNode.current === w ? h : g
    }

    function H(h) {
        return h = k(h), h !== null ? N(h) : null
    }

    function N(h) {
        if (h.tag === 5 || h.tag === 6) return h;
        for (h = h.child; h !== null;) {
            var g = N(h);
            if (g !== null) return g;
            h = h.sibling
        }
        return null
    }

    function B(h) {
        if (h.tag === 5 || h.tag === 6) return h;
        for (h = h.child; h !== null;) {
            if (h.tag !== 4) {
                var g = B(h);
                if (g !== null) return g
            }
            h = h.sibling
        }
        return null
    }
    var U = Array.isArray,
        q = e.getPublicInstance,
        Q = e.getRootHostContext,
        F = e.getChildHostContext,
        G = e.prepareForCommit,
        W = e.resetAfterCommit,
        se = e.createInstance,
        ee = e.appendInitialChild,
        ae = e.finalizeInitialChildren,
        de = e.prepareUpdate,
        re = e.shouldSetTextContent,
        _e = e.createTextInstance,
        fe = e.scheduleTimeout,
        ue = e.cancelTimeout,
        ve = e.noTimeout,
        xe = e.isPrimaryRenderer,
        be = e.supportsMutation,
        he = e.supportsPersistence,
        me = e.supportsHydration,
        Ce = e.getInstanceFromNode,
        Ne = e.preparePortalMount,
        De = e.getCurrentEventPriority,
        je = e.detachDeletedInstance,
        Ke = e.supportsMicrotasks,
        He = e.scheduleMicrotask,
        qe = e.supportsTestSelectors,
        Xe = e.findFiberRoot,
        K = e.getBoundingRect,
        V = e.getTextContent,
        ge = e.isHiddenSubtree,
        Be = e.matchAccessibilityRole,
        ze = e.setFocusIfFocusable,
        Ue = e.setupIntersectionObserver,
        Ye = e.appendChild,
        Te = e.appendChildToContainer,
        we = e.commitTextUpdate,
        lt = e.commitMount,
        nt = e.commitUpdate,
        vt = e.insertBefore,
        ht = e.insertInContainerBefore,
        pt = e.removeChild,
        le = e.removeChildFromContainer,
        Ie = e.resetTextContent,
        tt = e.hideInstance,
        oe = e.hideTextInstance,
        Ee = e.unhideInstance,
        Fe = e.unhideTextInstance,
        Ve = e.clearContainer,
        ct = e.cloneInstance,
        bt = e.createContainerChildSet,
        Kt = e.appendChildToContainerChildSet,
        un = e.finalizeContainerChildren,
        zt = e.replaceContainerChildren,
        Ot = e.cloneHiddenInstance,
        tn = e.cloneHiddenTextInstance,
        Xt = e.canHydrateInstance,
        Hr = e.canHydrateTextInstance,
        cs = e.canHydrateSuspenseInstance,
        Gn = e.isSuspenseInstancePending,
        D = e.isSuspenseInstanceFallback,
        z = e.registerSuspenseInstanceRetry,
        j = e.getNextHydratableSibling,
        X = e.getFirstHydratableChild,
        te = e.getFirstHydratableChildWithinContainer,
        Oe = e.getFirstHydratableChildWithinSuspenseInstance,
        $e = e.hydrateInstance,
        rt = e.hydrateTextInstance,
        Ze = e.hydrateSuspenseInstance,
        Tt = e.getNextHydratableInstanceAfterSuspenseInstance,
        st = e.commitHydratedContainer,
        St = e.commitHydratedSuspenseInstance,
        Qe = e.clearSuspenseBoundary,
        ft = e.clearSuspenseBoundaryFromContainer,
        Vt = e.shouldDeleteUnhydratedTailInstances,
        bn = e.didNotMatchHydratedContainerTextInstance,
        Ht = e.didNotMatchHydratedTextInstance,
        kt;

    function nr(h) {
        if (kt === void 0) try {
            throw Error()
        } catch (w) {
            var g = w.stack.trim().match(/\n( *(at )?)/);
            kt = g && g[1] || ""
        }
        return `
` + kt + h
    }
    var vn = !1;

    function qn(h, g) {
        if (!h || vn) return "";
        vn = !0;
        var w = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (g)
                if (g = function() {
                        throw Error()
                    }, Object.defineProperty(g.prototype, "props", {
                        set: function() {
                            throw Error()
                        }
                    }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(g, [])
                    } catch (Je) {
                        var C = Je
                    }
                    Reflect.construct(h, [], g)
                } else {
                    try {
                        g.call()
                    } catch (Je) {
                        C = Je
                    }
                    h.call(g.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (Je) {
                    C = Je
                }
                h()
            }
        } catch (Je) {
            if (Je && C && typeof Je.stack == "string") {
                for (var R = Je.stack.split(`
`), L = C.stack.split(`
`), ne = R.length - 1, pe = L.length - 1; 1 <= ne && 0 <= pe && R[ne] !== L[pe];) pe--;
                for (; 1 <= ne && 0 <= pe; ne--, pe--)
                    if (R[ne] !== L[pe]) {
                        if (ne !== 1 || pe !== 1)
                            do
                                if (ne--, pe--, 0 > pe || R[ne] !== L[pe]) {
                                    var Re = `
` + R[ne].replace(" at new ", " at ");
                                    return h.displayName && Re.includes("<anonymous>") && (Re = Re.replace("<anonymous>", h.displayName)), Re
                                }
                        while (1 <= ne && 0 <= pe);
                        break
                    }
            }
        } finally {
            vn = !1, Error.prepareStackTrace = w
        }
        return (h = h ? h.displayName || h.name : "") ? nr(h) : ""
    }
    var Ii = Object.prototype.hasOwnProperty,
        rr = [],
        Pn = -1;

    function xn(h) {
        return {
            current: h
        }
    }

    function $t(h) {
        0 > Pn || (h.current = rr[Pn], rr[Pn] = null, Pn--)
    }

    function cn(h, g) {
        Pn++, rr[Pn] = h.current, h.current = g
    }
    var zn = {},
        Qn = xn(zn),
        ar = xn(!1),
        Ir = zn;

    function fs(h, g) {
        var w = h.type.contextTypes;
        if (!w) return zn;
        var C = h.stateNode;
        if (C && C.__reactInternalMemoizedUnmaskedChildContext === g) return C.__reactInternalMemoizedMaskedChildContext;
        var R = {},
            L;
        for (L in w) R[L] = g[L];
        return C && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = g, h.__reactInternalMemoizedMaskedChildContext = R), R
    }

    function Ur(h) {
        return h = h.childContextTypes, h != null
    }

    function fa() {
        $t(ar), $t(Qn)
    }

    function xo(h, g, w) {
        if (Qn.current !== zn) throw Error(o(168));
        cn(Qn, g), cn(ar, w)
    }

    function Mf(h, g, w) {
        var C = h.stateNode;
        if (g = g.childContextTypes, typeof C.getChildContext != "function") return w;
        C = C.getChildContext();
        for (var R in C)
            if (!(R in g)) throw Error(o(108, M(h) || "Unknown", R));
        return s({}, w, C)
    }

    function Ul(h) {
        return h = (h = h.stateNode) && h.__reactInternalMemoizedMergedChildContext || zn, Ir = Qn.current, cn(Qn, h), cn(ar, ar.current), !0
    }

    function $l(h, g, w) {
        var C = h.stateNode;
        if (!C) throw Error(o(169));
        w ? (h = Mf(h, g, Ir), C.__reactInternalMemoizedMergedChildContext = h, $t(ar), $t(Qn), cn(Qn, h)) : $t(ar), cn(ar, w)
    }
    var ui = Math.clz32 ? Math.clz32 : Ap,
        Bg = Math.log,
        Fg = Math.LN2;

    function Ap(h) {
        return h >>>= 0, h === 0 ? 32 : 31 - (Bg(h) / Fg | 0) | 0
    }
    var Ju = 64,
        Yu = 4194304;

    function Gl(h) {
        switch (h & -h) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return h & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return h & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return h
        }
    }

    function Vl(h, g) {
        var w = h.pendingLanes;
        if (w === 0) return 0;
        var C = 0,
            R = h.suspendedLanes,
            L = h.pingedLanes,
            ne = w & 268435455;
        if (ne !== 0) {
            var pe = ne & ~R;
            pe !== 0 ? C = Gl(pe) : (L &= ne, L !== 0 && (C = Gl(L)))
        } else ne = w & ~R, ne !== 0 ? C = Gl(ne) : L !== 0 && (C = Gl(L));
        if (C === 0) return 0;
        if (g !== 0 && g !== C && !(g & R) && (R = C & -C, L = g & -g, R >= L || R === 16 && (L & 4194240) !== 0)) return g;
        if (C & 4 && (C |= w & 16), g = h.entangledLanes, g !== 0)
            for (h = h.entanglements, g &= C; 0 < g;) w = 31 - ui(g), R = 1 << w, C |= h[w], g &= ~R;
        return C
    }

    function Ng(h, g) {
        switch (h) {
            case 1:
            case 2:
            case 4:
                return g + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return g + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }

    function zg(h, g) {
        for (var w = h.suspendedLanes, C = h.pingedLanes, R = h.expirationTimes, L = h.pendingLanes; 0 < L;) {
            var ne = 31 - ui(L),
                pe = 1 << ne,
                Re = R[ne];
            Re === -1 ? (!(pe & w) || pe & C) && (R[ne] = Ng(pe, g)) : Re <= g && (h.expiredLanes |= pe), L &= ~pe
        }
    }

    function Tf(h) {
        return h = h.pendingLanes & -1073741825, h !== 0 ? h : h & 1073741824 ? 1073741824 : 0
    }

    function el(h) {
        for (var g = [], w = 0; 31 > w; w++) g.push(h);
        return g
    }

    function jl(h, g, w) {
        h.pendingLanes |= g, g !== 536870912 && (h.suspendedLanes = 0, h.pingedLanes = 0), h = h.eventTimes, g = 31 - ui(g), h[g] = w
    }

    function Hg(h, g) {
        var w = h.pendingLanes & ~g;
        h.pendingLanes = g, h.suspendedLanes = 0, h.pingedLanes = 0, h.expiredLanes &= g, h.mutableReadLanes &= g, h.entangledLanes &= g, g = h.entanglements;
        var C = h.eventTimes;
        for (h = h.expirationTimes; 0 < w;) {
            var R = 31 - ui(w),
                L = 1 << R;
            g[R] = 0, C[R] = -1, h[R] = -1, w &= ~L
        }
    }

    function Pf(h, g) {
        var w = h.entangledLanes |= g;
        for (h = h.entanglements; w;) {
            var C = 31 - ui(w),
                R = 1 << C;
            R & g | h[C] & g && (h[C] |= g), w &= ~R
        }
    }
    var fn = 0;

    function Qu(h) {
        return h &= -h, 1 < h ? 4 < h ? h & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var Wl = i.unstable_scheduleCallback,
        da = i.unstable_cancelCallback,
        Ug = i.unstable_shouldYield,
        pa = i.unstable_requestPaint,
        kn = i.unstable_now,
        Zu = i.unstable_ImmediatePriority,
        Ms = i.unstable_UserBlockingPriority,
        Ts = i.unstable_NormalPriority,
        $g = i.unstable_IdlePriority,
        Kl = null,
        Ps = null;

    function Cp(h) {
        if (Ps && typeof Ps.onCommitFiberRoot == "function") try {
            Ps.onCommitFiberRoot(Kl, h, void 0, (h.current.flags & 128) === 128)
        } catch {}
    }

    function If(h, g) {
        return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g
    }
    var Is = typeof Object.is == "function" ? Object.is : If,
        ji = null,
        ds = !1,
        Rf = !1;

    function Z(h) {
        ji === null ? ji = [h] : ji.push(h)
    }

    function ce(h) {
        ds = !0, Z(h)
    }

    function Se() {
        if (!Rf && ji !== null) {
            Rf = !0;
            var h = 0,
                g = fn;
            try {
                var w = ji;
                for (fn = 1; h < w.length; h++) {
                    var C = w[h];
                    do C = C(!0); while (C !== null)
                }
                ji = null, ds = !1
            } catch (R) {
                throw ji !== null && (ji = ji.slice(h + 1)), Wl(Zu, Se), R
            } finally {
                fn = g, Rf = !1
            }
        }
        return null
    }
    var ut = a.ReactCurrentBatchConfig;

    function Jt(h, g) {
        if (Is(h, g)) return !0;
        if (typeof h != "object" || h === null || typeof g != "object" || g === null) return !1;
        var w = Object.keys(h),
            C = Object.keys(g);
        if (w.length !== C.length) return !1;
        for (C = 0; C < w.length; C++) {
            var R = w[C];
            if (!Ii.call(g, R) || !Is(h[R], g[R])) return !1
        }
        return !0
    }

    function wn(h) {
        switch (h.tag) {
            case 5:
                return nr(h.type);
            case 16:
                return nr("Lazy");
            case 13:
                return nr("Suspense");
            case 19:
                return nr("SuspenseList");
            case 0:
            case 2:
            case 15:
                return h = qn(h.type, !1), h;
            case 11:
                return h = qn(h.type.render, !1), h;
            case 1:
                return h = qn(h.type, !0), h;
            default:
                return ""
        }
    }

    function mn(h, g) {
        if (h && h.defaultProps) {
            g = s({}, g), h = h.defaultProps;
            for (var w in h) g[w] === void 0 && (g[w] = h[w]);
            return g
        }
        return g
    }
    var Yt = xn(null),
        Cn = null,
        gr = null,
        $r = null;

    function ha() {
        $r = gr = Cn = null
    }

    function ec(h, g, w) {
        xe ? (cn(Yt, g._currentValue), g._currentValue = w) : (cn(Yt, g._currentValue2), g._currentValue2 = w)
    }

    function ql(h) {
        var g = Yt.current;
        $t(Yt), xe ? h._currentValue = g : h._currentValue2 = g
    }

    function tc(h, g, w) {
        for (; h !== null;) {
            var C = h.alternate;
            if ((h.childLanes & g) !== g ? (h.childLanes |= g, C !== null && (C.childLanes |= g)) : C !== null && (C.childLanes & g) !== g && (C.childLanes |= g), h === w) break;
            h = h.return
        }
    }

    function ma(h, g) {
        Cn = h, $r = gr = null, h = h.dependencies, h !== null && h.firstContext !== null && (h.lanes & g && (Js = !0), h.firstContext = null)
    }

    function Rs(h) {
        var g = xe ? h._currentValue : h._currentValue2;
        if ($r !== h)
            if (h = {
                    context: h,
                    memoizedValue: g,
                    next: null
                }, gr === null) {
                if (Cn === null) throw Error(o(308));
                gr = h, Cn.dependencies = {
                    lanes: 0,
                    firstContext: h
                }
            } else gr = gr.next = h;
        return g
    }
    var _o = null,
        $ = !1;

    function ie(h) {
        h.updateQueue = {
            baseState: h.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }

    function Me(h, g) {
        h = h.updateQueue, g.updateQueue === h && (g.updateQueue = {
            baseState: h.baseState,
            firstBaseUpdate: h.firstBaseUpdate,
            lastBaseUpdate: h.lastBaseUpdate,
            shared: h.shared,
            effects: h.effects
        })
    }

    function Ge(h, g) {
        return {
            eventTime: h,
            lane: g,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }

    function Pt(h, g) {
        var w = h.updateQueue;
        w !== null && (w = w.shared, Zr !== null && h.mode & 1 && !(gn & 2) ? (h = w.interleaved, h === null ? (g.next = g, _o === null ? _o = [w] : _o.push(w)) : (g.next = h.next, h.next = g), w.interleaved = g) : (h = w.pending, h === null ? g.next = g : (g.next = h.next, h.next = g), w.pending = g))
    }

    function xt(h, g, w) {
        if (g = g.updateQueue, g !== null && (g = g.shared, (w & 4194240) !== 0)) {
            var C = g.lanes;
            C &= h.pendingLanes, w |= C, g.lanes = w, Pf(h, w)
        }
    }

    function an(h, g) {
        var w = h.updateQueue,
            C = h.alternate;
        if (C !== null && (C = C.updateQueue, w === C)) {
            var R = null,
                L = null;
            if (w = w.firstBaseUpdate, w !== null) {
                do {
                    var ne = {
                        eventTime: w.eventTime,
                        lane: w.lane,
                        tag: w.tag,
                        payload: w.payload,
                        callback: w.callback,
                        next: null
                    };
                    L === null ? R = L = ne : L = L.next = ne, w = w.next
                } while (w !== null);
                L === null ? R = L = g : L = L.next = g
            } else R = L = g;
            w = {
                baseState: C.baseState,
                firstBaseUpdate: R,
                lastBaseUpdate: L,
                shared: C.shared,
                effects: C.effects
            }, h.updateQueue = w;
            return
        }
        h = w.lastBaseUpdate, h === null ? w.firstBaseUpdate = g : h.next = g, w.lastBaseUpdate = g
    }

    function Bn(h, g, w, C) {
        var R = h.updateQueue;
        $ = !1;
        var L = R.firstBaseUpdate,
            ne = R.lastBaseUpdate,
            pe = R.shared.pending;
        if (pe !== null) {
            R.shared.pending = null;
            var Re = pe,
                Je = Re.next;
            Re.next = null, ne === null ? L = Je : ne.next = Je, ne = Re;
            var At = h.alternate;
            At !== null && (At = At.updateQueue, pe = At.lastBaseUpdate, pe !== ne && (pe === null ? At.firstBaseUpdate = Je : pe.next = Je, At.lastBaseUpdate = Re))
        }
        if (L !== null) {
            var nn = R.baseState;
            ne = 0, At = Je = Re = null, pe = L;
            do {
                var Ft = pe.lane,
                    Zn = pe.eventTime;
                if ((C & Ft) === Ft) {
                    At !== null && (At = At.next = {
                        eventTime: Zn,
                        lane: 0,
                        tag: pe.tag,
                        payload: pe.payload,
                        callback: pe.callback,
                        next: null
                    });
                    e: {
                        var Lt = h,
                            Ji = pe;
                        switch (Ft = g, Zn = w, Ji.tag) {
                            case 1:
                                if (Lt = Ji.payload, typeof Lt == "function") {
                                    nn = Lt.call(Zn, nn, Ft);
                                    break e
                                }
                                nn = Lt;
                                break e;
                            case 3:
                                Lt.flags = Lt.flags & -65537 | 128;
                            case 0:
                                if (Lt = Ji.payload, Ft = typeof Lt == "function" ? Lt.call(Zn, nn, Ft) : Lt, Ft == null) break e;
                                nn = s({}, nn, Ft);
                                break e;
                            case 2:
                                $ = !0
                        }
                    }
                    pe.callback !== null && pe.lane !== 0 && (h.flags |= 64, Ft = R.effects, Ft === null ? R.effects = [pe] : Ft.push(pe))
                } else Zn = {
                    eventTime: Zn,
                    lane: Ft,
                    tag: pe.tag,
                    payload: pe.payload,
                    callback: pe.callback,
                    next: null
                }, At === null ? (Je = At = Zn, Re = nn) : At = At.next = Zn, ne |= Ft;
                if (pe = pe.next, pe === null) {
                    if (pe = R.shared.pending, pe === null) break;
                    Ft = pe, pe = Ft.next, Ft.next = null, R.lastBaseUpdate = Ft, R.shared.pending = null
                }
            } while (1);
            if (At === null && (Re = nn), R.baseState = Re, R.firstBaseUpdate = Je, R.lastBaseUpdate = At, g = R.shared.interleaved, g !== null) {
                R = g;
                do ne |= R.lane, R = R.next; while (R !== g)
            } else L === null && (R.shared.lanes = 0);
            Dp |= ne, h.lanes = ne, h.memoizedState = nn
        }
    }

    function ir(h, g, w) {
        if (h = g.effects, g.effects = null, h !== null)
            for (g = 0; g < h.length; g++) {
                var C = h[g],
                    R = C.callback;
                if (R !== null) {
                    if (C.callback = null, C = w, typeof R != "function") throw Error(o(191, R));
                    R.call(C)
                }
            }
    }
    var Gr = new r.Component().refs;

    function ci(h, g, w, C) {
        g = h.memoizedState, w = w(C, g), w = w == null ? g : s({}, g, w), h.memoizedState = w, h.lanes === 0 && (h.updateQueue.baseState = w)
    }
    var fi = {
        isMounted: function(h) {
            return (h = h._reactInternals) ? I(h) === h : !1
        },
        enqueueSetState: function(h, g, w) {
            h = h._reactInternals;
            var C = gs(),
                R = ic(h),
                L = Ge(C, R);
            L.payload = g, w != null && (L.callback = w), Pt(h, L), g = Co(h, R, C), g !== null && xt(g, h, R)
        },
        enqueueReplaceState: function(h, g, w) {
            h = h._reactInternals;
            var C = gs(),
                R = ic(h),
                L = Ge(C, R);
            L.tag = 1, L.payload = g, w != null && (L.callback = w), Pt(h, L), g = Co(h, R, C), g !== null && xt(g, h, R)
        },
        enqueueForceUpdate: function(h, g) {
            h = h._reactInternals;
            var w = gs(),
                C = ic(h),
                R = Ge(w, C);
            R.tag = 2, g != null && (R.callback = g), Pt(h, R), g = Co(h, C, w), g !== null && xt(g, h, C)
        }
    };

    function Vr(h, g, w, C, R, L, ne) {
        return h = h.stateNode, typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(C, L, ne) : g.prototype && g.prototype.isPureReactComponent ? !Jt(w, C) || !Jt(R, L) : !0
    }

    function ps(h, g, w) {
        var C = !1,
            R = zn,
            L = g.contextType;
        return typeof L == "object" && L !== null ? L = Rs(L) : (R = Ur(g) ? Ir : Qn.current, C = g.contextTypes, L = (C = C != null) ? fs(h, R) : zn), g = new g(w, L), h.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, g.updater = fi, h.stateNode = g, g._reactInternals = h, C && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = R, h.__reactInternalMemoizedMaskedChildContext = L), g
    }

    function hs(h, g, w, C) {
        h = g.state, typeof g.componentWillReceiveProps == "function" && g.componentWillReceiveProps(w, C), typeof g.UNSAFE_componentWillReceiveProps == "function" && g.UNSAFE_componentWillReceiveProps(w, C), g.state !== h && fi.enqueueReplaceState(g, g.state, null)
    }

    function So(h, g, w, C) {
        var R = h.stateNode;
        R.props = w, R.state = h.memoizedState, R.refs = Gr, ie(h);
        var L = g.contextType;
        typeof L == "object" && L !== null ? R.context = Rs(L) : (L = Ur(g) ? Ir : Qn.current, R.context = fs(h, L)), R.state = h.memoizedState, L = g.getDerivedStateFromProps, typeof L == "function" && (ci(h, g, L, w), R.state = h.memoizedState), typeof g.getDerivedStateFromProps == "function" || typeof R.getSnapshotBeforeUpdate == "function" || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (g = R.state, typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount(), g !== R.state && fi.enqueueReplaceState(R, R.state, null), Bn(h, w, R, C), R.state = h.memoizedState), typeof R.componentDidMount == "function" && (h.flags |= 4194308)
    }
    var Wi = [],
        Os = 0,
        Of = null,
        Xl = 0,
        Ri = [],
        wo = 0,
        Df = null,
        Jl = 1,
        Yl = "";

    function Lf(h, g) {
        Wi[Os++] = Xl, Wi[Os++] = Of, Of = h, Xl = g
    }

    function $B(h, g, w) {
        Ri[wo++] = Jl, Ri[wo++] = Yl, Ri[wo++] = Df, Df = h;
        var C = Jl;
        h = Yl;
        var R = 32 - ui(C) - 1;
        C &= ~(1 << R), w += 1;
        var L = 32 - ui(g) + R;
        if (30 < L) {
            var ne = R - R % 5;
            L = (C & (1 << ne) - 1).toString(32), C >>= ne, R -= ne, Jl = 1 << 32 - ui(g) + R | w << R | C, Yl = L + h
        } else Jl = 1 << L | w << R | C, Yl = h
    }

    function sC(h) {
        h.return !== null && (Lf(h, 1), $B(h, 1, 0))
    }

    function oC(h) {
        for (; h === Of;) Of = Wi[--Os], Wi[Os] = null, Xl = Wi[--Os], Wi[Os] = null;
        for (; h === Df;) Df = Ri[--wo], Ri[wo] = null, Yl = Ri[--wo], Ri[wo] = null, Jl = Ri[--wo], Ri[wo] = null
    }
    var qs = null,
        Xs = null,
        yr = !1,
        Gg = !1,
        ga = null;

    function GB(h, g) {
        var w = Mo(5, null, null, 0);
        w.elementType = "DELETED", w.stateNode = g, w.return = h, g = h.deletions, g === null ? (h.deletions = [w], h.flags |= 16) : g.push(w)
    }

    function VB(h, g) {
        switch (h.tag) {
            case 5:
                return g = Xt(g, h.type, h.pendingProps), g !== null ? (h.stateNode = g, qs = h, Xs = X(g), !0) : !1;
            case 6:
                return g = Hr(g, h.pendingProps), g !== null ? (h.stateNode = g, qs = h, Xs = null, !0) : !1;
            case 13:
                if (g = cs(g), g !== null) {
                    var w = Df !== null ? {
                        id: Jl,
                        overflow: Yl
                    } : null;
                    return h.memoizedState = {
                        dehydrated: g,
                        treeContext: w,
                        retryLane: 1073741824
                    }, w = Mo(18, null, null, 0), w.stateNode = g, w.return = h, h.child = w, qs = h, Xs = null, !0
                }
                return !1;
            default:
                return !1
        }
    }

    function aC(h) {
        return (h.mode & 1) !== 0 && (h.flags & 128) === 0
    }

    function lC(h) {
        if (yr) {
            var g = Xs;
            if (g) {
                var w = g;
                if (!VB(h, g)) {
                    if (aC(h)) throw Error(o(418));
                    g = j(w);
                    var C = qs;
                    g && VB(h, g) ? GB(C, w) : (h.flags = h.flags & -4097 | 2, yr = !1, qs = h)
                }
            } else {
                if (aC(h)) throw Error(o(418));
                h.flags = h.flags & -4097 | 2, yr = !1, qs = h
            }
        }
    }

    function jB(h) {
        for (h = h.return; h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13;) h = h.return;
        qs = h
    }

    function Vg(h) {
        if (!me || h !== qs) return !1;
        if (!yr) return jB(h), yr = !0, !1;
        if (h.tag !== 3 && (h.tag !== 5 || Vt(h.type) && !re(h.type, h.memoizedProps))) {
            var g = Xs;
            if (g) {
                if (aC(h)) {
                    for (h = Xs; h;) h = j(h);
                    throw Error(o(418))
                }
                for (; g;) GB(h, g), g = j(g)
            }
        }
        if (jB(h), h.tag === 13) {
            if (!me) throw Error(o(316));
            if (h = h.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(o(317));
            Xs = Tt(h)
        } else Xs = qs ? j(h.stateNode) : null;
        return !0
    }

    function Mp() {
        me && (Xs = qs = null, Gg = yr = !1)
    }

    function uC(h) {
        ga === null ? ga = [h] : ga.push(h)
    }

    function jg(h, g, w) {
        if (h = w.ref, h !== null && typeof h != "function" && typeof h != "object") {
            if (w._owner) {
                if (w = w._owner, w) {
                    if (w.tag !== 1) throw Error(o(309));
                    var C = w.stateNode
                }
                if (!C) throw Error(o(147, h));
                var R = C,
                    L = "" + h;
                return g !== null && g.ref !== null && typeof g.ref == "function" && g.ref._stringRef === L ? g.ref : (g = function(ne) {
                    var pe = R.refs;
                    pe === Gr && (pe = R.refs = {}), ne === null ? delete pe[L] : pe[L] = ne
                }, g._stringRef = L, g)
            }
            if (typeof h != "string") throw Error(o(284));
            if (!w._owner) throw Error(o(290, h))
        }
        return h
    }

    function hb(h, g) {
        throw h = Object.prototype.toString.call(g), Error(o(31, h === "[object Object]" ? "object with keys {" + Object.keys(g).join(", ") + "}" : h))
    }

    function WB(h) {
        var g = h._init;
        return g(h._payload)
    }

    function KB(h) {
        function g(Ae, ye) {
            if (h) {
                var Pe = Ae.deletions;
                Pe === null ? (Ae.deletions = [ye], Ae.flags |= 16) : Pe.push(ye)
            }
        }

        function w(Ae, ye) {
            if (!h) return null;
            for (; ye !== null;) g(Ae, ye), ye = ye.sibling;
            return null
        }

        function C(Ae, ye) {
            for (Ae = new Map; ye !== null;) ye.key !== null ? Ae.set(ye.key, ye) : Ae.set(ye.index, ye), ye = ye.sibling;
            return Ae
        }

        function R(Ae, ye) {
            return Ae = oc(Ae, ye), Ae.index = 0, Ae.sibling = null, Ae
        }

        function L(Ae, ye, Pe) {
            return Ae.index = Pe, h ? (Pe = Ae.alternate, Pe !== null ? (Pe = Pe.index, Pe < ye ? (Ae.flags |= 2, ye) : Pe) : (Ae.flags |= 2, ye)) : (Ae.flags |= 1048576, ye)
        }

        function ne(Ae) {
            return h && Ae.alternate === null && (Ae.flags |= 2), Ae
        }

        function pe(Ae, ye, Pe, yt) {
            return ye === null || ye.tag !== 6 ? (ye = WC(Pe, Ae.mode, yt), ye.return = Ae, ye) : (ye = R(ye, Pe), ye.return = Ae, ye)
        }

        function Re(Ae, ye, Pe, yt) {
            var Dt = Pe.type;
            return Dt === c ? At(Ae, ye, Pe.props.children, yt, Pe.key) : ye !== null && (ye.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === x && WB(Dt) === ye.type) ? (yt = R(ye, Pe.props), yt.ref = jg(Ae, ye, Pe), yt.return = Ae, yt) : (yt = jb(Pe.type, Pe.key, Pe.props, null, Ae.mode, yt), yt.ref = jg(Ae, ye, Pe), yt.return = Ae, yt)
        }

        function Je(Ae, ye, Pe, yt) {
            return ye === null || ye.tag !== 4 || ye.stateNode.containerInfo !== Pe.containerInfo || ye.stateNode.implementation !== Pe.implementation ? (ye = KC(Pe, Ae.mode, yt), ye.return = Ae, ye) : (ye = R(ye, Pe.children || []), ye.return = Ae, ye)
        }

        function At(Ae, ye, Pe, yt, Dt) {
            return ye === null || ye.tag !== 7 ? (ye = Uf(Pe, Ae.mode, yt, Dt), ye.return = Ae, ye) : (ye = R(ye, Pe), ye.return = Ae, ye)
        }

        function nn(Ae, ye, Pe) {
            if (typeof ye == "string" && ye !== "" || typeof ye == "number") return ye = WC("" + ye, Ae.mode, Pe), ye.return = Ae, ye;
            if (typeof ye == "object" && ye !== null) {
                switch (ye.$$typeof) {
                    case l:
                        return Pe = jb(ye.type, ye.key, ye.props, null, Ae.mode, Pe), Pe.ref = jg(Ae, null, ye), Pe.return = Ae, Pe;
                    case u:
                        return ye = KC(ye, Ae.mode, Pe), ye.return = Ae, ye;
                    case x:
                        var yt = ye._init;
                        return nn(Ae, yt(ye._payload), Pe)
                }
                if (U(ye) || A(ye)) return ye = Uf(ye, Ae.mode, Pe, null), ye.return = Ae, ye;
                hb(Ae, ye)
            }
            return null
        }

        function Ft(Ae, ye, Pe, yt) {
            var Dt = ye !== null ? ye.key : null;
            if (typeof Pe == "string" && Pe !== "" || typeof Pe == "number") return Dt !== null ? null : pe(Ae, ye, "" + Pe, yt);
            if (typeof Pe == "object" && Pe !== null) {
                switch (Pe.$$typeof) {
                    case l:
                        return Pe.key === Dt ? Re(Ae, ye, Pe, yt) : null;
                    case u:
                        return Pe.key === Dt ? Je(Ae, ye, Pe, yt) : null;
                    case x:
                        return Dt = Pe._init, Ft(Ae, ye, Dt(Pe._payload), yt)
                }
                if (U(Pe) || A(Pe)) return Dt !== null ? null : At(Ae, ye, Pe, yt, null);
                hb(Ae, Pe)
            }
            return null
        }

        function Zn(Ae, ye, Pe, yt, Dt) {
            if (typeof yt == "string" && yt !== "" || typeof yt == "number") return Ae = Ae.get(Pe) || null, pe(ye, Ae, "" + yt, Dt);
            if (typeof yt == "object" && yt !== null) {
                switch (yt.$$typeof) {
                    case l:
                        return Ae = Ae.get(yt.key === null ? Pe : yt.key) || null, Re(ye, Ae, yt, Dt);
                    case u:
                        return Ae = Ae.get(yt.key === null ? Pe : yt.key) || null, Je(ye, Ae, yt, Dt);
                    case x:
                        var dn = yt._init;
                        return Zn(Ae, ye, Pe, dn(yt._payload), Dt)
                }
                if (U(yt) || A(yt)) return Ae = Ae.get(Pe) || null, At(ye, Ae, yt, Dt, null);
                hb(ye, yt)
            }
            return null
        }

        function Lt(Ae, ye, Pe, yt) {
            for (var Dt = null, dn = null, rn = ye, On = ye = 0, Si = null; rn !== null && On < Pe.length; On++) {
                rn.index > On ? (Si = rn, rn = null) : Si = rn.sibling;
                var Dn = Ft(Ae, rn, Pe[On], yt);
                if (Dn === null) {
                    rn === null && (rn = Si);
                    break
                }
                h && rn && Dn.alternate === null && g(Ae, rn), ye = L(Dn, ye, On), dn === null ? Dt = Dn : dn.sibling = Dn, dn = Dn, rn = Si
            }
            if (On === Pe.length) return w(Ae, rn), yr && Lf(Ae, On), Dt;
            if (rn === null) {
                for (; On < Pe.length; On++) rn = nn(Ae, Pe[On], yt), rn !== null && (ye = L(rn, ye, On), dn === null ? Dt = rn : dn.sibling = rn, dn = rn);
                return yr && Lf(Ae, On), Dt
            }
            for (rn = C(Ae, rn); On < Pe.length; On++) Si = Zn(rn, Ae, On, Pe[On], yt), Si !== null && (h && Si.alternate !== null && rn.delete(Si.key === null ? On : Si.key), ye = L(Si, ye, On), dn === null ? Dt = Si : dn.sibling = Si, dn = Si);
            return h && rn.forEach(function(ac) {
                return g(Ae, ac)
            }), yr && Lf(Ae, On), Dt
        }

        function Ji(Ae, ye, Pe, yt) {
            var Dt = A(Pe);
            if (typeof Dt != "function") throw Error(o(150));
            if (Pe = Dt.call(Pe), Pe == null) throw Error(o(151));
            for (var dn = Dt = null, rn = ye, On = ye = 0, Si = null, Dn = Pe.next(); rn !== null && !Dn.done; On++, Dn = Pe.next()) {
                rn.index > On ? (Si = rn, rn = null) : Si = rn.sibling;
                var ac = Ft(Ae, rn, Dn.value, yt);
                if (ac === null) {
                    rn === null && (rn = Si);
                    break
                }
                h && rn && ac.alternate === null && g(Ae, rn), ye = L(ac, ye, On), dn === null ? Dt = ac : dn.sibling = ac, dn = ac, rn = Si
            }
            if (Dn.done) return w(Ae, rn), yr && Lf(Ae, On), Dt;
            if (rn === null) {
                for (; !Dn.done; On++, Dn = Pe.next()) Dn = nn(Ae, Dn.value, yt), Dn !== null && (ye = L(Dn, ye, On), dn === null ? Dt = Dn : dn.sibling = Dn, dn = Dn);
                return yr && Lf(Ae, On), Dt
            }
            for (rn = C(Ae, rn); !Dn.done; On++, Dn = Pe.next()) Dn = Zn(rn, Ae, On, Dn.value, yt), Dn !== null && (h && Dn.alternate !== null && rn.delete(Dn.key === null ? On : Dn.key), ye = L(Dn, ye, On), dn === null ? Dt = Dn : dn.sibling = Dn, dn = Dn);
            return h && rn.forEach(function(ste) {
                return g(Ae, ste)
            }), yr && Lf(Ae, On), Dt
        }

        function To(Ae, ye, Pe, yt) {
            if (typeof Pe == "object" && Pe !== null && Pe.type === c && Pe.key === null && (Pe = Pe.props.children), typeof Pe == "object" && Pe !== null) {
                switch (Pe.$$typeof) {
                    case l:
                        e: {
                            for (var Dt = Pe.key, dn = ye; dn !== null;) {
                                if (dn.key === Dt) {
                                    if (Dt = Pe.type, Dt === c) {
                                        if (dn.tag === 7) {
                                            w(Ae, dn.sibling), ye = R(dn, Pe.props.children), ye.return = Ae, Ae = ye;
                                            break e
                                        }
                                    } else if (dn.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === x && WB(Dt) === dn.type) {
                                        w(Ae, dn.sibling), ye = R(dn, Pe.props), ye.ref = jg(Ae, dn, Pe), ye.return = Ae, Ae = ye;
                                        break e
                                    }
                                    w(Ae, dn);
                                    break
                                } else g(Ae, dn);
                                dn = dn.sibling
                            }
                            Pe.type === c ? (ye = Uf(Pe.props.children, Ae.mode, yt, Pe.key), ye.return = Ae, Ae = ye) : (yt = jb(Pe.type, Pe.key, Pe.props, null, Ae.mode, yt), yt.ref = jg(Ae, ye, Pe), yt.return = Ae, Ae = yt)
                        }
                        return ne(Ae);
                    case u:
                        e: {
                            for (dn = Pe.key; ye !== null;) {
                                if (ye.key === dn)
                                    if (ye.tag === 4 && ye.stateNode.containerInfo === Pe.containerInfo && ye.stateNode.implementation === Pe.implementation) {
                                        w(Ae, ye.sibling), ye = R(ye, Pe.children || []), ye.return = Ae, Ae = ye;
                                        break e
                                    } else {
                                        w(Ae, ye);
                                        break
                                    }
                                else g(Ae, ye);
                                ye = ye.sibling
                            }
                            ye = KC(Pe, Ae.mode, yt),
                            ye.return = Ae,
                            Ae = ye
                        }
                        return ne(Ae);
                    case x:
                        return dn = Pe._init, To(Ae, ye, dn(Pe._payload), yt)
                }
                if (U(Pe)) return Lt(Ae, ye, Pe, yt);
                if (A(Pe)) return Ji(Ae, ye, Pe, yt);
                hb(Ae, Pe)
            }
            return typeof Pe == "string" && Pe !== "" || typeof Pe == "number" ? (Pe = "" + Pe, ye !== null && ye.tag === 6 ? (w(Ae, ye.sibling), ye = R(ye, Pe), ye.return = Ae, Ae = ye) : (w(Ae, ye), ye = WC(Pe, Ae.mode, yt), ye.return = Ae, Ae = ye), ne(Ae)) : w(Ae, ye)
        }
        return To
    }
    var Tp = KB(!0),
        qB = KB(!1),
        Wg = {},
        Eo = xn(Wg),
        Kg = xn(Wg),
        Pp = xn(Wg);

    function tl(h) {
        if (h === Wg) throw Error(o(174));
        return h
    }

    function cC(h, g) {
        cn(Pp, g), cn(Kg, h), cn(Eo, Wg), h = Q(g), $t(Eo), cn(Eo, h)
    }

    function Ip() {
        $t(Eo), $t(Kg), $t(Pp)
    }

    function XB(h) {
        var g = tl(Pp.current),
            w = tl(Eo.current);
        g = F(w, h.type, g), w !== g && (cn(Kg, h), cn(Eo, g))
    }

    function fC(h) {
        Kg.current === h && ($t(Eo), $t(Kg))
    }
    var wr = xn(0);

    function mb(h) {
        for (var g = h; g !== null;) {
            if (g.tag === 13) {
                var w = g.memoizedState;
                if (w !== null && (w = w.dehydrated, w === null || Gn(w) || D(w))) return g
            } else if (g.tag === 19 && g.memoizedProps.revealOrder !== void 0) {
                if (g.flags & 128) return g
            } else if (g.child !== null) {
                g.child.return = g, g = g.child;
                continue
            }
            if (g === h) break;
            for (; g.sibling === null;) {
                if (g.return === null || g.return === h) return null;
                g = g.return
            }
            g.sibling.return = g.return, g = g.sibling
        }
        return null
    }
    var dC = [];

    function pC() {
        for (var h = 0; h < dC.length; h++) {
            var g = dC[h];
            xe ? g._workInProgressVersionPrimary = null : g._workInProgressVersionSecondary = null
        }
        dC.length = 0
    }
    var gb = a.ReactCurrentDispatcher,
        Ao = a.ReactCurrentBatchConfig,
        Rp = 0,
        Rr = null,
        Ki = null,
        _i = null,
        yb = !1,
        qg = !1,
        Xg = 0,
        Iee = 0;

    function qi() {
        throw Error(o(321))
    }

    function hC(h, g) {
        if (g === null) return !1;
        for (var w = 0; w < g.length && w < h.length; w++)
            if (!Is(h[w], g[w])) return !1;
        return !0
    }

    function mC(h, g, w, C, R, L) {
        if (Rp = L, Rr = g, g.memoizedState = null, g.updateQueue = null, g.lanes = 0, gb.current = h === null || h.memoizedState === null ? Lee : kee, h = w(C, R), qg) {
            L = 0;
            do {
                if (qg = !1, Xg = 0, 25 <= L) throw Error(o(301));
                L += 1, _i = Ki = null, g.updateQueue = null, gb.current = Bee, h = w(C, R)
            } while (qg)
        }
        if (gb.current = Sb, g = Ki !== null && Ki.next !== null, Rp = 0, _i = Ki = Rr = null, yb = !1, g) throw Error(o(300));
        return h
    }

    function gC() {
        var h = Xg !== 0;
        return Xg = 0, h
    }

    function Ql() {
        var h = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return _i === null ? Rr.memoizedState = _i = h : _i = _i.next = h, _i
    }

    function nl() {
        if (Ki === null) {
            var h = Rr.alternate;
            h = h !== null ? h.memoizedState : null
        } else h = Ki.next;
        var g = _i === null ? Rr.memoizedState : _i.next;
        if (g !== null) _i = g, Ki = h;
        else {
            if (h === null) throw Error(o(310));
            Ki = h, h = {
                memoizedState: Ki.memoizedState,
                baseState: Ki.baseState,
                baseQueue: Ki.baseQueue,
                queue: Ki.queue,
                next: null
            }, _i === null ? Rr.memoizedState = _i = h : _i = _i.next = h
        }
        return _i
    }

    function kf(h, g) {
        return typeof g == "function" ? g(h) : g
    }

    function vb(h) {
        var g = nl(),
            w = g.queue;
        if (w === null) throw Error(o(311));
        w.lastRenderedReducer = h;
        var C = Ki,
            R = C.baseQueue,
            L = w.pending;
        if (L !== null) {
            if (R !== null) {
                var ne = R.next;
                R.next = L.next, L.next = ne
            }
            C.baseQueue = R = L, w.pending = null
        }
        if (R !== null) {
            L = R.next, C = C.baseState;
            var pe = ne = null,
                Re = null,
                Je = L;
            do {
                var At = Je.lane;
                if ((Rp & At) === At) Re !== null && (Re = Re.next = {
                    lane: 0,
                    action: Je.action,
                    hasEagerState: Je.hasEagerState,
                    eagerState: Je.eagerState,
                    next: null
                }), C = Je.hasEagerState ? Je.eagerState : h(C, Je.action);
                else {
                    var nn = {
                        lane: At,
                        action: Je.action,
                        hasEagerState: Je.hasEagerState,
                        eagerState: Je.eagerState,
                        next: null
                    };
                    Re === null ? (pe = Re = nn, ne = C) : Re = Re.next = nn, Rr.lanes |= At, Dp |= At
                }
                Je = Je.next
            } while (Je !== null && Je !== L);
            Re === null ? ne = C : Re.next = pe, Is(C, g.memoizedState) || (Js = !0), g.memoizedState = C, g.baseState = ne, g.baseQueue = Re, w.lastRenderedState = C
        }
        if (h = w.interleaved, h !== null) {
            R = h;
            do L = R.lane, Rr.lanes |= L, Dp |= L, R = R.next; while (R !== h)
        } else R === null && (w.lanes = 0);
        return [g.memoizedState, w.dispatch]
    }

    function bb(h) {
        var g = nl(),
            w = g.queue;
        if (w === null) throw Error(o(311));
        w.lastRenderedReducer = h;
        var C = w.dispatch,
            R = w.pending,
            L = g.memoizedState;
        if (R !== null) {
            w.pending = null;
            var ne = R = R.next;
            do L = h(L, ne.action), ne = ne.next; while (ne !== R);
            Is(L, g.memoizedState) || (Js = !0), g.memoizedState = L, g.baseQueue === null && (g.baseState = L), w.lastRenderedState = L
        }
        return [L, C]
    }

    function JB() {}

    function YB(h, g) {
        var w = Rr,
            C = nl(),
            R = g(),
            L = !Is(C.memoizedState, R);
        if (L && (C.memoizedState = R, Js = !0), C = C.queue, Yg(eF.bind(null, w, C, h), [h]), C.getSnapshot !== g || L || _i !== null && _i.memoizedState.tag & 1) {
            if (w.flags |= 2048, Jg(9, ZB.bind(null, w, C, R, g), void 0, null), Zr === null) throw Error(o(349));
            Rp & 30 || QB(w, g, R)
        }
        return R
    }

    function QB(h, g, w) {
        h.flags |= 16384, h = {
            getSnapshot: g,
            value: w
        }, g = Rr.updateQueue, g === null ? (g = {
            lastEffect: null,
            stores: null
        }, Rr.updateQueue = g, g.stores = [h]) : (w = g.stores, w === null ? g.stores = [h] : w.push(h))
    }

    function ZB(h, g, w, C) {
        g.value = w, g.getSnapshot = C, tF(g) && Co(h, 1, -1)
    }

    function eF(h, g, w) {
        return w(function() {
            tF(g) && Co(h, 1, -1)
        })
    }

    function tF(h) {
        var g = h.getSnapshot;
        h = h.value;
        try {
            var w = g();
            return !Is(h, w)
        } catch {
            return !0
        }
    }

    function yC(h) {
        var g = Ql();
        return typeof h == "function" && (h = h()), g.memoizedState = g.baseState = h, h = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: kf,
            lastRenderedState: h
        }, g.queue = h, h = h.dispatch = Dee.bind(null, Rr, h), [g.memoizedState, h]
    }

    function Jg(h, g, w, C) {
        return h = {
            tag: h,
            create: g,
            destroy: w,
            deps: C,
            next: null
        }, g = Rr.updateQueue, g === null ? (g = {
            lastEffect: null,
            stores: null
        }, Rr.updateQueue = g, g.lastEffect = h.next = h) : (w = g.lastEffect, w === null ? g.lastEffect = h.next = h : (C = w.next, w.next = h, h.next = C, g.lastEffect = h)), h
    }

    function nF() {
        return nl().memoizedState
    }

    function xb(h, g, w, C) {
        var R = Ql();
        Rr.flags |= h, R.memoizedState = Jg(1 | g, w, void 0, C === void 0 ? null : C)
    }

    function _b(h, g, w, C) {
        var R = nl();
        C = C === void 0 ? null : C;
        var L = void 0;
        if (Ki !== null) {
            var ne = Ki.memoizedState;
            if (L = ne.destroy, C !== null && hC(C, ne.deps)) {
                R.memoizedState = Jg(g, w, L, C);
                return
            }
        }
        Rr.flags |= h, R.memoizedState = Jg(1 | g, w, L, C)
    }

    function vC(h, g) {
        return xb(8390656, 8, h, g)
    }

    function Yg(h, g) {
        return _b(2048, 8, h, g)
    }

    function rF(h, g) {
        return _b(4, 2, h, g)
    }

    function iF(h, g) {
        return _b(4, 4, h, g)
    }

    function sF(h, g) {
        if (typeof g == "function") return h = h(), g(h),
            function() {
                g(null)
            };
        if (g != null) return h = h(), g.current = h,
            function() {
                g.current = null
            }
    }

    function oF(h, g, w) {
        return w = w != null ? w.concat([h]) : null, _b(4, 4, sF.bind(null, g, h), w)
    }

    function bC() {}

    function aF(h, g) {
        var w = nl();
        g = g === void 0 ? null : g;
        var C = w.memoizedState;
        return C !== null && g !== null && hC(g, C[1]) ? C[0] : (w.memoizedState = [h, g], h)
    }

    function lF(h, g) {
        var w = nl();
        g = g === void 0 ? null : g;
        var C = w.memoizedState;
        return C !== null && g !== null && hC(g, C[1]) ? C[0] : (h = h(), w.memoizedState = [h, g], h)
    }

    function Ree(h, g) {
        var w = fn;
        fn = w !== 0 && 4 > w ? w : 4, h(!0);
        var C = Ao.transition;
        Ao.transition = {};
        try {
            h(!1), g()
        } finally {
            fn = w, Ao.transition = C
        }
    }

    function uF() {
        return nl().memoizedState
    }

    function Oee(h, g, w) {
        var C = ic(h);
        w = {
            lane: C,
            action: w,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, cF(h) ? fF(g, w) : (dF(h, g, w), w = gs(), h = Co(h, C, w), h !== null && pF(h, g, C))
    }

    function Dee(h, g, w) {
        var C = ic(h),
            R = {
                lane: C,
                action: w,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
        if (cF(h)) fF(g, R);
        else {
            dF(h, g, R);
            var L = h.alternate;
            if (h.lanes === 0 && (L === null || L.lanes === 0) && (L = g.lastRenderedReducer, L !== null)) try {
                var ne = g.lastRenderedState,
                    pe = L(ne, w);
                if (R.hasEagerState = !0, R.eagerState = pe, Is(pe, ne)) return
            } catch {} finally {}
            w = gs(), h = Co(h, C, w), h !== null && pF(h, g, C)
        }
    }

    function cF(h) {
        var g = h.alternate;
        return h === Rr || g !== null && g === Rr
    }

    function fF(h, g) {
        qg = yb = !0;
        var w = h.pending;
        w === null ? g.next = g : (g.next = w.next, w.next = g), h.pending = g
    }

    function dF(h, g, w) {
        Zr !== null && h.mode & 1 && !(gn & 2) ? (h = g.interleaved, h === null ? (w.next = w, _o === null ? _o = [g] : _o.push(g)) : (w.next = h.next, h.next = w), g.interleaved = w) : (h = g.pending, h === null ? w.next = w : (w.next = h.next, h.next = w), g.pending = w)
    }

    function pF(h, g, w) {
        if (w & 4194240) {
            var C = g.lanes;
            C &= h.pendingLanes, w |= C, g.lanes = w, Pf(h, w)
        }
    }
    var Sb = {
            readContext: Rs,
            useCallback: qi,
            useContext: qi,
            useEffect: qi,
            useImperativeHandle: qi,
            useInsertionEffect: qi,
            useLayoutEffect: qi,
            useMemo: qi,
            useReducer: qi,
            useRef: qi,
            useState: qi,
            useDebugValue: qi,
            useDeferredValue: qi,
            useTransition: qi,
            useMutableSource: qi,
            useSyncExternalStore: qi,
            useId: qi,
            unstable_isNewReconciler: !1
        },
        Lee = {
            readContext: Rs,
            useCallback: function(h, g) {
                return Ql().memoizedState = [h, g === void 0 ? null : g], h
            },
            useContext: Rs,
            useEffect: vC,
            useImperativeHandle: function(h, g, w) {
                return w = w != null ? w.concat([h]) : null, xb(4194308, 4, sF.bind(null, g, h), w)
            },
            useLayoutEffect: function(h, g) {
                return xb(4194308, 4, h, g)
            },
            useInsertionEffect: function(h, g) {
                return xb(4, 2, h, g)
            },
            useMemo: function(h, g) {
                var w = Ql();
                return g = g === void 0 ? null : g, h = h(), w.memoizedState = [h, g], h
            },
            useReducer: function(h, g, w) {
                var C = Ql();
                return g = w !== void 0 ? w(g) : g, C.memoizedState = C.baseState = g, h = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: h,
                    lastRenderedState: g
                }, C.queue = h, h = h.dispatch = Oee.bind(null, Rr, h), [C.memoizedState, h]
            },
            useRef: function(h) {
                var g = Ql();
                return h = {
                    current: h
                }, g.memoizedState = h
            },
            useState: yC,
            useDebugValue: bC,
            useDeferredValue: function(h) {
                var g = yC(h),
                    w = g[0],
                    C = g[1];
                return vC(function() {
                    var R = Ao.transition;
                    Ao.transition = {};
                    try {
                        C(h)
                    } finally {
                        Ao.transition = R
                    }
                }, [h]), w
            },
            useTransition: function() {
                var h = yC(!1),
                    g = h[0];
                return h = Ree.bind(null, h[1]), Ql().memoizedState = h, [g, h]
            },
            useMutableSource: function() {},
            useSyncExternalStore: function(h, g, w) {
                var C = Rr,
                    R = Ql();
                if (yr) {
                    if (w === void 0) throw Error(o(407));
                    w = w()
                } else {
                    if (w = g(), Zr === null) throw Error(o(349));
                    Rp & 30 || QB(C, g, w)
                }
                R.memoizedState = w;
                var L = {
                    value: w,
                    getSnapshot: g
                };
                return R.queue = L, vC(eF.bind(null, C, L, h), [h]), C.flags |= 2048, Jg(9, ZB.bind(null, C, L, w, g), void 0, null), w
            },
            useId: function() {
                var h = Ql(),
                    g = Zr.identifierPrefix;
                if (yr) {
                    var w = Yl,
                        C = Jl;
                    w = (C & ~(1 << 32 - ui(C) - 1)).toString(32) + w, g = ":" + g + "R" + w, w = Xg++, 0 < w && (g += "H" + w.toString(32)), g += ":"
                } else w = Iee++, g = ":" + g + "r" + w.toString(32) + ":";
                return h.memoizedState = g
            },
            unstable_isNewReconciler: !1
        },
        kee = {
            readContext: Rs,
            useCallback: aF,
            useContext: Rs,
            useEffect: Yg,
            useImperativeHandle: oF,
            useInsertionEffect: rF,
            useLayoutEffect: iF,
            useMemo: lF,
            useReducer: vb,
            useRef: nF,
            useState: function() {
                return vb(kf)
            },
            useDebugValue: bC,
            useDeferredValue: function(h) {
                var g = vb(kf),
                    w = g[0],
                    C = g[1];
                return Yg(function() {
                    var R = Ao.transition;
                    Ao.transition = {};
                    try {
                        C(h)
                    } finally {
                        Ao.transition = R
                    }
                }, [h]), w
            },
            useTransition: function() {
                var h = vb(kf)[0],
                    g = nl().memoizedState;
                return [h, g]
            },
            useMutableSource: JB,
            useSyncExternalStore: YB,
            useId: uF,
            unstable_isNewReconciler: !1
        },
        Bee = {
            readContext: Rs,
            useCallback: aF,
            useContext: Rs,
            useEffect: Yg,
            useImperativeHandle: oF,
            useInsertionEffect: rF,
            useLayoutEffect: iF,
            useMemo: lF,
            useReducer: bb,
            useRef: nF,
            useState: function() {
                return bb(kf)
            },
            useDebugValue: bC,
            useDeferredValue: function(h) {
                var g = bb(kf),
                    w = g[0],
                    C = g[1];
                return Yg(function() {
                    var R = Ao.transition;
                    Ao.transition = {};
                    try {
                        C(h)
                    } finally {
                        Ao.transition = R
                    }
                }, [h]), w
            },
            useTransition: function() {
                var h = bb(kf)[0],
                    g = nl().memoizedState;
                return [h, g]
            },
            useMutableSource: JB,
            useSyncExternalStore: YB,
            useId: uF,
            unstable_isNewReconciler: !1
        };

    function xC(h, g) {
        try {
            var w = "",
                C = g;
            do w += wn(C), C = C.return; while (C);
            var R = w
        } catch (L) {
            R = `
Error generating stack: ` + L.message + `
` + L.stack
        }
        return {
            value: h,
            source: g,
            stack: R
        }
    }

    function _C(h, g) {
        try {
            console.error(g.value)
        } catch (w) {
            setTimeout(function() {
                throw w
            })
        }
    }
    var Fee = typeof WeakMap == "function" ? WeakMap : Map;

    function hF(h, g, w) {
        w = Ge(-1, w), w.tag = 3, w.payload = {
            element: null
        };
        var C = g.value;
        return w.callback = function() {
            Nb || (Nb = !0, zC = C), _C(h, g)
        }, w
    }

    function mF(h, g, w) {
        w = Ge(-1, w), w.tag = 3;
        var C = h.type.getDerivedStateFromError;
        if (typeof C == "function") {
            var R = g.value;
            w.payload = function() {
                return C(R)
            }, w.callback = function() {
                _C(h, g)
            }
        }
        var L = h.stateNode;
        return L !== null && typeof L.componentDidCatch == "function" && (w.callback = function() {
            _C(h, g), typeof C != "function" && (nc === null ? nc = new Set([this]) : nc.add(this));
            var ne = g.stack;
            this.componentDidCatch(g.value, {
                componentStack: ne !== null ? ne : ""
            })
        }), w
    }

    function gF(h, g, w) {
        var C = h.pingCache;
        if (C === null) {
            C = h.pingCache = new Fee;
            var R = new Set;
            C.set(g, R)
        } else R = C.get(g), R === void 0 && (R = new Set, C.set(g, R));
        R.has(w) || (R.add(w), h = Yee.bind(null, h, g, w), g.then(h, h))
    }

    function yF(h) {
        do {
            var g;
            if ((g = h.tag === 13) && (g = h.memoizedState, g = g !== null ? g.dehydrated !== null : !0), g) return h;
            h = h.return
        } while (h !== null);
        return null
    }

    function vF(h, g, w, C, R) {
        return h.mode & 1 ? (h.flags |= 65536, h.lanes = R, h) : (h === g ? h.flags |= 65536 : (h.flags |= 128, w.flags |= 131072, w.flags &= -52805, w.tag === 1 && (w.alternate === null ? w.tag = 17 : (g = Ge(-1, 1), g.tag = 2, Pt(w, g))), w.lanes |= 1), h)
    }

    function rl(h) {
        h.flags |= 4
    }

    function bF(h, g) {
        if (h !== null && h.child === g.child) return !0;
        if (g.flags & 16) return !1;
        for (h = g.child; h !== null;) {
            if (h.flags & 12854 || h.subtreeFlags & 12854) return !1;
            h = h.sibling
        }
        return !0
    }
    var Qg, Zg, wb, Eb;
    if (be) Qg = function(h, g) {
        for (var w = g.child; w !== null;) {
            if (w.tag === 5 || w.tag === 6) ee(h, w.stateNode);
            else if (w.tag !== 4 && w.child !== null) {
                w.child.return = w, w = w.child;
                continue
            }
            if (w === g) break;
            for (; w.sibling === null;) {
                if (w.return === null || w.return === g) return;
                w = w.return
            }
            w.sibling.return = w.return, w = w.sibling
        }
    }, Zg = function() {}, wb = function(h, g, w, C, R) {
        if (h = h.memoizedProps, h !== C) {
            var L = g.stateNode,
                ne = tl(Eo.current);
            w = de(L, w, h, C, R, ne), (g.updateQueue = w) && rl(g)
        }
    }, Eb = function(h, g, w, C) {
        w !== C && rl(g)
    };
    else if (he) {
        Qg = function(h, g, w, C) {
            for (var R = g.child; R !== null;) {
                if (R.tag === 5) {
                    var L = R.stateNode;
                    w && C && (L = Ot(L, R.type, R.memoizedProps, R)), ee(h, L)
                } else if (R.tag === 6) L = R.stateNode, w && C && (L = tn(L, R.memoizedProps, R)), ee(h, L);
                else if (R.tag !== 4) {
                    if (R.tag === 22 && R.memoizedState !== null) L = R.child, L !== null && (L.return = R), Qg(h, R, !0, !0);
                    else if (R.child !== null) {
                        R.child.return = R, R = R.child;
                        continue
                    }
                }
                if (R === g) break;
                for (; R.sibling === null;) {
                    if (R.return === null || R.return === g) return;
                    R = R.return
                }
                R.sibling.return = R.return, R = R.sibling
            }
        };
        var xF = function(h, g, w, C) {
            for (var R = g.child; R !== null;) {
                if (R.tag === 5) {
                    var L = R.stateNode;
                    w && C && (L = Ot(L, R.type, R.memoizedProps, R)), Kt(h, L)
                } else if (R.tag === 6) L = R.stateNode, w && C && (L = tn(L, R.memoizedProps, R)), Kt(h, L);
                else if (R.tag !== 4) {
                    if (R.tag === 22 && R.memoizedState !== null) L = R.child, L !== null && (L.return = R), xF(h, R, !0, !0);
                    else if (R.child !== null) {
                        R.child.return = R, R = R.child;
                        continue
                    }
                }
                if (R === g) break;
                for (; R.sibling === null;) {
                    if (R.return === null || R.return === g) return;
                    R = R.return
                }
                R.sibling.return = R.return, R = R.sibling
            }
        };
        Zg = function(h, g) {
            var w = g.stateNode;
            if (!bF(h, g)) {
                h = w.containerInfo;
                var C = bt(h);
                xF(C, g, !1, !1), w.pendingChildren = C, rl(g), un(h, C)
            }
        }, wb = function(h, g, w, C, R) {
            var L = h.stateNode,
                ne = h.memoizedProps;
            if ((h = bF(h, g)) && ne === C) g.stateNode = L;
            else {
                var pe = g.stateNode,
                    Re = tl(Eo.current),
                    Je = null;
                ne !== C && (Je = de(pe, w, ne, C, R, Re)), h && Je === null ? g.stateNode = L : (L = ct(L, Je, w, ne, C, g, h, pe), ae(L, w, C, R, Re) && rl(g), g.stateNode = L, h ? rl(g) : Qg(L, g, !1, !1))
            }
        }, Eb = function(h, g, w, C) {
            w !== C ? (h = tl(Pp.current), w = tl(Eo.current), g.stateNode = _e(C, h, w, g), rl(g)) : g.stateNode = h.stateNode
        }
    } else Zg = function() {}, wb = function() {}, Eb = function() {};

    function ey(h, g) {
        if (!yr) switch (h.tailMode) {
            case "hidden":
                g = h.tail;
                for (var w = null; g !== null;) g.alternate !== null && (w = g), g = g.sibling;
                w === null ? h.tail = null : w.sibling = null;
                break;
            case "collapsed":
                w = h.tail;
                for (var C = null; w !== null;) w.alternate !== null && (C = w), w = w.sibling;
                C === null ? g || h.tail === null ? h.tail = null : h.tail.sibling = null : C.sibling = null
        }
    }

    function Xi(h) {
        var g = h.alternate !== null && h.alternate.child === h.child,
            w = 0,
            C = 0;
        if (g)
            for (var R = h.child; R !== null;) w |= R.lanes | R.childLanes, C |= R.subtreeFlags & 14680064, C |= R.flags & 14680064, R.return = h, R = R.sibling;
        else
            for (R = h.child; R !== null;) w |= R.lanes | R.childLanes, C |= R.subtreeFlags, C |= R.flags, R.return = h, R = R.sibling;
        return h.subtreeFlags |= C, h.childLanes = w, g
    }

    function Nee(h, g, w) {
        var C = g.pendingProps;
        switch (oC(g), g.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return Xi(g), null;
            case 1:
                return Ur(g.type) && fa(), Xi(g), null;
            case 3:
                return C = g.stateNode, Ip(), $t(ar), $t(Qn), pC(), C.pendingContext && (C.context = C.pendingContext, C.pendingContext = null), (h === null || h.child === null) && (Vg(g) ? rl(g) : h === null || h.memoizedState.isDehydrated && !(g.flags & 256) || (g.flags |= 1024, ga !== null && ($C(ga), ga = null))), Zg(h, g), Xi(g), null;
            case 5:
                fC(g), w = tl(Pp.current);
                var R = g.type;
                if (h !== null && g.stateNode != null) wb(h, g, R, C, w), h.ref !== g.ref && (g.flags |= 512, g.flags |= 2097152);
                else {
                    if (!C) {
                        if (g.stateNode === null) throw Error(o(166));
                        return Xi(g), null
                    }
                    if (h = tl(Eo.current), Vg(g)) {
                        if (!me) throw Error(o(175));
                        h = $e(g.stateNode, g.type, g.memoizedProps, w, h, g, !Gg), g.updateQueue = h, h !== null && rl(g)
                    } else {
                        var L = se(R, C, w, h, g);
                        Qg(L, g, !1, !1), g.stateNode = L, ae(L, R, C, w, h) && rl(g)
                    }
                    g.ref !== null && (g.flags |= 512, g.flags |= 2097152)
                }
                return Xi(g), null;
            case 6:
                if (h && g.stateNode != null) Eb(h, g, h.memoizedProps, C);
                else {
                    if (typeof C != "string" && g.stateNode === null) throw Error(o(166));
                    if (h = tl(Pp.current), w = tl(Eo.current), Vg(g)) {
                        if (!me) throw Error(o(176));
                        if (h = g.stateNode, C = g.memoizedProps, (w = rt(h, C, g, !Gg)) && (R = qs, R !== null)) switch (L = (R.mode & 1) !== 0, R.tag) {
                            case 3:
                                bn(R.stateNode.containerInfo, h, C, L);
                                break;
                            case 5:
                                Ht(R.type, R.memoizedProps, R.stateNode, h, C, L)
                        }
                        w && rl(g)
                    } else g.stateNode = _e(C, h, w, g)
                }
                return Xi(g), null;
            case 13:
                if ($t(wr), C = g.memoizedState, yr && Xs !== null && g.mode & 1 && !(g.flags & 128)) {
                    for (h = Xs; h;) h = j(h);
                    return Mp(), g.flags |= 98560, g
                }
                if (C !== null && C.dehydrated !== null) {
                    if (C = Vg(g), h === null) {
                        if (!C) throw Error(o(318));
                        if (!me) throw Error(o(344));
                        if (h = g.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(o(317));
                        Ze(h, g)
                    } else Mp(), !(g.flags & 128) && (g.memoizedState = null), g.flags |= 4;
                    return Xi(g), null
                }
                return ga !== null && ($C(ga), ga = null), g.flags & 128 ? (g.lanes = w, g) : (C = C !== null, w = !1, h === null ? Vg(g) : w = h.memoizedState !== null, C && !w && (g.child.flags |= 8192, g.mode & 1 && (h === null || wr.current & 1 ? di === 0 && (di = 3) : VC())), g.updateQueue !== null && (g.flags |= 4), Xi(g), null);
            case 4:
                return Ip(), Zg(h, g), h === null && Ne(g.stateNode.containerInfo), Xi(g), null;
            case 10:
                return ql(g.type._context), Xi(g), null;
            case 17:
                return Ur(g.type) && fa(), Xi(g), null;
            case 19:
                if ($t(wr), R = g.memoizedState, R === null) return Xi(g), null;
                if (C = (g.flags & 128) !== 0, L = R.rendering, L === null)
                    if (C) ey(R, !1);
                    else {
                        if (di !== 0 || h !== null && h.flags & 128)
                            for (h = g.child; h !== null;) {
                                if (L = mb(h), L !== null) {
                                    for (g.flags |= 128, ey(R, !1), h = L.updateQueue, h !== null && (g.updateQueue = h, g.flags |= 4), g.subtreeFlags = 0, h = w, C = g.child; C !== null;) w = C, R = h, w.flags &= 14680066, L = w.alternate, L === null ? (w.childLanes = 0, w.lanes = R, w.child = null, w.subtreeFlags = 0, w.memoizedProps = null, w.memoizedState = null, w.updateQueue = null, w.dependencies = null, w.stateNode = null) : (w.childLanes = L.childLanes, w.lanes = L.lanes, w.child = L.child, w.subtreeFlags = 0, w.deletions = null, w.memoizedProps = L.memoizedProps, w.memoizedState = L.memoizedState, w.updateQueue = L.updateQueue, w.type = L.type, R = L.dependencies, w.dependencies = R === null ? null : {
                                        lanes: R.lanes,
                                        firstContext: R.firstContext
                                    }), C = C.sibling;
                                    return cn(wr, wr.current & 1 | 2), g.child
                                }
                                h = h.sibling
                            }
                        R.tail !== null && kn() > NC && (g.flags |= 128, C = !0, ey(R, !1), g.lanes = 4194304)
                    }
                else {
                    if (!C)
                        if (h = mb(L), h !== null) {
                            if (g.flags |= 128, C = !0, h = h.updateQueue, h !== null && (g.updateQueue = h, g.flags |= 4), ey(R, !0), R.tail === null && R.tailMode === "hidden" && !L.alternate && !yr) return Xi(g), null
                        } else 2 * kn() - R.renderingStartTime > NC && w !== 1073741824 && (g.flags |= 128, C = !0, ey(R, !1), g.lanes = 4194304);
                    R.isBackwards ? (L.sibling = g.child, g.child = L) : (h = R.last, h !== null ? h.sibling = L : g.child = L, R.last = L)
                }
                return R.tail !== null ? (g = R.tail, R.rendering = g, R.tail = g.sibling, R.renderingStartTime = kn(), g.sibling = null, h = wr.current, cn(wr, C ? h & 1 | 2 : h & 1), g) : (Xi(g), null);
            case 22:
            case 23:
                return GC(), C = g.memoizedState !== null, h !== null && h.memoizedState !== null !== C && (g.flags |= 8192), C && g.mode & 1 ? Ys & 1073741824 && (Xi(g), be && g.subtreeFlags & 6 && (g.flags |= 8192)) : Xi(g), null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(o(156, g.tag))
    }
    var zee = a.ReactCurrentOwner,
        Js = !1;

    function ms(h, g, w, C) {
        g.child = h === null ? qB(g, null, w, C) : Tp(g, h.child, w, C)
    }

    function _F(h, g, w, C, R) {
        w = w.render;
        var L = g.ref;
        return ma(g, R), C = mC(h, g, w, C, L, R), w = gC(), h !== null && !Js ? (g.updateQueue = h.updateQueue, g.flags &= -2053, h.lanes &= ~R, Zl(h, g, R)) : (yr && w && sC(g), g.flags |= 1, ms(h, g, C, R), g.child)
    }

    function SF(h, g, w, C, R) {
        if (h === null) {
            var L = w.type;
            return typeof L == "function" && !jC(L) && L.defaultProps === void 0 && w.compare === null && w.defaultProps === void 0 ? (g.tag = 15, g.type = L, wF(h, g, L, C, R)) : (h = jb(w.type, null, C, g, g.mode, R), h.ref = g.ref, h.return = g, g.child = h)
        }
        if (L = h.child, !(h.lanes & R)) {
            var ne = L.memoizedProps;
            if (w = w.compare, w = w !== null ? w : Jt, w(ne, C) && h.ref === g.ref) return Zl(h, g, R)
        }
        return g.flags |= 1, h = oc(L, C), h.ref = g.ref, h.return = g, g.child = h
    }

    function wF(h, g, w, C, R) {
        if (h !== null && Jt(h.memoizedProps, C) && h.ref === g.ref)
            if (Js = !1, (h.lanes & R) !== 0) h.flags & 131072 && (Js = !0);
            else return g.lanes = h.lanes, Zl(h, g, R);
        return SC(h, g, w, C, R)
    }

    function EF(h, g, w) {
        var C = g.pendingProps,
            R = C.children,
            L = h !== null ? h.memoizedState : null;
        if (C.mode === "hidden")
            if (!(g.mode & 1)) g.memoizedState = {
                baseLanes: 0,
                cachePool: null
            }, cn(Op, Ys), Ys |= w;
            else if (w & 1073741824) g.memoizedState = {
            baseLanes: 0,
            cachePool: null
        }, C = L !== null ? L.baseLanes : w, cn(Op, Ys), Ys |= C;
        else return h = L !== null ? L.baseLanes | w : w, g.lanes = g.childLanes = 1073741824, g.memoizedState = {
            baseLanes: h,
            cachePool: null
        }, g.updateQueue = null, cn(Op, Ys), Ys |= h, null;
        else L !== null ? (C = L.baseLanes | w, g.memoizedState = null) : C = w, cn(Op, Ys), Ys |= C;
        return ms(h, g, R, w), g.child
    }

    function AF(h, g) {
        var w = g.ref;
        (h === null && w !== null || h !== null && h.ref !== w) && (g.flags |= 512, g.flags |= 2097152)
    }

    function SC(h, g, w, C, R) {
        var L = Ur(w) ? Ir : Qn.current;
        return L = fs(g, L), ma(g, R), w = mC(h, g, w, C, L, R), C = gC(), h !== null && !Js ? (g.updateQueue = h.updateQueue, g.flags &= -2053, h.lanes &= ~R, Zl(h, g, R)) : (yr && C && sC(g), g.flags |= 1, ms(h, g, w, R), g.child)
    }

    function CF(h, g, w, C, R) {
        if (Ur(w)) {
            var L = !0;
            Ul(g)
        } else L = !1;
        if (ma(g, R), g.stateNode === null) h !== null && (h.alternate = null, g.alternate = null, g.flags |= 2), ps(g, w, C), So(g, w, C, R), C = !0;
        else if (h === null) {
            var ne = g.stateNode,
                pe = g.memoizedProps;
            ne.props = pe;
            var Re = ne.context,
                Je = w.contextType;
            typeof Je == "object" && Je !== null ? Je = Rs(Je) : (Je = Ur(w) ? Ir : Qn.current, Je = fs(g, Je));
            var At = w.getDerivedStateFromProps,
                nn = typeof At == "function" || typeof ne.getSnapshotBeforeUpdate == "function";
            nn || typeof ne.UNSAFE_componentWillReceiveProps != "function" && typeof ne.componentWillReceiveProps != "function" || (pe !== C || Re !== Je) && hs(g, ne, C, Je), $ = !1;
            var Ft = g.memoizedState;
            ne.state = Ft, Bn(g, C, ne, R), Re = g.memoizedState, pe !== C || Ft !== Re || ar.current || $ ? (typeof At == "function" && (ci(g, w, At, C), Re = g.memoizedState), (pe = $ || Vr(g, w, pe, C, Ft, Re, Je)) ? (nn || typeof ne.UNSAFE_componentWillMount != "function" && typeof ne.componentWillMount != "function" || (typeof ne.componentWillMount == "function" && ne.componentWillMount(), typeof ne.UNSAFE_componentWillMount == "function" && ne.UNSAFE_componentWillMount()), typeof ne.componentDidMount == "function" && (g.flags |= 4194308)) : (typeof ne.componentDidMount == "function" && (g.flags |= 4194308), g.memoizedProps = C, g.memoizedState = Re), ne.props = C, ne.state = Re, ne.context = Je, C = pe) : (typeof ne.componentDidMount == "function" && (g.flags |= 4194308), C = !1)
        } else {
            ne = g.stateNode, Me(h, g), pe = g.memoizedProps, Je = g.type === g.elementType ? pe : mn(g.type, pe), ne.props = Je, nn = g.pendingProps, Ft = ne.context, Re = w.contextType, typeof Re == "object" && Re !== null ? Re = Rs(Re) : (Re = Ur(w) ? Ir : Qn.current, Re = fs(g, Re));
            var Zn = w.getDerivedStateFromProps;
            (At = typeof Zn == "function" || typeof ne.getSnapshotBeforeUpdate == "function") || typeof ne.UNSAFE_componentWillReceiveProps != "function" && typeof ne.componentWillReceiveProps != "function" || (pe !== nn || Ft !== Re) && hs(g, ne, C, Re), $ = !1, Ft = g.memoizedState, ne.state = Ft, Bn(g, C, ne, R);
            var Lt = g.memoizedState;
            pe !== nn || Ft !== Lt || ar.current || $ ? (typeof Zn == "function" && (ci(g, w, Zn, C), Lt = g.memoizedState), (Je = $ || Vr(g, w, Je, C, Ft, Lt, Re) || !1) ? (At || typeof ne.UNSAFE_componentWillUpdate != "function" && typeof ne.componentWillUpdate != "function" || (typeof ne.componentWillUpdate == "function" && ne.componentWillUpdate(C, Lt, Re), typeof ne.UNSAFE_componentWillUpdate == "function" && ne.UNSAFE_componentWillUpdate(C, Lt, Re)), typeof ne.componentDidUpdate == "function" && (g.flags |= 4), typeof ne.getSnapshotBeforeUpdate == "function" && (g.flags |= 1024)) : (typeof ne.componentDidUpdate != "function" || pe === h.memoizedProps && Ft === h.memoizedState || (g.flags |= 4), typeof ne.getSnapshotBeforeUpdate != "function" || pe === h.memoizedProps && Ft === h.memoizedState || (g.flags |= 1024), g.memoizedProps = C, g.memoizedState = Lt), ne.props = C, ne.state = Lt, ne.context = Re, C = Je) : (typeof ne.componentDidUpdate != "function" || pe === h.memoizedProps && Ft === h.memoizedState || (g.flags |= 4), typeof ne.getSnapshotBeforeUpdate != "function" || pe === h.memoizedProps && Ft === h.memoizedState || (g.flags |= 1024), C = !1)
        }
        return wC(h, g, w, C, L, R)
    }

    function wC(h, g, w, C, R, L) {
        AF(h, g);
        var ne = (g.flags & 128) !== 0;
        if (!C && !ne) return R && $l(g, w, !1), Zl(h, g, L);
        C = g.stateNode, zee.current = g;
        var pe = ne && typeof w.getDerivedStateFromError != "function" ? null : C.render();
        return g.flags |= 1, h !== null && ne ? (g.child = Tp(g, h.child, null, L), g.child = Tp(g, null, pe, L)) : ms(h, g, pe, L), g.memoizedState = C.state, R && $l(g, w, !0), g.child
    }

    function MF(h) {
        var g = h.stateNode;
        g.pendingContext ? xo(h, g.pendingContext, g.pendingContext !== g.context) : g.context && xo(h, g.context, !1), cC(h, g.containerInfo)
    }

    function TF(h, g, w, C, R) {
        return Mp(), uC(R), g.flags |= 256, ms(h, g, w, C), g.child
    }
    var Ab = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };

    function Cb(h) {
        return {
            baseLanes: h,
            cachePool: null
        }
    }

    function PF(h, g, w) {
        var C = g.pendingProps,
            R = wr.current,
            L = !1,
            ne = (g.flags & 128) !== 0,
            pe;
        if ((pe = ne) || (pe = h !== null && h.memoizedState === null ? !1 : (R & 2) !== 0), pe ? (L = !0, g.flags &= -129) : (h === null || h.memoizedState !== null) && (R |= 1), cn(wr, R & 1), h === null) return lC(g), h = g.memoizedState, h !== null && (h = h.dehydrated, h !== null) ? (g.mode & 1 ? D(h) ? g.lanes = 8 : g.lanes = 1073741824 : g.lanes = 1, null) : (R = C.children, h = C.fallback, L ? (C = g.mode, L = g.child, R = {
            mode: "hidden",
            children: R
        }, !(C & 1) && L !== null ? (L.childLanes = 0, L.pendingProps = R) : L = Wb(R, C, 0, null), h = Uf(h, C, w, null), L.return = g, h.return = g, L.sibling = h, g.child = L, g.child.memoizedState = Cb(w), g.memoizedState = Ab, h) : EC(g, R));
        if (R = h.memoizedState, R !== null) {
            if (pe = R.dehydrated, pe !== null) {
                if (ne) return g.flags & 256 ? (g.flags &= -257, Mb(h, g, w, Error(o(422)))) : g.memoizedState !== null ? (g.child = h.child, g.flags |= 128, null) : (L = C.fallback, R = g.mode, C = Wb({
                    mode: "visible",
                    children: C.children
                }, R, 0, null), L = Uf(L, R, w, null), L.flags |= 2, C.return = g, L.return = g, C.sibling = L, g.child = C, g.mode & 1 && Tp(g, h.child, null, w), g.child.memoizedState = Cb(w), g.memoizedState = Ab, L);
                if (!(g.mode & 1)) g = Mb(h, g, w, null);
                else if (D(pe)) g = Mb(h, g, w, Error(o(419)));
                else if (C = (w & h.childLanes) !== 0, Js || C) {
                    if (C = Zr, C !== null) {
                        switch (w & -w) {
                            case 4:
                                L = 2;
                                break;
                            case 16:
                                L = 8;
                                break;
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                            case 67108864:
                                L = 32;
                                break;
                            case 536870912:
                                L = 268435456;
                                break;
                            default:
                                L = 0
                        }
                        C = L & (C.suspendedLanes | w) ? 0 : L, C !== 0 && C !== R.retryLane && (R.retryLane = C, Co(h, C, -1))
                    }
                    VC(), g = Mb(h, g, w, Error(o(421)))
                } else Gn(pe) ? (g.flags |= 128, g.child = h.child, g = Qee.bind(null, h), z(pe, g), g = null) : (w = R.treeContext, me && (Xs = Oe(pe), qs = g, yr = !0, ga = null, Gg = !1, w !== null && (Ri[wo++] = Jl, Ri[wo++] = Yl, Ri[wo++] = Df, Jl = w.id, Yl = w.overflow, Df = g)), g = EC(g, g.pendingProps.children), g.flags |= 4096);
                return g
            }
            return L ? (C = RF(h, g, C.children, C.fallback, w), L = g.child, R = h.child.memoizedState, L.memoizedState = R === null ? Cb(w) : {
                baseLanes: R.baseLanes | w,
                cachePool: null
            }, L.childLanes = h.childLanes & ~w, g.memoizedState = Ab, C) : (w = IF(h, g, C.children, w), g.memoizedState = null, w)
        }
        return L ? (C = RF(h, g, C.children, C.fallback, w), L = g.child, R = h.child.memoizedState, L.memoizedState = R === null ? Cb(w) : {
            baseLanes: R.baseLanes | w,
            cachePool: null
        }, L.childLanes = h.childLanes & ~w, g.memoizedState = Ab, C) : (w = IF(h, g, C.children, w), g.memoizedState = null, w)
    }

    function EC(h, g) {
        return g = Wb({
            mode: "visible",
            children: g
        }, h.mode, 0, null), g.return = h, h.child = g
    }

    function IF(h, g, w, C) {
        var R = h.child;
        return h = R.sibling, w = oc(R, {
            mode: "visible",
            children: w
        }), !(g.mode & 1) && (w.lanes = C), w.return = g, w.sibling = null, h !== null && (C = g.deletions, C === null ? (g.deletions = [h], g.flags |= 16) : C.push(h)), g.child = w
    }

    function RF(h, g, w, C, R) {
        var L = g.mode;
        h = h.child;
        var ne = h.sibling,
            pe = {
                mode: "hidden",
                children: w
            };
        return !(L & 1) && g.child !== h ? (w = g.child, w.childLanes = 0, w.pendingProps = pe, g.deletions = null) : (w = oc(h, pe), w.subtreeFlags = h.subtreeFlags & 14680064), ne !== null ? C = oc(ne, C) : (C = Uf(C, L, R, null), C.flags |= 2), C.return = g, w.return = g, w.sibling = C, g.child = w, C
    }

    function Mb(h, g, w, C) {
        return C !== null && uC(C), Tp(g, h.child, null, w), h = EC(g, g.pendingProps.children), h.flags |= 2, g.memoizedState = null, h
    }

    function OF(h, g, w) {
        h.lanes |= g;
        var C = h.alternate;
        C !== null && (C.lanes |= g), tc(h.return, g, w)
    }

    function AC(h, g, w, C, R) {
        var L = h.memoizedState;
        L === null ? h.memoizedState = {
            isBackwards: g,
            rendering: null,
            renderingStartTime: 0,
            last: C,
            tail: w,
            tailMode: R
        } : (L.isBackwards = g, L.rendering = null, L.renderingStartTime = 0, L.last = C, L.tail = w, L.tailMode = R)
    }

    function DF(h, g, w) {
        var C = g.pendingProps,
            R = C.revealOrder,
            L = C.tail;
        if (ms(h, g, C.children, w), C = wr.current, C & 2) C = C & 1 | 2, g.flags |= 128;
        else {
            if (h !== null && h.flags & 128) e: for (h = g.child; h !== null;) {
                if (h.tag === 13) h.memoizedState !== null && OF(h, w, g);
                else if (h.tag === 19) OF(h, w, g);
                else if (h.child !== null) {
                    h.child.return = h, h = h.child;
                    continue
                }
                if (h === g) break e;
                for (; h.sibling === null;) {
                    if (h.return === null || h.return === g) break e;
                    h = h.return
                }
                h.sibling.return = h.return, h = h.sibling
            }
            C &= 1
        }
        if (cn(wr, C), !(g.mode & 1)) g.memoizedState = null;
        else switch (R) {
            case "forwards":
                for (w = g.child, R = null; w !== null;) h = w.alternate, h !== null && mb(h) === null && (R = w), w = w.sibling;
                w = R, w === null ? (R = g.child, g.child = null) : (R = w.sibling, w.sibling = null), AC(g, !1, R, w, L);
                break;
            case "backwards":
                for (w = null, R = g.child, g.child = null; R !== null;) {
                    if (h = R.alternate, h !== null && mb(h) === null) {
                        g.child = R;
                        break
                    }
                    h = R.sibling, R.sibling = w, w = R, R = h
                }
                AC(g, !0, w, null, L);
                break;
            case "together":
                AC(g, !1, null, null, void 0);
                break;
            default:
                g.memoizedState = null
        }
        return g.child
    }

    function Zl(h, g, w) {
        if (h !== null && (g.dependencies = h.dependencies), Dp |= g.lanes, !(w & g.childLanes)) return null;
        if (h !== null && g.child !== h.child) throw Error(o(153));
        if (g.child !== null) {
            for (h = g.child, w = oc(h, h.pendingProps), g.child = w, w.return = g; h.sibling !== null;) h = h.sibling, w = w.sibling = oc(h, h.pendingProps), w.return = g;
            w.sibling = null
        }
        return g.child
    }

    function Hee(h, g, w) {
        switch (g.tag) {
            case 3:
                MF(g), Mp();
                break;
            case 5:
                XB(g);
                break;
            case 1:
                Ur(g.type) && Ul(g);
                break;
            case 4:
                cC(g, g.stateNode.containerInfo);
                break;
            case 10:
                ec(g, g.type._context, g.memoizedProps.value);
                break;
            case 13:
                var C = g.memoizedState;
                if (C !== null) return C.dehydrated !== null ? (cn(wr, wr.current & 1), g.flags |= 128, null) : w & g.child.childLanes ? PF(h, g, w) : (cn(wr, wr.current & 1), h = Zl(h, g, w), h !== null ? h.sibling : null);
                cn(wr, wr.current & 1);
                break;
            case 19:
                if (C = (w & g.childLanes) !== 0, h.flags & 128) {
                    if (C) return DF(h, g, w);
                    g.flags |= 128
                }
                var R = g.memoizedState;
                if (R !== null && (R.rendering = null, R.tail = null, R.lastEffect = null), cn(wr, wr.current), C) break;
                return null;
            case 22:
            case 23:
                return g.lanes = 0, EF(h, g, w)
        }
        return Zl(h, g, w)
    }

    function Uee(h, g) {
        switch (oC(g), g.tag) {
            case 1:
                return Ur(g.type) && fa(), h = g.flags, h & 65536 ? (g.flags = h & -65537 | 128, g) : null;
            case 3:
                return Ip(), $t(ar), $t(Qn), pC(), h = g.flags, h & 65536 && !(h & 128) ? (g.flags = h & -65537 | 128, g) : null;
            case 5:
                return fC(g), null;
            case 13:
                if ($t(wr), h = g.memoizedState, h !== null && h.dehydrated !== null) {
                    if (g.alternate === null) throw Error(o(340));
                    Mp()
                }
                return h = g.flags, h & 65536 ? (g.flags = h & -65537 | 128, g) : null;
            case 19:
                return $t(wr), null;
            case 4:
                return Ip(), null;
            case 10:
                return ql(g.type._context), null;
            case 22:
            case 23:
                return GC(), null;
            case 24:
                return null;
            default:
                return null
        }
    }
    var Tb = !1,
        Bf = !1,
        $ee = typeof WeakSet == "function" ? WeakSet : Set,
        mt = null;

    function Pb(h, g) {
        var w = h.ref;
        if (w !== null)
            if (typeof w == "function") try {
                w(null)
            } catch (C) {
                ks(h, g, C)
            } else w.current = null
    }

    function CC(h, g, w) {
        try {
            w()
        } catch (C) {
            ks(h, g, C)
        }
    }
    var LF = !1;

    function Gee(h, g) {
        for (G(h.containerInfo), mt = g; mt !== null;)
            if (h = mt, g = h.child, (h.subtreeFlags & 1028) !== 0 && g !== null) g.return = h, mt = g;
            else
                for (; mt !== null;) {
                    h = mt;
                    try {
                        var w = h.alternate;
                        if (h.flags & 1024) switch (h.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (w !== null) {
                                    var C = w.memoizedProps,
                                        R = w.memoizedState,
                                        L = h.stateNode,
                                        ne = L.getSnapshotBeforeUpdate(h.elementType === h.type ? C : mn(h.type, C), R);
                                    L.__reactInternalSnapshotBeforeUpdate = ne
                                }
                                break;
                            case 3:
                                be && Ve(h.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                        }
                    } catch (pe) {
                        ks(h, h.return, pe)
                    }
                    if (g = h.sibling, g !== null) {
                        g.return = h.return, mt = g;
                        break
                    }
                    mt = h.return
                }
        return w = LF, LF = !1, w
    }

    function Ff(h, g, w) {
        var C = g.updateQueue;
        if (C = C !== null ? C.lastEffect : null, C !== null) {
            var R = C = C.next;
            do {
                if ((R.tag & h) === h) {
                    var L = R.destroy;
                    R.destroy = void 0, L !== void 0 && CC(g, w, L)
                }
                R = R.next
            } while (R !== C)
        }
    }

    function ty(h, g) {
        if (g = g.updateQueue, g = g !== null ? g.lastEffect : null, g !== null) {
            var w = g = g.next;
            do {
                if ((w.tag & h) === h) {
                    var C = w.create;
                    w.destroy = C()
                }
                w = w.next
            } while (w !== g)
        }
    }

    function MC(h) {
        var g = h.ref;
        if (g !== null) {
            var w = h.stateNode;
            switch (h.tag) {
                case 5:
                    h = q(w);
                    break;
                default:
                    h = w
            }
            typeof g == "function" ? g(h) : g.current = h
        }
    }

    function kF(h, g, w) {
        if (Ps && typeof Ps.onCommitFiberUnmount == "function") try {
            Ps.onCommitFiberUnmount(Kl, g)
        } catch {}
        switch (g.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (h = g.updateQueue, h !== null && (h = h.lastEffect, h !== null)) {
                    var C = h = h.next;
                    do {
                        var R = C,
                            L = R.destroy;
                        R = R.tag, L !== void 0 && (R & 2 || R & 4) && CC(g, w, L), C = C.next
                    } while (C !== h)
                }
                break;
            case 1:
                if (Pb(g, w), h = g.stateNode, typeof h.componentWillUnmount == "function") try {
                    h.props = g.memoizedProps, h.state = g.memoizedState, h.componentWillUnmount()
                } catch (ne) {
                    ks(g, w, ne)
                }
                break;
            case 5:
                Pb(g, w);
                break;
            case 4:
                be ? UF(h, g, w) : he && he && (g = g.stateNode.containerInfo, w = bt(g), zt(g, w))
        }
    }

    function BF(h, g, w) {
        for (var C = g;;)
            if (kF(h, C, w), C.child === null || be && C.tag === 4) {
                if (C === g) break;
                for (; C.sibling === null;) {
                    if (C.return === null || C.return === g) return;
                    C = C.return
                }
                C.sibling.return = C.return, C = C.sibling
            } else C.child.return = C, C = C.child
    }

    function FF(h) {
        var g = h.alternate;
        g !== null && (h.alternate = null, FF(g)), h.child = null, h.deletions = null, h.sibling = null, h.tag === 5 && (g = h.stateNode, g !== null && je(g)), h.stateNode = null, h.return = null, h.dependencies = null, h.memoizedProps = null, h.memoizedState = null, h.pendingProps = null, h.stateNode = null, h.updateQueue = null
    }

    function NF(h) {
        return h.tag === 5 || h.tag === 3 || h.tag === 4
    }

    function zF(h) {
        e: for (;;) {
            for (; h.sibling === null;) {
                if (h.return === null || NF(h.return)) return null;
                h = h.return
            }
            for (h.sibling.return = h.return, h = h.sibling; h.tag !== 5 && h.tag !== 6 && h.tag !== 18;) {
                if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
                h.child.return = h, h = h.child
            }
            if (!(h.flags & 2)) return h.stateNode
        }
    }

    function HF(h) {
        if (be) {
            e: {
                for (var g = h.return; g !== null;) {
                    if (NF(g)) break e;
                    g = g.return
                }
                throw Error(o(160))
            }
            var w = g;
            switch (w.tag) {
                case 5:
                    g = w.stateNode, w.flags & 32 && (Ie(g), w.flags &= -33), w = zF(h), PC(h, w, g);
                    break;
                case 3:
                case 4:
                    g = w.stateNode.containerInfo, w = zF(h), TC(h, w, g);
                    break;
                default:
                    throw Error(o(161))
            }
        }
    }

    function TC(h, g, w) {
        var C = h.tag;
        if (C === 5 || C === 6) h = h.stateNode, g ? ht(w, h, g) : Te(w, h);
        else if (C !== 4 && (h = h.child, h !== null))
            for (TC(h, g, w), h = h.sibling; h !== null;) TC(h, g, w), h = h.sibling
    }

    function PC(h, g, w) {
        var C = h.tag;
        if (C === 5 || C === 6) h = h.stateNode, g ? vt(w, h, g) : Ye(w, h);
        else if (C !== 4 && (h = h.child, h !== null))
            for (PC(h, g, w), h = h.sibling; h !== null;) PC(h, g, w), h = h.sibling
    }

    function UF(h, g, w) {
        for (var C = g, R = !1, L, ne;;) {
            if (!R) {
                R = C.return;
                e: for (;;) {
                    if (R === null) throw Error(o(160));
                    switch (L = R.stateNode, R.tag) {
                        case 5:
                            ne = !1;
                            break e;
                        case 3:
                            L = L.containerInfo, ne = !0;
                            break e;
                        case 4:
                            L = L.containerInfo, ne = !0;
                            break e
                    }
                    R = R.return
                }
                R = !0
            }
            if (C.tag === 5 || C.tag === 6) BF(h, C, w), ne ? le(L, C.stateNode) : pt(L, C.stateNode);
            else if (C.tag === 18) ne ? ft(L, C.stateNode) : Qe(L, C.stateNode);
            else if (C.tag === 4) {
                if (C.child !== null) {
                    L = C.stateNode.containerInfo, ne = !0, C.child.return = C, C = C.child;
                    continue
                }
            } else if (kF(h, C, w), C.child !== null) {
                C.child.return = C, C = C.child;
                continue
            }
            if (C === g) break;
            for (; C.sibling === null;) {
                if (C.return === null || C.return === g) return;
                C = C.return, C.tag === 4 && (R = !1)
            }
            C.sibling.return = C.return, C = C.sibling
        }
    }

    function IC(h, g) {
        if (be) {
            switch (g.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    Ff(3, g, g.return), ty(3, g), Ff(5, g, g.return);
                    return;
                case 1:
                    return;
                case 5:
                    var w = g.stateNode;
                    if (w != null) {
                        var C = g.memoizedProps;
                        h = h !== null ? h.memoizedProps : C;
                        var R = g.type,
                            L = g.updateQueue;
                        g.updateQueue = null, L !== null && nt(w, L, R, h, C, g)
                    }
                    return;
                case 6:
                    if (g.stateNode === null) throw Error(o(162));
                    w = g.memoizedProps, we(g.stateNode, h !== null ? h.memoizedProps : w, w);
                    return;
                case 3:
                    me && h !== null && h.memoizedState.isDehydrated && st(g.stateNode.containerInfo);
                    return;
                case 12:
                    return;
                case 13:
                    Ib(g);
                    return;
                case 19:
                    Ib(g);
                    return;
                case 17:
                    return
            }
            throw Error(o(163))
        }
        switch (g.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Ff(3, g, g.return), ty(3, g), Ff(5, g, g.return);
                return;
            case 12:
                return;
            case 13:
                Ib(g);
                return;
            case 19:
                Ib(g);
                return;
            case 3:
                me && h !== null && h.memoizedState.isDehydrated && st(g.stateNode.containerInfo);
                break;
            case 22:
            case 23:
                return
        }
        e: if (he) {
            switch (g.tag) {
                case 1:
                case 5:
                case 6:
                    break e;
                case 3:
                case 4:
                    g = g.stateNode, zt(g.containerInfo, g.pendingChildren);
                    break e
            }
            throw Error(o(163))
        }
    }

    function Ib(h) {
        var g = h.updateQueue;
        if (g !== null) {
            h.updateQueue = null;
            var w = h.stateNode;
            w === null && (w = h.stateNode = new $ee), g.forEach(function(C) {
                var R = Zee.bind(null, h, C);
                w.has(C) || (w.add(C), C.then(R, R))
            })
        }
    }

    function Vee(h, g) {
        for (mt = g; mt !== null;) {
            g = mt;
            var w = g.deletions;
            if (w !== null)
                for (var C = 0; C < w.length; C++) {
                    var R = w[C];
                    try {
                        var L = h;
                        be ? UF(L, R, g) : BF(L, R, g);
                        var ne = R.alternate;
                        ne !== null && (ne.return = null), R.return = null
                    } catch (Dt) {
                        ks(R, g, Dt)
                    }
                }
            if (w = g.child, g.subtreeFlags & 12854 && w !== null) w.return = g, mt = w;
            else
                for (; mt !== null;) {
                    g = mt;
                    try {
                        var pe = g.flags;
                        if (pe & 32 && be && Ie(g.stateNode), pe & 512) {
                            var Re = g.alternate;
                            if (Re !== null) {
                                var Je = Re.ref;
                                Je !== null && (typeof Je == "function" ? Je(null) : Je.current = null)
                            }
                        }
                        if (pe & 8192) switch (g.tag) {
                            case 13:
                                if (g.memoizedState !== null) {
                                    var At = g.alternate;
                                    (At === null || At.memoizedState === null) && (FC = kn())
                                }
                                break;
                            case 22:
                                var nn = g.memoizedState !== null,
                                    Ft = g.alternate,
                                    Zn = Ft !== null && Ft.memoizedState !== null;
                                if (w = g, be) {
                                    e: if (C = w, R = nn, L = null, be)
                                        for (var Lt = C;;) {
                                            if (Lt.tag === 5) {
                                                if (L === null) {
                                                    L = Lt;
                                                    var Ji = Lt.stateNode;
                                                    R ? tt(Ji) : Ee(Lt.stateNode, Lt.memoizedProps)
                                                }
                                            } else if (Lt.tag === 6) {
                                                if (L === null) {
                                                    var To = Lt.stateNode;
                                                    R ? oe(To) : Fe(To, Lt.memoizedProps)
                                                }
                                            } else if ((Lt.tag !== 22 && Lt.tag !== 23 || Lt.memoizedState === null || Lt === C) && Lt.child !== null) {
                                                Lt.child.return = Lt, Lt = Lt.child;
                                                continue
                                            }
                                            if (Lt === C) break;
                                            for (; Lt.sibling === null;) {
                                                if (Lt.return === null || Lt.return === C) break e;
                                                L === Lt && (L = null), Lt = Lt.return
                                            }
                                            L === Lt && (L = null), Lt.sibling.return = Lt.return, Lt = Lt.sibling
                                        }
                                }
                                if (nn && !Zn && w.mode & 1) {
                                    mt = w;
                                    for (var Ae = w.child; Ae !== null;) {
                                        for (w = mt = Ae; mt !== null;) {
                                            C = mt;
                                            var ye = C.child;
                                            switch (C.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    Ff(4, C, C.return);
                                                    break;
                                                case 1:
                                                    Pb(C, C.return);
                                                    var Pe = C.stateNode;
                                                    if (typeof Pe.componentWillUnmount == "function") {
                                                        var yt = C.return;
                                                        try {
                                                            Pe.props = C.memoizedProps, Pe.state = C.memoizedState, Pe.componentWillUnmount()
                                                        } catch (Dt) {
                                                            ks(C, yt, Dt)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    Pb(C, C.return);
                                                    break;
                                                case 22:
                                                    if (C.memoizedState !== null) {
                                                        VF(w);
                                                        continue
                                                    }
                                            }
                                            ye !== null ? (ye.return = C, mt = ye) : VF(w)
                                        }
                                        Ae = Ae.sibling
                                    }
                                }
                        }
                        switch (pe & 4102) {
                            case 2:
                                HF(g), g.flags &= -3;
                                break;
                            case 6:
                                HF(g), g.flags &= -3, IC(g.alternate, g);
                                break;
                            case 4096:
                                g.flags &= -4097;
                                break;
                            case 4100:
                                g.flags &= -4097, IC(g.alternate, g);
                                break;
                            case 4:
                                IC(g.alternate, g)
                        }
                    } catch (Dt) {
                        ks(g, g.return, Dt)
                    }
                    if (w = g.sibling, w !== null) {
                        w.return = g.return, mt = w;
                        break
                    }
                    mt = g.return
                }
        }
    }

    function jee(h, g, w) {
        mt = h, $F(h)
    }

    function $F(h, g, w) {
        for (var C = (h.mode & 1) !== 0; mt !== null;) {
            var R = mt,
                L = R.child;
            if (R.tag === 22 && C) {
                var ne = R.memoizedState !== null || Tb;
                if (!ne) {
                    var pe = R.alternate,
                        Re = pe !== null && pe.memoizedState !== null || Bf;
                    pe = Tb;
                    var Je = Bf;
                    if (Tb = ne, (Bf = Re) && !Je)
                        for (mt = R; mt !== null;) ne = mt, Re = ne.child, ne.tag === 22 && ne.memoizedState !== null ? jF(R) : Re !== null ? (Re.return = ne, mt = Re) : jF(R);
                    for (; L !== null;) mt = L, $F(L), L = L.sibling;
                    mt = R, Tb = pe, Bf = Je
                }
                GF(h)
            } else R.subtreeFlags & 8772 && L !== null ? (L.return = R, mt = L) : GF(h)
        }
    }

    function GF(h) {
        for (; mt !== null;) {
            var g = mt;
            if (g.flags & 8772) {
                var w = g.alternate;
                try {
                    if (g.flags & 8772) switch (g.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Bf || ty(5, g);
                            break;
                        case 1:
                            var C = g.stateNode;
                            if (g.flags & 4 && !Bf)
                                if (w === null) C.componentDidMount();
                                else {
                                    var R = g.elementType === g.type ? w.memoizedProps : mn(g.type, w.memoizedProps);
                                    C.componentDidUpdate(R, w.memoizedState, C.__reactInternalSnapshotBeforeUpdate)
                                }
                            var L = g.updateQueue;
                            L !== null && ir(g, L, C);
                            break;
                        case 3:
                            var ne = g.updateQueue;
                            if (ne !== null) {
                                if (w = null, g.child !== null) switch (g.child.tag) {
                                    case 5:
                                        w = q(g.child.stateNode);
                                        break;
                                    case 1:
                                        w = g.child.stateNode
                                }
                                ir(g, ne, w)
                            }
                            break;
                        case 5:
                            var pe = g.stateNode;
                            w === null && g.flags & 4 && lt(pe, g.type, g.memoizedProps, g);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (me && g.memoizedState === null) {
                                var Re = g.alternate;
                                if (Re !== null) {
                                    var Je = Re.memoizedState;
                                    if (Je !== null) {
                                        var At = Je.dehydrated;
                                        At !== null && St(At)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                    }
                    Bf || g.flags & 512 && MC(g)
                } catch (nn) {
                    ks(g, g.return, nn)
                }
            }
            if (g === h) {
                mt = null;
                break
            }
            if (w = g.sibling, w !== null) {
                w.return = g.return, mt = w;
                break
            }
            mt = g.return
        }
    }

    function VF(h) {
        for (; mt !== null;) {
            var g = mt;
            if (g === h) {
                mt = null;
                break
            }
            var w = g.sibling;
            if (w !== null) {
                w.return = g.return, mt = w;
                break
            }
            mt = g.return
        }
    }

    function jF(h) {
        for (; mt !== null;) {
            var g = mt;
            try {
                switch (g.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var w = g.return;
                        try {
                            ty(4, g)
                        } catch (Re) {
                            ks(g, w, Re)
                        }
                        break;
                    case 1:
                        var C = g.stateNode;
                        if (typeof C.componentDidMount == "function") {
                            var R = g.return;
                            try {
                                C.componentDidMount()
                            } catch (Re) {
                                ks(g, R, Re)
                            }
                        }
                        var L = g.return;
                        try {
                            MC(g)
                        } catch (Re) {
                            ks(g, L, Re)
                        }
                        break;
                    case 5:
                        var ne = g.return;
                        try {
                            MC(g)
                        } catch (Re) {
                            ks(g, ne, Re)
                        }
                }
            } catch (Re) {
                ks(g, g.return, Re)
            }
            if (g === h) {
                mt = null;
                break
            }
            var pe = g.sibling;
            if (pe !== null) {
                pe.return = g.return, mt = pe;
                break
            }
            mt = g.return
        }
    }
    var Rb = 0,
        Ob = 1,
        Db = 2,
        Lb = 3,
        kb = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var ny = Symbol.for;
        Rb = ny("selector.component"), Ob = ny("selector.has_pseudo_class"), Db = ny("selector.role"), Lb = ny("selector.test_id"), kb = ny("selector.text")
    }

    function RC(h) {
        var g = Ce(h);
        if (g != null) {
            if (typeof g.memoizedProps["data-testname"] != "string") throw Error(o(364));
            return g
        }
        if (h = Xe(h), h === null) throw Error(o(362));
        return h.stateNode.current
    }

    function OC(h, g) {
        switch (g.$$typeof) {
            case Rb:
                if (h.type === g.value) return !0;
                break;
            case Ob:
                e: {
                    g = g.value,
                    h = [h, 0];
                    for (var w = 0; w < h.length;) {
                        var C = h[w++],
                            R = h[w++],
                            L = g[R];
                        if (C.tag !== 5 || !ge(C)) {
                            for (; L != null && OC(C, L);) R++, L = g[R];
                            if (R === g.length) {
                                g = !0;
                                break e
                            } else
                                for (C = C.child; C !== null;) h.push(C, R), C = C.sibling
                        }
                    }
                    g = !1
                }
                return g;
            case Db:
                if (h.tag === 5 && Be(h.stateNode, g.value)) return !0;
                break;
            case kb:
                if ((h.tag === 5 || h.tag === 6) && (h = V(h), h !== null && 0 <= h.indexOf(g.value))) return !0;
                break;
            case Lb:
                if (h.tag === 5 && (h = h.memoizedProps["data-testname"], typeof h == "string" && h.toLowerCase() === g.value.toLowerCase())) return !0;
                break;
            default:
                throw Error(o(365))
        }
        return !1
    }

    function DC(h) {
        switch (h.$$typeof) {
            case Rb:
                return "<" + (T(h.value) || "Unknown") + ">";
            case Ob:
                return ":has(" + (DC(h) || "") + ")";
            case Db:
                return '[role="' + h.value + '"]';
            case kb:
                return '"' + h.value + '"';
            case Lb:
                return '[data-testname="' + h.value + '"]';
            default:
                throw Error(o(365))
        }
    }

    function WF(h, g) {
        var w = [];
        h = [h, 0];
        for (var C = 0; C < h.length;) {
            var R = h[C++],
                L = h[C++],
                ne = g[L];
            if (R.tag !== 5 || !ge(R)) {
                for (; ne != null && OC(R, ne);) L++, ne = g[L];
                if (L === g.length) w.push(R);
                else
                    for (R = R.child; R !== null;) h.push(R, L), R = R.sibling
            }
        }
        return w
    }

    function LC(h, g) {
        if (!qe) throw Error(o(363));
        h = RC(h), h = WF(h, g), g = [], h = Array.from(h);
        for (var w = 0; w < h.length;) {
            var C = h[w++];
            if (C.tag === 5) ge(C) || g.push(C.stateNode);
            else
                for (C = C.child; C !== null;) h.push(C), C = C.sibling
        }
        return g
    }
    var Wee = Math.ceil,
        Bb = a.ReactCurrentDispatcher,
        kC = a.ReactCurrentOwner,
        jr = a.ReactCurrentBatchConfig,
        gn = 0,
        Zr = null,
        ei = null,
        Oi = 0,
        Ys = 0,
        Op = xn(0),
        di = 0,
        ry = null,
        Dp = 0,
        Fb = 0,
        BC = 0,
        iy = null,
        Ds = null,
        FC = 0,
        NC = 1 / 0;

    function Lp() {
        NC = kn() + 500
    }
    var Nb = !1,
        zC = null,
        nc = null,
        zb = !1,
        rc = null,
        Hb = 0,
        sy = 0,
        HC = null,
        Ub = -1,
        $b = 0;

    function gs() {
        return gn & 6 ? kn() : Ub !== -1 ? Ub : Ub = kn()
    }

    function ic(h) {
        return h.mode & 1 ? gn & 2 && Oi !== 0 ? Oi & -Oi : ut.transition !== null ? ($b === 0 && (h = Ju, Ju <<= 1, !(Ju & 4194240) && (Ju = 64), $b = h), $b) : (h = fn, h !== 0 ? h : De()) : 1
    }

    function Co(h, g, w) {
        if (50 < sy) throw sy = 0, HC = null, Error(o(185));
        var C = Gb(h, g);
        return C === null ? null : (jl(C, g, w), (!(gn & 2) || C !== Zr) && (C === Zr && (!(gn & 2) && (Fb |= g), di === 4 && sc(C, Oi)), Ls(C, w), g === 1 && gn === 0 && !(h.mode & 1) && (Lp(), ds && Se())), C)
    }

    function Gb(h, g) {
        h.lanes |= g;
        var w = h.alternate;
        for (w !== null && (w.lanes |= g), w = h, h = h.return; h !== null;) h.childLanes |= g, w = h.alternate, w !== null && (w.childLanes |= g), w = h, h = h.return;
        return w.tag === 3 ? w.stateNode : null
    }

    function Ls(h, g) {
        var w = h.callbackNode;
        zg(h, g);
        var C = Vl(h, h === Zr ? Oi : 0);
        if (C === 0) w !== null && da(w), h.callbackNode = null, h.callbackPriority = 0;
        else if (g = C & -C, h.callbackPriority !== g) {
            if (w != null && da(w), g === 1) h.tag === 0 ? ce(qF.bind(null, h)) : Z(qF.bind(null, h)), Ke ? He(function() {
                gn === 0 && Se()
            }) : Wl(Zu, Se), w = null;
            else {
                switch (Qu(C)) {
                    case 1:
                        w = Zu;
                        break;
                    case 4:
                        w = Ms;
                        break;
                    case 16:
                        w = Ts;
                        break;
                    case 536870912:
                        w = $g;
                        break;
                    default:
                        w = Ts
                }
                w = r5(w, KF.bind(null, h))
            }
            h.callbackPriority = g, h.callbackNode = w
        }
    }

    function KF(h, g) {
        if (Ub = -1, $b = 0, gn & 6) throw Error(o(327));
        var w = h.callbackNode;
        if (Hf() && h.callbackNode !== w) return null;
        var C = Vl(h, h === Zr ? Oi : 0);
        if (C === 0) return null;
        if (C & 30 || C & h.expiredLanes || g) g = Vb(h, C);
        else {
            g = C;
            var R = gn;
            gn |= 2;
            var L = YF();
            (Zr !== h || Oi !== g) && (Lp(), Nf(h, g));
            do try {
                Xee();
                break
            } catch (pe) {
                JF(h, pe)
            }
            while (1);
            ha(), Bb.current = L, gn = R, ei !== null ? g = 0 : (Zr = null, Oi = 0, g = di)
        }
        if (g !== 0) {
            if (g === 2 && (R = Tf(h), R !== 0 && (C = R, g = UC(h, R))), g === 1) throw w = ry, Nf(h, 0), sc(h, C), Ls(h, kn()), w;
            if (g === 6) sc(h, C);
            else {
                if (R = h.current.alternate, !(C & 30) && !Kee(R) && (g = Vb(h, C), g === 2 && (L = Tf(h), L !== 0 && (C = L, g = UC(h, L))), g === 1)) throw w = ry, Nf(h, 0), sc(h, C), Ls(h, kn()), w;
                switch (h.finishedWork = R, h.finishedLanes = C, g) {
                    case 0:
                    case 1:
                        throw Error(o(345));
                    case 2:
                        zf(h, Ds);
                        break;
                    case 3:
                        if (sc(h, C), (C & 130023424) === C && (g = FC + 500 - kn(), 10 < g)) {
                            if (Vl(h, 0) !== 0) break;
                            if (R = h.suspendedLanes, (R & C) !== C) {
                                gs(), h.pingedLanes |= h.suspendedLanes & R;
                                break
                            }
                            h.timeoutHandle = fe(zf.bind(null, h, Ds), g);
                            break
                        }
                        zf(h, Ds);
                        break;
                    case 4:
                        if (sc(h, C), (C & 4194240) === C) break;
                        for (g = h.eventTimes, R = -1; 0 < C;) {
                            var ne = 31 - ui(C);
                            L = 1 << ne, ne = g[ne], ne > R && (R = ne), C &= ~L
                        }
                        if (C = R, C = kn() - C, C = (120 > C ? 120 : 480 > C ? 480 : 1080 > C ? 1080 : 1920 > C ? 1920 : 3e3 > C ? 3e3 : 4320 > C ? 4320 : 1960 * Wee(C / 1960)) - C, 10 < C) {
                            h.timeoutHandle = fe(zf.bind(null, h, Ds), C);
                            break
                        }
                        zf(h, Ds);
                        break;
                    case 5:
                        zf(h, Ds);
                        break;
                    default:
                        throw Error(o(329))
                }
            }
        }
        return Ls(h, kn()), h.callbackNode === w ? KF.bind(null, h) : null
    }

    function UC(h, g) {
        var w = iy;
        return h.current.memoizedState.isDehydrated && (Nf(h, g).flags |= 256), h = Vb(h, g), h !== 2 && (g = Ds, Ds = w, g !== null && $C(g)), h
    }

    function $C(h) {
        Ds === null ? Ds = h : Ds.push.apply(Ds, h)
    }

    function Kee(h) {
        for (var g = h;;) {
            if (g.flags & 16384) {
                var w = g.updateQueue;
                if (w !== null && (w = w.stores, w !== null))
                    for (var C = 0; C < w.length; C++) {
                        var R = w[C],
                            L = R.getSnapshot;
                        R = R.value;
                        try {
                            if (!Is(L(), R)) return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (w = g.child, g.subtreeFlags & 16384 && w !== null) w.return = g, g = w;
            else {
                if (g === h) break;
                for (; g.sibling === null;) {
                    if (g.return === null || g.return === h) return !0;
                    g = g.return
                }
                g.sibling.return = g.return, g = g.sibling
            }
        }
        return !0
    }

    function sc(h, g) {
        for (g &= ~BC, g &= ~Fb, h.suspendedLanes |= g, h.pingedLanes &= ~g, h = h.expirationTimes; 0 < g;) {
            var w = 31 - ui(g),
                C = 1 << w;
            h[w] = -1, g &= ~C
        }
    }

    function qF(h) {
        if (gn & 6) throw Error(o(327));
        Hf();
        var g = Vl(h, 0);
        if (!(g & 1)) return Ls(h, kn()), null;
        var w = Vb(h, g);
        if (h.tag !== 0 && w === 2) {
            var C = Tf(h);
            C !== 0 && (g = C, w = UC(h, C))
        }
        if (w === 1) throw w = ry, Nf(h, 0), sc(h, g), Ls(h, kn()), w;
        if (w === 6) throw Error(o(345));
        return h.finishedWork = h.current.alternate, h.finishedLanes = g, zf(h, Ds), Ls(h, kn()), null
    }

    function XF(h) {
        rc !== null && rc.tag === 0 && !(gn & 6) && Hf();
        var g = gn;
        gn |= 1;
        var w = jr.transition,
            C = fn;
        try {
            if (jr.transition = null, fn = 1, h) return h()
        } finally {
            fn = C, jr.transition = w, gn = g, !(gn & 6) && Se()
        }
    }

    function GC() {
        Ys = Op.current, $t(Op)
    }

    function Nf(h, g) {
        h.finishedWork = null, h.finishedLanes = 0;
        var w = h.timeoutHandle;
        if (w !== ve && (h.timeoutHandle = ve, ue(w)), ei !== null)
            for (w = ei.return; w !== null;) {
                var C = w;
                switch (oC(C), C.tag) {
                    case 1:
                        C = C.type.childContextTypes, C != null && fa();
                        break;
                    case 3:
                        Ip(), $t(ar), $t(Qn), pC();
                        break;
                    case 5:
                        fC(C);
                        break;
                    case 4:
                        Ip();
                        break;
                    case 13:
                        $t(wr);
                        break;
                    case 19:
                        $t(wr);
                        break;
                    case 10:
                        ql(C.type._context);
                        break;
                    case 22:
                    case 23:
                        GC()
                }
                w = w.return
            }
        if (Zr = h, ei = h = oc(h.current, null), Oi = Ys = g, di = 0, ry = null, BC = Fb = Dp = 0, Ds = iy = null, _o !== null) {
            for (g = 0; g < _o.length; g++)
                if (w = _o[g], C = w.interleaved, C !== null) {
                    w.interleaved = null;
                    var R = C.next,
                        L = w.pending;
                    if (L !== null) {
                        var ne = L.next;
                        L.next = R, C.next = ne
                    }
                    w.pending = C
                }
            _o = null
        }
        return h
    }

    function JF(h, g) {
        do {
            var w = ei;
            try {
                if (ha(), gb.current = Sb, yb) {
                    for (var C = Rr.memoizedState; C !== null;) {
                        var R = C.queue;
                        R !== null && (R.pending = null), C = C.next
                    }
                    yb = !1
                }
                if (Rp = 0, _i = Ki = Rr = null, qg = !1, Xg = 0, kC.current = null, w === null || w.return === null) {
                    di = 1, ry = g, ei = null;
                    break
                }
                e: {
                    var L = h,
                        ne = w.return,
                        pe = w,
                        Re = g;
                    if (g = Oi, pe.flags |= 32768, Re !== null && typeof Re == "object" && typeof Re.then == "function") {
                        var Je = Re,
                            At = pe,
                            nn = At.tag;
                        if (!(At.mode & 1) && (nn === 0 || nn === 11 || nn === 15)) {
                            var Ft = At.alternate;
                            Ft ? (At.updateQueue = Ft.updateQueue, At.memoizedState = Ft.memoizedState, At.lanes = Ft.lanes) : (At.updateQueue = null, At.memoizedState = null)
                        }
                        var Zn = yF(ne);
                        if (Zn !== null) {
                            Zn.flags &= -257, vF(Zn, ne, pe, L, g), Zn.mode & 1 && gF(L, Je, g), g = Zn, Re = Je;
                            var Lt = g.updateQueue;
                            if (Lt === null) {
                                var Ji = new Set;
                                Ji.add(Re), g.updateQueue = Ji
                            } else Lt.add(Re);
                            break e
                        } else {
                            if (!(g & 1)) {
                                gF(L, Je, g), VC();
                                break e
                            }
                            Re = Error(o(426))
                        }
                    } else if (yr && pe.mode & 1) {
                        var To = yF(ne);
                        if (To !== null) {
                            !(To.flags & 65536) && (To.flags |= 256), vF(To, ne, pe, L, g), uC(Re);
                            break e
                        }
                    }
                    L = Re,
                    di !== 4 && (di = 2),
                    iy === null ? iy = [L] : iy.push(L),
                    Re = xC(Re, pe),
                    pe = ne;do {
                        switch (pe.tag) {
                            case 3:
                                pe.flags |= 65536, g &= -g, pe.lanes |= g;
                                var Ae = hF(pe, Re, g);
                                an(pe, Ae);
                                break e;
                            case 1:
                                L = Re;
                                var ye = pe.type,
                                    Pe = pe.stateNode;
                                if (!(pe.flags & 128) && (typeof ye.getDerivedStateFromError == "function" || Pe !== null && typeof Pe.componentDidCatch == "function" && (nc === null || !nc.has(Pe)))) {
                                    pe.flags |= 65536, g &= -g, pe.lanes |= g;
                                    var yt = mF(pe, L, g);
                                    an(pe, yt);
                                    break e
                                }
                        }
                        pe = pe.return
                    } while (pe !== null)
                }
                ZF(w)
            } catch (Dt) {
                g = Dt, ei === w && w !== null && (ei = w = w.return);
                continue
            }
            break
        } while (1)
    }

    function YF() {
        var h = Bb.current;
        return Bb.current = Sb, h === null ? Sb : h
    }

    function VC() {
        (di === 0 || di === 3 || di === 2) && (di = 4), Zr === null || !(Dp & 268435455) && !(Fb & 268435455) || sc(Zr, Oi)
    }

    function Vb(h, g) {
        var w = gn;
        gn |= 2;
        var C = YF();
        Zr === h && Oi === g || Nf(h, g);
        do try {
            qee();
            break
        } catch (R) {
            JF(h, R)
        }
        while (1);
        if (ha(), gn = w, Bb.current = C, ei !== null) throw Error(o(261));
        return Zr = null, Oi = 0, di
    }

    function qee() {
        for (; ei !== null;) QF(ei)
    }

    function Xee() {
        for (; ei !== null && !Ug();) QF(ei)
    }

    function QF(h) {
        var g = n5(h.alternate, h, Ys);
        h.memoizedProps = h.pendingProps, g === null ? ZF(h) : ei = g, kC.current = null
    }

    function ZF(h) {
        var g = h;
        do {
            var w = g.alternate;
            if (h = g.return, g.flags & 32768) {
                if (w = Uee(w, g), w !== null) {
                    w.flags &= 32767, ei = w;
                    return
                }
                if (h !== null) h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null;
                else {
                    di = 6, ei = null;
                    return
                }
            } else if (w = Nee(w, g, Ys), w !== null) {
                ei = w;
                return
            }
            if (g = g.sibling, g !== null) {
                ei = g;
                return
            }
            ei = g = h
        } while (g !== null);
        di === 0 && (di = 5)
    }

    function zf(h, g) {
        var w = fn,
            C = jr.transition;
        try {
            jr.transition = null, fn = 1, Jee(h, g, w)
        } finally {
            jr.transition = C, fn = w
        }
        return null
    }

    function Jee(h, g, w) {
        do Hf(); while (rc !== null);
        if (gn & 6) throw Error(o(327));
        var C = h.finishedWork,
            R = h.finishedLanes;
        if (C === null) return null;
        if (h.finishedWork = null, h.finishedLanes = 0, C === h.current) throw Error(o(177));
        h.callbackNode = null, h.callbackPriority = 0;
        var L = C.lanes | C.childLanes;
        if (Hg(h, L), h === Zr && (ei = Zr = null, Oi = 0), !(C.subtreeFlags & 2064) && !(C.flags & 2064) || zb || (zb = !0, r5(Ts, function() {
                return Hf(), null
            })), L = (C.flags & 15990) !== 0, C.subtreeFlags & 15990 || L) {
            L = jr.transition, jr.transition = null;
            var ne = fn;
            fn = 1;
            var pe = gn;
            gn |= 4, kC.current = null, Gee(h, C), Vee(h, C), W(h.containerInfo), h.current = C, jee(C), pa(), gn = pe, fn = ne, jr.transition = L
        } else h.current = C;
        if (zb && (zb = !1, rc = h, Hb = R), L = h.pendingLanes, L === 0 && (nc = null), Cp(C.stateNode), Ls(h, kn()), g !== null)
            for (w = h.onRecoverableError, C = 0; C < g.length; C++) w(g[C]);
        if (Nb) throw Nb = !1, h = zC, zC = null, h;
        return Hb & 1 && h.tag !== 0 && Hf(), L = h.pendingLanes, L & 1 ? h === HC ? sy++ : (sy = 0, HC = h) : sy = 0, Se(), null
    }

    function Hf() {
        if (rc !== null) {
            var h = Qu(Hb),
                g = jr.transition,
                w = fn;
            try {
                if (jr.transition = null, fn = 16 > h ? 16 : h, rc === null) var C = !1;
                else {
                    if (h = rc, rc = null, Hb = 0, gn & 6) throw Error(o(331));
                    var R = gn;
                    for (gn |= 4, mt = h.current; mt !== null;) {
                        var L = mt,
                            ne = L.child;
                        if (mt.flags & 16) {
                            var pe = L.deletions;
                            if (pe !== null) {
                                for (var Re = 0; Re < pe.length; Re++) {
                                    var Je = pe[Re];
                                    for (mt = Je; mt !== null;) {
                                        var At = mt;
                                        switch (At.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Ff(8, At, L)
                                        }
                                        var nn = At.child;
                                        if (nn !== null) nn.return = At, mt = nn;
                                        else
                                            for (; mt !== null;) {
                                                At = mt;
                                                var Ft = At.sibling,
                                                    Zn = At.return;
                                                if (FF(At), At === Je) {
                                                    mt = null;
                                                    break
                                                }
                                                if (Ft !== null) {
                                                    Ft.return = Zn, mt = Ft;
                                                    break
                                                }
                                                mt = Zn
                                            }
                                    }
                                }
                                var Lt = L.alternate;
                                if (Lt !== null) {
                                    var Ji = Lt.child;
                                    if (Ji !== null) {
                                        Lt.child = null;
                                        do {
                                            var To = Ji.sibling;
                                            Ji.sibling = null, Ji = To
                                        } while (Ji !== null)
                                    }
                                }
                                mt = L
                            }
                        }
                        if (L.subtreeFlags & 2064 && ne !== null) ne.return = L, mt = ne;
                        else e: for (; mt !== null;) {
                            if (L = mt, L.flags & 2048) switch (L.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ff(9, L, L.return)
                            }
                            var Ae = L.sibling;
                            if (Ae !== null) {
                                Ae.return = L.return, mt = Ae;
                                break e
                            }
                            mt = L.return
                        }
                    }
                    var ye = h.current;
                    for (mt = ye; mt !== null;) {
                        ne = mt;
                        var Pe = ne.child;
                        if (ne.subtreeFlags & 2064 && Pe !== null) Pe.return = ne, mt = Pe;
                        else e: for (ne = ye; mt !== null;) {
                            if (pe = mt, pe.flags & 2048) try {
                                switch (pe.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ty(9, pe)
                                }
                            } catch (Dt) {
                                ks(pe, pe.return, Dt)
                            }
                            if (pe === ne) {
                                mt = null;
                                break e
                            }
                            var yt = pe.sibling;
                            if (yt !== null) {
                                yt.return = pe.return, mt = yt;
                                break e
                            }
                            mt = pe.return
                        }
                    }
                    if (gn = R, Se(), Ps && typeof Ps.onPostCommitFiberRoot == "function") try {
                        Ps.onPostCommitFiberRoot(Kl, h)
                    } catch {}
                    C = !0
                }
                return C
            } finally {
                fn = w, jr.transition = g
            }
        }
        return !1
    }

    function e5(h, g, w) {
        g = xC(w, g), g = hF(h, g, 1), Pt(h, g), g = gs(), h = Gb(h, 1), h !== null && (jl(h, 1, g), Ls(h, g))
    }

    function ks(h, g, w) {
        if (h.tag === 3) e5(h, h, w);
        else
            for (; g !== null;) {
                if (g.tag === 3) {
                    e5(g, h, w);
                    break
                } else if (g.tag === 1) {
                    var C = g.stateNode;
                    if (typeof g.type.getDerivedStateFromError == "function" || typeof C.componentDidCatch == "function" && (nc === null || !nc.has(C))) {
                        h = xC(w, h), h = mF(g, h, 1), Pt(g, h), h = gs(), g = Gb(g, 1), g !== null && (jl(g, 1, h), Ls(g, h));
                        break
                    }
                }
                g = g.return
            }
    }

    function Yee(h, g, w) {
        var C = h.pingCache;
        C !== null && C.delete(g), g = gs(), h.pingedLanes |= h.suspendedLanes & w, Zr === h && (Oi & w) === w && (di === 4 || di === 3 && (Oi & 130023424) === Oi && 500 > kn() - FC ? Nf(h, 0) : BC |= w), Ls(h, g)
    }

    function t5(h, g) {
        g === 0 && (h.mode & 1 ? (g = Yu, Yu <<= 1, !(Yu & 130023424) && (Yu = 4194304)) : g = 1);
        var w = gs();
        h = Gb(h, g), h !== null && (jl(h, g, w), Ls(h, w))
    }

    function Qee(h) {
        var g = h.memoizedState,
            w = 0;
        g !== null && (w = g.retryLane), t5(h, w)
    }

    function Zee(h, g) {
        var w = 0;
        switch (h.tag) {
            case 13:
                var C = h.stateNode,
                    R = h.memoizedState;
                R !== null && (w = R.retryLane);
                break;
            case 19:
                C = h.stateNode;
                break;
            default:
                throw Error(o(314))
        }
        C !== null && C.delete(g), t5(h, w)
    }
    var n5;
    n5 = function(h, g, w) {
        if (h !== null)
            if (h.memoizedProps !== g.pendingProps || ar.current) Js = !0;
            else {
                if (!(h.lanes & w) && !(g.flags & 128)) return Js = !1, Hee(h, g, w);
                Js = !!(h.flags & 131072)
            }
        else Js = !1, yr && g.flags & 1048576 && $B(g, Xl, g.index);
        switch (g.lanes = 0, g.tag) {
            case 2:
                var C = g.type;
                h !== null && (h.alternate = null, g.alternate = null, g.flags |= 2), h = g.pendingProps;
                var R = fs(g, Qn.current);
                ma(g, w), R = mC(null, g, C, h, R, w);
                var L = gC();
                return g.flags |= 1, typeof R == "object" && R !== null && typeof R.render == "function" && R.$$typeof === void 0 ? (g.tag = 1, g.memoizedState = null, g.updateQueue = null, Ur(C) ? (L = !0, Ul(g)) : L = !1, g.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null, ie(g), R.updater = fi, g.stateNode = R, R._reactInternals = g, So(g, C, h, w), g = wC(null, g, C, !0, L, w)) : (g.tag = 0, yr && L && sC(g), ms(null, g, R, w), g = g.child), g;
            case 16:
                C = g.elementType;
                e: {
                    switch (h !== null && (h.alternate = null, g.alternate = null, g.flags |= 2), h = g.pendingProps, R = C._init, C = R(C._payload), g.type = C, R = g.tag = tte(C), h = mn(C, h), R) {
                        case 0:
                            g = SC(null, g, C, h, w);
                            break e;
                        case 1:
                            g = CF(null, g, C, h, w);
                            break e;
                        case 11:
                            g = _F(null, g, C, h, w);
                            break e;
                        case 14:
                            g = SF(null, g, C, mn(C.type, h), w);
                            break e
                    }
                    throw Error(o(306, C, ""))
                }
                return g;
            case 0:
                return C = g.type, R = g.pendingProps, R = g.elementType === C ? R : mn(C, R), SC(h, g, C, R, w);
            case 1:
                return C = g.type, R = g.pendingProps, R = g.elementType === C ? R : mn(C, R), CF(h, g, C, R, w);
            case 3:
                e: {
                    if (MF(g), h === null) throw Error(o(387));C = g.pendingProps,
                    L = g.memoizedState,
                    R = L.element,
                    Me(h, g),
                    Bn(g, C, null, w);
                    var ne = g.memoizedState;
                    if (C = ne.element, me && L.isDehydrated)
                        if (L = {
                                element: C,
                                isDehydrated: !1,
                                cache: ne.cache,
                                transitions: ne.transitions
                            }, g.updateQueue.baseState = L, g.memoizedState = L, g.flags & 256) {
                            R = Error(o(423)), g = TF(h, g, C, w, R);
                            break e
                        } else if (C !== R) {
                        R = Error(o(424)), g = TF(h, g, C, w, R);
                        break e
                    } else
                        for (me && (Xs = te(g.stateNode.containerInfo), qs = g, yr = !0, ga = null, Gg = !1), w = qB(g, null, C, w), g.child = w; w;) w.flags = w.flags & -3 | 4096, w = w.sibling;
                    else {
                        if (Mp(), C === R) {
                            g = Zl(h, g, w);
                            break e
                        }
                        ms(h, g, C, w)
                    }
                    g = g.child
                }
                return g;
            case 5:
                return XB(g), h === null && lC(g), C = g.type, R = g.pendingProps, L = h !== null ? h.memoizedProps : null, ne = R.children, re(C, R) ? ne = null : L !== null && re(C, L) && (g.flags |= 32), AF(h, g), ms(h, g, ne, w), g.child;
            case 6:
                return h === null && lC(g), null;
            case 13:
                return PF(h, g, w);
            case 4:
                return cC(g, g.stateNode.containerInfo), C = g.pendingProps, h === null ? g.child = Tp(g, null, C, w) : ms(h, g, C, w), g.child;
            case 11:
                return C = g.type, R = g.pendingProps, R = g.elementType === C ? R : mn(C, R), _F(h, g, C, R, w);
            case 7:
                return ms(h, g, g.pendingProps, w), g.child;
            case 8:
                return ms(h, g, g.pendingProps.children, w), g.child;
            case 12:
                return ms(h, g, g.pendingProps.children, w), g.child;
            case 10:
                e: {
                    if (C = g.type._context, R = g.pendingProps, L = g.memoizedProps, ne = R.value, ec(g, C, ne), L !== null)
                        if (Is(L.value, ne)) {
                            if (L.children === R.children && !ar.current) {
                                g = Zl(h, g, w);
                                break e
                            }
                        } else
                            for (L = g.child, L !== null && (L.return = g); L !== null;) {
                                var pe = L.dependencies;
                                if (pe !== null) {
                                    ne = L.child;
                                    for (var Re = pe.firstContext; Re !== null;) {
                                        if (Re.context === C) {
                                            if (L.tag === 1) {
                                                Re = Ge(-1, w & -w), Re.tag = 2;
                                                var Je = L.updateQueue;
                                                if (Je !== null) {
                                                    Je = Je.shared;
                                                    var At = Je.pending;
                                                    At === null ? Re.next = Re : (Re.next = At.next, At.next = Re), Je.pending = Re
                                                }
                                            }
                                            L.lanes |= w, Re = L.alternate, Re !== null && (Re.lanes |= w), tc(L.return, w, g), pe.lanes |= w;
                                            break
                                        }
                                        Re = Re.next
                                    }
                                } else if (L.tag === 10) ne = L.type === g.type ? null : L.child;
                                else if (L.tag === 18) {
                                    if (ne = L.return, ne === null) throw Error(o(341));
                                    ne.lanes |= w, pe = ne.alternate, pe !== null && (pe.lanes |= w), tc(ne, w, g), ne = L.sibling
                                } else ne = L.child;
                                if (ne !== null) ne.return = L;
                                else
                                    for (ne = L; ne !== null;) {
                                        if (ne === g) {
                                            ne = null;
                                            break
                                        }
                                        if (L = ne.sibling, L !== null) {
                                            L.return = ne.return, ne = L;
                                            break
                                        }
                                        ne = ne.return
                                    }
                                L = ne
                            }
                    ms(h, g, R.children, w),
                    g = g.child
                }
                return g;
            case 9:
                return R = g.type, C = g.pendingProps.children, ma(g, w), R = Rs(R), C = C(R), g.flags |= 1, ms(h, g, C, w), g.child;
            case 14:
                return C = g.type, R = mn(C, g.pendingProps), R = mn(C.type, R), SF(h, g, C, R, w);
            case 15:
                return wF(h, g, g.type, g.pendingProps, w);
            case 17:
                return C = g.type, R = g.pendingProps, R = g.elementType === C ? R : mn(C, R), h !== null && (h.alternate = null, g.alternate = null, g.flags |= 2), g.tag = 1, Ur(C) ? (h = !0, Ul(g)) : h = !1, ma(g, w), ps(g, C, R), So(g, C, R, w), wC(null, g, C, !0, h, w);
            case 19:
                return DF(h, g, w);
            case 22:
                return EF(h, g, w)
        }
        throw Error(o(156, g.tag))
    };

    function r5(h, g) {
        return Wl(h, g)
    }

    function ete(h, g, w, C) {
        this.tag = h, this.key = w, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = g, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = C, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
    }

    function Mo(h, g, w, C) {
        return new ete(h, g, w, C)
    }

    function jC(h) {
        return h = h.prototype, !(!h || !h.isReactComponent)
    }

    function tte(h) {
        if (typeof h == "function") return jC(h) ? 1 : 0;
        if (h != null) {
            if (h = h.$$typeof, h === y) return 11;
            if (h === _) return 14
        }
        return 2
    }

    function oc(h, g) {
        var w = h.alternate;
        return w === null ? (w = Mo(h.tag, g, h.key, h.mode), w.elementType = h.elementType, w.type = h.type, w.stateNode = h.stateNode, w.alternate = h, h.alternate = w) : (w.pendingProps = g, w.type = h.type, w.flags = 0, w.subtreeFlags = 0, w.deletions = null), w.flags = h.flags & 14680064, w.childLanes = h.childLanes, w.lanes = h.lanes, w.child = h.child, w.memoizedProps = h.memoizedProps, w.memoizedState = h.memoizedState, w.updateQueue = h.updateQueue, g = h.dependencies, w.dependencies = g === null ? null : {
            lanes: g.lanes,
            firstContext: g.firstContext
        }, w.sibling = h.sibling, w.index = h.index, w.ref = h.ref, w
    }

    function jb(h, g, w, C, R, L) {
        var ne = 2;
        if (C = h, typeof h == "function") jC(h) && (ne = 1);
        else if (typeof h == "string") ne = 5;
        else e: switch (h) {
            case c:
                return Uf(w.children, R, L, g);
            case f:
                ne = 8, R |= 8;
                break;
            case d:
                return h = Mo(12, w, g, R | 2), h.elementType = d, h.lanes = L, h;
            case v:
                return h = Mo(13, w, g, R), h.elementType = v, h.lanes = L, h;
            case b:
                return h = Mo(19, w, g, R), h.elementType = b, h.lanes = L, h;
            case S:
                return Wb(w, R, L, g);
            default:
                if (typeof h == "object" && h !== null) switch (h.$$typeof) {
                    case p:
                        ne = 10;
                        break e;
                    case m:
                        ne = 9;
                        break e;
                    case y:
                        ne = 11;
                        break e;
                    case _:
                        ne = 14;
                        break e;
                    case x:
                        ne = 16, C = null;
                        break e
                }
                throw Error(o(130, h == null ? h : typeof h, ""))
        }
        return g = Mo(ne, w, g, R), g.elementType = h, g.type = C, g.lanes = L, g
    }

    function Uf(h, g, w, C) {
        return h = Mo(7, h, C, g), h.lanes = w, h
    }

    function Wb(h, g, w, C) {
        return h = Mo(22, h, C, g), h.elementType = S, h.lanes = w, h.stateNode = {}, h
    }

    function WC(h, g, w) {
        return h = Mo(6, h, null, g), h.lanes = w, h
    }

    function KC(h, g, w) {
        return g = Mo(4, h.children !== null ? h.children : [], h.key, g), g.lanes = w, g.stateNode = {
            containerInfo: h.containerInfo,
            pendingChildren: null,
            implementation: h.implementation
        }, g
    }

    function nte(h, g, w, C, R) {
        this.tag = g, this.containerInfo = h, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ve, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = el(0), this.expirationTimes = el(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = el(0), this.identifierPrefix = C, this.onRecoverableError = R, me && (this.mutableSourceEagerHydrationData = null)
    }

    function i5(h, g, w, C, R, L, ne, pe, Re) {
        return h = new nte(h, g, w, pe, Re), g === 1 ? (g = 1, L === !0 && (g |= 8)) : g = 0, L = Mo(3, null, null, g), h.current = L, L.stateNode = h, L.memoizedState = {
            element: C,
            isDehydrated: w,
            cache: null,
            transitions: null
        }, ie(L), h
    }

    function s5(h) {
        if (!h) return zn;
        h = h._reactInternals;
        e: {
            if (I(h) !== h || h.tag !== 1) throw Error(o(170));
            var g = h;do {
                switch (g.tag) {
                    case 3:
                        g = g.stateNode.context;
                        break e;
                    case 1:
                        if (Ur(g.type)) {
                            g = g.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                g = g.return
            } while (g !== null);
            throw Error(o(171))
        }
        if (h.tag === 1) {
            var w = h.type;
            if (Ur(w)) return Mf(h, w, g)
        }
        return g
    }

    function o5(h) {
        var g = h._reactInternals;
        if (g === void 0) throw typeof h.render == "function" ? Error(o(188)) : (h = Object.keys(h).join(","), Error(o(268, h)));
        return h = H(g), h === null ? null : h.stateNode
    }

    function a5(h, g) {
        if (h = h.memoizedState, h !== null && h.dehydrated !== null) {
            var w = h.retryLane;
            h.retryLane = w !== 0 && w < g ? w : g
        }
    }

    function qC(h, g) {
        a5(h, g), (h = h.alternate) && a5(h, g)
    }

    function rte(h) {
        return h = H(h), h === null ? null : h.stateNode
    }

    function ite() {
        return null
    }
    return n.attemptContinuousHydration = function(h) {
        if (h.tag === 13) {
            var g = gs();
            Co(h, 134217728, g), qC(h, 134217728)
        }
    }, n.attemptHydrationAtCurrentPriority = function(h) {
        if (h.tag === 13) {
            var g = gs(),
                w = ic(h);
            Co(h, w, g), qC(h, w)
        }
    }, n.attemptSynchronousHydration = function(h) {
        switch (h.tag) {
            case 3:
                var g = h.stateNode;
                if (g.current.memoizedState.isDehydrated) {
                    var w = Gl(g.pendingLanes);
                    w !== 0 && (Pf(g, w | 1), Ls(g, kn()), !(gn & 6) && (Lp(), Se()))
                }
                break;
            case 13:
                var C = gs();
                XF(function() {
                    return Co(h, 1, C)
                }), qC(h, 1)
        }
    }, n.batchedUpdates = function(h, g) {
        var w = gn;
        gn |= 1;
        try {
            return h(g)
        } finally {
            gn = w, gn === 0 && (Lp(), ds && Se())
        }
    }, n.createComponentSelector = function(h) {
        return {
            $$typeof: Rb,
            value: h
        }
    }, n.createContainer = function(h, g, w, C, R, L, ne) {
        return i5(h, g, !1, null, w, C, R, L, ne)
    }, n.createHasPseudoClassSelector = function(h) {
        return {
            $$typeof: Ob,
            value: h
        }
    }, n.createHydrationContainer = function(h, g, w, C, R, L, ne, pe, Re) {
        return h = i5(w, C, !0, h, R, L, ne, pe, Re), h.context = s5(null), w = h.current, C = gs(), R = ic(w), L = Ge(C, R), L.callback = g ? ? null, Pt(w, L), h.current.lanes = R, jl(h, R, C), Ls(h, C), h
    }, n.createPortal = function(h, g, w) {
        var C = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: u,
            key: C == null ? null : "" + C,
            children: h,
            containerInfo: g,
            implementation: w
        }
    }, n.createRoleSelector = function(h) {
        return {
            $$typeof: Db,
            value: h
        }
    }, n.createTestNameSelector = function(h) {
        return {
            $$typeof: Lb,
            value: h
        }
    }, n.createTextSelector = function(h) {
        return {
            $$typeof: kb,
            value: h
        }
    }, n.deferredUpdates = function(h) {
        var g = fn,
            w = jr.transition;
        try {
            return jr.transition = null, fn = 16, h()
        } finally {
            fn = g, jr.transition = w
        }
    }, n.discreteUpdates = function(h, g, w, C, R) {
        var L = fn,
            ne = jr.transition;
        try {
            return jr.transition = null, fn = 1, h(g, w, C, R)
        } finally {
            fn = L, jr.transition = ne, gn === 0 && Lp()
        }
    }, n.findAllNodes = LC, n.findBoundingRects = function(h, g) {
        if (!qe) throw Error(o(363));
        g = LC(h, g), h = [];
        for (var w = 0; w < g.length; w++) h.push(K(g[w]));
        for (g = h.length - 1; 0 < g; g--) {
            w = h[g];
            for (var C = w.x, R = C + w.width, L = w.y, ne = L + w.height, pe = g - 1; 0 <= pe; pe--)
                if (g !== pe) {
                    var Re = h[pe],
                        Je = Re.x,
                        At = Je + Re.width,
                        nn = Re.y,
                        Ft = nn + Re.height;
                    if (C >= Je && L >= nn && R <= At && ne <= Ft) {
                        h.splice(g, 1);
                        break
                    } else if (C !== Je || w.width !== Re.width || Ft < L || nn > ne) {
                        if (!(L !== nn || w.height !== Re.height || At < C || Je > R)) {
                            Je > C && (Re.width += Je - C, Re.x = C), At < R && (Re.width = R - Je), h.splice(g, 1);
                            break
                        }
                    } else {
                        nn > L && (Re.height += nn - L, Re.y = L), Ft < ne && (Re.height = ne - nn), h.splice(g, 1);
                        break
                    }
                }
        }
        return h
    }, n.findHostInstance = o5, n.findHostInstanceWithNoPortals = function(h) {
        return h = k(h), h = h !== null ? B(h) : null, h === null ? null : h.stateNode
    }, n.findHostInstanceWithWarning = function(h) {
        return o5(h)
    }, n.flushControlled = function(h) {
        var g = gn;
        gn |= 1;
        var w = jr.transition,
            C = fn;
        try {
            jr.transition = null, fn = 1, h()
        } finally {
            fn = C, jr.transition = w, gn = g, gn === 0 && (Lp(), Se())
        }
    }, n.flushPassiveEffects = Hf, n.flushSync = XF, n.focusWithin = function(h, g) {
        if (!qe) throw Error(o(363));
        for (h = RC(h), g = WF(h, g), g = Array.from(g), h = 0; h < g.length;) {
            var w = g[h++];
            if (!ge(w)) {
                if (w.tag === 5 && ze(w.stateNode)) return !0;
                for (w = w.child; w !== null;) g.push(w), w = w.sibling
            }
        }
        return !1
    }, n.getCurrentUpdatePriority = function() {
        return fn
    }, n.getFindAllNodesFailureDescription = function(h, g) {
        if (!qe) throw Error(o(363));
        var w = 0,
            C = [];
        h = [RC(h), 0];
        for (var R = 0; R < h.length;) {
            var L = h[R++],
                ne = h[R++],
                pe = g[ne];
            if ((L.tag !== 5 || !ge(L)) && (OC(L, pe) && (C.push(DC(pe)), ne++, ne > w && (w = ne)), ne < g.length))
                for (L = L.child; L !== null;) h.push(L, ne), L = L.sibling
        }
        if (w < g.length) {
            for (h = []; w < g.length; w++) h.push(DC(g[w]));
            return `findAllNodes was able to match part of the selector:
  ` + (C.join(" > ") + `

No matching component was found for:
  `) + h.join(" > ")
        }
        return null
    }, n.getPublicRootInstance = function(h) {
        if (h = h.current, !h.child) return null;
        switch (h.child.tag) {
            case 5:
                return q(h.child.stateNode);
            default:
                return h.child.stateNode
        }
    }, n.injectIntoDevTools = function(h) {
        if (h = {
                bundleType: h.bundleType,
                version: h.version,
                rendererPackageName: h.rendererPackageName,
                rendererConfig: h.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: a.ReactCurrentDispatcher,
                findHostInstanceByFiber: rte,
                findFiberByHostInstance: h.findFiberByHostInstance || ite,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329"
            }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") h = !1;
        else {
            var g = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (g.isDisabled || !g.supportsFiber) h = !0;
            else {
                try {
                    Kl = g.inject(h), Ps = g
                } catch {}
                h = !!g.checkDCE
            }
        }
        return h
    }, n.isAlreadyRendering = function() {
        return !1
    }, n.observeVisibleRects = function(h, g, w, C) {
        if (!qe) throw Error(o(363));
        h = LC(h, g);
        var R = Ue(h, w, C).disconnect;
        return {
            disconnect: function() {
                R()
            }
        }
    }, n.registerMutableSourceForHydration = function(h, g) {
        var w = g._getVersion;
        w = w(g._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [g, w] : h.mutableSourceEagerHydrationData.push(g, w)
    }, n.runWithPriority = function(h, g) {
        var w = fn;
        try {
            return fn = h, g()
        } finally {
            fn = w
        }
    }, n.shouldError = function() {
        return null
    }, n.shouldSuspend = function() {
        return !1
    }, n.updateContainer = function(h, g, w, C) {
        var R = g.current,
            L = gs(),
            ne = ic(R);
        return w = s5(w), g.context === null ? g.context = w : g.pendingContext = w, g = Ge(L, ne), g.payload = {
            element: h
        }, C = C === void 0 ? null : C, C !== null && (g.callback = C), Pt(R, g), h = Co(R, ne, L), h !== null && xt(h, R, ne), ne
    }, n
};
LQ.exports = OFe;
var DFe = LQ.exports;
const LFe = la(DFe);

function FQ(t, e, n = (r, i) => r === i) {
    if (t === e) return !0;
    if (!t || !e) return !1;
    const r = t.length;
    if (e.length !== r) return !1;
    for (let i = 0; i < r; i++)
        if (!n(t[i], e[i])) return !1;
    return !0
}
const vu = [];

function NQ(t, e, n = !1, r = {}) {
    for (const s of vu)
        if (FQ(e, s.keys, s.equal)) {
            if (n) return;
            if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response")) return s.response;
            if (!n) throw s.promise
        }
    const i = {
        keys: e,
        equal: r.equal,
        promise: t(...e).then(s => i.response = s).then(() => {
            r.lifespan && r.lifespan > 0 && setTimeout(() => {
                const s = vu.indexOf(i);
                s !== -1 && vu.splice(s, 1)
            }, r.lifespan)
        }).catch(s => i.error = s)
    };
    if (vu.push(i), !n) throw i.promise
}
const kFe = (t, e, n) => NQ(t, e, !1, n),
    BFe = (t, e, n) => void NQ(t, e, !0, n),
    FFe = t => {
        if (t === void 0 || t.length === 0) vu.splice(0, vu.length);
        else {
            const e = vu.find(n => FQ(t, n.keys, n.equal));
            if (e) {
                const n = vu.indexOf(e);
                n !== -1 && vu.splice(n, 1)
            }
        }
    };
var VH, jH;
const NFe = (t, ...e) => e.reduce((n, r) => n == null ? void 0 : n[r], t),
    xh = "ColorManagement" in y0 && NFe(y0, "ColorManagement") || null,
    zQ = t => t && t.isOrthographicCamera,
    zFe = t => t && t.hasOwnProperty("current"),
    tb = typeof window < "u" && ((VH = window.document) != null && VH.createElement || ((jH = window.navigator) == null ? void 0 : jH.product) === "ReactNative") ? P.useLayoutEffect : P.useEffect;

function HQ(t) {
    const e = P.useRef(t);
    return tb(() => void(e.current = t), [t]), e
}

function HFe({
    set: t
}) {
    return tb(() => (t(new Promise(() => null)), () => t(!1)), [t]), null
}
class UQ extends P.Component {
    constructor(...e) {
        super(...e), this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
UQ.getDerivedStateFromError = () => ({
    error: !0
});
const $Q = "__default",
    WH = new Map,
    UFe = t => t && !!t.memoized && !!t.changes;

function GQ(t) {
    const e = typeof window < "u" ? window.devicePixelRatio : 1;
    return Array.isArray(t) ? Math.min(Math.max(t[0], e), t[1]) : t
}
const Dy = t => {
        var e;
        return (e = t.__r3f) == null ? void 0 : e.root.getState()
    },
    Er = {
        obj: t => t === Object(t) && !Er.arr(t) && typeof t != "function",
        fun: t => typeof t == "function",
        str: t => typeof t == "string",
        num: t => typeof t == "number",
        boo: t => typeof t == "boolean",
        und: t => t === void 0,
        arr: t => Array.isArray(t),
        equ(t, e, {
            arrays: n = "shallow",
            objects: r = "reference",
            strict: i = !0
        } = {}) {
            if (typeof t != typeof e || !!t != !!e) return !1;
            if (Er.str(t) || Er.num(t)) return t === e;
            const s = Er.obj(t);
            if (s && r === "reference") return t === e;
            const o = Er.arr(t);
            if (o && n === "reference") return t === e;
            if ((o || s) && t === e) return !0;
            let a;
            for (a in t)
                if (!(a in e)) return !1;
            for (a in i ? e : t)
                if (t[a] !== e[a]) return !1;
            if (Er.und(a)) {
                if (o && t.length === 0 && e.length === 0 || s && Object.keys(t).length === 0 && Object.keys(e).length === 0) return !0;
                if (t !== e) return !1
            }
            return !0
        }
    };

function $Fe(t) {
    const e = {
        nodes: {},
        materials: {}
    };
    return t && t.traverse(n => {
        n.name && (e.nodes[n.name] = n), n.material && !e.materials[n.material.name] && (e.materials[n.material.name] = n.material)
    }), e
}

function GFe(t) {
    t.dispose && t.type !== "Scene" && t.dispose();
    for (const e in t) e.dispose == null || e.dispose(), delete t[e]
}

function _h(t, e) {
    const n = t;
    return (e != null && e.primitive || !n.__r3f) && (n.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }), t
}

function aO(t, e) {
    let n = t;
    if (e.includes("-")) {
        const r = e.split("-"),
            i = r.pop();
        return n = r.reduce((s, o) => s[o], t), {
            target: n,
            key: i
        }
    } else return {
        target: n,
        key: e
    }
}
const KH = /-\d+$/;

function fP(t, e, n) {
    if (Er.str(n)) {
        if (KH.test(n)) {
            const s = n.replace(KH, ""),
                {
                    target: o,
                    key: a
                } = aO(t, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {
            target: r,
            key: i
        } = aO(t, n);
        e.__r3f.previousAttach = r[i], r[i] = e
    } else e.__r3f.previousAttach = n(t, e)
}

function qH(t, e, n) {
    var r, i;
    if (Er.str(n)) {
        const {
            target: s,
            key: o
        } = aO(t, n), a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else(r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(t, e);
    (i = e.__r3f) == null || delete i.previousAttach
}

function VQ(t, {
    children: e,
    key: n,
    ref: r,
    ...i
}, {
    children: s,
    key: o,
    ref: a,
    ...l
} = {}, u = !1) {
    var c;
    const f = (c = t == null ? void 0 : t.__r3f) != null ? c : {},
        d = Object.entries(i),
        p = [];
    if (u) {
        const y = Object.keys(l);
        for (let v = 0; v < y.length; v++) i.hasOwnProperty(y[v]) || d.unshift([y[v], $Q + "remove"])
    }
    d.forEach(([y, v]) => {
        var b;
        if ((b = t.__r3f) != null && b.primitive && y === "object" || Er.equ(v, l[y])) return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y)) return p.push([y, v, !0, []]);
        let _ = [];
        y.includes("-") && (_ = y.split("-")), p.push([y, v, !1, _]);
        for (const x in i) {
            const S = i[x];
            x.startsWith(`${y}-`) && p.push([x, S, !1, x.split("-")])
        }
    });
    const m = { ...i
    };
    return f.memoizedProps && f.memoizedProps.args && (m.args = f.memoizedProps.args), f.memoizedProps && f.memoizedProps.attach && (m.attach = f.memoizedProps.attach), {
        memoized: m,
        changes: p
    }
}

function dP(t, e) {
    var n, r, i;
    const s = (n = t.__r3f) != null ? n : {},
        o = s.root,
        a = (r = o == null || o.getState == null ? void 0 : o.getState()) != null ? r : {},
        {
            memoized: l,
            changes: u
        } = UFe(e) ? e : VQ(t, e),
        c = s.eventCount;
    t.__r3f && (t.__r3f.memoizedProps = l);
    for (let d = 0; d < u.length; d++) {
        let [p, m, y, v] = u[d], b = t, _ = b[p];
        if (v.length && (_ = v.reduce((x, S) => x[S], t), !(_ && _.set))) {
            const [x, ...S] = v.reverse();
            b = S.reverse().reduce((E, A) => E[A], t), p = x
        }
        if (m === $Q + "remove")
            if (b.constructor) {
                let x = WH.get(b.constructor);
                x || (x = new b.constructor, WH.set(b.constructor, x)), m = x[p]
            } else m = 0;
        if (y) m ? s.handlers[p] = m : delete s.handlers[p], s.eventCount = Object.keys(s.handlers).length;
        else if (_ && _.set && (_.copy || _ instanceof Bd)) {
            if (Array.isArray(m)) _.fromArray ? _.fromArray(m) : _.set(...m);
            else if (_.copy && m && m.constructor && _.constructor === m.constructor) _.copy(m);
            else if (m !== void 0) {
                const x = _ instanceof dt;
                !x && _.setScalar ? _.setScalar(m) : _ instanceof Bd && m instanceof Bd ? _.mask = m.mask : _.set(m), !xh && !a.linear && x && _.convertSRGBToLinear()
            }
        } else b[p] = m, !a.linear && b[p] instanceof Sr && b[p].format === Ns && b[p].type === Du && (b[p].encoding = Xn);
        Sh(t)
    }
    if (s.parent && a.internal && t.raycast && c !== s.eventCount) {
        const d = a.internal.interaction.indexOf(t);
        d > -1 && a.internal.interaction.splice(d, 1), s.eventCount && a.internal.interaction.push(t)
    }
    return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (i = t.__r3f) != null && i.parent && lO(t), t
}

function Sh(t) {
    var e, n;
    const r = (e = t.__r3f) == null || (n = e.root) == null || n.getState == null ? void 0 : n.getState();
    r && r.internal.frames === 0 && r.invalidate()
}

function lO(t) {
    t.onUpdate == null || t.onUpdate(t)
}

function VFe(t, e) {
    t.manual || (zQ(t) ? (t.left = e.width / -2, t.right = e.width / 2, t.top = e.height / 2, t.bottom = e.height / -2) : t.aspect = e.width / e.height, t.updateProjectionMatrix(), t.updateMatrixWorld())
}

function $_(t) {
    return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId
}

function jFe() {
    var t;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e) return Yh.DefaultEventPriority;
    switch ((t = e.event) == null ? void 0 : t.type) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
            return Yh.DiscreteEventPriority;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
            return Yh.ContinuousEventPriority;
        default:
            return Yh.DefaultEventPriority
    }
}

function jQ(t, e, n, r) {
    const i = n.get(e);
    i && (n.delete(e), n.size === 0 && (t.delete(r), i.target.releasePointerCapture(r)))
}

function WFe(t, e) {
    const {
        internal: n
    } = t.getState();
    n.interaction = n.interaction.filter(r => r !== e), n.initialHits = n.initialHits.filter(r => r !== e), n.hovered.forEach((r, i) => {
        (r.eventObject === e || r.object === e) && n.hovered.delete(i)
    }), n.capturedMap.forEach((r, i) => {
        jQ(n.capturedMap, e, r, i)
    })
}

function KFe(t) {
    function e(l) {
        const {
            internal: u
        } = t.getState(), c = l.offsetX - u.initialClick[0], f = l.offsetY - u.initialClick[1];
        return Math.round(Math.sqrt(c * c + f * f))
    }

    function n(l) {
        return l.filter(u => ["Move", "Over", "Enter", "Out", "Leave"].some(c => {
            var f;
            return (f = u.__r3f) == null ? void 0 : f.handlers["onPointer" + c]
        }))
    }

    function r(l, u) {
        const c = t.getState(),
            f = new Set,
            d = [],
            p = u ? u(c.internal.interaction) : c.internal.interaction;
        for (let b = 0; b < p.length; b++) {
            const _ = Dy(p[b]);
            _ && (_.raycaster.camera = void 0)
        }
        c.previousRoot || c.events.compute == null || c.events.compute(l, c);

        function m(b) {
            const _ = Dy(b);
            if (!_ || !_.events.enabled || _.raycaster.camera === null) return [];
            if (_.raycaster.camera === void 0) {
                var x;
                _.events.compute == null || _.events.compute(l, _, (x = _.previousRoot) == null ? void 0 : x.getState()), _.raycaster.camera === void 0 && (_.raycaster.camera = null)
            }
            return _.raycaster.camera ? _.raycaster.intersectObject(b, !0) : []
        }
        let y = p.flatMap(m).sort((b, _) => {
            const x = Dy(b.object),
                S = Dy(_.object);
            return !x || !S ? b.distance - _.distance : S.events.priority - x.events.priority || b.distance - _.distance
        }).filter(b => {
            const _ = $_(b);
            return f.has(_) ? !1 : (f.add(_), !0)
        });
        c.events.filter && (y = c.events.filter(y, c));
        for (const b of y) {
            let _ = b.object;
            for (; _;) {
                var v;
                (v = _.__r3f) != null && v.eventCount && d.push({ ...b,
                    eventObject: _
                }), _ = _.parent
            }
        }
        if ("pointerId" in l && c.internal.capturedMap.has(l.pointerId))
            for (let b of c.internal.capturedMap.get(l.pointerId).values()) f.has($_(b.intersection)) || d.push(b.intersection);
        return d
    }

    function i(l, u, c, f) {
        const d = t.getState();
        if (l.length) {
            const p = {
                stopped: !1
            };
            for (const m of l) {
                const y = Dy(m.object) || d,
                    {
                        raycaster: v,
                        pointer: b,
                        camera: _,
                        internal: x
                    } = y,
                    S = new J(b.x, b.y, 0).unproject(_),
                    E = O => {
                        var k, H;
                        return (k = (H = x.capturedMap.get(O)) == null ? void 0 : H.has(m.eventObject)) != null ? k : !1
                    },
                    A = O => {
                        const k = {
                            intersection: m,
                            target: u.target
                        };
                        x.capturedMap.has(O) ? x.capturedMap.get(O).set(m.eventObject, k) : x.capturedMap.set(O, new Map([
                            [m.eventObject, k]
                        ])), u.target.setPointerCapture(O)
                    },
                    T = O => {
                        const k = x.capturedMap.get(O);
                        k && jQ(x.capturedMap, m.eventObject, k, O)
                    };
                let M = {};
                for (let O in u) {
                    let k = u[O];
                    typeof k != "function" && (M[O] = k)
                }
                let I = { ...m,
                    ...M,
                    pointer: b,
                    intersections: l,
                    stopped: p.stopped,
                    delta: c,
                    unprojectedPoint: S,
                    ray: v.ray,
                    camera: _,
                    stopPropagation() {
                        const O = "pointerId" in u && x.capturedMap.get(u.pointerId);
                        if ((!O || O.has(m.eventObject)) && (I.stopped = p.stopped = !0, x.hovered.size && Array.from(x.hovered.values()).find(k => k.eventObject === m.eventObject))) {
                            const k = l.slice(0, l.indexOf(m));
                            s([...k, m])
                        }
                    },
                    target: {
                        hasPointerCapture: E,
                        setPointerCapture: A,
                        releasePointerCapture: T
                    },
                    currentTarget: {
                        hasPointerCapture: E,
                        setPointerCapture: A,
                        releasePointerCapture: T
                    },
                    nativeEvent: u
                };
                if (f(I), p.stopped === !0) break
            }
        }
        return l
    }

    function s(l) {
        const {
            internal: u
        } = t.getState();
        for (const c of u.hovered.values())
            if (!l.length || !l.find(f => f.object === c.object && f.index === c.index && f.instanceId === c.instanceId)) {
                const d = c.eventObject.__r3f,
                    p = d == null ? void 0 : d.handlers;
                if (u.hovered.delete($_(c)), d != null && d.eventCount) {
                    const m = { ...c,
                        intersections: l
                    };
                    p.onPointerOut == null || p.onPointerOut(m), p.onPointerLeave == null || p.onPointerLeave(m)
                }
            }
    }

    function o(l, u) {
        for (let c = 0; c < u.length; c++) {
            const f = u[c].__r3f;
            f == null || f.handlers.onPointerMissed == null || f.handlers.onPointerMissed(l)
        }
    }

    function a(l) {
        switch (l) {
            case "onPointerLeave":
            case "onPointerCancel":
                return () => s([]);
            case "onLostPointerCapture":
                return u => {
                    const {
                        internal: c
                    } = t.getState();
                    "pointerId" in u && c.capturedMap.has(u.pointerId) && (c.capturedMap.delete(u.pointerId), s([]))
                }
        }
        return function(c) {
            const {
                onPointerMissed: f,
                internal: d
            } = t.getState();
            d.lastEvent.current = c;
            const p = l === "onPointerMove",
                m = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
                v = r(c, p ? n : void 0),
                b = m ? e(c) : 0;
            l === "onPointerDown" && (d.initialClick = [c.offsetX, c.offsetY], d.initialHits = v.map(x => x.eventObject)), m && !v.length && b <= 2 && (o(c, d.interaction), f && f(c)), p && s(v);

            function _(x) {
                const S = x.eventObject,
                    E = S.__r3f,
                    A = E == null ? void 0 : E.handlers;
                if (E != null && E.eventCount)
                    if (p) {
                        if (A.onPointerOver || A.onPointerEnter || A.onPointerOut || A.onPointerLeave) {
                            const T = $_(x),
                                M = d.hovered.get(T);
                            M ? M.stopped && x.stopPropagation() : (d.hovered.set(T, x), A.onPointerOver == null || A.onPointerOver(x), A.onPointerEnter == null || A.onPointerEnter(x))
                        }
                        A.onPointerMove == null || A.onPointerMove(x)
                    } else {
                        const T = A[l];
                        T ? (!m || d.initialHits.includes(S)) && (o(c, d.interaction.filter(M => !d.initialHits.includes(M))), T(x)) : m && d.initialHits.includes(S) && o(c, d.interaction.filter(M => !d.initialHits.includes(M)))
                    }
            }
            i(v, c, b, _)
        }
    }
    return {
        handlePointer: a
    }
}
let uO = {},
    WQ = t => void(uO = { ...uO,
        ...t
    });

function qFe(t, e) {
    function n(c, {
        args: f = [],
        attach: d,
        ...p
    }, m) {
        let y = `${c[0].toUpperCase()}${c.slice(1)}`,
            v;
        if (c === "primitive") {
            if (p.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
            const b = p.object;
            v = _h(b, {
                type: c,
                root: m,
                attach: d,
                primitive: !0
            })
        } else {
            const b = uO[y];
            if (!b) throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(f)) throw new Error("R3F: The args prop must be an array!");
            v = _h(new b(...f), {
                type: c,
                root: m,
                attach: d,
                memoizedProps: {
                    args: f
                }
            })
        }
        return v.__r3f.attach === void 0 && (v instanceof on ? v.__r3f.attach = "geometry" : v instanceof li && (v.__r3f.attach = "material")), y !== "inject" && dP(v, p), v
    }

    function r(c, f) {
        let d = !1;
        if (f) {
            var p, m;
            (p = f.__r3f) != null && p.attach ? fP(c, f, f.__r3f.attach) : f.isObject3D && c.isObject3D && (c.add(f), d = !0), d || (m = c.__r3f) == null || m.objects.push(f), f.__r3f || _h(f, {}), f.__r3f.parent = c, lO(f), Sh(f)
        }
    }

    function i(c, f, d) {
        let p = !1;
        if (f) {
            var m, y;
            if ((m = f.__r3f) != null && m.attach) fP(c, f, f.__r3f.attach);
            else if (f.isObject3D && c.isObject3D) {
                f.parent = c, f.dispatchEvent({
                    type: "added"
                });
                const v = c.children.filter(_ => _ !== f),
                    b = v.indexOf(d);
                c.children = [...v.slice(0, b), f, ...v.slice(b)], p = !0
            }
            p || (y = c.__r3f) == null || y.objects.push(f), f.__r3f || _h(f, {}), f.__r3f.parent = c, lO(f), Sh(f)
        }
    }

    function s(c, f, d = !1) {
        c && [...c].forEach(p => o(f, p, d))
    }

    function o(c, f, d) {
        if (f) {
            var p, m, y;
            if (f.__r3f && (f.__r3f.parent = null), (p = c.__r3f) != null && p.objects && (c.__r3f.objects = c.__r3f.objects.filter(S => S !== f)), (m = f.__r3f) != null && m.attach) qH(c, f, f.__r3f.attach);
            else if (f.isObject3D && c.isObject3D) {
                var v;
                c.remove(f), (v = f.__r3f) != null && v.root && WFe(f.__r3f.root, f)
            }
            const _ = (y = f.__r3f) == null ? void 0 : y.primitive,
                x = d === void 0 ? f.dispose !== null && !_ : d;
            if (!_) {
                var b;
                s((b = f.__r3f) == null ? void 0 : b.objects, f, x), s(f.children, f, x)
            }
            f.__r3f && (delete f.__r3f.root, delete f.__r3f.objects, delete f.__r3f.handlers, delete f.__r3f.memoizedProps, _ || delete f.__r3f), x && f.dispose && f.type !== "Scene" && oO.unstable_scheduleCallback(oO.unstable_IdlePriority, () => {
                try {
                    f.dispose()
                } catch {}
            }), Sh(c)
        }
    }

    function a(c, f, d, p) {
        var m;
        const y = (m = c.__r3f) == null ? void 0 : m.parent;
        if (!y) return;
        const v = n(f, d, c.__r3f.root);
        if (c.children) {
            for (const b of c.children) b.__r3f && r(v, b);
            c.children = c.children.filter(b => !b.__r3f)
        }
        c.__r3f.objects.forEach(b => r(v, b)), c.__r3f.objects = [], c.__r3f.autoRemovedBeforeAppend || o(y, c), v.parent && (v.__r3f.autoRemovedBeforeAppend = !0), r(y, v), v.raycast && v.__r3f.eventCount && v.__r3f.root.getState().internal.interaction.push(v), [p, p.alternate].forEach(b => {
            b !== null && (b.stateNode = v, b.ref && (typeof b.ref == "function" ? b.ref(v) : b.ref.current = v))
        })
    }
    const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: LFe({
            createInstance: n,
            removeChild: o,
            appendChild: r,
            appendInitialChild: r,
            insertBefore: i,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (c, f) => {
                if (!f) return;
                const d = c.getState().scene;
                d.__r3f && (d.__r3f.root = c, r(d, f))
            },
            removeChildFromContainer: (c, f) => {
                f && o(c.getState().scene, f)
            },
            insertInContainerBefore: (c, f, d) => {
                if (!f || !d) return;
                const p = c.getState().scene;
                p.__r3f && i(p, f, d)
            },
            getRootHostContext: () => null,
            getChildHostContext: c => c,
            finalizeInitialChildren(c) {
                var f;
                return !!((f = c == null ? void 0 : c.__r3f) != null ? f : {}).handlers
            },
            prepareUpdate(c, f, d, p) {
                if (c.__r3f.primitive && p.object && p.object !== c) return [!0]; {
                    const {
                        args: m = [],
                        children: y,
                        ...v
                    } = p, {
                        args: b = [],
                        children: _,
                        ...x
                    } = d;
                    if (!Array.isArray(m)) throw new Error("R3F: the args prop must be an array!");
                    if (m.some((E, A) => E !== b[A])) return [!0];
                    const S = VQ(c, v, x, !0);
                    return S.changes.length ? [!1, S] : null
                }
            },
            commitUpdate(c, [f, d], p, m, y, v) {
                f ? a(c, p, y, v) : dP(c, d)
            },
            commitMount(c, f, d, p) {
                var m;
                const y = (m = c.__r3f) != null ? m : {};
                c.raycast && y.handlers && y.eventCount && c.__r3f.root.getState().internal.interaction.push(c)
            },
            getPublicInstance: c => c,
            prepareForCommit: () => null,
            preparePortalMount: c => _h(c.getState().scene),
            resetAfterCommit: () => {},
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(c) {
                var f;
                const {
                    attach: d,
                    parent: p
                } = (f = c.__r3f) != null ? f : {};
                d && p && qH(p, c, d), c.isObject3D && (c.visible = !1), Sh(c)
            },
            unhideInstance(c, f) {
                var d;
                const {
                    attach: p,
                    parent: m
                } = (d = c.__r3f) != null ? d : {};
                p && m && fP(m, c, p), (c.isObject3D && f.visible == null || f.visible) && (c.visible = !0), Sh(c)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: () => e ? e() : Yh.DefaultEventPriority,
            beforeActiveInstanceBlur: () => {},
            afterActiveInstanceBlur: () => {},
            detachDeletedInstance: () => {},
            now: typeof performance < "u" && Er.fun(performance.now) ? performance.now : Er.fun(Date.now) ? Date.now : () => 0,
            scheduleTimeout: Er.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: Er.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: dP
    }
}
const KQ = t => !!(t != null && t.render),
    qQ = P.createContext(null),
    XFe = (t, e) => {
        const n = DQ((a, l) => {
                const u = new J,
                    c = new J,
                    f = new J;

                function d(b = l().camera, _ = c, x = l().size) {
                    const {
                        width: S,
                        height: E,
                        top: A,
                        left: T
                    } = x, M = S / E;
                    _ instanceof J ? f.copy(_) : f.set(..._);
                    const I = b.getWorldPosition(u).distanceTo(f);
                    if (zQ(b)) return {
                        width: S / b.zoom,
                        height: E / b.zoom,
                        top: A,
                        left: T,
                        factor: 1,
                        distance: I,
                        aspect: M
                    }; {
                        const O = b.fov * Math.PI / 180,
                            k = 2 * Math.tan(O / 2) * I,
                            H = k * (S / E);
                        return {
                            width: H,
                            height: k,
                            top: A,
                            left: T,
                            factor: S / H,
                            distance: I,
                            aspect: M
                        }
                    }
                }
                let p;
                const m = b => a(_ => ({
                        performance: { ..._.performance,
                            current: b
                        }
                    })),
                    y = new ke;
                return {
                    set: a,
                    get: l,
                    gl: null,
                    camera: null,
                    raycaster: null,
                    events: {
                        priority: 1,
                        enabled: !0,
                        connected: !1
                    },
                    xr: null,
                    invalidate: (b = 1) => t(l(), b),
                    advance: (b, _) => e(b, _, l()),
                    legacy: !1,
                    linear: !1,
                    flat: !1,
                    scene: _h(new _L),
                    controls: null,
                    clock: new WL,
                    pointer: y,
                    mouse: y,
                    frameloop: "always",
                    onPointerMissed: void 0,
                    performance: {
                        current: 1,
                        min: .5,
                        max: 1,
                        debounce: 200,
                        regress: () => {
                            const b = l();
                            p && clearTimeout(p), b.performance.current !== b.performance.min && m(b.performance.min), p = setTimeout(() => m(l().performance.max), b.performance.debounce)
                        }
                    },
                    size: {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        updateStyle: !1
                    },
                    viewport: {
                        initialDpr: 0,
                        dpr: 0,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: d
                    },
                    setEvents: b => a(_ => ({ ..._,
                        events: { ..._.events,
                            ...b
                        }
                    })),
                    setSize: (b, _, x, S, E) => {
                        const A = l().camera,
                            T = {
                                width: b,
                                height: _,
                                top: S || 0,
                                left: E || 0,
                                updateStyle: x
                            };
                        a(M => ({
                            size: T,
                            viewport: { ...M.viewport,
                                ...d(A, c, T)
                            }
                        }))
                    },
                    setDpr: b => a(_ => {
                        const x = GQ(b);
                        return {
                            viewport: { ..._.viewport,
                                dpr: x,
                                initialDpr: _.viewport.initialDpr || x
                            }
                        }
                    }),
                    setFrameloop: (b = "always") => {
                        const _ = l().clock;
                        _.stop(), _.elapsedTime = 0, b !== "never" && (_.start(), _.elapsedTime = 0), a(() => ({
                            frameloop: b
                        }))
                    },
                    previousRoot: void 0,
                    internal: {
                        active: !1,
                        priority: 0,
                        frames: 0,
                        lastEvent: P.createRef(),
                        interaction: [],
                        hovered: new Map,
                        subscribers: [],
                        initialClick: [0, 0],
                        initialHits: [],
                        capturedMap: new Map,
                        subscribe: (b, _, x) => {
                            const S = l().internal;
                            return S.priority = S.priority + (_ > 0 ? 1 : 0), S.subscribers.push({
                                ref: b,
                                priority: _,
                                store: x
                            }), S.subscribers = S.subscribers.sort((E, A) => E.priority - A.priority), () => {
                                const E = l().internal;
                                E != null && E.subscribers && (E.priority = E.priority - (_ > 0 ? 1 : 0), E.subscribers = E.subscribers.filter(A => A.ref !== b))
                            }
                        }
                    }
                }
            }),
            r = n.getState();
        let i = r.size,
            s = r.viewport.dpr,
            o = r.camera;
        return n.subscribe(() => {
            const {
                camera: a,
                size: l,
                viewport: u,
                gl: c,
                set: f
            } = n.getState();
            if (l !== i || u.dpr !== s) {
                var d;
                i = l, s = u.dpr, VFe(a, l), c.setPixelRatio(u.dpr);
                const p = (d = l.updateStyle) != null ? d : typeof HTMLCanvasElement < "u" && c.domElement instanceof HTMLCanvasElement;
                c.setSize(l.width, l.height, p)
            }
            a !== o && (o = a, f(p => ({
                viewport: { ...p.viewport,
                    ...p.viewport.getCurrentViewport(a)
                }
            })))
        }), n.subscribe(a => t(a)), n
    };

function JFe(t, e) {
    const n = {
        callback: t
    };
    return e.add(n), () => void e.delete(n)
}
let G_, XQ = new Set,
    YFe = new Set,
    QFe = new Set;
const JQ = t => JFe(t, XQ);

function pP(t, e) {
    if (t.size)
        for (const {
                callback: n
            } of t.values()) n(e)
}

function Ly(t, e) {
    switch (t) {
        case "before":
            return pP(XQ, e);
        case "after":
            return pP(YFe, e);
        case "tail":
            return pP(QFe, e)
    }
}
let hP, mP;

function gP(t, e, n) {
    let r = e.clock.getDelta();
    for (e.frameloop === "never" && typeof t == "number" && (r = t - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = t), hP = e.internal.subscribers, G_ = 0; G_ < hP.length; G_++) mP = hP[G_], mP.ref.current(mP.store.getState(), r, n);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames
}

function ZFe(t) {
    let e = !1,
        n, r, i;

    function s(l) {
        r = requestAnimationFrame(s), e = !0, n = 0, Ly("before", l);
        for (const c of t.values()) {
            var u;
            i = c.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((u = i.gl.xr) != null && u.isPresenting) && (n += gP(l, i))
        }
        if (Ly("after", l), n === 0) return Ly("tail", l), e = !1, cancelAnimationFrame(r)
    }

    function o(l, u = 1) {
        var c;
        if (!l) return t.forEach(f => o(f.store.getState()), u);
        (c = l.gl.xr) != null && c.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + u), e || (e = !0, requestAnimationFrame(s)))
    }

    function a(l, u = !0, c, f) {
        if (u && Ly("before", l), c) gP(l, c, f);
        else
            for (const d of t.values()) gP(l, d.store.getState());
        u && Ly("after", l)
    }
    return {
        loop: s,
        invalidate: o,
        advance: a
    }
}

function YQ() {
    const t = P.useContext(qQ);
    if (!t) throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return t
}

function ri(t = n => n, e) {
    return YQ()(t, e)
}

function nb(t, e = 0) {
    const n = YQ(),
        r = n.getState().internal.subscribe,
        i = HQ(t);
    return tb(() => r(i, e, n), [e, r, n]), null
}

function QQ(t, e) {
    return function(n, ...r) {
        const i = new n;
        return t && t(i), Promise.all(r.map(s => new Promise((o, a) => i.load(s, l => {
            l.scene && Object.assign(l, $Fe(l.scene)), o(l)
        }, e, l => a(new Error(`Could not load ${s}: ${l.message})`))))))
    }
}

function rb(t, e, n, r) {
    const i = Array.isArray(e) ? e : [e],
        s = kFe(QQ(n, r), [t, ...i], {
            equal: Er.equ
        });
    return Array.isArray(e) ? s : s[0]
}
rb.preload = function(t, e, n) {
    const r = Array.isArray(e) ? e : [e];
    return BFe(QQ(n), [t, ...r])
};
rb.clear = function(t, e) {
    const n = Array.isArray(e) ? e : [e];
    return FFe([t, ...n])
};
const og = new Map,
    {
        invalidate: XH,
        advance: JH
    } = ZFe(og),
    {
        reconciler: m2,
        applyProps: Qh
    } = qFe(og, jFe),
    ky = {
        objects: "shallow",
        strict: !1
    },
    e5e = (t, e) => {
        const n = typeof t == "function" ? t(e) : t;
        return KQ(n) ? n : new zE({
            powerPreference: "high-performance",
            canvas: e,
            antialias: !0,
            alpha: !0,
            ...t
        })
    };

function t5e(t, e) {
    if (e) return e;
    if (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && t.parentElement) {
        const {
            width: n,
            height: r,
            top: i,
            left: s
        } = t.parentElement.getBoundingClientRect();
        return {
            width: n,
            height: r,
            top: i,
            left: s
        }
    } else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas) return {
        width: t.width,
        height: t.height,
        top: 0,
        left: 0
    };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}

function n5e(t) {
    const e = og.get(t),
        n = e == null ? void 0 : e.fiber,
        r = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const i = typeof reportError == "function" ? reportError : console.error,
        s = r || XFe(XH, JH),
        o = n || m2.createContainer(s, Yh.ConcurrentRoot, null, !1, null, "", i, null);
    e || og.set(t, {
        fiber: o,
        store: s
    });
    let a, l = !1;
    return {
        configure(u = {}) {
            let {
                gl: c,
                size: f,
                events: d,
                onCreated: p,
                shadows: m = !1,
                linear: y = !1,
                flat: v = !1,
                legacy: b = !1,
                orthographic: _ = !1,
                frameloop: x = "always",
                dpr: S = [1, 2],
                performance: E,
                raycaster: A,
                camera: T,
                onPointerMissed: M
            } = u, I = s.getState(), O = I.gl;
            I.gl || I.set({
                gl: O = e5e(c, t)
            });
            let k = I.raycaster;
            k || I.set({
                raycaster: k = new eK
            });
            const {
                params: H,
                ...N
            } = A || {};
            if (Er.equ(N, k, ky) || Qh(k, { ...N
                }), Er.equ(H, k.params, ky) || Qh(k, {
                    params: { ...k.params,
                        ...H
                    }
                }), !I.camera) {
                const F = T instanceof f1,
                    G = F ? T : _ ? new Ko(0, 0, 0, 0, .1, 1e3) : new dr(75, 0, .1, 1e3);
                F || (G.position.z = 5, T && Qh(G, T), T != null && T.rotation || G.lookAt(0, 0, 0)), I.set({
                    camera: G
                })
            }
            if (!I.xr) {
                const F = (se, ee) => {
                        const ae = s.getState();
                        ae.frameloop !== "never" && JH(se, !0, ae, ee)
                    },
                    G = () => {
                        const se = s.getState();
                        se.gl.xr.enabled = se.gl.xr.isPresenting, se.gl.xr.setAnimationLoop(se.gl.xr.isPresenting ? F : null), se.gl.xr.isPresenting || XH(se)
                    },
                    W = {
                        connect() {
                            const se = s.getState().gl;
                            se.xr.addEventListener("sessionstart", G), se.xr.addEventListener("sessionend", G)
                        },
                        disconnect() {
                            const se = s.getState().gl;
                            se.xr.removeEventListener("sessionstart", G), se.xr.removeEventListener("sessionend", G)
                        }
                    };
                O.xr && W.connect(), I.set({
                    xr: W
                })
            }
            if (O.shadowMap) {
                const F = O.shadowMap.enabled,
                    G = O.shadowMap.type;
                if (O.shadowMap.enabled = !!m, Er.boo(m)) O.shadowMap.type = pv;
                else if (Er.str(m)) {
                    var B;
                    const W = {
                        basic: fj,
                        percentage: OE,
                        soft: pv,
                        variance: gd
                    };
                    O.shadowMap.type = (B = W[m]) != null ? B : pv
                } else Er.obj(m) && Object.assign(O.shadowMap, m);
                (F !== O.shadowMap.enabled || G !== O.shadowMap.type) && (O.shadowMap.needsUpdate = !0)
            }
            xh && ("enabled" in xh ? xh.enabled = !b : "legacyMode" in xh && (xh.legacyMode = b));
            const U = y ? Lu : Xn,
                q = v ? Na : aL;
            O.outputEncoding !== U && (O.outputEncoding = U), O.toneMapping !== q && (O.toneMapping = q), I.legacy !== b && I.set(() => ({
                legacy: b
            })), I.linear !== y && I.set(() => ({
                linear: y
            })), I.flat !== v && I.set(() => ({
                flat: v
            })), c && !Er.fun(c) && !KQ(c) && !Er.equ(c, O, ky) && Qh(O, c), d && !I.events.handlers && I.set({
                events: d(s)
            });
            const Q = t5e(t, f);
            return Er.equ(Q, I.size, ky) || I.setSize(Q.width, Q.height, Q.updateStyle, Q.top, Q.left), S && I.viewport.dpr !== GQ(S) && I.setDpr(S), I.frameloop !== x && I.setFrameloop(x), I.onPointerMissed || I.set({
                onPointerMissed: M
            }), E && !Er.equ(E, I.performance, ky) && I.set(F => ({
                performance: { ...F.performance,
                    ...E
                }
            })), a = p, l = !0, this
        },
        render(u) {
            return l || this.configure(), m2.updateContainer(P.createElement(r5e, {
                store: s,
                children: u,
                onCreated: a,
                rootElement: t
            }), o, null, () => {}), s
        },
        unmount() {
            ZQ(t)
        }
    }
}

function r5e({
    store: t,
    children: e,
    onCreated: n,
    rootElement: r
}) {
    return tb(() => {
        const i = t.getState();
        i.set(s => ({
            internal: { ...s.internal,
                active: !0
            }
        })), n && n(i), t.getState().events.connected || i.events.connect == null || i.events.connect(r)
    }, []), P.createElement(qQ.Provider, {
        value: t
    }, e)
}

function ZQ(t, e) {
    const n = og.get(t),
        r = n == null ? void 0 : n.fiber;
    if (r) {
        const i = n == null ? void 0 : n.store.getState();
        i && (i.internal.active = !1), m2.updateContainer(null, r, null, () => {
            i && setTimeout(() => {
                try {
                    var s, o, a, l;
                    i.events.disconnect == null || i.events.disconnect(), (s = i.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = i.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = i.gl) != null && l.xr && i.xr.disconnect(), GFe(i), og.delete(t), e && e(t)
                } catch {}
            }, 500)
        })
    }
}
m2.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: P.version
});

function cO(t, e, n) {
    var r, i, s, o, a;
    e == null && (e = 100);

    function l() {
        var c = Date.now() - o;
        c < e && c >= 0 ? r = setTimeout(l, e - c) : (r = null, n || (a = t.apply(s, i), s = i = null))
    }
    var u = function() {
        s = this, i = arguments, o = Date.now();
        var c = n && !r;
        return r || (r = setTimeout(l, e)), c && (a = t.apply(s, i), s = i = null), a
    };
    return u.clear = function() {
        r && (clearTimeout(r), r = null)
    }, u.flush = function() {
        r && (a = t.apply(s, i), s = i = null, clearTimeout(r), r = null)
    }, u
}
cO.debounce = cO;
var i5e = cO;
const YH = la(i5e);

function s5e(t) {
    let {
        debounce: e,
        scroll: n,
        polyfill: r,
        offsetSize: i
    } = t === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : t;
    const s = r || (typeof window > "u" ? class {} : window.ResizeObserver);
    if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o, a] = P.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    }), l = P.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    }), u = e ? typeof e == "number" ? e : e.scroll : null, c = e ? typeof e == "number" ? e : e.resize : null, f = P.useRef(!1);
    P.useEffect(() => (f.current = !0, () => void(f.current = !1)));
    const [d, p, m] = P.useMemo(() => {
        const _ = () => {
            if (!l.current.element) return;
            const {
                left: x,
                top: S,
                width: E,
                height: A,
                bottom: T,
                right: M,
                x: I,
                y: O
            } = l.current.element.getBoundingClientRect(), k = {
                left: x,
                top: S,
                width: E,
                height: A,
                bottom: T,
                right: M,
                x: I,
                y: O
            };
            l.current.element instanceof HTMLElement && i && (k.height = l.current.element.offsetHeight, k.width = l.current.element.offsetWidth), Object.freeze(k), f.current && !u5e(l.current.lastBounds, k) && a(l.current.lastBounds = k)
        };
        return [_, c ? YH(_, c) : _, u ? YH(_, u) : _]
    }, [a, i, u, c]);

    function y() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(_ => _.removeEventListener("scroll", m, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null)
    }

    function v() {
        l.current.element && (l.current.resizeObserver = new s(m), l.current.resizeObserver.observe(l.current.element), n && l.current.scrollContainers && l.current.scrollContainers.forEach(_ => _.addEventListener("scroll", m, {
            capture: !0,
            passive: !0
        })))
    }
    const b = _ => {
        !_ || _ === l.current.element || (y(), l.current.element = _, l.current.scrollContainers = eZ(_), v())
    };
    return a5e(m, !!n), o5e(p), P.useEffect(() => {
        y(), v()
    }, [n, m, p]), P.useEffect(() => y, []), [b, o, d]
}

function o5e(t) {
    P.useEffect(() => {
        const e = t;
        return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e)
    }, [t])
}

function a5e(t, e) {
    P.useEffect(() => {
        if (e) {
            const n = t;
            return window.addEventListener("scroll", n, {
                capture: !0,
                passive: !0
            }), () => void window.removeEventListener("scroll", n, !0)
        }
    }, [t, e])
}

function eZ(t) {
    const e = [];
    if (!t || t === document.body) return e;
    const {
        overflow: n,
        overflowX: r,
        overflowY: i
    } = window.getComputedStyle(t);
    return [n, r, i].some(s => s === "auto" || s === "scroll") && e.push(t), [...e, ...eZ(t.parentElement)]
}
const l5e = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
    u5e = (t, e) => l5e.every(n => t[n] === e[n]);
var c5e = Object.defineProperty,
    f5e = Object.defineProperties,
    d5e = Object.getOwnPropertyDescriptors,
    QH = Object.getOwnPropertySymbols,
    p5e = Object.prototype.hasOwnProperty,
    h5e = Object.prototype.propertyIsEnumerable,
    ZH = (t, e, n) => e in t ? c5e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    eU = (t, e) => {
        for (var n in e || (e = {})) p5e.call(e, n) && ZH(t, n, e[n]);
        if (QH)
            for (var n of QH(e)) h5e.call(e, n) && ZH(t, n, e[n]);
        return t
    },
    m5e = (t, e) => f5e(t, d5e(e));

function tZ(t, e, n) {
    if (!t) return;
    if (n(t) === !0) return t;
    let r = e ? t.return : t.child;
    for (; r;) {
        const i = tZ(r, e, n);
        if (i) return i;
        r = e ? null : r.sibling
    }
}

function nZ(t) {
    try {
        return Object.defineProperties(t, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return t
    }
}
const rB = nZ(P.createContext(null));
class rZ extends P.Component {
    render() {
        return P.createElement(rB.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
const {
    ReactCurrentOwner: g5e,
    ReactCurrentDispatcher: y5e
} = P.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function v5e() {
    const t = P.useContext(rB);
    if (!t) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = P.useId();
    return P.useMemo(() => {
        var r;
        return (r = g5e.current) != null ? r : tZ(t, !1, i => {
            let s = i.memoizedState;
            for (; s;) {
                if (s.memoizedState === e) return !0;
                s = s.next
            }
        })
    }, [t, e])
}

function b5e() {
    var t, e;
    const n = v5e(),
        [r] = P.useState(() => new Map);
    r.clear();
    let i = n;
    for (; i;) {
        const s = (t = i.type) == null ? void 0 : t._context;
        s && s !== rB && !r.has(s) && r.set(s, (e = y5e.current) == null ? void 0 : e.readContext(nZ(s))), i = i.return
    }
    return P.useMemo(() => Array.from(r.keys()).reduce((s, o) => a => P.createElement(s, null, P.createElement(o.Provider, m5e(eU({}, a), {
        value: r.get(o)
    }))), s => P.createElement(rZ, eU({}, s))), [r])
}
const yP = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};

function x5e(t) {
    const {
        handlePointer: e
    } = KFe(t);
    return {
        priority: 1,
        enabled: !0,
        compute(n, r, i) {
            r.pointer.set(n.offsetX / r.size.width * 2 - 1, -(n.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera)
        },
        connected: void 0,
        handlers: Object.keys(yP).reduce((n, r) => ({ ...n,
            [r]: e(r)
        }), {}),
        update: () => {
            var n;
            const {
                events: r,
                internal: i
            } = t.getState();
            (n = i.lastEvent) != null && n.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current)
        },
        connect: n => {
            var r;
            const {
                set: i,
                events: s
            } = t.getState();
            s.disconnect == null || s.disconnect(), i(o => ({
                events: { ...o.events,
                    connected: n
                }
            })), Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
                const [l, u] = yP[o];
                n.addEventListener(l, a, {
                    passive: u
                })
            })
        },
        disconnect: () => {
            const {
                set: n,
                events: r
            } = t.getState();
            if (r.connected) {
                var i;
                Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
                    if (r && r.connected instanceof HTMLElement) {
                        const [a] = yP[s];
                        r.connected.removeEventListener(a, o)
                    }
                }), n(s => ({
                    events: { ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const _5e = P.forwardRef(function({
        children: e,
        fallback: n,
        resize: r,
        style: i,
        gl: s,
        events: o = x5e,
        eventSource: a,
        eventPrefix: l,
        shadows: u,
        linear: c,
        flat: f,
        legacy: d,
        orthographic: p,
        frameloop: m,
        dpr: y,
        performance: v,
        raycaster: b,
        camera: _,
        onPointerMissed: x,
        onCreated: S,
        ...E
    }, A) {
        P.useMemo(() => WQ(y0), []);
        const T = b5e(),
            [M, I] = s5e({
                scroll: !0,
                debounce: {
                    scroll: 50,
                    resize: 0
                },
                ...r
            }),
            O = P.useRef(null),
            k = P.useRef(null),
            [H, N] = P.useState(null);
        P.useImperativeHandle(A, () => O.current);
        const B = HQ(x),
            [U, q] = P.useState(!1),
            [Q, F] = P.useState(!1);
        if (U) throw U;
        if (Q) throw Q;
        const G = P.useRef(null);
        I.width > 0 && I.height > 0 && H && (G.current || (G.current = n5e(H)), G.current.configure({
            gl: s,
            events: o,
            shadows: u,
            linear: c,
            flat: f,
            legacy: d,
            orthographic: p,
            frameloop: m,
            dpr: y,
            performance: v,
            raycaster: b,
            camera: _,
            size: I,
            onPointerMissed: (...se) => B.current == null ? void 0 : B.current(...se),
            onCreated: se => {
                se.events.connect == null || se.events.connect(a ? zFe(a) ? a.current : a : k.current), l && se.setEvents({
                    compute: (ee, ae) => {
                        const de = ee[l + "X"],
                            re = ee[l + "Y"];
                        ae.pointer.set(de / ae.size.width * 2 - 1, -(re / ae.size.height) * 2 + 1), ae.raycaster.setFromCamera(ae.pointer, ae.camera)
                    }
                }), S == null || S(se)
            }
        }), G.current.render(P.createElement(T, null, P.createElement(UQ, {
            set: F
        }, P.createElement(P.Suspense, {
            fallback: P.createElement(HFe, {
                set: q
            })
        }, e))))), tb(() => {
            N(O.current)
        }, []), P.useEffect(() => {
            if (H) return () => ZQ(H)
        }, [H]);
        const W = a ? "none" : "auto";
        return P.createElement("div", Y({
            ref: k,
            style: {
                position: "relative",
                width: "100%",
                height: "100%",
                overflow: "hidden",
                pointerEvents: W,
                ...i
            }
        }, E), P.createElement("div", {
            ref: M,
            style: {
                width: "100%",
                height: "100%"
            }
        }, P.createElement("canvas", {
            ref: O,
            style: {
                display: "block"
            }
        }, n)))
    }),
    HUe = P.forwardRef(function(e, n) {
        return P.createElement(rZ, null, P.createElement(_5e, Y({}, e, {
            ref: n
        })))
    }),
    ib = new J,
    iB = new J,
    S5e = new J,
    tU = new ke;

function w5e(t, e, n) {
    const r = ib.setFromMatrixPosition(t.matrixWorld);
    r.project(e);
    const i = n.width / 2,
        s = n.height / 2;
    return [r.x * i + i, -(r.y * s) + s]
}

function E5e(t, e) {
    const n = ib.setFromMatrixPosition(t.matrixWorld),
        r = iB.setFromMatrixPosition(e.matrixWorld),
        i = n.sub(r),
        s = e.getWorldDirection(S5e);
    return i.angleTo(s) > Math.PI / 2
}

function A5e(t, e, n, r) {
    const i = ib.setFromMatrixPosition(t.matrixWorld),
        s = i.clone();
    s.project(e), tU.set(s.x, s.y), n.setFromCamera(tU, e);
    const o = n.intersectObjects(r, !0);
    if (o.length) {
        const a = o[0].distance;
        return i.distanceTo(n.ray.origin) < a
    }
    return !0
}

function C5e(t, e) {
    if (e instanceof Ko) return e.zoom;
    if (e instanceof dr) {
        const n = ib.setFromMatrixPosition(t.matrixWorld),
            r = iB.setFromMatrixPosition(e.matrixWorld),
            i = e.fov * Math.PI / 180,
            s = n.distanceTo(r);
        return 1 / (2 * Math.tan(i / 2) * s)
    } else return 1
}

function M5e(t, e, n) {
    if (e instanceof dr || e instanceof Ko) {
        const r = ib.setFromMatrixPosition(t.matrixWorld),
            i = iB.setFromMatrixPosition(e.matrixWorld),
            s = r.distanceTo(i),
            o = (n[1] - n[0]) / (e.far - e.near),
            a = n[1] - o * e.far;
        return Math.round(o * s + a)
    }
}
const fO = t => Math.abs(t) < 1e-10 ? 0 : t;

function iZ(t, e, n = "") {
    let r = "matrix3d(";
    for (let i = 0; i !== 16; i++) r += fO(e[i] * t.elements[i]) + (i !== 15 ? "," : ")");
    return n + r
}
const T5e = (t => e => iZ(e, t))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
    P5e = (t => (e, n) => iZ(e, t(n), "translate(-50%,-50%)"))(t => [1 / t, 1 / t, 1 / t, 1, -1 / t, -1 / t, -1 / t, -1, 1 / t, 1 / t, 1 / t, 1, 1, 1, 1, 1]);

function I5e(t) {
    return t && typeof t == "object" && "current" in t
}
const UUe = P.forwardRef(({
    children: t,
    eps: e = .001,
    style: n,
    className: r,
    prepend: i,
    center: s,
    fullscreen: o,
    portal: a,
    distanceFactor: l,
    sprite: u = !1,
    transform: c = !1,
    occlude: f,
    onOcclude: d,
    castShadow: p,
    receiveShadow: m,
    material: y,
    geometry: v,
    zIndexRange: b = [16777271, 0],
    calculatePosition: _ = w5e,
    as: x = "div",
    wrapperClass: S,
    pointerEvents: E = "auto",
    ...A
}, T) => {
    const {
        gl: M,
        camera: I,
        scene: O,
        size: k,
        raycaster: H,
        events: N,
        viewport: B
    } = ri(), [U] = P.useState(() => document.createElement(x)), q = P.useRef(), Q = P.useRef(null), F = P.useRef(0), G = P.useRef([0, 0]), W = P.useRef(null), se = P.useRef(null), ee = (a == null ? void 0 : a.current) || N.connected || M.domElement.parentNode, ae = P.useRef(null), de = P.useRef(!1), re = P.useMemo(() => f && f !== "blending" || Array.isArray(f) && f.length && I5e(f[0]), [f]);
    P.useLayoutEffect(() => {
        const xe = M.domElement;
        f && f === "blending" ? (xe.style.zIndex = `${Math.floor(b[0]/2)}`, xe.style.position = "absolute", xe.style.pointerEvents = "none") : (xe.style.zIndex = null, xe.style.position = null, xe.style.pointerEvents = null)
    }, [f]), P.useLayoutEffect(() => {
        if (Q.current) {
            const xe = q.current = VG(U);
            if (O.updateMatrixWorld(), c) U.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
                const be = _(Q.current, I, k);
                U.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${be[0]}px,${be[1]}px,0);transform-origin:0 0;`
            }
            return ee && (i ? ee.prepend(U) : ee.appendChild(U)), () => {
                ee && ee.removeChild(U), xe.unmount()
            }
        }
    }, [ee, c]), P.useLayoutEffect(() => {
        S && (U.className = S)
    }, [S]);
    const _e = P.useMemo(() => c ? {
            position: "absolute",
            top: 0,
            left: 0,
            width: k.width,
            height: k.height,
            transformStyle: "preserve-3d",
            pointerEvents: "none"
        } : {
            position: "absolute",
            transform: s ? "translate3d(-50%,-50%,0)" : "none",
            ...o && {
                top: -k.height / 2,
                left: -k.width / 2,
                width: k.width,
                height: k.height
            },
            ...n
        }, [n, s, o, k, c]),
        fe = P.useMemo(() => ({
            position: "absolute",
            pointerEvents: E
        }), [E]);
    P.useLayoutEffect(() => {
        if (de.current = !1, c) {
            var xe;
            (xe = q.current) == null || xe.render(P.createElement("div", {
                ref: W,
                style: _e
            }, P.createElement("div", {
                ref: se,
                style: fe
            }, P.createElement("div", {
                ref: T,
                className: r,
                style: n,
                children: t
            }))))
        } else {
            var be;
            (be = q.current) == null || be.render(P.createElement("div", {
                ref: T,
                style: _e,
                className: r,
                children: t
            }))
        }
    });
    const ue = P.useRef(!0);
    nb(xe => {
        if (Q.current) {
            I.updateMatrixWorld(), Q.current.updateWorldMatrix(!0, !1);
            const be = c ? G.current : _(Q.current, I, k);
            if (c || Math.abs(F.current - I.zoom) > e || Math.abs(G.current[0] - be[0]) > e || Math.abs(G.current[1] - be[1]) > e) {
                const he = E5e(Q.current, I);
                let me = !1;
                re && (Array.isArray(f) ? me = f.map(je => je.current) : f !== "blending" && (me = [O]));
                const Ce = ue.current;
                if (me) {
                    const je = A5e(Q.current, I, H, me);
                    ue.current = je && !he
                } else ue.current = !he;
                Ce !== ue.current && (d ? d(!ue.current) : U.style.display = ue.current ? "block" : "none");
                const Ne = Math.floor(b[0] / 2),
                    De = f ? re ? [b[0], Ne] : [Ne - 1, 0] : b;
                if (U.style.zIndex = `${M5e(Q.current,I,De)}`, c) {
                    const [je, Ke] = [k.width / 2, k.height / 2], He = I.projectionMatrix.elements[5] * Ke, {
                        isOrthographicCamera: qe,
                        top: Xe,
                        left: K,
                        bottom: V,
                        right: ge
                    } = I, Be = T5e(I.matrixWorldInverse), ze = qe ? `scale(${He})translate(${fO(-(ge+K)/2)}px,${fO((Xe+V)/2)}px)` : `translateZ(${He}px)`;
                    let Ue = Q.current.matrixWorld;
                    u && (Ue = I.matrixWorldInverse.clone().transpose().copyPosition(Ue).scale(Q.current.scale), Ue.elements[3] = Ue.elements[7] = Ue.elements[11] = 0, Ue.elements[15] = 1), U.style.width = k.width + "px", U.style.height = k.height + "px", U.style.perspective = qe ? "" : `${He}px`, W.current && se.current && (W.current.style.transform = `${ze}${Be}translate(${je}px,${Ke}px)`, se.current.style.transform = P5e(Ue, 1 / ((l || 10) / 400)))
                } else {
                    const je = l === void 0 ? 1 : C5e(Q.current, I) * l;
                    U.style.transform = `translate3d(${be[0]}px,${be[1]}px,0) scale(${je})`
                }
                G.current = be, F.current = I.zoom
            }
        }
        if (!re && ae.current && !de.current)
            if (c) {
                if (W.current) {
                    const be = W.current.children[0];
                    if (be != null && be.clientWidth && be != null && be.clientHeight) {
                        const {
                            isOrthographicCamera: he
                        } = I;
                        if (he || v) A.scale && (Array.isArray(A.scale) ? A.scale instanceof J ? ae.current.scale.copy(A.scale.clone().divideScalar(1)) : ae.current.scale.set(1 / A.scale[0], 1 / A.scale[1], 1 / A.scale[2]) : ae.current.scale.setScalar(1 / A.scale));
                        else {
                            const me = (l || 10) / 400,
                                Ce = be.clientWidth * me,
                                Ne = be.clientHeight * me;
                            ae.current.scale.set(Ce, Ne, 1)
                        }
                        de.current = !0
                    }
                }
            } else {
                const be = U.children[0];
                if (be != null && be.clientWidth && be != null && be.clientHeight) {
                    const he = 1 / B.factor,
                        me = be.clientWidth * he,
                        Ce = be.clientHeight * he;
                    ae.current.scale.set(me, Ce, 1), de.current = !0
                }
                ae.current.lookAt(xe.camera.position)
            }
    });
    const ve = P.useMemo(() => ({
        vertexShader: c ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    }), [c]);
    return P.createElement("group", Y({}, A, {
        ref: Q
    }), f && !re && P.createElement("mesh", {
        castShadow: p,
        receiveShadow: m,
        ref: ae
    }, v || P.createElement("planeGeometry", null), y || P.createElement("shaderMaterial", {
        side: Ra,
        vertexShader: ve.vertexShader,
        fragmentShader: ve.fragmentShader
    })))
});
let By = 0;
const $Ue = DQ(t => (Uh.onStart = (e, n, r) => {
    t({
        active: !0,
        item: e,
        loaded: n,
        total: r,
        progress: (n - By) / (r - By) * 100
    })
}, Uh.onLoad = () => {
    t({
        active: !1
    })
}, Uh.onError = e => t(n => ({
    errors: [...n.errors, e]
})), Uh.onProgress = (e, n, r) => {
    n === r && (By = r), t({
        active: !0,
        item: e,
        loaded: n,
        total: r,
        progress: (n - By) / (r - By) * 100 || 100
    })
}, {
    errors: [],
    active: !1,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
}));

function R5e(t, e, n) {
    return Math.max(e, Math.min(t, n))
}
const mr = {
    toVector(t, e) {
        return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t]
    },
    add(t, e) {
        return [t[0] + e[0], t[1] + e[1]]
    },
    sub(t, e) {
        return [t[0] - e[0], t[1] - e[1]]
    },
    addTo(t, e) {
        t[0] += e[0], t[1] += e[1]
    },
    subTo(t, e) {
        t[0] -= e[0], t[1] -= e[1]
    }
};

function nU(t, e, n) {
    return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t)
}

function rU(t, e, n, r = .15) {
    return r === 0 ? R5e(t, e, n) : t < e ? -nU(e - t, n - e, r) + e : t > n ? +nU(t - n, n - e, r) + n : t
}

function O5e(t, [e, n], [r, i]) {
    const [
        [s, o],
        [a, l]
    ] = t;
    return [rU(e, s, o, r), rU(n, a, l, i)]
}

function D5e(t, e) {
    if (typeof t != "object" || t === null) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e || "default");
        if (typeof r != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}

function L5e(t) {
    var e = D5e(t, "string");
    return typeof e == "symbol" ? e : String(e)
}

function ni(t, e, n) {
    return e = L5e(e), e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function iU(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Mr(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? iU(Object(n), !0).forEach(function(r) {
            ni(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : iU(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}
const sZ = {
    pointer: {
        start: "down",
        change: "move",
        end: "up"
    },
    mouse: {
        start: "down",
        change: "move",
        end: "up"
    },
    touch: {
        start: "start",
        change: "move",
        end: "end"
    },
    gesture: {
        start: "start",
        change: "change",
        end: "end"
    }
};

function sU(t) {
    return t ? t[0].toUpperCase() + t.slice(1) : ""
}
const k5e = ["enter", "leave"];

function B5e(t = !1, e) {
    return t && !k5e.includes(e)
}

function F5e(t, e = "", n = !1) {
    const r = sZ[t],
        i = r && r[e] || e;
    return "on" + sU(t) + sU(i) + (B5e(n, i) ? "Capture" : "")
}
const N5e = ["gotpointercapture", "lostpointercapture"];

function z5e(t) {
    let e = t.substring(2).toLowerCase();
    const n = !!~e.indexOf("passive");
    n && (e = e.replace("passive", ""));
    const r = N5e.includes(e) ? "capturecapture" : "capture",
        i = !!~e.indexOf(r);
    return i && (e = e.replace("capture", "")), {
        device: e,
        capture: i,
        passive: n
    }
}

function H5e(t, e = "") {
    const n = sZ[t],
        r = n && n[e] || e;
    return t + r
}

function VA(t) {
    return "touches" in t
}

function oZ(t) {
    return VA(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse"
}

function U5e(t) {
    return Array.from(t.touches).filter(e => {
        var n, r;
        return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (r = n.contains) === null || r === void 0 ? void 0 : r.call(n, e.target))
    })
}

function $5e(t) {
    return t.type === "touchend" || t.type === "touchcancel" ? t.changedTouches : t.targetTouches
}

function aZ(t) {
    return VA(t) ? $5e(t)[0] : t
}

function dO(t, e) {
    const n = e.clientX - t.clientX,
        r = e.clientY - t.clientY,
        i = (e.clientX + t.clientX) / 2,
        s = (e.clientY + t.clientY) / 2,
        o = Math.hypot(n, r);
    return {
        angle: -(Math.atan2(n, r) * 180) / Math.PI,
        distance: o,
        origin: [i, s]
    }
}

function G5e(t) {
    return U5e(t).map(e => e.identifier)
}

function oU(t, e) {
    const [n, r] = Array.from(t.touches).filter(i => e.includes(i.identifier));
    return dO(n, r)
}

function vP(t) {
    const e = aZ(t);
    return VA(t) ? e.identifier : e.pointerId
}

function ag(t) {
    const e = aZ(t);
    return [e.clientX, e.clientY]
}
const aU = 40,
    lU = 800;

function lZ(t) {
    let {
        deltaX: e,
        deltaY: n,
        deltaMode: r
    } = t;
    return r === 1 ? (e *= aU, n *= aU) : r === 2 && (e *= lU, n *= lU), [e, n]
}

function V5e(t) {
    var e, n;
    const {
        scrollX: r,
        scrollY: i,
        scrollLeft: s,
        scrollTop: o
    } = t.currentTarget;
    return [(e = r ? ? s) !== null && e !== void 0 ? e : 0, (n = i ? ? o) !== null && n !== void 0 ? n : 0]
}

function j5e(t) {
    const e = {};
    if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
        const {
            shiftKey: n,
            altKey: r,
            metaKey: i,
            ctrlKey: s
        } = t;
        Object.assign(e, {
            shiftKey: n,
            altKey: r,
            metaKey: i,
            ctrlKey: s
        })
    }
    return e
}

function g2(t, ...e) {
    return typeof t == "function" ? t(...e) : t
}

function W5e() {}

function K5e(...t) {
    return t.length === 0 ? W5e : t.length === 1 ? t[0] : function() {
        let e;
        for (const n of t) e = n.apply(this, arguments) || e;
        return e
    }
}

function uU(t, e) {
    return Object.assign({}, e, t || {})
}
const q5e = 32;
class uZ {
    constructor(e, n, r) {
        this.ctrl = e, this.args = n, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset())
    }
    get state() {
        return this.ctrl.state[this.key]
    }
    set state(e) {
        this.ctrl.state[this.key] = e
    }
    get shared() {
        return this.ctrl.state.shared
    }
    get eventStore() {
        return this.ctrl.gestureEventStores[this.key]
    }
    get timeoutStore() {
        return this.ctrl.gestureTimeoutStores[this.key]
    }
    get config() {
        return this.ctrl.config[this.key]
    }
    get sharedConfig() {
        return this.ctrl.config.shared
    }
    get handler() {
        return this.ctrl.handlers[this.key]
    }
    reset() {
        const {
            state: e,
            shared: n,
            ingKey: r,
            args: i
        } = this;
        n[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [
            [-1 / 0, 1 / 0],
            [-1 / 0, 1 / 0]
        ], e.args = i, e.axis = void 0, e.memo = void 0, e.elapsedTime = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0
    }
    start(e) {
        const n = this.state,
            r = this.config;
        n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = r.from ? g2(r.from, n) : n.offset, n.offset = n.lastOffset), n.startTime = n.timeStamp = e.timeStamp
    }
    computeValues(e) {
        const n = this.state;
        n._values = e, n.values = this.config.transform(e)
    }
    computeInitial() {
        const e = this.state;
        e._initial = e._values, e.initial = e.values
    }
    compute(e) {
        const {
            state: n,
            config: r,
            shared: i
        } = this;
        n.args = this.args;
        let s = 0;
        if (e && (n.event = e, r.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, j5e(e)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, s = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
            const A = n._delta.map(Math.abs);
            mr.addTo(n._distance, A)
        }
        this.axisIntent && this.axisIntent(e);
        const [o, a] = n._movement, [l, u] = r.threshold, {
            _step: c,
            values: f
        } = n;
        if (r.hasCustomTransform ? (c[0] === !1 && (c[0] = Math.abs(o) >= l && f[0]), c[1] === !1 && (c[1] = Math.abs(a) >= u && f[1])) : (c[0] === !1 && (c[0] = Math.abs(o) >= l && Math.sign(o) * l), c[1] === !1 && (c[1] = Math.abs(a) >= u && Math.sign(a) * u)), n.intentional = c[0] !== !1 || c[1] !== !1, !n.intentional) return;
        const d = [0, 0];
        if (r.hasCustomTransform) {
            const [A, T] = f;
            d[0] = c[0] !== !1 ? A - c[0] : 0, d[1] = c[1] !== !1 ? T - c[1] : 0
        } else d[0] = c[0] !== !1 ? o - c[0] : 0, d[1] = c[1] !== !1 ? a - c[1] : 0;
        this.restrictToAxis && !n._blocked && this.restrictToAxis(d);
        const p = n.offset,
            m = n._active && !n._blocked || n.active;
        m && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = i[this.ingKey] = n._active, e && (n.first && ("bounds" in r && (n._bounds = g2(r.bounds, n)), this.setup && this.setup()), n.movement = d, this.computeOffset()));
        const [y, v] = n.offset, [
            [b, _],
            [x, S]
        ] = n._bounds;
        n.overflow = [y < b ? -1 : y > _ ? 1 : 0, v < x ? -1 : v > S ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
        const E = n._active ? r.rubberband || [0, 0] : [0, 0];
        if (n.offset = O5e(n._bounds, n.offset, E), n.delta = mr.sub(n.offset, p), this.computeMovement(), m && (!n.last || s > q5e)) {
            n.delta = mr.sub(n.offset, p);
            const A = n.delta.map(Math.abs);
            mr.addTo(n.distance, A), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && s > 0 && (n.velocity = [A[0] / s, A[1] / s])
        }
    }
    emit() {
        const e = this.state,
            n = this.shared,
            r = this.config;
        if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents) return;
        const i = this.handler(Mr(Mr(Mr({}, n), e), {}, {
            [this.aliasKey]: e.values
        }));
        i !== void 0 && (e.memo = i)
    }
    clean() {
        this.eventStore.clean(), this.timeoutStore.clean()
    }
}

function X5e([t, e], n) {
    const r = Math.abs(t),
        i = Math.abs(e);
    if (r > i && r > n) return "x";
    if (i > r && i > n) return "y"
}
class sb extends uZ {
    constructor(...e) {
        super(...e), ni(this, "aliasKey", "xy")
    }
    reset() {
        super.reset(), this.state.axis = void 0
    }
    init() {
        this.state.offset = [0, 0], this.state.lastOffset = [0, 0]
    }
    computeOffset() {
        this.state.offset = mr.add(this.state.lastOffset, this.state.movement)
    }
    computeMovement() {
        this.state.movement = mr.sub(this.state.offset, this.state.lastOffset)
    }
    axisIntent(e) {
        const n = this.state,
            r = this.config;
        if (!n.axis && e) {
            const i = typeof r.axisThreshold == "object" ? r.axisThreshold[oZ(e)] : r.axisThreshold;
            n.axis = X5e(n._movement, i)
        }
        n._blocked = (r.lockDirection || !!r.axis) && !n.axis || !!r.axis && r.axis !== n.axis
    }
    restrictToAxis(e) {
        if (this.config.axis || this.config.lockDirection) switch (this.state.axis) {
            case "x":
                e[1] = 0;
                break;
            case "y":
                e[0] = 0;
                break
        }
    }
}
const J5e = t => t,
    cU = .15,
    cZ = {
        enabled(t = !0) {
            return t
        },
        eventOptions(t, e, n) {
            return Mr(Mr({}, n.shared.eventOptions), t)
        },
        preventDefault(t = !1) {
            return t
        },
        triggerAllEvents(t = !1) {
            return t
        },
        rubberband(t = 0) {
            switch (t) {
                case !0:
                    return [cU, cU];
                case !1:
                    return [0, 0];
                default:
                    return mr.toVector(t)
            }
        },
        from(t) {
            if (typeof t == "function") return t;
            if (t != null) return mr.toVector(t)
        },
        transform(t, e, n) {
            const r = t || n.shared.transform;
            return this.hasCustomTransform = !!r, r || J5e
        },
        threshold(t) {
            return mr.toVector(t, 0)
        }
    },
    Y5e = 0,
    Ep = Mr(Mr({}, cZ), {}, {
        axis(t, e, {
            axis: n
        }) {
            if (this.lockDirection = n === "lock", !this.lockDirection) return n
        },
        axisThreshold(t = Y5e) {
            return t
        },
        bounds(t = {}) {
            if (typeof t == "function") return s => Ep.bounds(t(s));
            if ("current" in t) return () => t.current;
            if (typeof HTMLElement == "function" && t instanceof HTMLElement) return t;
            const {
                left: e = -1 / 0,
                right: n = 1 / 0,
                top: r = -1 / 0,
                bottom: i = 1 / 0
            } = t;
            return [
                [e, n],
                [r, i]
            ]
        }
    }),
    fU = {
        ArrowRight: (t, e = 1) => [t * e, 0],
        ArrowLeft: (t, e = 1) => [-1 * t * e, 0],
        ArrowUp: (t, e = 1) => [0, -1 * t * e],
        ArrowDown: (t, e = 1) => [0, t * e]
    };
class Q5e extends sb {
    constructor(...e) {
        super(...e), ni(this, "ingKey", "dragging")
    }
    reset() {
        super.reset();
        const e = this.state;
        e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this)
    }
    setup() {
        const e = this.state;
        if (e._bounds instanceof HTMLElement) {
            const n = e._bounds.getBoundingClientRect(),
                r = e.currentTarget.getBoundingClientRect(),
                i = {
                    left: n.left - r.left + e.offset[0],
                    right: n.right - r.right + e.offset[0],
                    top: n.top - r.top + e.offset[1],
                    bottom: n.bottom - r.bottom + e.offset[1]
                };
            e._bounds = Ep.bounds(i)
        }
    }
    cancel() {
        const e = this.state;
        e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
            this.compute(), this.emit()
        }, 0))
    }
    setActive() {
        this.state._active = this.state._pointerActive || this.state._keyboardActive
    }
    clean() {
        this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean()
    }
    pointerDown(e) {
        const n = this.config,
            r = this.state;
        if (e.buttons != null && (Array.isArray(n.pointerButtons) ? !n.pointerButtons.includes(e.buttons) : n.pointerButtons !== -1 && n.pointerButtons !== e.buttons)) return;
        const i = this.ctrl.setEventIds(e);
        n.pointerCapture && e.target.setPointerCapture(e.pointerId), !(i && i.size > 1 && r._pointerActive) && (this.start(e), this.setupPointer(e), r._pointerId = vP(e), r._pointerActive = !0, this.computeValues(ag(e)), this.computeInitial(), n.preventScrollAxis && oZ(e) !== "mouse" ? (r._active = !1, this.setupScrollPrevention(e)) : n.delay > 0 ? (this.setupDelayTrigger(e), n.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e))
    }
    startPointerDrag(e) {
        const n = this.state;
        n._active = !0, n._preventScroll = !0, n._delayed = !1, this.compute(e), this.emit()
    }
    pointerMove(e) {
        const n = this.state,
            r = this.config;
        if (!n._pointerActive || n.type === e.type && e.timeStamp === n.timeStamp) return;
        const i = vP(e);
        if (n._pointerId !== void 0 && i !== n._pointerId) return;
        const s = ag(e);
        if (document.pointerLockElement === e.target ? n._delta = [e.movementX, e.movementY] : (n._delta = mr.sub(s, n._values), this.computeValues(s)), mr.addTo(n._movement, n._delta), this.compute(e), n._delayed && n.intentional) {
            this.timeoutStore.remove("dragDelay"), n.active = !1, this.startPointerDrag(e);
            return
        }
        if (r.preventScrollAxis && !n._preventScroll)
            if (n.axis)
                if (n.axis === r.preventScrollAxis || r.preventScrollAxis === "xy") {
                    n._active = !1, this.clean();
                    return
                } else {
                    this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
                    return
                }
        else return;
        this.emit()
    }
    pointerUp(e) {
        this.ctrl.setEventIds(e);
        try {
            this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId)
        } catch {}
        const n = this.state,
            r = this.config;
        if (!n._active || !n._pointerActive) return;
        const i = vP(e);
        if (n._pointerId !== void 0 && i !== n._pointerId) return;
        this.state._pointerActive = !1, this.setActive(), this.compute(e);
        const [s, o] = n._distance;
        if (n.tap = s <= r.tapsThreshold && o <= r.tapsThreshold, n.tap && r.filterTaps) n._force = !0;
        else {
            const [a, l] = n.direction, [u, c] = n.velocity, [f, d] = n.movement, [p, m] = r.swipe.velocity, [y, v] = r.swipe.distance, b = r.swipe.duration;
            n.elapsedTime < b && (Math.abs(u) > p && Math.abs(f) > y && (n.swipe[0] = a), Math.abs(c) > m && Math.abs(d) > v && (n.swipe[1] = l))
        }
        this.emit()
    }
    pointerClick(e) {
        !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation())
    }
    setupPointer(e) {
        const n = this.config,
            r = n.device;
        n.pointerLock && e.currentTarget.requestPointerLock(), n.pointerCapture || (this.eventStore.add(this.sharedConfig.window, r, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "cancel", this.pointerUp.bind(this)))
    }
    pointerClean() {
        this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
    }
    preventScroll(e) {
        this.state._preventScroll && e.cancelable && e.preventDefault()
    }
    setupScrollPrevention(e) {
        this.state._preventScroll = !1, Z5e(e);
        const n = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
            passive: !1
        });
        this.eventStore.add(this.sharedConfig.window, "touch", "end", n), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", n), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e)
    }
    setupDelayTrigger(e) {
        this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
            this.state._step = [0, 0], this.startPointerDrag(e)
        }, this.config.delay)
    }
    keyDown(e) {
        const n = fU[e.key];
        if (n) {
            const r = this.state,
                i = e.shiftKey ? 10 : e.altKey ? .1 : 1;
            this.start(e), r._delta = n(this.config.keyboardDisplacement, i), r._keyboardActive = !0, mr.addTo(r._movement, r._delta), this.compute(e), this.emit()
        }
    }
    keyUp(e) {
        e.key in fU && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit())
    }
    bind(e) {
        const n = this.config.device;
        e(n, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(n, "change", this.pointerMove.bind(this)), e(n, "end", this.pointerUp.bind(this)), e(n, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
            capture: !0,
            passive: !1
        })
    }
}

function Z5e(t) {
    "persist" in t && typeof t.persist == "function" && t.persist()
}
const ob = typeof window < "u" && window.document && window.document.createElement;

function eNe() {
    return ob && "ontouchstart" in window
}

function dU() {
    return eNe() || ob && window.navigator.maxTouchPoints > 1
}

function tNe() {
    return ob && "onpointerdown" in window
}

function nNe() {
    return ob && "exitPointerLock" in window.document
}

function rNe() {
    try {
        return "constructor" in GestureEvent
    } catch {
        return !1
    }
}
const $o = {
        isBrowser: ob,
        gesture: rNe(),
        touch: dU(),
        touchscreen: dU(),
        pointer: tNe(),
        pointerLock: nNe()
    },
    iNe = 250,
    sNe = 180,
    oNe = .5,
    aNe = 50,
    lNe = 250,
    uNe = 10,
    pU = {
        mouse: 0,
        touch: 0,
        pen: 8
    },
    cNe = Mr(Mr({}, Ep), {}, {
        device(t, e, {
            pointer: {
                touch: n = !1,
                lock: r = !1,
                mouse: i = !1
            } = {}
        }) {
            return this.pointerLock = r && $o.pointerLock, $o.touch && n ? "touch" : this.pointerLock ? "mouse" : $o.pointer && !i ? "pointer" : $o.touch ? "touch" : "mouse"
        },
        preventScrollAxis(t, e, {
            preventScroll: n
        }) {
            if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? iNe : void 0, !(!$o.touchscreen || n === !1)) return t || (n !== void 0 ? "y" : void 0)
        },
        pointerCapture(t, e, {
            pointer: {
                capture: n = !0,
                buttons: r = 1,
                keys: i = !0
            } = {}
        }) {
            return this.pointerButtons = r, this.keys = i, !this.pointerLock && this.device === "pointer" && n
        },
        threshold(t, e, {
            filterTaps: n = !1,
            tapsThreshold: r = 3,
            axis: i = void 0
        }) {
            const s = mr.toVector(t, n ? r : i ? 1 : 0);
            return this.filterTaps = n, this.tapsThreshold = r, s
        },
        swipe({
            velocity: t = oNe,
            distance: e = aNe,
            duration: n = lNe
        } = {}) {
            return {
                velocity: this.transform(mr.toVector(t)),
                distance: this.transform(mr.toVector(e)),
                duration: n
            }
        },
        delay(t = 0) {
            switch (t) {
                case !0:
                    return sNe;
                case !1:
                    return 0;
                default:
                    return t
            }
        },
        axisThreshold(t) {
            return t ? Mr(Mr({}, pU), t) : pU
        },
        keyboardDisplacement(t = uNe) {
            return t
        }
    });

function fZ(t) {
    const [e, n] = t.overflow, [r, i] = t._delta, [s, o] = t._direction;
    (e < 0 && r > 0 && s < 0 || e > 0 && r < 0 && s > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && i > 0 && o < 0 || n > 0 && i < 0 && o > 0) && (t._movement[1] = t._movementBound[1])
}
const fNe = 30,
    dNe = 100;
class pNe extends uZ {
    constructor(...e) {
        super(...e), ni(this, "ingKey", "pinching"), ni(this, "aliasKey", "da")
    }
    init() {
        this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = new Map
    }
    reset() {
        super.reset();
        const e = this.state;
        e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0
    }
    computeOffset() {
        const {
            type: e,
            movement: n,
            lastOffset: r
        } = this.state;
        e === "wheel" ? this.state.offset = mr.add(n, r) : this.state.offset = [(1 + n[0]) * r[0], n[1] + r[1]]
    }
    computeMovement() {
        const {
            offset: e,
            lastOffset: n
        } = this.state;
        this.state.movement = [e[0] / n[0], e[1] - n[1]]
    }
    axisIntent() {
        const e = this.state,
            [n, r] = e._movement;
        if (!e.axis) {
            const i = Math.abs(n) * fNe - Math.abs(r);
            i < 0 ? e.axis = "angle" : i > 0 && (e.axis = "scale")
        }
    }
    restrictToAxis(e) {
        this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0))
    }
    cancel() {
        const e = this.state;
        e.canceled || setTimeout(() => {
            e.canceled = !0, e._active = !1, this.compute(), this.emit()
        }, 0)
    }
    touchStart(e) {
        this.ctrl.setEventIds(e);
        const n = this.state,
            r = this.ctrl.touchIds;
        if (n._active && n._touchIds.every(s => r.has(s)) || r.size < 2) return;
        this.start(e), n._touchIds = Array.from(r).slice(0, 2);
        const i = oU(e, n._touchIds);
        this.pinchStart(e, i)
    }
    pointerStart(e) {
        if (e.buttons != null && e.buttons % 2 !== 1) return;
        this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
        const n = this.state,
            r = n._pointerEvents,
            i = this.ctrl.pointerIds;
        if (n._active && Array.from(r.keys()).every(o => i.has(o)) || (r.size < 2 && r.set(e.pointerId, e), n._pointerEvents.size < 2)) return;
        this.start(e);
        const s = dO(...Array.from(r.values()));
        this.pinchStart(e, s)
    }
    pinchStart(e, n) {
        const r = this.state;
        r.origin = n.origin, this.computeValues([n.distance, n.angle]), this.computeInitial(), this.compute(e), this.emit()
    }
    touchMove(e) {
        if (!this.state._active) return;
        const n = oU(e, this.state._touchIds);
        this.pinchMove(e, n)
    }
    pointerMove(e) {
        const n = this.state._pointerEvents;
        if (n.has(e.pointerId) && n.set(e.pointerId, e), !this.state._active) return;
        const r = dO(...Array.from(n.values()));
        this.pinchMove(e, r)
    }
    pinchMove(e, n) {
        const r = this.state,
            i = r._values[1],
            s = n.angle - i;
        let o = 0;
        Math.abs(s) > 270 && (o += Math.sign(s)), this.computeValues([n.distance, n.angle - 360 * o]), r.origin = n.origin, r.turns = o, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(e), this.emit()
    }
    touchEnd(e) {
        this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some(n => !this.ctrl.touchIds.has(n)) && (this.state._active = !1, this.compute(e), this.emit())
    }
    pointerEnd(e) {
        const n = this.state;
        this.ctrl.setEventIds(e);
        try {
            e.target.releasePointerCapture(e.pointerId)
        } catch {}
        n._pointerEvents.has(e.pointerId) && n._pointerEvents.delete(e.pointerId), n._active && n._pointerEvents.size < 2 && (n._active = !1, this.compute(e), this.emit())
    }
    gestureStart(e) {
        e.cancelable && e.preventDefault();
        const n = this.state;
        n._active || (this.start(e), this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY], this.compute(e), this.emit())
    }
    gestureMove(e) {
        if (e.cancelable && e.preventDefault(), !this.state._active) return;
        const n = this.state;
        this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY];
        const r = n._movement;
        n._movement = [e.scale - 1, e.rotation], n._delta = mr.sub(n._movement, r), this.compute(e), this.emit()
    }
    gestureEnd(e) {
        this.state._active && (this.state._active = !1, this.compute(e), this.emit())
    }
    wheel(e) {
        const n = this.config.modifierKey;
        n && !e[n] || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
    }
    wheelStart(e) {
        this.start(e), this.wheelChange(e)
    }
    wheelChange(e) {
        "uv" in e || e.cancelable && e.preventDefault();
        const r = this.state;
        r._delta = [-lZ(e)[1] / dNe * r.offset[0], 0], mr.addTo(r._movement, r._delta), fZ(r), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1, this.compute(), this.emit())
    }
    bind(e) {
        const n = this.config.device;
        n && (e(n, "start", this[n + "Start"].bind(this)), e(n, "change", this[n + "Move"].bind(this)), e(n, "end", this[n + "End"].bind(this)), e(n, "cancel", this[n + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
            passive: !1
        })
    }
}
const hNe = Mr(Mr({}, cZ), {}, {
    device(t, e, {
        shared: n,
        pointer: {
            touch: r = !1
        } = {}
    }) {
        if (n.target && !$o.touch && $o.gesture) return "gesture";
        if ($o.touch && r) return "touch";
        if ($o.touchscreen) {
            if ($o.pointer) return "pointer";
            if ($o.touch) return "touch"
        }
    },
    bounds(t, e, {
        scaleBounds: n = {},
        angleBounds: r = {}
    }) {
        const i = o => {
                const a = uU(g2(n, o), {
                    min: -1 / 0,
                    max: 1 / 0
                });
                return [a.min, a.max]
            },
            s = o => {
                const a = uU(g2(r, o), {
                    min: -1 / 0,
                    max: 1 / 0
                });
                return [a.min, a.max]
            };
        return typeof n != "function" && typeof r != "function" ? [i(), s()] : o => [i(o), s(o)]
    },
    threshold(t, e, n) {
        return this.lockDirection = n.axis === "lock", mr.toVector(t, this.lockDirection ? [.1, 3] : 0)
    },
    modifierKey(t) {
        return t === void 0 ? "ctrlKey" : t
    },
    pinchOnWheel(t = !0) {
        return t
    }
});
class mNe extends sb {
    constructor(...e) {
        super(...e), ni(this, "ingKey", "moving")
    }
    move(e) {
        this.config.mouseOnly && e.pointerType !== "mouse" || (this.state._active ? this.moveChange(e) : this.moveStart(e), this.timeoutStore.add("moveEnd", this.moveEnd.bind(this)))
    }
    moveStart(e) {
        this.start(e), this.computeValues(ag(e)), this.compute(e), this.computeInitial(), this.emit()
    }
    moveChange(e) {
        if (!this.state._active) return;
        const n = ag(e),
            r = this.state;
        r._delta = mr.sub(n, r._values), mr.addTo(r._movement, r._delta), this.computeValues(n), this.compute(e), this.emit()
    }
    moveEnd(e) {
        this.state._active && (this.state._active = !1, this.compute(e), this.emit())
    }
    bind(e) {
        e("pointer", "change", this.move.bind(this)), e("pointer", "leave", this.moveEnd.bind(this))
    }
}
const gNe = Mr(Mr({}, Ep), {}, {
    mouseOnly: (t = !0) => t
});
class yNe extends sb {
    constructor(...e) {
        super(...e), ni(this, "ingKey", "scrolling")
    }
    scroll(e) {
        this.state._active || this.start(e), this.scrollChange(e), this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this))
    }
    scrollChange(e) {
        e.cancelable && e.preventDefault();
        const n = this.state,
            r = V5e(e);
        n._delta = mr.sub(r, n._values), mr.addTo(n._movement, n._delta), this.computeValues(r), this.compute(e), this.emit()
    }
    scrollEnd() {
        this.state._active && (this.state._active = !1, this.compute(), this.emit())
    }
    bind(e) {
        e("scroll", "", this.scroll.bind(this))
    }
}
const vNe = Ep;
class bNe extends sb {
    constructor(...e) {
        super(...e), ni(this, "ingKey", "wheeling")
    }
    wheel(e) {
        this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
    }
    wheelChange(e) {
        const n = this.state;
        n._delta = lZ(e), mr.addTo(n._movement, n._delta), fZ(n), this.compute(e), this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1, this.compute(), this.emit())
    }
    bind(e) {
        e("wheel", "", this.wheel.bind(this))
    }
}
const xNe = Ep;
class _Ne extends sb {
    constructor(...e) {
        super(...e), ni(this, "ingKey", "hovering")
    }
    enter(e) {
        this.config.mouseOnly && e.pointerType !== "mouse" || (this.start(e), this.computeValues(ag(e)), this.compute(e), this.emit())
    }
    leave(e) {
        if (this.config.mouseOnly && e.pointerType !== "mouse") return;
        const n = this.state;
        if (!n._active) return;
        n._active = !1;
        const r = ag(e);
        n._movement = n._delta = mr.sub(r, n._values), this.computeValues(r), this.compute(e), n.delta = n.movement, this.emit()
    }
    bind(e) {
        e("pointer", "enter", this.enter.bind(this)), e("pointer", "leave", this.leave.bind(this))
    }
}
const SNe = Mr(Mr({}, Ep), {}, {
        mouseOnly: (t = !0) => t
    }),
    sB = new Map,
    pO = new Map;

function wNe(t) {
    sB.set(t.key, t.engine), pO.set(t.key, t.resolver)
}
const ENe = {
        key: "drag",
        engine: Q5e,
        resolver: cNe
    },
    ANe = {
        key: "hover",
        engine: _Ne,
        resolver: SNe
    },
    CNe = {
        key: "move",
        engine: mNe,
        resolver: gNe
    },
    MNe = {
        key: "pinch",
        engine: pNe,
        resolver: hNe
    },
    TNe = {
        key: "scroll",
        engine: yNe,
        resolver: vNe
    },
    PNe = {
        key: "wheel",
        engine: bNe,
        resolver: xNe
    };

function INe(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}

function RNe(t, e) {
    if (t == null) return {};
    var n = INe(t, e),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (i = 0; i < s.length; i++) r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
    }
    return n
}
const ONe = {
        target(t) {
            if (t) return () => "current" in t ? t.current : t
        },
        enabled(t = !0) {
            return t
        },
        window(t = $o.isBrowser ? window : void 0) {
            return t
        },
        eventOptions({
            passive: t = !0,
            capture: e = !1
        } = {}) {
            return {
                passive: t,
                capture: e
            }
        },
        transform(t) {
            return t
        }
    },
    DNe = ["target", "eventOptions", "window", "enabled", "transform"];

function VS(t = {}, e) {
    const n = {};
    for (const [r, i] of Object.entries(e)) switch (typeof i) {
        case "function":
            n[r] = i.call(n, t[r], r, t);
            break;
        case "object":
            n[r] = VS(t[r], i);
            break;
        case "boolean":
            i && (n[r] = t[r]);
            break
    }
    return n
}

function LNe(t, e, n = {}) {
    const r = t,
        {
            target: i,
            eventOptions: s,
            window: o,
            enabled: a,
            transform: l
        } = r,
        u = RNe(r, DNe);
    if (n.shared = VS({
            target: i,
            eventOptions: s,
            window: o,
            enabled: a,
            transform: l
        }, ONe), e) {
        const c = pO.get(e);
        n[e] = VS(Mr({
            shared: n.shared
        }, u), c)
    } else
        for (const c in u) {
            const f = pO.get(c);
            f && (n[c] = VS(Mr({
                shared: n.shared
            }, u[c]), f))
        }
    return n
}
class dZ {
    constructor(e, n) {
        ni(this, "_listeners", new Set), this._ctrl = e, this._gestureKey = n
    }
    add(e, n, r, i, s) {
        const o = this._listeners,
            a = H5e(n, r),
            l = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {},
            u = Mr(Mr({}, l), s);
        e.addEventListener(a, i, u);
        const c = () => {
            e.removeEventListener(a, i, u), o.delete(c)
        };
        return o.add(c), c
    }
    clean() {
        this._listeners.forEach(e => e()), this._listeners.clear()
    }
}
class kNe {
    constructor() {
        ni(this, "_timeouts", new Map)
    }
    add(e, n, r = 140, ...i) {
        this.remove(e), this._timeouts.set(e, window.setTimeout(n, r, ...i))
    }
    remove(e) {
        const n = this._timeouts.get(e);
        n && window.clearTimeout(n)
    }
    clean() {
        this._timeouts.forEach(e => void window.clearTimeout(e)), this._timeouts.clear()
    }
}
let BNe = class {
    constructor(e) {
        ni(this, "gestures", new Set), ni(this, "_targetEventStore", new dZ(this)), ni(this, "gestureEventStores", {}), ni(this, "gestureTimeoutStores", {}), ni(this, "handlers", {}), ni(this, "config", {}), ni(this, "pointerIds", new Set), ni(this, "touchIds", new Set), ni(this, "state", {
            shared: {
                shiftKey: !1,
                metaKey: !1,
                ctrlKey: !1,
                altKey: !1
            }
        }), FNe(this, e)
    }
    setEventIds(e) {
        if (VA(e)) return this.touchIds = new Set(G5e(e)), this.touchIds;
        if ("pointerId" in e) return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds
    }
    applyHandlers(e, n) {
        this.handlers = e, this.nativeHandlers = n
    }
    applyConfig(e, n) {
        this.config = LNe(e, n, this.config)
    }
    clean() {
        this._targetEventStore.clean();
        for (const e of this.gestures) this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean()
    }
    effect() {
        return this.config.shared.target && this.bind(), () => this._targetEventStore.clean()
    }
    bind(...e) {
        const n = this.config.shared,
            r = {};
        let i;
        if (!(n.target && (i = n.target(), !i))) {
            if (n.enabled) {
                for (const o of this.gestures) {
                    const a = this.config[o],
                        l = hU(r, a.eventOptions, !!i);
                    if (a.enabled) {
                        const u = sB.get(o);
                        new u(this, e, o).bind(l)
                    }
                }
                const s = hU(r, n.eventOptions, !!i);
                for (const o in this.nativeHandlers) s(o, "", a => this.nativeHandlers[o](Mr(Mr({}, this.state.shared), {}, {
                    event: a,
                    args: e
                })), void 0, !0)
            }
            for (const s in r) r[s] = K5e(...r[s]);
            if (!i) return r;
            for (const s in r) {
                const {
                    device: o,
                    capture: a,
                    passive: l
                } = z5e(s);
                this._targetEventStore.add(i, o, "", r[s], {
                    capture: a,
                    passive: l
                })
            }
        }
    }
};

function dh(t, e) {
    t.gestures.add(e), t.gestureEventStores[e] = new dZ(t, e), t.gestureTimeoutStores[e] = new kNe
}

function FNe(t, e) {
    e.drag && dh(t, "drag"), e.wheel && dh(t, "wheel"), e.scroll && dh(t, "scroll"), e.move && dh(t, "move"), e.pinch && dh(t, "pinch"), e.hover && dh(t, "hover")
}
const hU = (t, e, n) => (r, i, s, o = {}, a = !1) => {
        var l, u;
        const c = (l = o.capture) !== null && l !== void 0 ? l : e.capture,
            f = (u = o.passive) !== null && u !== void 0 ? u : e.passive;
        let d = a ? r : F5e(r, i, c);
        n && f && (d += "Passive"), t[d] = t[d] || [], t[d].push(s)
    },
    NNe = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;

function zNe(t) {
    const e = {},
        n = {},
        r = new Set;
    for (let i in t) NNe.test(i) ? (r.add(RegExp.lastMatch), n[i] = t[i]) : e[i] = t[i];
    return [n, e, r]
}

function ph(t, e, n, r, i, s) {
    if (!t.has(n) || !sB.has(r)) return;
    const o = n + "Start",
        a = n + "End",
        l = u => {
            let c;
            return u.first && o in e && e[o](u), n in e && (c = e[n](u)), u.last && a in e && e[a](u), c
        };
    i[r] = l, s[r] = s[r] || {}
}

function HNe(t, e) {
    const [n, r, i] = zNe(t), s = {};
    return ph(i, n, "onDrag", "drag", s, e), ph(i, n, "onWheel", "wheel", s, e), ph(i, n, "onScroll", "scroll", s, e), ph(i, n, "onPinch", "pinch", s, e), ph(i, n, "onMove", "move", s, e), ph(i, n, "onHover", "hover", s, e), {
        handlers: s,
        config: e,
        nativeHandlers: r
    }
}

function UNe(t, e = {}, n, r) {
    const i = Bt.useMemo(() => new BNe(t), []);
    if (i.applyHandlers(t, r), i.applyConfig(e, n), Bt.useEffect(i.effect.bind(i)), Bt.useEffect(() => i.clean.bind(i), []), e.target === void 0) return i.bind.bind(i)
}

function $Ne(t) {
    return t.forEach(wNe),
        function(n, r) {
            const {
                handlers: i,
                nativeHandlers: s,
                config: o
            } = HNe(n, r || {});
            return UNe(i, o, void 0, s)
        }
}

function GNe(t, e) {
    return $Ne([ENe, MNe, TNe, PNe, CNe, ANe])(t, e || {})
}
let oB = lb();
const Qt = t => ab(t, oB);
let aB = lb();
Qt.write = t => ab(t, aB);
let jA = lb();
Qt.onStart = t => ab(t, jA);
let lB = lb();
Qt.onFrame = t => ab(t, lB);
let uB = lb();
Qt.onFinish = t => ab(t, uB);
let bm = [];
Qt.setTimeout = (t, e) => {
    let n = Qt.now() + e,
        r = () => {
            let s = bm.findIndex(o => o.cancel == r);
            ~s && bm.splice(s, 1), zc -= ~s ? 1 : 0
        },
        i = {
            time: n,
            handler: t,
            cancel: r
        };
    return bm.splice(pZ(n), 0, i), zc += 1, hZ(), i
};
let pZ = t => ~(~bm.findIndex(e => e.time > t) || ~bm.length);
Qt.cancel = t => {
    jA.delete(t), lB.delete(t), uB.delete(t), oB.delete(t), aB.delete(t)
};
Qt.sync = t => {
    hO = !0, Qt.batchedUpdates(t), hO = !1
};
Qt.throttle = t => {
    let e;

    function n() {
        try {
            t(...e)
        } finally {
            e = null
        }
    }

    function r(...i) {
        e = i, Qt.onStart(n)
    }
    return r.handler = t, r.cancel = () => {
        jA.delete(n), e = null
    }, r
};
let cB = typeof window < "u" ? window.requestAnimationFrame : () => {};
Qt.use = t => cB = t;
Qt.now = typeof performance < "u" ? () => performance.now() : Date.now;
Qt.batchedUpdates = t => t();
Qt.catch = console.error;
Qt.frameLoop = "always";
Qt.advance = () => {
    Qt.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : gZ()
};
let Nc = -1,
    zc = 0,
    hO = !1;

function ab(t, e) {
    hO ? (e.delete(t), t(0)) : (e.add(t), hZ())
}

function hZ() {
    Nc < 0 && (Nc = 0, Qt.frameLoop !== "demand" && cB(mZ))
}

function VNe() {
    Nc = -1
}

function mZ() {
    ~Nc && (cB(mZ), Qt.batchedUpdates(gZ))
}

function gZ() {
    let t = Nc;
    Nc = Qt.now();
    let e = pZ(Nc);
    if (e && (yZ(bm.splice(0, e), n => n.handler()), zc -= e), !zc) {
        VNe();
        return
    }
    jA.flush(), oB.flush(t ? Math.min(64, Nc - t) : 16.667), lB.flush(), aB.flush(), uB.flush()
}

function lb() {
    let t = new Set,
        e = t;
    return {
        add(n) {
            zc += e == t && !t.has(n) ? 1 : 0, t.add(n)
        },
        delete(n) {
            return zc -= e == t && t.has(n) ? 1 : 0, t.delete(n)
        },
        flush(n) {
            e.size && (t = new Set, zc -= e.size, yZ(e, r => r(n) && t.add(r)), zc += t.size, e = t)
        }
    }
}

function yZ(t, e) {
    t.forEach(n => {
        try {
            e(n)
        } catch (r) {
            Qt.catch(r)
        }
    })
}

function mO() {}
const jNe = (t, e, n) => Object.defineProperty(t, e, {
        value: n,
        writable: !0,
        configurable: !0
    }),
    at = {
        arr: Array.isArray,
        obj: t => !!t && t.constructor.name === "Object",
        fun: t => typeof t == "function",
        str: t => typeof t == "string",
        num: t => typeof t == "number",
        und: t => t === void 0
    };

function du(t, e) {
    if (at.arr(t)) {
        if (!at.arr(e) || t.length !== e.length) return !1;
        for (let n = 0; n < t.length; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }
    return t === e
}
const Un = (t, e) => t.forEach(e);

function Uu(t, e, n) {
    if (at.arr(t)) {
        for (let r = 0; r < t.length; r++) e.call(n, t[r], `${r}`);
        return
    }
    for (const r in t) t.hasOwnProperty(r) && e.call(n, t[r], r)
}
const qo = t => at.und(t) ? [] : at.arr(t) ? t : [t];

function Ov(t, e) {
    if (t.size) {
        const n = Array.from(t);
        t.clear(), Un(n, e)
    }
}
const tv = (t, ...e) => Ov(t, n => n(...e)),
    fB = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
let dB, vZ, tf = null,
    bZ = !1,
    pB = mO;
const WNe = t => {
    t.to && (vZ = t.to), t.now && (Qt.now = t.now), t.colors !== void 0 && (tf = t.colors), t.skipAnimation != null && (bZ = t.skipAnimation), t.createStringInterpolator && (dB = t.createStringInterpolator), t.requestAnimationFrame && Qt.use(t.requestAnimationFrame), t.batchedUpdates && (Qt.batchedUpdates = t.batchedUpdates), t.willAdvance && (pB = t.willAdvance), t.frameLoop && (Qt.frameLoop = t.frameLoop)
};
var kl = Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
        return dB
    },
    get to() {
        return vZ
    },
    get colors() {
        return tf
    },
    get skipAnimation() {
        return bZ
    },
    get willAdvance() {
        return pB
    },
    assign: WNe
});
const Dv = new Set;
let Vo = [],
    bP = [],
    y2 = 0;
const WA = {
    get idle() {
        return !Dv.size && !Vo.length
    },
    start(t) {
        y2 > t.priority ? (Dv.add(t), Qt.onStart(KNe)) : (xZ(t), Qt(gO))
    },
    advance: gO,
    sort(t) {
        if (y2) Qt.onFrame(() => WA.sort(t));
        else {
            const e = Vo.indexOf(t);
            ~e && (Vo.splice(e, 1), _Z(t))
        }
    },
    clear() {
        Vo = [], Dv.clear()
    }
};

function KNe() {
    Dv.forEach(xZ), Dv.clear(), Qt(gO)
}

function xZ(t) {
    Vo.includes(t) || _Z(t)
}

function _Z(t) {
    Vo.splice(qNe(Vo, e => e.priority > t.priority), 0, t)
}

function gO(t) {
    const e = bP;
    for (let n = 0; n < Vo.length; n++) {
        const r = Vo[n];
        y2 = r.priority, r.idle || (pB(r), r.advance(t), r.idle || e.push(r))
    }
    return y2 = 0, bP = Vo, bP.length = 0, Vo = e, Vo.length > 0
}

function qNe(t, e) {
    const n = t.findIndex(e);
    return n < 0 ? t.length : n
}
const XNe = (t, e, n) => Math.min(Math.max(n, t), e),
    JNe = {
        transparent: 0,
        aliceblue: 4042850303,
        antiquewhite: 4209760255,
        aqua: 16777215,
        aquamarine: 2147472639,
        azure: 4043309055,
        beige: 4126530815,
        bisque: 4293182719,
        black: 255,
        blanchedalmond: 4293643775,
        blue: 65535,
        blueviolet: 2318131967,
        brown: 2771004159,
        burlywood: 3736635391,
        burntsienna: 3934150143,
        cadetblue: 1604231423,
        chartreuse: 2147418367,
        chocolate: 3530104575,
        coral: 4286533887,
        cornflowerblue: 1687547391,
        cornsilk: 4294499583,
        crimson: 3692313855,
        cyan: 16777215,
        darkblue: 35839,
        darkcyan: 9145343,
        darkgoldenrod: 3095792639,
        darkgray: 2846468607,
        darkgreen: 6553855,
        darkgrey: 2846468607,
        darkkhaki: 3182914559,
        darkmagenta: 2332068863,
        darkolivegreen: 1433087999,
        darkorange: 4287365375,
        darkorchid: 2570243327,
        darkred: 2332033279,
        darksalmon: 3918953215,
        darkseagreen: 2411499519,
        darkslateblue: 1211993087,
        darkslategray: 793726975,
        darkslategrey: 793726975,
        darkturquoise: 13554175,
        darkviolet: 2483082239,
        deeppink: 4279538687,
        deepskyblue: 12582911,
        dimgray: 1768516095,
        dimgrey: 1768516095,
        dodgerblue: 512819199,
        firebrick: 2988581631,
        floralwhite: 4294635775,
        forestgreen: 579543807,
        fuchsia: 4278255615,
        gainsboro: 3705462015,
        ghostwhite: 4177068031,
        gold: 4292280575,
        goldenrod: 3668254975,
        gray: 2155905279,
        green: 8388863,
        greenyellow: 2919182335,
        grey: 2155905279,
        honeydew: 4043305215,
        hotpink: 4285117695,
        indianred: 3445382399,
        indigo: 1258324735,
        ivory: 4294963455,
        khaki: 4041641215,
        lavender: 3873897215,
        lavenderblush: 4293981695,
        lawngreen: 2096890111,
        lemonchiffon: 4294626815,
        lightblue: 2916673279,
        lightcoral: 4034953471,
        lightcyan: 3774873599,
        lightgoldenrodyellow: 4210742015,
        lightgray: 3553874943,
        lightgreen: 2431553791,
        lightgrey: 3553874943,
        lightpink: 4290167295,
        lightsalmon: 4288707327,
        lightseagreen: 548580095,
        lightskyblue: 2278488831,
        lightslategray: 2005441023,
        lightslategrey: 2005441023,
        lightsteelblue: 2965692159,
        lightyellow: 4294959359,
        lime: 16711935,
        limegreen: 852308735,
        linen: 4210091775,
        magenta: 4278255615,
        maroon: 2147483903,
        mediumaquamarine: 1724754687,
        mediumblue: 52735,
        mediumorchid: 3126187007,
        mediumpurple: 2473647103,
        mediumseagreen: 1018393087,
        mediumslateblue: 2070474495,
        mediumspringgreen: 16423679,
        mediumturquoise: 1221709055,
        mediumvioletred: 3340076543,
        midnightblue: 421097727,
        mintcream: 4127193855,
        mistyrose: 4293190143,
        moccasin: 4293178879,
        navajowhite: 4292783615,
        navy: 33023,
        oldlace: 4260751103,
        olive: 2155872511,
        olivedrab: 1804477439,
        orange: 4289003775,
        orangered: 4282712319,
        orchid: 3664828159,
        palegoldenrod: 4008225535,
        palegreen: 2566625535,
        paleturquoise: 2951671551,
        palevioletred: 3681588223,
        papayawhip: 4293907967,
        peachpuff: 4292524543,
        peru: 3448061951,
        pink: 4290825215,
        plum: 3718307327,
        powderblue: 2967529215,
        purple: 2147516671,
        rebeccapurple: 1714657791,
        red: 4278190335,
        rosybrown: 3163525119,
        royalblue: 1097458175,
        saddlebrown: 2336560127,
        salmon: 4202722047,
        sandybrown: 4104413439,
        seagreen: 780883967,
        seashell: 4294307583,
        sienna: 2689740287,
        silver: 3233857791,
        skyblue: 2278484991,
        slateblue: 1784335871,
        slategray: 1887473919,
        slategrey: 1887473919,
        snow: 4294638335,
        springgreen: 16744447,
        steelblue: 1182971135,
        tan: 3535047935,
        teal: 8421631,
        thistle: 3636451583,
        tomato: 4284696575,
        turquoise: 1088475391,
        violet: 4001558271,
        wheat: 4125012991,
        white: 4294967295,
        whitesmoke: 4126537215,
        yellow: 4294902015,
        yellowgreen: 2597139199
    },
    La = "[-+]?\\d*\\.?\\d+",
    v2 = La + "%";

function KA(...t) {
    return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)"
}
const YNe = new RegExp("rgb" + KA(La, La, La)),
    QNe = new RegExp("rgba" + KA(La, La, La, La)),
    ZNe = new RegExp("hsl" + KA(La, v2, v2)),
    e6e = new RegExp("hsla" + KA(La, v2, v2, La)),
    t6e = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    n6e = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    r6e = /^#([0-9a-fA-F]{6})$/,
    i6e = /^#([0-9a-fA-F]{8})$/;

function s6e(t) {
    let e;
    return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = r6e.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : tf && tf[t] !== void 0 ? tf[t] : (e = YNe.exec(t)) ? (hh(e[1]) << 24 | hh(e[2]) << 16 | hh(e[3]) << 8 | 255) >>> 0 : (e = QNe.exec(t)) ? (hh(e[1]) << 24 | hh(e[2]) << 16 | hh(e[3]) << 8 | yU(e[4])) >>> 0 : (e = t6e.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = i6e.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = n6e.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = ZNe.exec(t)) ? (mU(gU(e[1]), V_(e[2]), V_(e[3])) | 255) >>> 0 : (e = e6e.exec(t)) ? (mU(gU(e[1]), V_(e[2]), V_(e[3])) | yU(e[4])) >>> 0 : null
}

function xP(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}

function mU(t, e, n) {
    const r = n < .5 ? n * (1 + e) : n + e - n * e,
        i = 2 * n - r,
        s = xP(i, r, t + 1 / 3),
        o = xP(i, r, t),
        a = xP(i, r, t - 1 / 3);
    return Math.round(s * 255) << 24 | Math.round(o * 255) << 16 | Math.round(a * 255) << 8
}

function hh(t) {
    const e = parseInt(t, 10);
    return e < 0 ? 0 : e > 255 ? 255 : e
}

function gU(t) {
    return (parseFloat(t) % 360 + 360) % 360 / 360
}

function yU(t) {
    const e = parseFloat(t);
    return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255)
}

function V_(t) {
    const e = parseFloat(t);
    return e < 0 ? 0 : e > 100 ? 1 : e / 100
}

function vU(t) {
    let e = s6e(t);
    if (e === null) return t;
    e = e || 0;
    let n = (e & 4278190080) >>> 24,
        r = (e & 16711680) >>> 16,
        i = (e & 65280) >>> 8,
        s = (e & 255) / 255;
    return `rgba(${n}, ${r}, ${i}, ${s})`
}
const H0 = (t, e, n) => {
    if (at.fun(t)) return t;
    if (at.arr(t)) return H0({
        range: t,
        output: e,
        extrapolate: n
    });
    if (at.str(t.output[0])) return dB(t);
    const r = t,
        i = r.output,
        s = r.range || [0, 1],
        o = r.extrapolateLeft || r.extrapolate || "extend",
        a = r.extrapolateRight || r.extrapolate || "extend",
        l = r.easing || (u => u);
    return u => {
        const c = a6e(u, s);
        return o6e(u, s[c], s[c + 1], i[c], i[c + 1], l, o, a, r.map)
    }
};

function o6e(t, e, n, r, i, s, o, a, l) {
    let u = l ? l(t) : t;
    if (u < e) {
        if (o === "identity") return u;
        o === "clamp" && (u = e)
    }
    if (u > n) {
        if (a === "identity") return u;
        a === "clamp" && (u = n)
    }
    return r === i ? r : e === n ? t <= e ? r : i : (e === -1 / 0 ? u = -u : n === 1 / 0 ? u = u - e : u = (u - e) / (n - e), u = s(u), r === -1 / 0 ? u = -u : i === 1 / 0 ? u = u + r : u = u * (i - r) + r, u)
}

function a6e(t, e) {
    for (var n = 1; n < e.length - 1 && !(e[n] >= t); ++n);
    return n - 1
}
const l6e = (t, e = "end") => n => {
        n = e === "end" ? Math.min(n, .999) : Math.max(n, .001);
        const r = n * t,
            i = e === "end" ? Math.floor(r) : Math.ceil(r);
        return XNe(0, 1, i / t)
    },
    b2 = 1.70158,
    j_ = b2 * 1.525,
    bU = b2 + 1,
    xU = 2 * Math.PI / 3,
    _U = 2 * Math.PI / 4.5,
    W_ = t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
    u6e = {
        linear: t => t,
        easeInQuad: t => t * t,
        easeOutQuad: t => 1 - (1 - t) * (1 - t),
        easeInOutQuad: t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
        easeInCubic: t => t * t * t,
        easeOutCubic: t => 1 - Math.pow(1 - t, 3),
        easeInOutCubic: t => t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
        easeInQuart: t => t * t * t * t,
        easeOutQuart: t => 1 - Math.pow(1 - t, 4),
        easeInOutQuart: t => t < .5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
        easeInQuint: t => t * t * t * t * t,
        easeOutQuint: t => 1 - Math.pow(1 - t, 5),
        easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
        easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
        easeOutSine: t => Math.sin(t * Math.PI / 2),
        easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
        easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
        easeOutExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
        easeInOutExpo: t => t === 0 ? 0 : t === 1 ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
        easeInCirc: t => 1 - Math.sqrt(1 - Math.pow(t, 2)),
        easeOutCirc: t => Math.sqrt(1 - Math.pow(t - 1, 2)),
        easeInOutCirc: t => t < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
        easeInBack: t => bU * t * t * t - b2 * t * t,
        easeOutBack: t => 1 + bU * Math.pow(t - 1, 3) + b2 * Math.pow(t - 1, 2),
        easeInOutBack: t => t < .5 ? Math.pow(2 * t, 2) * ((j_ + 1) * 2 * t - j_) / 2 : (Math.pow(2 * t - 2, 2) * ((j_ + 1) * (t * 2 - 2) + j_) + 2) / 2,
        easeInElastic: t => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * xU),
        easeOutElastic: t => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - .75) * xU) + 1,
        easeInOutElastic: t => t === 0 ? 0 : t === 1 ? 1 : t < .5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * _U)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * _U) / 2 + 1,
        easeInBounce: t => 1 - W_(1 - t),
        easeOutBounce: W_,
        easeInOutBounce: t => t < .5 ? (1 - W_(1 - 2 * t)) / 2 : (1 + W_(2 * t - 1)) / 2,
        steps: l6e
    };

function yO() {
    return yO = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, yO.apply(this, arguments)
}
const lg = Symbol.for("FluidValue.get"),
    dp = Symbol.for("FluidValue.observers"),
    gl = t => !!(t && t[lg]),
    Bo = t => t && t[lg] ? t[lg]() : t,
    SU = t => t[dp] || null;

function c6e(t, e) {
    t.eventObserved ? t.eventObserved(e) : t(e)
}

function x2(t, e) {
    let n = t[dp];
    n && n.forEach(r => {
        c6e(r, e)
    })
}
class f6e {
    constructor(e) {
        if (this[lg] = void 0, this[dp] = void 0, !e && !(e = this.get)) throw Error("Unknown getter");
        d6e(this, e)
    }
}
const d6e = (t, e) => SZ(t, lg, e);

function ub(t, e) {
    if (t[lg]) {
        let n = t[dp];
        n || SZ(t, dp, n = new Set), n.has(e) || (n.add(e), t.observerAdded && t.observerAdded(n.size, e))
    }
    return e
}

function _2(t, e) {
    let n = t[dp];
    if (n && n.has(e)) {
        const r = n.size - 1;
        r ? n.delete(e) : t[dp] = null, t.observerRemoved && t.observerRemoved(r, e)
    }
}
const SZ = (t, e, n) => Object.defineProperty(t, e, {
        value: n,
        writable: !0,
        configurable: !0
    }),
    jS = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
    p6e = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,
    wU = new RegExp(`(${jS.source})(%|[a-z]+)`, "i"),
    h6e = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,
    qA = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
    wZ = t => {
        const [e, n] = m6e(t);
        if (!e || fB()) return t;
        const r = window.getComputedStyle(document.documentElement).getPropertyValue(e);
        if (r) return r.trim();
        if (n && n.startsWith("--")) {
            const i = window.getComputedStyle(document.documentElement).getPropertyValue(n);
            return i || t
        } else {
            if (n && qA.test(n)) return wZ(n);
            if (n) return n
        }
        return t
    },
    m6e = t => {
        const e = qA.exec(t);
        if (!e) return [, ];
        const [, n, r] = e;
        return [n, r]
    };
let _P;
const g6e = (t, e, n, r, i) => `rgba(${Math.round(e)}, ${Math.round(n)}, ${Math.round(r)}, ${i})`,
    EZ = t => {
        _P || (_P = tf ? new RegExp(`(${Object.keys(tf).join("|")})(?!\\w)`, "g") : /^\b$/);
        const e = t.output.map(s => Bo(s).replace(qA, wZ).replace(p6e, vU).replace(_P, vU)),
            n = e.map(s => s.match(jS).map(Number)),
            i = n[0].map((s, o) => n.map(a => {
                if (!(o in a)) throw Error('The arity of each "output" value must be equal');
                return a[o]
            })).map(s => H0(yO({}, t, {
                output: s
            })));
        return s => {
            var o;
            const a = !wU.test(e[0]) && ((o = e.find(u => wU.test(u))) == null ? void 0 : o.replace(jS, ""));
            let l = 0;
            return e[0].replace(jS, () => `${i[l++](s)}${a||""}`).replace(h6e, g6e)
        }
    },
    hB = "react-spring: ",
    AZ = t => {
        const e = t;
        let n = !1;
        if (typeof e != "function") throw new TypeError(`${hB}once requires a function parameter`);
        return (...r) => {
            n || (e(...r), n = !0)
        }
    },
    y6e = AZ(console.warn);

function v6e() {
    y6e(`${hB}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
const b6e = AZ(console.warn);

function x6e() {
    b6e(`${hB}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
}

function XA(t) {
    return at.str(t) && (t[0] == "#" || /\d/.test(t) || !fB() && qA.test(t) || t in (tf || {}))
}
const mB = fB() ? P.useEffect : P.useLayoutEffect,
    _6e = () => {
        const t = P.useRef(!1);
        return mB(() => (t.current = !0, () => {
            t.current = !1
        }), []), t
    };

function CZ() {
    const t = P.useState()[1],
        e = _6e();
    return () => {
        e.current && t(Math.random())
    }
}

function S6e(t, e) {
    const [n] = P.useState(() => ({
        inputs: e,
        result: t()
    })), r = P.useRef(), i = r.current;
    let s = i;
    return s ? e && s.inputs && w6e(e, s.inputs) || (s = {
        inputs: e,
        result: t()
    }) : s = n, P.useEffect(() => {
        r.current = s, i == n && (n.inputs = n.result = void 0)
    }, [s]), s.result
}

function w6e(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}
const MZ = t => P.useEffect(t, E6e),
    E6e = [];

function EU(t) {
    const e = P.useRef();
    return P.useEffect(() => {
        e.current = t
    }), e.current
}
const U0 = Symbol.for("Animated:node"),
    A6e = t => !!t && t[U0] === t,
    fl = t => t && t[U0],
    gB = (t, e) => jNe(t, U0, e),
    JA = t => t && t[U0] && t[U0].getPayload();
class TZ {
    constructor() {
        this.payload = void 0, gB(this, this)
    }
    getPayload() {
        return this.payload || []
    }
}
class kg extends TZ {
    constructor(e) {
        super(), this.done = !0, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e, at.num(this._value) && (this.lastPosition = this._value)
    }
    static create(e) {
        return new kg(e)
    }
    getPayload() {
        return [this]
    }
    getValue() {
        return this._value
    }
    setValue(e, n) {
        return at.num(e) && (this.lastPosition = e, n && (e = Math.round(e / n) * n, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0)
    }
    reset() {
        const {
            done: e
        } = this;
        this.done = !1, at.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null)
    }
}
class ug extends kg {
    constructor(e) {
        super(0), this._string = null, this._toString = void 0, this._toString = H0({
            output: [e, e]
        })
    }
    static create(e) {
        return new ug(e)
    }
    getValue() {
        let e = this._string;
        return e ? ? (this._string = this._toString(this._value))
    }
    setValue(e) {
        if (at.str(e)) {
            if (e == this._string) return !1;
            this._string = e, this._value = 1
        } else if (super.setValue(e)) this._string = null;
        else return !1;
        return !0
    }
    reset(e) {
        e && (this._toString = H0({
            output: [this.getValue(), e]
        })), this._value = 0, super.reset()
    }
}
const S2 = {
    dependencies: null
};
class yB extends TZ {
    constructor(e) {
        super(), this.source = e, this.setValue(e)
    }
    getValue(e) {
        const n = {};
        return Uu(this.source, (r, i) => {
            A6e(r) ? n[i] = r.getValue(e) : gl(r) ? n[i] = Bo(r) : e || (n[i] = r)
        }), n
    }
    setValue(e) {
        this.source = e, this.payload = this._makePayload(e)
    }
    reset() {
        this.payload && Un(this.payload, e => e.reset())
    }
    _makePayload(e) {
        if (e) {
            const n = new Set;
            return Uu(e, this._addToPayload, n), Array.from(n)
        }
    }
    _addToPayload(e) {
        S2.dependencies && gl(e) && S2.dependencies.add(e);
        const n = JA(e);
        n && Un(n, r => this.add(r))
    }
}
class vB extends yB {
    constructor(e) {
        super(e)
    }
    static create(e) {
        return new vB(e)
    }
    getValue() {
        return this.source.map(e => e.getValue())
    }
    setValue(e) {
        const n = this.getPayload();
        return e.length == n.length ? n.map((r, i) => r.setValue(e[i])).some(Boolean) : (super.setValue(e.map(C6e)), !0)
    }
}

function C6e(t) {
    return (XA(t) ? ug : kg).create(t)
}

function vO(t) {
    const e = fl(t);
    return e ? e.constructor : at.arr(t) ? vB : XA(t) ? ug : kg
}

function w2() {
    return w2 = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, w2.apply(this, arguments)
}
const AU = (t, e) => {
    const n = !at.fun(t) || t.prototype && t.prototype.isReactComponent;
    return P.forwardRef((r, i) => {
        const s = P.useRef(null),
            o = n && P.useCallback(m => {
                s.current = P6e(i, m)
            }, [i]),
            [a, l] = T6e(r, e),
            u = CZ(),
            c = () => {
                const m = s.current;
                if (n && !m) return;
                (m ? e.applyAnimatedValues(m, a.getValue(!0)) : !1) === !1 && u()
            },
            f = new M6e(c, l),
            d = P.useRef();
        mB(() => (d.current = f, Un(l, m => ub(m, f)), () => {
            d.current && (Un(d.current.deps, m => _2(m, d.current)), Qt.cancel(d.current.update))
        })), P.useEffect(c, []), MZ(() => () => {
            const m = d.current;
            Un(m.deps, y => _2(y, m))
        });
        const p = e.getComponentProps(a.getValue());
        return P.createElement(t, w2({}, p, {
            ref: o
        }))
    })
};
class M6e {
    constructor(e, n) {
        this.update = e, this.deps = n
    }
    eventObserved(e) {
        e.type == "change" && Qt.write(this.update)
    }
}

function T6e(t, e) {
    const n = new Set;
    return S2.dependencies = n, t.style && (t = w2({}, t, {
        style: e.createAnimatedStyle(t.style)
    })), t = new yB(t), S2.dependencies = null, [t, n]
}

function P6e(t, e) {
    return t && (at.fun(t) ? t(e) : t.current = e), e
}
const CU = Symbol.for("AnimatedComponent"),
    I6e = (t, {
        applyAnimatedValues: e = () => !1,
        createAnimatedStyle: n = i => new yB(i),
        getComponentProps: r = i => i
    } = {}) => {
        const i = {
                applyAnimatedValues: e,
                createAnimatedStyle: n,
                getComponentProps: r
            },
            s = o => {
                const a = MU(o) || "Anonymous";
                return at.str(o) ? o = s[o] || (s[o] = AU(o, i)) : o = o[CU] || (o[CU] = AU(o, i)), o.displayName = `Animated(${a})`, o
            };
        return Uu(t, (o, a) => {
            at.arr(t) && (a = MU(o)), s[a] = s(o)
        }), {
            animated: s
        }
    },
    MU = t => at.str(t) ? t : t && at.str(t.displayName) ? t.displayName : at.fun(t) && t.name || null;

function Ci() {
    return Ci = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, Ci.apply(this, arguments)
}

function fd(t, ...e) {
    return at.fun(t) ? t(...e) : t
}
const Lv = (t, e) => t === !0 || !!(e && t && (at.fun(t) ? t(e) : qo(t).includes(e))),
    PZ = (t, e) => at.obj(t) ? e && t[e] : t,
    IZ = (t, e) => t.default === !0 ? t[e] : t.default ? t.default[e] : void 0,
    R6e = t => t,
    bB = (t, e = R6e) => {
        let n = O6e;
        t.default && t.default !== !0 && (t = t.default, n = Object.keys(t));
        const r = {};
        for (const i of n) {
            const s = e(t[i], i);
            at.und(s) || (r[i] = s)
        }
        return r
    },
    O6e = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"],
    D6e = {
        config: 1,
        from: 1,
        to: 1,
        ref: 1,
        loop: 1,
        reset: 1,
        pause: 1,
        cancel: 1,
        reverse: 1,
        immediate: 1,
        default: 1,
        delay: 1,
        onProps: 1,
        onStart: 1,
        onChange: 1,
        onPause: 1,
        onResume: 1,
        onRest: 1,
        onResolve: 1,
        items: 1,
        trail: 1,
        sort: 1,
        expires: 1,
        initial: 1,
        enter: 1,
        update: 1,
        leave: 1,
        children: 1,
        onDestroyed: 1,
        keys: 1,
        callId: 1,
        parentId: 1
    };

function L6e(t) {
    const e = {};
    let n = 0;
    if (Uu(t, (r, i) => {
            D6e[i] || (e[i] = r, n++)
        }), n) return e
}

function RZ(t) {
    const e = L6e(t);
    if (e) {
        const n = {
            to: e
        };
        return Uu(t, (r, i) => i in e || (n[i] = r)), n
    }
    return Ci({}, t)
}

function $0(t) {
    return t = Bo(t), at.arr(t) ? t.map($0) : XA(t) ? kl.createStringInterpolator({
        range: [0, 1],
        output: [t, t]
    })(1) : t
}

function k6e(t) {
    for (const e in t) return !0;
    return !1
}

function bO(t) {
    return at.fun(t) || at.arr(t) && at.obj(t[0])
}

function B6e(t, e) {
    var n;
    (n = t.ref) == null || n.delete(t), e == null || e.delete(t)
}

function F6e(t, e) {
    if (e && t.ref !== e) {
        var n;
        (n = t.ref) == null || n.delete(t), e.add(t), t.ref = e
    }
}
const N6e = {
        default: {
            tension: 170,
            friction: 26
        },
        gentle: {
            tension: 120,
            friction: 14
        },
        wobbly: {
            tension: 180,
            friction: 12
        },
        stiff: {
            tension: 210,
            friction: 20
        },
        slow: {
            tension: 280,
            friction: 60
        },
        molasses: {
            tension: 280,
            friction: 120
        }
    },
    xO = Ci({}, N6e.default, {
        mass: 1,
        damping: 1,
        easing: u6e.linear,
        clamp: !1
    });
class z6e {
    constructor() {
        this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, xO)
    }
}

function H6e(t, e, n) {
    n && (n = Ci({}, n), TU(n, e), e = Ci({}, n, e)), TU(t, e), Object.assign(t, e);
    for (const o in xO) t[o] == null && (t[o] = xO[o]);
    let {
        mass: r,
        frequency: i,
        damping: s
    } = t;
    return at.und(i) || (i < .01 && (i = .01), s < 0 && (s = 0), t.tension = Math.pow(2 * Math.PI / i, 2) * r, t.friction = 4 * Math.PI * s * r / i), t
}

function TU(t, e) {
    if (!at.und(e.decay)) t.duration = void 0;
    else {
        const n = !at.und(e.tension) || !at.und(e.friction);
        (n || !at.und(e.frequency) || !at.und(e.damping) || !at.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0)
    }
}
const PU = [];
class U6e {
    constructor() {
        this.changed = !1, this.values = PU, this.toValues = null, this.fromValues = PU, this.to = void 0, this.from = void 0, this.config = new z6e, this.immediate = !1
    }
}

function OZ(t, {
    key: e,
    props: n,
    defaultProps: r,
    state: i,
    actions: s
}) {
    return new Promise((o, a) => {
        var l;
        let u, c, f = Lv((l = n.cancel) != null ? l : r == null ? void 0 : r.cancel, e);
        if (f) m();
        else {
            at.und(n.pause) || (i.paused = Lv(n.pause, e));
            let y = r == null ? void 0 : r.pause;
            y !== !0 && (y = i.paused || Lv(y, e)), u = fd(n.delay || 0, e), y ? (i.resumeQueue.add(p), s.pause()) : (s.resume(), p())
        }

        function d() {
            i.resumeQueue.add(p), i.timeouts.delete(c), c.cancel(), u = c.time - Qt.now()
        }

        function p() {
            u > 0 && !kl.skipAnimation ? (i.delayed = !0, c = Qt.setTimeout(m, u), i.pauseQueue.add(d), i.timeouts.add(c)) : m()
        }

        function m() {
            i.delayed && (i.delayed = !1), i.pauseQueue.delete(d), i.timeouts.delete(c), t <= (i.cancelId || 0) && (f = !0);
            try {
                s.start(Ci({}, n, {
                    callId: t,
                    cancel: f
                }), o)
            } catch (y) {
                a(y)
            }
        }
    })
}
const xB = (t, e) => e.length == 1 ? e[0] : e.some(n => n.cancelled) ? xm(t.get()) : e.every(n => n.noop) ? DZ(t.get()) : Ta(t.get(), e.every(n => n.finished)),
    DZ = t => ({
        value: t,
        noop: !0,
        finished: !0,
        cancelled: !1
    }),
    Ta = (t, e, n = !1) => ({
        value: t,
        finished: e,
        cancelled: n
    }),
    xm = t => ({
        value: t,
        cancelled: !0,
        finished: !1
    });

function LZ(t, e, n, r) {
    const {
        callId: i,
        parentId: s,
        onRest: o
    } = e, {
        asyncTo: a,
        promise: l
    } = n;
    return !s && t === a && !e.reset ? l : n.promise = (async () => {
        n.asyncId = i, n.asyncTo = t;
        const u = bB(e, (v, b) => b === "onRest" ? void 0 : v);
        let c, f;
        const d = new Promise((v, b) => (c = v, f = b)),
            p = v => {
                const b = i <= (n.cancelId || 0) && xm(r) || i !== n.asyncId && Ta(r, !1);
                if (b) throw v.result = b, f(v), v
            },
            m = (v, b) => {
                const _ = new IU,
                    x = new RU;
                return (async () => {
                    if (kl.skipAnimation) throw G0(n), x.result = Ta(r, !1), f(x), x;
                    p(_);
                    const S = at.obj(v) ? Ci({}, v) : Ci({}, b, {
                        to: v
                    });
                    S.parentId = i, Uu(u, (A, T) => {
                        at.und(S[T]) && (S[T] = A)
                    });
                    const E = await r.start(S);
                    return p(_), n.paused && await new Promise(A => {
                        n.resumeQueue.add(A)
                    }), E
                })()
            };
        let y;
        if (kl.skipAnimation) return G0(n), Ta(r, !1);
        try {
            let v;
            at.arr(t) ? v = (async b => {
                for (const _ of b) await m(_)
            })(t) : v = Promise.resolve(t(m, r.stop.bind(r))), await Promise.all([v.then(c), d]), y = Ta(r.get(), !0, !1)
        } catch (v) {
            if (v instanceof IU) y = v.result;
            else if (v instanceof RU) y = v.result;
            else throw v
        } finally {
            i == n.asyncId && (n.asyncId = s, n.asyncTo = s ? a : void 0, n.promise = s ? l : void 0)
        }
        return at.fun(o) && Qt.batchedUpdates(() => {
            o(y, r, r.item)
        }), y
    })()
}

function G0(t, e) {
    Ov(t.timeouts, n => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e)
}
class IU extends Error {
    constructor() {
        super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0
    }
}
class RU extends Error {
    constructor() {
        super("SkipAnimationSignal"), this.result = void 0
    }
}
const _O = t => t instanceof _B;
let $6e = 1;
class _B extends f6e {
    constructor(...e) {
        super(...e), this.id = $6e++, this.key = void 0, this._priority = 0
    }
    get priority() {
        return this._priority
    }
    set priority(e) {
        this._priority != e && (this._priority = e, this._onPriorityChange(e))
    }
    get() {
        const e = fl(this);
        return e && e.getValue()
    }
    to(...e) {
        return kl.to(this, e)
    }
    interpolate(...e) {
        return v6e(), kl.to(this, e)
    }
    toJSON() {
        return this.get()
    }
    observerAdded(e) {
        e == 1 && this._attach()
    }
    observerRemoved(e) {
        e == 0 && this._detach()
    }
    _attach() {}
    _detach() {}
    _onChange(e, n = !1) {
        x2(this, {
            type: "change",
            parent: this,
            value: e,
            idle: n
        })
    }
    _onPriorityChange(e) {
        this.idle || WA.sort(this), x2(this, {
            type: "priority",
            parent: this,
            priority: e
        })
    }
}
const pp = Symbol.for("SpringPhase"),
    kZ = 1,
    SO = 2,
    wO = 4,
    SP = t => (t[pp] & kZ) > 0,
    yc = t => (t[pp] & SO) > 0,
    Fy = t => (t[pp] & wO) > 0,
    OU = (t, e) => e ? t[pp] |= SO | kZ : t[pp] &= ~SO,
    DU = (t, e) => e ? t[pp] |= wO : t[pp] &= ~wO;
class G6e extends _B {
    constructor(e, n) {
        if (super(), this.key = void 0, this.animation = new U6e, this.queue = void 0, this.defaultProps = {}, this._state = {
                paused: !1,
                delayed: !1,
                pauseQueue: new Set,
                resumeQueue: new Set,
                timeouts: new Set
            }, this._pendingCalls = new Set, this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !at.und(e) || !at.und(n)) {
            const r = at.obj(e) ? Ci({}, e) : Ci({}, n, {
                from: e
            });
            at.und(r.default) && (r.default = !0), this.start(r)
        }
    }
    get idle() {
        return !(yc(this) || this._state.asyncTo) || Fy(this)
    }
    get goal() {
        return Bo(this.animation.to)
    }
    get velocity() {
        const e = fl(this);
        return e instanceof kg ? e.lastVelocity || 0 : e.getPayload().map(n => n.lastVelocity || 0)
    }
    get hasAnimated() {
        return SP(this)
    }
    get isAnimating() {
        return yc(this)
    }
    get isPaused() {
        return Fy(this)
    }
    get isDelayed() {
        return this._state.delayed
    }
    advance(e) {
        let n = !0,
            r = !1;
        const i = this.animation;
        let {
            config: s,
            toValues: o
        } = i;
        const a = JA(i.to);
        !a && gl(i.to) && (o = qo(Bo(i.to))), i.values.forEach((c, f) => {
            if (c.done) return;
            const d = c.constructor == ug ? 1 : a ? a[f].lastPosition : o[f];
            let p = i.immediate,
                m = d;
            if (!p) {
                if (m = c.lastPosition, s.tension <= 0) {
                    c.done = !0;
                    return
                }
                let y = c.elapsedTime += e;
                const v = i.fromValues[f],
                    b = c.v0 != null ? c.v0 : c.v0 = at.arr(s.velocity) ? s.velocity[f] : s.velocity;
                let _;
                const x = s.precision || (v == d ? .005 : Math.min(1, Math.abs(d - v) * .001));
                if (at.und(s.duration))
                    if (s.decay) {
                        const S = s.decay === !0 ? .998 : s.decay,
                            E = Math.exp(-(1 - S) * y);
                        m = v + b / (1 - S) * (1 - E), p = Math.abs(c.lastPosition - m) <= x, _ = b * E
                    } else {
                        _ = c.lastVelocity == null ? b : c.lastVelocity;
                        const S = s.restVelocity || x / 10,
                            E = s.clamp ? 0 : s.bounce,
                            A = !at.und(E),
                            T = v == d ? c.v0 > 0 : v < d;
                        let M, I = !1;
                        const O = 1,
                            k = Math.ceil(e / O);
                        for (let H = 0; H < k && (M = Math.abs(_) > S, !(!M && (p = Math.abs(d - m) <= x, p))); ++H) {
                            A && (I = m == d || m > d == T, I && (_ = -_ * E, m = d));
                            const N = -s.tension * 1e-6 * (m - d),
                                B = -s.friction * .001 * _,
                                U = (N + B) / s.mass;
                            _ = _ + U * O, m = m + _ * O
                        }
                    }
                else {
                    let S = 1;
                    s.duration > 0 && (this._memoizedDuration !== s.duration && (this._memoizedDuration = s.duration, c.durationProgress > 0 && (c.elapsedTime = s.duration * c.durationProgress, y = c.elapsedTime += e)), S = (s.progress || 0) + y / this._memoizedDuration, S = S > 1 ? 1 : S < 0 ? 0 : S, c.durationProgress = S), m = v + s.easing(S) * (d - v), _ = (m - c.lastPosition) / e, p = S == 1
                }
                c.lastVelocity = _, Number.isNaN(m) && (console.warn("Got NaN while animating:", this), p = !0)
            }
            a && !a[f].done && (p = !1), p ? c.done = !0 : n = !1, c.setValue(m, s.round) && (r = !0)
        });
        const l = fl(this),
            u = l.getValue();
        if (n) {
            const c = Bo(i.to);
            (u !== c || r) && !s.decay ? (l.setValue(c), this._onChange(c)) : r && s.decay && this._onChange(u), this._stop()
        } else r && this._onChange(u)
    }
    set(e) {
        return Qt.batchedUpdates(() => {
            this._stop(), this._focus(e), this._set(e)
        }), this
    }
    pause() {
        this._update({
            pause: !0
        })
    }
    resume() {
        this._update({
            pause: !1
        })
    }
    finish() {
        if (yc(this)) {
            const {
                to: e,
                config: n
            } = this.animation;
            Qt.batchedUpdates(() => {
                this._onStart(), n.decay || this._set(e, !1), this._stop()
            })
        }
        return this
    }
    update(e) {
        return (this.queue || (this.queue = [])).push(e), this
    }
    start(e, n) {
        let r;
        return at.und(e) ? (r = this.queue || [], this.queue = []) : r = [at.obj(e) ? e : Ci({}, n, {
            to: e
        })], Promise.all(r.map(i => this._update(i))).then(i => xB(this, i))
    }
    stop(e) {
        const {
            to: n
        } = this.animation;
        return this._focus(this.get()), G0(this._state, e && this._lastCallId), Qt.batchedUpdates(() => this._stop(n, e)), this
    }
    reset() {
        this._update({
            reset: !0
        })
    }
    eventObserved(e) {
        e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1)
    }
    _prepareNode(e) {
        const n = this.key || "";
        let {
            to: r,
            from: i
        } = e;
        r = at.obj(r) ? r[n] : r, (r == null || bO(r)) && (r = void 0), i = at.obj(i) ? i[n] : i, i == null && (i = void 0);
        const s = {
            to: r,
            from: i
        };
        return SP(this) || (e.reverse && ([r, i] = [i, r]), i = Bo(i), at.und(i) ? fl(this) || this._set(r) : this._set(i)), s
    }
    _update(e, n) {
        let r = Ci({}, e);
        const {
            key: i,
            defaultProps: s
        } = this;
        r.default && Object.assign(s, bB(r, (l, u) => /^on/.test(u) ? PZ(l, i) : l)), kU(this, r, "onProps"), zy(this, "onProps", r, this);
        const o = this._prepareNode(r);
        if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
        const a = this._state;
        return OZ(++this._lastCallId, {
            key: i,
            props: r,
            defaultProps: s,
            state: a,
            actions: {
                pause: () => {
                    Fy(this) || (DU(this, !0), tv(a.pauseQueue), zy(this, "onPause", Ta(this, Ny(this, this.animation.to)), this))
                },
                resume: () => {
                    Fy(this) && (DU(this, !1), yc(this) && this._resume(), tv(a.resumeQueue), zy(this, "onResume", Ta(this, Ny(this, this.animation.to)), this))
                },
                start: this._merge.bind(this, o)
            }
        }).then(l => {
            if (r.loop && l.finished && !(n && l.noop)) {
                const u = BZ(r);
                if (u) return this._update(u, !0)
            }
            return l
        })
    }
    _merge(e, n, r) {
        if (n.cancel) return this.stop(!0), r(xm(this));
        const i = !at.und(e.to),
            s = !at.und(e.from);
        if (i || s)
            if (n.callId > this._lastToId) this._lastToId = n.callId;
            else return r(xm(this));
        const {
            key: o,
            defaultProps: a,
            animation: l
        } = this, {
            to: u,
            from: c
        } = l;
        let {
            to: f = u,
            from: d = c
        } = e;
        s && !i && (!n.default || at.und(f)) && (f = d), n.reverse && ([f, d] = [d, f]);
        const p = !du(d, c);
        p && (l.from = d), d = Bo(d);
        const m = !du(f, u);
        m && this._focus(f);
        const y = bO(n.to),
            {
                config: v
            } = l,
            {
                decay: b,
                velocity: _
            } = v;
        (i || s) && (v.velocity = 0), n.config && !y && H6e(v, fd(n.config, o), n.config !== a.config ? fd(a.config, o) : void 0);
        let x = fl(this);
        if (!x || at.und(f)) return r(Ta(this, !0));
        const S = at.und(n.reset) ? s && !n.default : !at.und(d) && Lv(n.reset, o),
            E = S ? d : this.get(),
            A = $0(f),
            T = at.num(A) || at.arr(A) || XA(A),
            M = !y && (!T || Lv(a.immediate || n.immediate, o));
        if (m) {
            const H = vO(f);
            if (H !== x.constructor)
                if (M) x = this._set(A);
                else throw Error(`Cannot animate between ${x.constructor.name} and ${H.name}, as the "to" prop suggests`)
        }
        const I = x.constructor;
        let O = gl(f),
            k = !1;
        if (!O) {
            const H = S || !SP(this) && p;
            (m || H) && (k = du($0(E), A), O = !k), (!du(l.immediate, M) && !M || !du(v.decay, b) || !du(v.velocity, _)) && (O = !0)
        }
        if (k && yc(this) && (l.changed && !S ? O = !0 : O || this._stop(u)), !y && ((O || gl(u)) && (l.values = x.getPayload(), l.toValues = gl(f) ? null : I == ug ? [1] : qo(A)), l.immediate != M && (l.immediate = M, !M && !S && this._set(u)), O)) {
            const {
                onRest: H
            } = l;
            Un(j6e, B => kU(this, n, B));
            const N = Ta(this, Ny(this, u));
            tv(this._pendingCalls, N), this._pendingCalls.add(r), l.changed && Qt.batchedUpdates(() => {
                l.changed = !S, H == null || H(N, this), S ? fd(a.onRest, N) : l.onStart == null || l.onStart(N, this)
            })
        }
        S && this._set(E), y ? r(LZ(n.to, n, this._state, this)) : O ? this._start() : yc(this) && !m ? this._pendingCalls.add(r) : r(DZ(E))
    }
    _focus(e) {
        const n = this.animation;
        e !== n.to && (SU(this) && this._detach(), n.to = e, SU(this) && this._attach())
    }
    _attach() {
        let e = 0;
        const {
            to: n
        } = this.animation;
        gl(n) && (ub(n, this), _O(n) && (e = n.priority + 1)), this.priority = e
    }
    _detach() {
        const {
            to: e
        } = this.animation;
        gl(e) && _2(e, this)
    }
    _set(e, n = !0) {
        const r = Bo(e);
        if (!at.und(r)) {
            const i = fl(this);
            if (!i || !du(r, i.getValue())) {
                const s = vO(r);
                !i || i.constructor != s ? gB(this, s.create(r)) : i.setValue(r), i && Qt.batchedUpdates(() => {
                    this._onChange(r, n)
                })
            }
        }
        return fl(this)
    }
    _onStart() {
        const e = this.animation;
        e.changed || (e.changed = !0, zy(this, "onStart", Ta(this, Ny(this, e.to)), this))
    }
    _onChange(e, n) {
        n || (this._onStart(), fd(this.animation.onChange, e, this)), fd(this.defaultProps.onChange, e, this), super._onChange(e, n)
    }
    _start() {
        const e = this.animation;
        fl(this).reset(Bo(e.to)), e.immediate || (e.fromValues = e.values.map(n => n.lastPosition)), yc(this) || (OU(this, !0), Fy(this) || this._resume())
    }
    _resume() {
        kl.skipAnimation ? this.finish() : WA.start(this)
    }
    _stop(e, n) {
        if (yc(this)) {
            OU(this, !1);
            const r = this.animation;
            Un(r.values, s => {
                s.done = !0
            }), r.toValues && (r.onChange = r.onPause = r.onResume = void 0), x2(this, {
                type: "idle",
                parent: this
            });
            const i = n ? xm(this.get()) : Ta(this.get(), Ny(this, e ? ? r.to));
            tv(this._pendingCalls, i), r.changed && (r.changed = !1, zy(this, "onRest", i, this))
        }
    }
}

function Ny(t, e) {
    const n = $0(e),
        r = $0(t.get());
    return du(r, n)
}

function BZ(t, e = t.loop, n = t.to) {
    let r = fd(e);
    if (r) {
        const i = r !== !0 && RZ(r),
            s = (i || t).reverse,
            o = !i || i.reset;
        return V0(Ci({}, t, {
            loop: e,
            default: !1,
            pause: void 0,
            to: !s || bO(n) ? n : void 0,
            from: o ? t.from : void 0,
            reset: o
        }, i))
    }
}

function V0(t) {
    const {
        to: e,
        from: n
    } = t = RZ(t), r = new Set;
    return at.obj(e) && LU(e, r), at.obj(n) && LU(n, r), t.keys = r.size ? Array.from(r) : null, t
}

function V6e(t) {
    const e = V0(t);
    return at.und(e.default) && (e.default = bB(e)), e
}

function LU(t, e) {
    Uu(t, (n, r) => n != null && e.add(r))
}
const j6e = ["onStart", "onRest", "onChange", "onPause", "onResume"];

function kU(t, e, n) {
    t.animation[n] = e[n] !== IZ(e, n) ? PZ(e[n], t.key) : void 0
}

function zy(t, e, ...n) {
    var r, i, s, o;
    (r = (i = t.animation)[e]) == null || r.call(i, ...n), (s = (o = t.defaultProps)[e]) == null || s.call(o, ...n)
}
const W6e = ["onStart", "onChange", "onRest"];
let K6e = 1;
class q6e {
    constructor(e, n) {
        this.id = K6e++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = new Set, this._changed = new Set, this._started = !1, this._item = void 0, this._state = {
            paused: !1,
            pauseQueue: new Set,
            resumeQueue: new Set,
            timeouts: new Set
        }, this._events = {
            onStart: new Map,
            onChange: new Map,
            onRest: new Map
        }, this._onFrame = this._onFrame.bind(this), n && (this._flush = n), e && this.start(Ci({
            default: !0
        }, e))
    }
    get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every(e => e.idle && !e.isDelayed && !e.isPaused)
    }
    get item() {
        return this._item
    }
    set item(e) {
        this._item = e
    }
    get() {
        const e = {};
        return this.each((n, r) => e[r] = n.get()), e
    }
    set(e) {
        for (const n in e) {
            const r = e[n];
            at.und(r) || this.springs[n].set(r)
        }
    }
    update(e) {
        return e && this.queue.push(V0(e)), this
    }
    start(e) {
        let {
            queue: n
        } = this;
        return e ? n = qo(e).map(V0) : this.queue = [], this._flush ? this._flush(this, n) : (UZ(this, n), EO(this, n))
    }
    stop(e, n) {
        if (e !== !!e && (n = e), n) {
            const r = this.springs;
            Un(qo(n), i => r[i].stop(!!e))
        } else G0(this._state, this._lastAsyncId), this.each(r => r.stop(!!e));
        return this
    }
    pause(e) {
        if (at.und(e)) this.start({
            pause: !0
        });
        else {
            const n = this.springs;
            Un(qo(e), r => n[r].pause())
        }
        return this
    }
    resume(e) {
        if (at.und(e)) this.start({
            pause: !1
        });
        else {
            const n = this.springs;
            Un(qo(e), r => n[r].resume())
        }
        return this
    }
    each(e) {
        Uu(this.springs, e)
    }
    _onFrame() {
        const {
            onStart: e,
            onChange: n,
            onRest: r
        } = this._events, i = this._active.size > 0, s = this._changed.size > 0;
        (i && !this._started || s && !this._started) && (this._started = !0, Ov(e, ([l, u]) => {
            u.value = this.get(), l(u, this, this._item)
        }));
        const o = !i && this._started,
            a = s || o && r.size ? this.get() : null;
        s && n.size && Ov(n, ([l, u]) => {
            u.value = a, l(u, this, this._item)
        }), o && (this._started = !1, Ov(r, ([l, u]) => {
            u.value = a, l(u, this, this._item)
        }))
    }
    eventObserved(e) {
        if (e.type == "change") this._changed.add(e.parent), e.idle || this._active.add(e.parent);
        else if (e.type == "idle") this._active.delete(e.parent);
        else return;
        Qt.onFrame(this._onFrame)
    }
}

function EO(t, e) {
    return Promise.all(e.map(n => FZ(t, n))).then(n => xB(t, n))
}
async function FZ(t, e, n) {
    const {
        keys: r,
        to: i,
        from: s,
        loop: o,
        onRest: a,
        onResolve: l
    } = e, u = at.obj(e.default) && e.default;
    o && (e.loop = !1), i === !1 && (e.to = null), s === !1 && (e.from = null);
    const c = at.arr(i) || at.fun(i) ? i : void 0;
    c ? (e.to = void 0, e.onRest = void 0, u && (u.onRest = void 0)) : Un(W6e, y => {
        const v = e[y];
        if (at.fun(v)) {
            const b = t._events[y];
            e[y] = ({
                finished: _,
                cancelled: x
            }) => {
                const S = b.get(v);
                S ? (_ || (S.finished = !1), x && (S.cancelled = !0)) : b.set(v, {
                    value: null,
                    finished: _ || !1,
                    cancelled: x || !1
                })
            }, u && (u[y] = e[y])
        }
    });
    const f = t._state;
    e.pause === !f.paused ? (f.paused = e.pause, tv(e.pause ? f.pauseQueue : f.resumeQueue)) : f.paused && (e.pause = !0);
    const d = (r || Object.keys(t.springs)).map(y => t.springs[y].start(e)),
        p = e.cancel === !0 || IZ(e, "cancel") === !0;
    (c || p && f.asyncId) && d.push(OZ(++t._lastAsyncId, {
        props: e,
        state: f,
        actions: {
            pause: mO,
            resume: mO,
            start(y, v) {
                p ? (G0(f, t._lastAsyncId), v(xm(t))) : (y.onRest = a, v(LZ(c, y, f, t)))
            }
        }
    })), f.paused && await new Promise(y => {
        f.resumeQueue.add(y)
    });
    const m = xB(t, await Promise.all(d));
    if (o && m.finished && !(n && m.noop)) {
        const y = BZ(e, o, i);
        if (y) return UZ(t, [y]), FZ(t, y, !0)
    }
    return l && Qt.batchedUpdates(() => l(m, t, t.item)), m
}

function BU(t, e) {
    const n = Ci({}, t.springs);
    return e && Un(qo(e), r => {
        at.und(r.keys) && (r = V0(r)), at.obj(r.to) || (r = Ci({}, r, {
            to: void 0
        })), HZ(n, r, i => zZ(i))
    }), NZ(t, n), n
}

function NZ(t, e) {
    Uu(e, (n, r) => {
        t.springs[r] || (t.springs[r] = n, ub(n, t))
    })
}

function zZ(t, e) {
    const n = new G6e;
    return n.key = t, e && ub(n, e), n
}

function HZ(t, e, n) {
    e.keys && Un(e.keys, r => {
        (t[r] || (t[r] = n(r)))._prepareNode(e)
    })
}

function UZ(t, e) {
    Un(e, n => {
        HZ(t.springs, n, r => zZ(r, t))
    })
}

function X6e(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}
const J6e = ["children"],
    YA = t => {
        let {
            children: e
        } = t, n = X6e(t, J6e);
        const r = P.useContext(E2),
            i = n.pause || !!r.pause,
            s = n.immediate || !!r.immediate;
        n = S6e(() => ({
            pause: i,
            immediate: s
        }), [i, s]);
        const {
            Provider: o
        } = E2;
        return P.createElement(o, {
            value: n
        }, e)
    },
    E2 = Y6e(YA, {});
YA.Provider = E2.Provider;
YA.Consumer = E2.Consumer;

function Y6e(t, e) {
    return Object.assign(t, P.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t
}
const Q6e = () => {
    const t = [],
        e = function(i) {
            x6e();
            const s = [];
            return Un(t, (o, a) => {
                if (at.und(i)) s.push(o.start());
                else {
                    const l = n(i, o, a);
                    l && s.push(o.start(l))
                }
            }), s
        };
    e.current = t, e.add = function(r) {
        t.includes(r) || t.push(r)
    }, e.delete = function(r) {
        const i = t.indexOf(r);
        ~i && t.splice(i, 1)
    }, e.pause = function() {
        return Un(t, r => r.pause(...arguments)), this
    }, e.resume = function() {
        return Un(t, r => r.resume(...arguments)), this
    }, e.set = function(r) {
        Un(t, i => i.set(r))
    }, e.start = function(r) {
        const i = [];
        return Un(t, (s, o) => {
            if (at.und(r)) i.push(s.start());
            else {
                const a = this._getProps(r, s, o);
                a && i.push(s.start(a))
            }
        }), i
    }, e.stop = function() {
        return Un(t, r => r.stop(...arguments)), this
    }, e.update = function(r) {
        return Un(t, (i, s) => i.update(this._getProps(r, i, s))), this
    };
    const n = function(i, s, o) {
        return at.fun(i) ? i(o, s) : i
    };
    return e._getProps = n, e
};

function Z6e(t, e, n) {
    const r = at.fun(e) && e;
    r && !n && (n = []);
    const i = P.useMemo(() => r || arguments.length == 3 ? Q6e() : void 0, []),
        s = P.useRef(0),
        o = CZ(),
        a = P.useMemo(() => ({
            ctrls: [],
            queue: [],
            flush(b, _) {
                const x = BU(b, _);
                return s.current > 0 && !a.queue.length && !Object.keys(x).some(E => !b.springs[E]) ? EO(b, _) : new Promise(E => {
                    NZ(b, x), a.queue.push(() => {
                        E(EO(b, _))
                    }), o()
                })
            }
        }), []),
        l = P.useRef([...a.ctrls]),
        u = [],
        c = EU(t) || 0;
    P.useMemo(() => {
        Un(l.current.slice(t, c), b => {
            B6e(b, i), b.stop(!0)
        }), l.current.length = t, f(c, t)
    }, [t]), P.useMemo(() => {
        f(0, Math.min(c, t))
    }, n);

    function f(b, _) {
        for (let x = b; x < _; x++) {
            const S = l.current[x] || (l.current[x] = new q6e(null, a.flush)),
                E = r ? r(x, S) : e[x];
            E && (u[x] = V6e(E))
        }
    }
    const d = l.current.map((b, _) => BU(b, u[_])),
        p = P.useContext(YA),
        m = EU(p),
        y = p !== m && k6e(p);
    mB(() => {
        s.current++, a.ctrls = l.current;
        const {
            queue: b
        } = a;
        b.length && (a.queue = [], Un(b, _ => _())), Un(l.current, (_, x) => {
            i == null || i.add(_), y && _.start({
                default: p
            });
            const S = u[x];
            S && (F6e(_, S.ref), _.ref ? _.queue.push(S) : _.start(S))
        })
    }), MZ(() => () => {
        Un(a.ctrls, b => b.stop(!0))
    });
    const v = d.map(b => Ci({}, b));
    return i ? [v, i] : v
}

function e8e(t, e) {
    const n = at.fun(t),
        [
            [r], i
        ] = Z6e(1, n ? t : [t], n ? e || [] : e);
    return n || arguments.length == 2 ? [r, i] : r
}
let FU;
(function(t) {
    t.MOUNT = "mount", t.ENTER = "enter", t.UPDATE = "update", t.LEAVE = "leave"
})(FU || (FU = {}));
class t8e extends _B {
    constructor(e, n) {
        super(), this.key = void 0, this.idle = !0, this.calc = void 0, this._active = new Set, this.source = e, this.calc = H0(...n);
        const r = this._get(),
            i = vO(r);
        gB(this, i.create(r))
    }
    advance(e) {
        const n = this._get(),
            r = this.get();
        du(n, r) || (fl(this).setValue(n), this._onChange(n, this.idle)), !this.idle && NU(this._active) && wP(this)
    }
    _get() {
        const e = at.arr(this.source) ? this.source.map(Bo) : qo(Bo(this.source));
        return this.calc(...e)
    }
    _start() {
        this.idle && !NU(this._active) && (this.idle = !1, Un(JA(this), e => {
            e.done = !1
        }), kl.skipAnimation ? (Qt.batchedUpdates(() => this.advance()), wP(this)) : WA.start(this))
    }
    _attach() {
        let e = 1;
        Un(qo(this.source), n => {
            gl(n) && ub(n, this), _O(n) && (n.idle || this._active.add(n), e = Math.max(e, n.priority + 1))
        }), this.priority = e, this._start()
    }
    _detach() {
        Un(qo(this.source), e => {
            gl(e) && _2(e, this)
        }), this._active.clear(), wP(this)
    }
    eventObserved(e) {
        e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = qo(this.source).reduce((n, r) => Math.max(n, (_O(r) ? r.priority : 0) + 1), 0))
    }
}

function n8e(t) {
    return t.idle !== !1
}

function NU(t) {
    return !t.size || Array.from(t).every(n8e)
}

function wP(t) {
    t.idle || (t.idle = !0, Un(JA(t), e => {
        e.done = !0
    }), x2(t, {
        type: "idle",
        parent: t
    }))
}
kl.assign({
    createStringInterpolator: EZ,
    to: (t, e) => new t8e(t, e)
});
const r8e = ["primitive"].concat(Object.keys(y0).filter(t => /^[A-Z]/.test(t)).map(t => t[0].toLowerCase() + t.slice(1)));
kl.assign({
    createStringInterpolator: EZ,
    colors: JNe,
    frameLoop: "demand"
});
JQ(() => {
    Qt.advance()
});
const i8e = I6e(r8e, {
        applyAnimatedValues: Qh
    }),
    s8e = i8e.animated;

function VUe({
    enabled: t = !0,
    snap: e,
    global: n,
    domElement: r,
    cursor: i = !0,
    children: s,
    speed: o = 1,
    rotation: a = [0, 0, 0],
    zoom: l = 1,
    polar: u = [0, Math.PI / 2],
    azimuth: c = [-1 / 0, 1 / 0],
    config: f = {
        mass: 1,
        tension: 170,
        friction: 26
    }
}) {
    const d = ri(A => A.events),
        p = ri(A => A.gl),
        m = r || d.connected || p.domElement,
        {
            size: y
        } = ri(),
        v = P.useMemo(() => [a[0] + u[0], a[0] + u[1]], [a[0], u[0], u[1]]),
        b = P.useMemo(() => [a[1] + c[0], a[1] + c[1]], [a[1], c[0], c[1]]),
        _ = P.useMemo(() => [bd.clamp(a[0], ...v), bd.clamp(a[1], ...b), a[2]], [a[0], a[1], a[2], v, b]),
        [x, S] = e8e(() => ({
            scale: 1,
            rotation: _,
            config: f
        }));
    P.useEffect(() => void S.start({
        scale: 1,
        rotation: _,
        config: f
    }), [_]), P.useEffect(() => {
        if (n && i && t) return m.style.cursor = "grab", p.domElement.style.cursor = "", () => {
            m.style.cursor = "default", p.domElement.style.cursor = "default"
        }
    }, [n, i, m, t]);
    const E = GNe({
        onHover: ({
            last: A
        }) => {
            i && !n && t && (m.style.cursor = A ? "auto" : "grab")
        },
        onDrag: ({
            down: A,
            delta: [T, M],
            memo: [I, O] = x.rotation.animation.to || _
        }) => {
            if (!t) return [M, T];
            i && (m.style.cursor = A ? "grabbing" : "grab"), T = bd.clamp(O + T / y.width * Math.PI * o, ...b), M = bd.clamp(I + M / y.height * Math.PI * o, ...v);
            const k = e && !A && typeof e != "boolean" ? e : f;
            return S.start({
                scale: A && M > v[1] / 2 ? l : 1,
                rotation: e && !A ? _ : [M, T, 0],
                config: H => H === "scale" ? { ...k,
                    friction: k.friction * 3
                } : k
            }), [M, T]
        }
    }, {
        target: n ? m : void 0
    });
    return P.createElement(s8e.group, Y({}, E == null ? void 0 : E(), x), s)
}

function zU(t, e) {
    if (e === tW) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), t;
    if (e === Dw || e === cL) {
        let n = t.getIndex();
        if (n === null) {
            const o = [],
                a = t.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++) o.push(l);
                t.setIndex(o), n = t.getIndex()
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t
        }
        const r = n.count - 2,
            i = [];
        if (n)
            if (e === Dw)
                for (let o = 1; o <= r; o++) i.push(n.getX(0)), i.push(n.getX(o)), i.push(n.getX(o + 1));
            else
                for (let o = 0; o < r; o++) o % 2 === 0 ? (i.push(n.getX(o)), i.push(n.getX(o + 1)), i.push(n.getX(o + 2))) : (i.push(n.getX(o + 2)), i.push(n.getX(o + 1)), i.push(n.getX(o)));
        i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = t.clone();
        return s.setIndex(i), s.clearGroups(), s
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), t
}
const o8e = parseInt(vp.replace(/\D+/g, ""));
var a8e = Object.defineProperty,
    l8e = (t, e, n) => e in t ? a8e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    jt = (t, e, n) => (l8e(t, typeof e != "symbol" ? e + "" : e, n), n);
const K_ = new yg,
    HU = new mu,
    u8e = Math.cos(70 * (Math.PI / 180)),
    UU = (t, e) => (t % e + e) % e;
let c8e = class extends Bl {
    constructor(e, n) {
        super(), jt(this, "object"), jt(this, "domElement"), jt(this, "enabled", !0), jt(this, "target", new J), jt(this, "minDistance", 0), jt(this, "maxDistance", 1 / 0), jt(this, "minZoom", 0), jt(this, "maxZoom", 1 / 0), jt(this, "minPolarAngle", 0), jt(this, "maxPolarAngle", Math.PI), jt(this, "minAzimuthAngle", -1 / 0), jt(this, "maxAzimuthAngle", 1 / 0), jt(this, "enableDamping", !1), jt(this, "dampingFactor", .05), jt(this, "enableZoom", !0), jt(this, "zoomSpeed", 1), jt(this, "enableRotate", !0), jt(this, "rotateSpeed", 1), jt(this, "enablePan", !0), jt(this, "panSpeed", 1), jt(this, "screenSpacePanning", !0), jt(this, "keyPanSpeed", 7), jt(this, "zoomToCursor", !1), jt(this, "autoRotate", !1), jt(this, "autoRotateSpeed", 2), jt(this, "reverseOrbit", !1), jt(this, "reverseHorizontalOrbit", !1), jt(this, "reverseVerticalOrbit", !1), jt(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }), jt(this, "mouseButtons", {
            LEFT: td.ROTATE,
            MIDDLE: td.DOLLY,
            RIGHT: td.PAN
        }), jt(this, "touches", {
            ONE: nd.ROTATE,
            TWO: nd.DOLLY_PAN
        }), jt(this, "target0"), jt(this, "position0"), jt(this, "zoom0"), jt(this, "_domElementKeyEvents", null), jt(this, "getPolarAngle"), jt(this, "getAzimuthalAngle"), jt(this, "setPolarAngle"), jt(this, "setAzimuthalAngle"), jt(this, "getDistance"), jt(this, "listenToKeyEvents"), jt(this, "stopListenToKeyEvents"), jt(this, "saveState"), jt(this, "reset"), jt(this, "update"), jt(this, "connect"), jt(this, "dispose"), this.object = e, this.domElement = n, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => c.phi, this.getAzimuthalAngle = () => c.theta, this.setPolarAngle = le => {
            let Ie = UU(le, 2 * Math.PI),
                tt = c.phi;
            tt < 0 && (tt += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI);
            let oe = Math.abs(Ie - tt);
            2 * Math.PI - oe < oe && (Ie < tt ? Ie += 2 * Math.PI : tt += 2 * Math.PI), f.phi = Ie - tt, r.update()
        }, this.setAzimuthalAngle = le => {
            let Ie = UU(le, 2 * Math.PI),
                tt = c.theta;
            tt < 0 && (tt += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI);
            let oe = Math.abs(Ie - tt);
            2 * Math.PI - oe < oe && (Ie < tt ? Ie += 2 * Math.PI : tt += 2 * Math.PI), f.theta = Ie - tt, r.update()
        }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = le => {
            le.addEventListener("keydown", Ye), this._domElementKeyEvents = le
        }, this.stopListenToKeyEvents = () => {
            this._domElementKeyEvents.removeEventListener("keydown", Ye), this._domElementKeyEvents = null
        }, this.saveState = () => {
            r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom
        }, this.reset = () => {
            r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(i), r.update(), l = a.NONE
        }, this.update = (() => {
            const le = new J,
                Ie = new J(0, 1, 0),
                tt = new Ti().setFromUnitVectors(e.up, Ie),
                oe = tt.clone().invert(),
                Ee = new J,
                Fe = new Ti,
                Ve = 2 * Math.PI;
            return function() {
                const bt = r.object.position;
                tt.setFromUnitVectors(e.up, Ie), oe.copy(tt).invert(), le.copy(bt).sub(r.target), le.applyQuaternion(tt), c.setFromVector3(le), r.autoRotate && l === a.NONE && B(H()), r.enableDamping ? (c.theta += f.theta * r.dampingFactor, c.phi += f.phi * r.dampingFactor) : (c.theta += f.theta, c.phi += f.phi);
                let Kt = r.minAzimuthAngle,
                    un = r.maxAzimuthAngle;
                isFinite(Kt) && isFinite(un) && (Kt < -Math.PI ? Kt += Ve : Kt > Math.PI && (Kt -= Ve), un < -Math.PI ? un += Ve : un > Math.PI && (un -= Ve), Kt <= un ? c.theta = Math.max(Kt, Math.min(un, c.theta)) : c.theta = c.theta > (Kt + un) / 2 ? Math.max(Kt, c.theta) : Math.min(un, c.theta)), c.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, c.phi)), c.makeSafe(), r.enableDamping === !0 ? r.target.addScaledVector(p, r.dampingFactor) : r.target.add(p), r.zoomToCursor && I || r.object.isOrthographicCamera ? c.radius = ee(c.radius) : c.radius = ee(c.radius * d), le.setFromSpherical(c), le.applyQuaternion(oe), bt.copy(r.target).add(le), r.object.matrixAutoUpdate || r.object.updateMatrix(), r.object.lookAt(r.target), r.enableDamping === !0 ? (f.theta *= 1 - r.dampingFactor, f.phi *= 1 - r.dampingFactor, p.multiplyScalar(1 - r.dampingFactor)) : (f.set(0, 0, 0), p.set(0, 0, 0));
                let zt = !1;
                if (r.zoomToCursor && I) {
                    let Ot = null;
                    if (r.object instanceof dr && r.object.isPerspectiveCamera) {
                        const tn = le.length();
                        Ot = ee(tn * d);
                        const Xt = tn - Ot;
                        r.object.position.addScaledVector(T, Xt), r.object.updateMatrixWorld()
                    } else if (r.object.isOrthographicCamera) {
                        const tn = new J(M.x, M.y, 0);
                        tn.unproject(r.object), r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / d)), r.object.updateProjectionMatrix(), zt = !0;
                        const Xt = new J(M.x, M.y, 0);
                        Xt.unproject(r.object), r.object.position.sub(Xt).add(tn), r.object.updateMatrixWorld(), Ot = le.length()
                    } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), r.zoomToCursor = !1;
                    Ot !== null && (r.screenSpacePanning ? r.target.set(0, 0, -1).transformDirection(r.object.matrix).multiplyScalar(Ot).add(r.object.position) : (K_.origin.copy(r.object.position), K_.direction.set(0, 0, -1).transformDirection(r.object.matrix), Math.abs(r.object.up.dot(K_.direction)) < u8e ? e.lookAt(r.target) : (HU.setFromNormalAndCoplanarPoint(r.object.up, r.target), K_.intersectPlane(HU, r.target))))
                } else r.object instanceof Ko && r.object.isOrthographicCamera && (zt = d !== 1, zt && (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / d)), r.object.updateProjectionMatrix()));
                return d = 1, I = !1, zt || Ee.distanceToSquared(r.object.position) > u || 8 * (1 - Fe.dot(r.object.quaternion)) > u ? (r.dispatchEvent(i), Ee.copy(r.object.position), Fe.copy(r.object.quaternion), zt = !1, !0) : !1
            }
        })(), this.connect = le => {
            le === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), r.domElement = le, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", lt), r.domElement.addEventListener("pointerdown", Xe), r.domElement.addEventListener("pointercancel", ge), r.domElement.addEventListener("wheel", Ue)
        }, this.dispose = () => {
            var le, Ie, tt, oe, Ee, Fe;
            (le = r.domElement) == null || le.removeEventListener("contextmenu", lt), (Ie = r.domElement) == null || Ie.removeEventListener("pointerdown", Xe), (tt = r.domElement) == null || tt.removeEventListener("pointercancel", ge), (oe = r.domElement) == null || oe.removeEventListener("wheel", Ue), (Ee = r.domElement) == null || Ee.ownerDocument.removeEventListener("pointermove", K), (Fe = r.domElement) == null || Fe.ownerDocument.removeEventListener("pointerup", V), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", Ye)
        };
        const r = this,
            i = {
                type: "change"
            },
            s = {
                type: "start"
            },
            o = {
                type: "end"
            },
            a = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
        let l = a.NONE;
        const u = 1e-6,
            c = new R3,
            f = new R3;
        let d = 1;
        const p = new J,
            m = new ke,
            y = new ke,
            v = new ke,
            b = new ke,
            _ = new ke,
            x = new ke,
            S = new ke,
            E = new ke,
            A = new ke,
            T = new J,
            M = new ke;
        let I = !1;
        const O = [],
            k = {};

        function H() {
            return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed
        }

        function N() {
            return Math.pow(.95, r.zoomSpeed)
        }

        function B(le) {
            r.reverseOrbit || r.reverseHorizontalOrbit ? f.theta += le : f.theta -= le
        }

        function U(le) {
            r.reverseOrbit || r.reverseVerticalOrbit ? f.phi += le : f.phi -= le
        }
        const q = (() => {
                const le = new J;
                return function(tt, oe) {
                    le.setFromMatrixColumn(oe, 0), le.multiplyScalar(-tt), p.add(le)
                }
            })(),
            Q = (() => {
                const le = new J;
                return function(tt, oe) {
                    r.screenSpacePanning === !0 ? le.setFromMatrixColumn(oe, 1) : (le.setFromMatrixColumn(oe, 0), le.crossVectors(r.object.up, le)), le.multiplyScalar(tt), p.add(le)
                }
            })(),
            F = (() => {
                const le = new J;
                return function(tt, oe) {
                    const Ee = r.domElement;
                    if (Ee && r.object instanceof dr && r.object.isPerspectiveCamera) {
                        const Fe = r.object.position;
                        le.copy(Fe).sub(r.target);
                        let Ve = le.length();
                        Ve *= Math.tan(r.object.fov / 2 * Math.PI / 180), q(2 * tt * Ve / Ee.clientHeight, r.object.matrix), Q(2 * oe * Ve / Ee.clientHeight, r.object.matrix)
                    } else Ee && r.object instanceof Ko && r.object.isOrthographicCamera ? (q(tt * (r.object.right - r.object.left) / r.object.zoom / Ee.clientWidth, r.object.matrix), Q(oe * (r.object.top - r.object.bottom) / r.object.zoom / Ee.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1)
                }
            })();

        function G(le) {
            r.object instanceof dr && r.object.isPerspectiveCamera || r.object instanceof Ko && r.object.isOrthographicCamera ? d /= le : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1)
        }

        function W(le) {
            r.object instanceof dr && r.object.isPerspectiveCamera || r.object instanceof Ko && r.object.isOrthographicCamera ? d *= le : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1)
        }

        function se(le) {
            if (!r.zoomToCursor || !r.domElement) return;
            I = !0;
            const Ie = r.domElement.getBoundingClientRect(),
                tt = le.clientX - Ie.left,
                oe = le.clientY - Ie.top,
                Ee = Ie.width,
                Fe = Ie.height;
            M.x = tt / Ee * 2 - 1, M.y = -(oe / Fe) * 2 + 1, T.set(M.x, M.y, 1).unproject(r.object).sub(r.object.position).normalize()
        }

        function ee(le) {
            return Math.max(r.minDistance, Math.min(r.maxDistance, le))
        }

        function ae(le) {
            m.set(le.clientX, le.clientY)
        }

        function de(le) {
            se(le), S.set(le.clientX, le.clientY)
        }

        function re(le) {
            b.set(le.clientX, le.clientY)
        }

        function _e(le) {
            y.set(le.clientX, le.clientY), v.subVectors(y, m).multiplyScalar(r.rotateSpeed);
            const Ie = r.domElement;
            Ie && (B(2 * Math.PI * v.x / Ie.clientHeight), U(2 * Math.PI * v.y / Ie.clientHeight)), m.copy(y), r.update()
        }

        function fe(le) {
            E.set(le.clientX, le.clientY), A.subVectors(E, S), A.y > 0 ? G(N()) : A.y < 0 && W(N()), S.copy(E), r.update()
        }

        function ue(le) {
            _.set(le.clientX, le.clientY), x.subVectors(_, b).multiplyScalar(r.panSpeed), F(x.x, x.y), b.copy(_), r.update()
        }

        function ve(le) {
            se(le), le.deltaY < 0 ? W(N()) : le.deltaY > 0 && G(N()), r.update()
        }

        function xe(le) {
            let Ie = !1;
            switch (le.code) {
                case r.keys.UP:
                    F(0, r.keyPanSpeed), Ie = !0;
                    break;
                case r.keys.BOTTOM:
                    F(0, -r.keyPanSpeed), Ie = !0;
                    break;
                case r.keys.LEFT:
                    F(r.keyPanSpeed, 0), Ie = !0;
                    break;
                case r.keys.RIGHT:
                    F(-r.keyPanSpeed, 0), Ie = !0;
                    break
            }
            Ie && (le.preventDefault(), r.update())
        }

        function be() {
            if (O.length == 1) m.set(O[0].pageX, O[0].pageY);
            else {
                const le = .5 * (O[0].pageX + O[1].pageX),
                    Ie = .5 * (O[0].pageY + O[1].pageY);
                m.set(le, Ie)
            }
        }

        function he() {
            if (O.length == 1) b.set(O[0].pageX, O[0].pageY);
            else {
                const le = .5 * (O[0].pageX + O[1].pageX),
                    Ie = .5 * (O[0].pageY + O[1].pageY);
                b.set(le, Ie)
            }
        }

        function me() {
            const le = O[0].pageX - O[1].pageX,
                Ie = O[0].pageY - O[1].pageY,
                tt = Math.sqrt(le * le + Ie * Ie);
            S.set(0, tt)
        }

        function Ce() {
            r.enableZoom && me(), r.enablePan && he()
        }

        function Ne() {
            r.enableZoom && me(), r.enableRotate && be()
        }

        function De(le) {
            if (O.length == 1) y.set(le.pageX, le.pageY);
            else {
                const tt = pt(le),
                    oe = .5 * (le.pageX + tt.x),
                    Ee = .5 * (le.pageY + tt.y);
                y.set(oe, Ee)
            }
            v.subVectors(y, m).multiplyScalar(r.rotateSpeed);
            const Ie = r.domElement;
            Ie && (B(2 * Math.PI * v.x / Ie.clientHeight), U(2 * Math.PI * v.y / Ie.clientHeight)), m.copy(y)
        }

        function je(le) {
            if (O.length == 1) _.set(le.pageX, le.pageY);
            else {
                const Ie = pt(le),
                    tt = .5 * (le.pageX + Ie.x),
                    oe = .5 * (le.pageY + Ie.y);
                _.set(tt, oe)
            }
            x.subVectors(_, b).multiplyScalar(r.panSpeed), F(x.x, x.y), b.copy(_)
        }

        function Ke(le) {
            const Ie = pt(le),
                tt = le.pageX - Ie.x,
                oe = le.pageY - Ie.y,
                Ee = Math.sqrt(tt * tt + oe * oe);
            E.set(0, Ee), A.set(0, Math.pow(E.y / S.y, r.zoomSpeed)), G(A.y), S.copy(E)
        }

        function He(le) {
            r.enableZoom && Ke(le), r.enablePan && je(le)
        }

        function qe(le) {
            r.enableZoom && Ke(le), r.enableRotate && De(le)
        }

        function Xe(le) {
            var Ie, tt;
            r.enabled !== !1 && (O.length === 0 && ((Ie = r.domElement) == null || Ie.ownerDocument.addEventListener("pointermove", K), (tt = r.domElement) == null || tt.ownerDocument.addEventListener("pointerup", V)), nt(le), le.pointerType === "touch" ? Te(le) : Be(le))
        }

        function K(le) {
            r.enabled !== !1 && (le.pointerType === "touch" ? we(le) : ze(le))
        }

        function V(le) {
            var Ie, tt, oe;
            vt(le), O.length === 0 && ((Ie = r.domElement) == null || Ie.releasePointerCapture(le.pointerId), (tt = r.domElement) == null || tt.ownerDocument.removeEventListener("pointermove", K), (oe = r.domElement) == null || oe.ownerDocument.removeEventListener("pointerup", V)), r.dispatchEvent(o), l = a.NONE
        }

        function ge(le) {
            vt(le)
        }

        function Be(le) {
            let Ie;
            switch (le.button) {
                case 0:
                    Ie = r.mouseButtons.LEFT;
                    break;
                case 1:
                    Ie = r.mouseButtons.MIDDLE;
                    break;
                case 2:
                    Ie = r.mouseButtons.RIGHT;
                    break;
                default:
                    Ie = -1
            }
            switch (Ie) {
                case td.DOLLY:
                    if (r.enableZoom === !1) return;
                    de(le), l = a.DOLLY;
                    break;
                case td.ROTATE:
                    if (le.ctrlKey || le.metaKey || le.shiftKey) {
                        if (r.enablePan === !1) return;
                        re(le), l = a.PAN
                    } else {
                        if (r.enableRotate === !1) return;
                        ae(le), l = a.ROTATE
                    }
                    break;
                case td.PAN:
                    if (le.ctrlKey || le.metaKey || le.shiftKey) {
                        if (r.enableRotate === !1) return;
                        ae(le), l = a.ROTATE
                    } else {
                        if (r.enablePan === !1) return;
                        re(le), l = a.PAN
                    }
                    break;
                default:
                    l = a.NONE
            }
            l !== a.NONE && r.dispatchEvent(s)
        }

        function ze(le) {
            if (r.enabled !== !1) switch (l) {
                case a.ROTATE:
                    if (r.enableRotate === !1) return;
                    _e(le);
                    break;
                case a.DOLLY:
                    if (r.enableZoom === !1) return;
                    fe(le);
                    break;
                case a.PAN:
                    if (r.enablePan === !1) return;
                    ue(le);
                    break
            }
        }

        function Ue(le) {
            r.enabled === !1 || r.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (le.preventDefault(), r.dispatchEvent(s), ve(le), r.dispatchEvent(o))
        }

        function Ye(le) {
            r.enabled === !1 || r.enablePan === !1 || xe(le)
        }

        function Te(le) {
            switch (ht(le), O.length) {
                case 1:
                    switch (r.touches.ONE) {
                        case nd.ROTATE:
                            if (r.enableRotate === !1) return;
                            be(), l = a.TOUCH_ROTATE;
                            break;
                        case nd.PAN:
                            if (r.enablePan === !1) return;
                            he(), l = a.TOUCH_PAN;
                            break;
                        default:
                            l = a.NONE
                    }
                    break;
                case 2:
                    switch (r.touches.TWO) {
                        case nd.DOLLY_PAN:
                            if (r.enableZoom === !1 && r.enablePan === !1) return;
                            Ce(), l = a.TOUCH_DOLLY_PAN;
                            break;
                        case nd.DOLLY_ROTATE:
                            if (r.enableZoom === !1 && r.enableRotate === !1) return;
                            Ne(), l = a.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            l = a.NONE
                    }
                    break;
                default:
                    l = a.NONE
            }
            l !== a.NONE && r.dispatchEvent(s)
        }

        function we(le) {
            switch (ht(le), l) {
                case a.TOUCH_ROTATE:
                    if (r.enableRotate === !1) return;
                    De(le), r.update();
                    break;
                case a.TOUCH_PAN:
                    if (r.enablePan === !1) return;
                    je(le), r.update();
                    break;
                case a.TOUCH_DOLLY_PAN:
                    if (r.enableZoom === !1 && r.enablePan === !1) return;
                    He(le), r.update();
                    break;
                case a.TOUCH_DOLLY_ROTATE:
                    if (r.enableZoom === !1 && r.enableRotate === !1) return;
                    qe(le), r.update();
                    break;
                default:
                    l = a.NONE
            }
        }

        function lt(le) {
            r.enabled !== !1 && le.preventDefault()
        }

        function nt(le) {
            O.push(le)
        }

        function vt(le) {
            delete k[le.pointerId];
            for (let Ie = 0; Ie < O.length; Ie++)
                if (O[Ie].pointerId == le.pointerId) {
                    O.splice(Ie, 1);
                    return
                }
        }

        function ht(le) {
            let Ie = k[le.pointerId];
            Ie === void 0 && (Ie = new ke, k[le.pointerId] = Ie), Ie.set(le.pageX, le.pageY)
        }

        function pt(le) {
            const Ie = le.pointerId === O[0].pointerId ? O[1] : O[0];
            return k[Ie.pointerId]
        }
        n !== void 0 && this.connect(n), this.update()
    }
};
class SB extends As {
    constructor(e) {
        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(n) {
            return new m8e(n)
        }), this.register(function(n) {
            return new w8e(n)
        }), this.register(function(n) {
            return new E8e(n)
        }), this.register(function(n) {
            return new A8e(n)
        }), this.register(function(n) {
            return new y8e(n)
        }), this.register(function(n) {
            return new v8e(n)
        }), this.register(function(n) {
            return new b8e(n)
        }), this.register(function(n) {
            return new x8e(n)
        }), this.register(function(n) {
            return new h8e(n)
        }), this.register(function(n) {
            return new _8e(n)
        }), this.register(function(n) {
            return new g8e(n)
        }), this.register(function(n) {
            return new S8e(n)
        }), this.register(function(n) {
            return new d8e(n)
        }), this.register(function(n) {
            return new C8e(n)
        }), this.register(function(n) {
            return new M8e(n)
        })
    }
    load(e, n, r, i) {
        const s = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = Tl.extractUrlBase(e), this.manager.itemStart(e);
        const a = function(u) {
                i ? i(u) : console.error(u), s.manager.itemError(e), s.manager.itemEnd(e)
            },
            l = new ho(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(u) {
            try {
                s.parse(u, o, function(c) {
                    n(c), s.manager.itemEnd(e)
                }, a)
            } catch (c) {
                a(c)
            }
        }, r, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e, this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e, this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e, this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    parse(e, n, r, i) {
        let s;
        const o = {},
            a = {};
        if (typeof e == "string") s = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (Tl.decodeText(new Uint8Array(e.slice(0, 4))) === $Z) {
                try {
                    o[An.KHR_BINARY_GLTF] = new T8e(e)
                } catch (c) {
                    i && i(c);
                    return
                }
                s = JSON.parse(o[An.KHR_BINARY_GLTF].content)
            } else s = JSON.parse(Tl.decodeText(new Uint8Array(e)));
        else s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const l = new U8e(s, {
            path: n || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const c = this.pluginCallbacks[u](l);
            a[c.name] = c, o[c.name] = !0
        }
        if (s.extensionsUsed)
            for (let u = 0; u < s.extensionsUsed.length; ++u) {
                const c = s.extensionsUsed[u],
                    f = s.extensionsRequired || [];
                switch (c) {
                    case An.KHR_MATERIALS_UNLIT:
                        o[c] = new p8e;
                        break;
                    case An.KHR_DRACO_MESH_COMPRESSION:
                        o[c] = new P8e(s, this.dracoLoader);
                        break;
                    case An.KHR_TEXTURE_TRANSFORM:
                        o[c] = new I8e;
                        break;
                    case An.KHR_MESH_QUANTIZATION:
                        o[c] = new R8e;
                        break;
                    default:
                        f.indexOf(c) >= 0 && a[c] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + c + '".')
                }
            }
        l.setExtensions(o), l.setPlugins(a), l.parse(r, i)
    }
    parseAsync(e, n) {
        const r = this;
        return new Promise(function(i, s) {
            r.parse(e, n, i, s)
        })
    }
}

function f8e() {
    let t = {};
    return {
        get: function(e) {
            return t[e]
        },
        add: function(e, n) {
            t[e] = n
        },
        remove: function(e) {
            delete t[e]
        },
        removeAll: function() {
            t = {}
        }
    }
}
const An = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class d8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser,
            n = this.parser.json.nodes || [];
        for (let r = 0, i = n.length; r < i; r++) {
            const s = n[r];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const n = this.parser,
            r = "light:" + e;
        let i = n.cache.get(r);
        if (i) return i;
        const s = n.json,
            l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let u;
        const c = new dt(16777215);
        l.color !== void 0 && c.fromArray(l.color);
        const f = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
            case "directional":
                u = new GL(c), u.target.position.set(0, 0, -1), u.add(u.target);
                break;
            case "point":
                u = new $L(c), u.distance = f;
                break;
            case "spot":
                u = new UL(c), u.distance = f, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, u.angle = l.spot.outerConeAngle, u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, u.target.position.set(0, 0, -1), u.add(u.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return u.position.set(0, 0, 0), u.decay = 2, Ec(u, l), l.intensity !== void 0 && (u.intensity = l.intensity), u.name = n.createUniqueName(l.name || "light_" + e), i = Promise.resolve(u), n.cache.add(r, i), i
    }
    getDependency(e, n) {
        if (e === "light") return this._loadLight(n)
    }
    createNodeAttachment(e) {
        const n = this,
            r = this.parser,
            s = r.json.nodes[e],
            a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return r._getNodeRef(n.cache, a, l)
        })
    }
}
class p8e {
    constructor() {
        this.name = An.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return oo
    }
    extendParams(e, n, r) {
        const i = [];
        e.color = new dt(1, 1, 1), e.opacity = 1;
        const s = n.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.fromArray(o), e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", s.baseColorTexture, 3001))
        }
        return Promise.all(i)
    }
}
class h8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, n) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (n.emissiveIntensity = s), Promise.resolve()
    }
}
class m8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (n.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(r.assignTexture(n, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (n.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(n, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(n, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            n.clearcoatNormalScale = new ke(a, a)
        }
        return Promise.all(s)
    }
}
class g8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (n.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(r.assignTexture(n, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (n.iridescenceIOR = o.iridescenceIor), n.iridescenceThicknessRange === void 0 && (n.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (n.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (n.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(n, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s)
    }
}
class y8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [];
        n.sheenColor = new dt(0, 0, 0), n.sheenRoughness = 0, n.sheen = 1;
        const o = i.extensions[this.name];
        return o.sheenColorFactor !== void 0 && n.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (n.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(r.assignTexture(n, "sheenColorMap", o.sheenColorTexture, 3001)), o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(n, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
    }
}
class v8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (n.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(r.assignTexture(n, "transmissionMap", o.transmissionTexture)), Promise.all(s)
    }
}
class b8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        n.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(r.assignTexture(n, "thicknessMap", o.thicknessTexture)), n.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return n.attenuationColor = new dt(a[0], a[1], a[2]), Promise.all(s)
    }
}
class x8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = i.extensions[this.name];
        return n.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
    }
}
class _8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        n.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(r.assignTexture(n, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return n.specularColor = new dt(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && s.push(r.assignTexture(n, "specularColorMap", o.specularColorTexture, 3001)), Promise.all(s)
    }
}
class S8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : Nl
    }
    extendMaterialParams(e, n) {
        const r = this.parser,
            i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (n.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (n.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(r.assignTexture(n, "anisotropyMap", o.anisotropyTexture)), Promise.all(s)
    }
}
class w8e {
    constructor(e) {
        this.parser = e, this.name = An.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const n = this.parser,
            r = n.json,
            i = r.textures[e];
        if (!i.extensions || !i.extensions[this.name]) return null;
        const s = i.extensions[this.name],
            o = n.options.ktx2Loader;
        if (!o) {
            if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return n.loadTextureImage(e, s.source, o)
    }
}
class E8e {
    constructor(e) {
        this.parser = e, this.name = An.EXT_TEXTURE_WEBP, this.isSupported = null
    }
    loadTexture(e) {
        const n = this.name,
            r = this.parser,
            i = r.json,
            s = i.textures[e];
        if (!s.extensions || !s.extensions[n]) return null;
        const o = s.extensions[n],
            a = i.images[o.source];
        let l = r.textureLoader;
        if (a.uri) {
            const u = r.options.manager.getHandler(a.uri);
            u !== null && (l = u)
        }
        return this.detectSupport().then(function(u) {
            if (u) return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(n) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return r.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const n = new Image;
            n.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", n.onload = n.onerror = function() {
                e(n.height === 1)
            }
        })), this.isSupported
    }
}
class A8e {
    constructor(e) {
        this.parser = e, this.name = An.EXT_TEXTURE_AVIF, this.isSupported = null
    }
    loadTexture(e) {
        const n = this.name,
            r = this.parser,
            i = r.json,
            s = i.textures[e];
        if (!s.extensions || !s.extensions[n]) return null;
        const o = s.extensions[n],
            a = i.images[o.source];
        let l = r.textureLoader;
        if (a.uri) {
            const u = r.options.manager.getHandler(a.uri);
            u !== null && (l = u)
        }
        return this.detectSupport().then(function(u) {
            if (u) return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(n) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return r.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const n = new Image;
            n.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", n.onload = n.onerror = function() {
                e(n.height === 1)
            }
        })), this.isSupported
    }
}
class C8e {
    constructor(e) {
        this.name = An.EXT_MESHOPT_COMPRESSION, this.parser = e
    }
    loadBufferView(e) {
        const n = this.parser.json,
            r = n.bufferViews[e];
        if (r.extensions && r.extensions[this.name]) {
            const i = r.extensions[this.name],
                s = this.parser.getDependency("buffer", i.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = i.byteOffset || 0,
                    u = i.byteLength || 0,
                    c = i.count,
                    f = i.byteStride,
                    d = new Uint8Array(a, l, u);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(c, f, d, i.mode, i.filter).then(function(p) {
                    return p.buffer
                }) : o.ready.then(function() {
                    const p = new ArrayBuffer(c * f);
                    return o.decodeGltfBuffer(new Uint8Array(p), c, f, d, i.mode, i.filter), p
                })
            })
        } else return null
    }
}
class M8e {
    constructor(e) {
        this.name = An.EXT_MESH_GPU_INSTANCING, this.parser = e
    }
    createNodeMesh(e) {
        const n = this.parser.json,
            r = n.nodes[e];
        if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0) return null;
        const i = n.meshes[r.mesh];
        for (const u of i.primitives)
            if (u.mode !== Ro.TRIANGLES && u.mode !== Ro.TRIANGLE_STRIP && u.mode !== Ro.TRIANGLE_FAN && u.mode !== void 0) return null;
        const o = r.extensions[this.name].attributes,
            a = [],
            l = {};
        for (const u in o) a.push(this.parser.getDependency("accessor", o[u]).then(c => (l[u] = c, l[u])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(u => {
            const c = u.pop(),
                f = c.isGroup ? c.children : [c],
                d = u[0].count,
                p = [];
            for (const m of f) {
                const y = new Gt,
                    v = new J,
                    b = new Ti,
                    _ = new J(1, 1, 1),
                    x = new EL(m.geometry, m.material, d);
                for (let S = 0; S < d; S++) l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, S), l.ROTATION && b.fromBufferAttribute(l.ROTATION, S), l.SCALE && _.fromBufferAttribute(l.SCALE, S), x.setMatrixAt(S, y.compose(v, b, _));
                for (const S in l) S !== "TRANSLATION" && S !== "ROTATION" && S !== "SCALE" && m.geometry.setAttribute(S, l[S]);
                Tn.prototype.copy.call(x, m), this.parser.assignFinalMaterial(x), p.push(x)
            }
            return c.isGroup ? (c.clear(), c.add(...p), c) : p[0]
        }))
    }
}
const $Z = "glTF",
    Hy = 12,
    $U = {
        JSON: 1313821514,
        BIN: 5130562
    };
class T8e {
    constructor(e) {
        this.name = An.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const n = new DataView(e, 0, Hy);
        if (this.header = {
                magic: Tl.decodeText(new Uint8Array(e.slice(0, 4))),
                version: n.getUint32(4, !0),
                length: n.getUint32(8, !0)
            }, this.header.magic !== $Z) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const r = this.header.length - Hy,
            i = new DataView(e, Hy);
        let s = 0;
        for (; s < r;) {
            const o = i.getUint32(s, !0);
            s += 4;
            const a = i.getUint32(s, !0);
            if (s += 4, a === $U.JSON) {
                const l = new Uint8Array(e, Hy + s, o);
                this.content = Tl.decodeText(l)
            } else if (a === $U.BIN) {
                const l = Hy + s;
                this.body = e.slice(l, l + o)
            }
            s += o
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class P8e {
    constructor(e, n) {
        if (!n) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = An.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = n, this.dracoLoader.preload()
    }
    decodePrimitive(e, n) {
        const r = this.json,
            i = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            u = {};
        for (const c in o) {
            const f = AO[c] || c.toLowerCase();
            a[f] = o[c]
        }
        for (const c in e.attributes) {
            const f = AO[c] || c.toLowerCase();
            if (o[c] !== void 0) {
                const d = r.accessors[e.attributes[c]],
                    p = _m[d.componentType];
                u[f] = p.name, l[f] = d.normalized === !0
            }
        }
        return n.getDependency("bufferView", s).then(function(c) {
            return new Promise(function(f) {
                i.decodeDracoFile(c, function(d) {
                    for (const p in d.attributes) {
                        const m = d.attributes[p],
                            y = l[p];
                        y !== void 0 && (m.normalized = y)
                    }
                    f(d)
                }, a, u)
            })
        })
    }
}
class I8e {
    constructor() {
        this.name = An.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, n) {
        return (n.texCoord === void 0 || n.texCoord === e.channel) && n.offset === void 0 && n.rotation === void 0 && n.scale === void 0 || (e = e.clone(), n.texCoord !== void 0 && (e.channel = n.texCoord), n.offset !== void 0 && e.offset.fromArray(n.offset), n.rotation !== void 0 && (e.rotation = n.rotation), n.scale !== void 0 && e.repeat.fromArray(n.scale), e.needsUpdate = !0), e
    }
}
class R8e {
    constructor() {
        this.name = An.KHR_MESH_QUANTIZATION
    }
}
class GZ extends wg {
    constructor(e, n, r, i) {
        super(e, n, r, i)
    }
    copySampleValue_(e) {
        const n = this.resultBuffer,
            r = this.sampleValues,
            i = this.valueSize,
            s = e * i * 3 + i;
        for (let o = 0; o !== i; o++) n[o] = r[s + o];
        return n
    }
    interpolate_(e, n, r, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = a * 2,
            u = a * 3,
            c = i - n,
            f = (r - n) / c,
            d = f * f,
            p = d * f,
            m = e * u,
            y = m - u,
            v = -2 * p + 3 * d,
            b = p - d,
            _ = 1 - v,
            x = b - d + f;
        for (let S = 0; S !== a; S++) {
            const E = o[y + S + a],
                A = o[y + S + l] * c,
                T = o[m + S + a],
                M = o[m + S] * c;
            s[S] = _ * E + x * A + v * T + b * M
        }
        return s
    }
}
const O8e = new Ti;
class D8e extends GZ {
    interpolate_(e, n, r, i) {
        const s = super.interpolate_(e, n, r, i);
        return O8e.fromArray(s).normalize().toArray(s), s
    }
}
const Ro = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    },
    _m = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    GU = {
        9728: Br,
        9729: fr,
        9984: a0,
        9985: LE,
        9986: um,
        9987: Dl
    },
    VU = {
        33071: zi,
        33648: Lm,
        10497: cf
    },
    EP = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    AO = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        ...o8e >= 152 ? {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3"
        } : {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2"
        },
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    vc = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    L8e = {
        CUBICSPLINE: void 0,
        LINEAR: ep,
        STEP: km
    },
    AP = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };

function k8e(t) {
    return t.DefaultMaterial === void 0 && (t.DefaultMaterial = new M1({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Ol
    })), t.DefaultMaterial
}

function Jf(t, e, n) {
    for (const r in n.extensions) t[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r])
}

function Ec(t, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}

function B8e(t, e, n) {
    let r = !1,
        i = !1,
        s = !1;
    for (let u = 0, c = e.length; u < c; u++) {
        const f = e[u];
        if (f.POSITION !== void 0 && (r = !0), f.NORMAL !== void 0 && (i = !0), f.COLOR_0 !== void 0 && (s = !0), r && i && s) break
    }
    if (!r && !i && !s) return Promise.resolve(t);
    const o = [],
        a = [],
        l = [];
    for (let u = 0, c = e.length; u < c; u++) {
        const f = e[u];
        if (r) {
            const d = f.POSITION !== void 0 ? n.getDependency("accessor", f.POSITION) : t.attributes.position;
            o.push(d)
        }
        if (i) {
            const d = f.NORMAL !== void 0 ? n.getDependency("accessor", f.NORMAL) : t.attributes.normal;
            a.push(d)
        }
        if (s) {
            const d = f.COLOR_0 !== void 0 ? n.getDependency("accessor", f.COLOR_0) : t.attributes.color;
            l.push(d)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(u) {
        const c = u[0],
            f = u[1],
            d = u[2];
        return r && (t.morphAttributes.position = c), i && (t.morphAttributes.normal = f), s && (t.morphAttributes.color = d), t.morphTargetsRelative = !0, t
    })
}

function F8e(t, e) {
    if (t.updateMorphTargets(), e.weights !== void 0)
        for (let n = 0, r = e.weights.length; n < r; n++) t.morphTargetInfluences[n] = e.weights[n];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const n = e.extras.targetNames;
        if (t.morphTargetInfluences.length === n.length) {
            t.morphTargetDictionary = {};
            for (let r = 0, i = n.length; r < i; r++) t.morphTargetDictionary[n[r]] = r
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function N8e(t) {
    let e;
    const n = t.extensions && t.extensions[An.KHR_DRACO_MESH_COMPRESSION];
    if (n ? e = "draco:" + n.bufferView + ":" + n.indices + ":" + CP(n.attributes) : e = t.indices + ":" + CP(t.attributes) + ":" + t.mode, t.targets !== void 0)
        for (let r = 0, i = t.targets.length; r < i; r++) e += ":" + CP(t.targets[r]);
    return e
}

function CP(t) {
    let e = "";
    const n = Object.keys(t).sort();
    for (let r = 0, i = n.length; r < i; r++) e += n[r] + ":" + t[n[r]] + ";";
    return e
}

function CO(t) {
    switch (t) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function z8e(t) {
    return t.search(/\.jpe?g($|\?)/i) > 0 || t.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || t.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const H8e = new Gt;
class U8e {
    constructor(e = {}, n = {}) {
        this.json = e, this.extensions = {}, this.plugins = {}, this.options = n, this.cache = new f8e, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let r = !1,
            i = !1,
            s = -1;
        typeof navigator < "u" && typeof navigator.userAgent < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || i && s < 98 ? this.textureLoader = new jW(this.options.manager) : this.textureLoader = new YW(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ho(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, n) {
        const r = this,
            i = this.json,
            s = this.extensions;
        this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }), Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: r,
                userData: {}
            };
            Jf(s, a, i), Ec(a, i), Promise.all(r._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(n)
    }
    _markDefs() {
        const e = this.json.nodes || [],
            n = this.json.skins || [],
            r = this.json.meshes || [];
        for (let i = 0, s = n.length; i < s; i++) {
            const o = n[i].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
        }
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, n) {
        n !== void 0 && (e.refs[n] === void 0 && (e.refs[n] = e.uses[n] = 0), e.refs[n]++)
    }
    _getNodeRef(e, n, r) {
        if (e.refs[n] <= 1) return r;
        const i = r.clone(),
            s = (o, a) => {
                const l = this.associations.get(o);
                l != null && this.associations.set(a, l);
                for (const [u, c] of o.children.entries()) s(c, a.children[u])
            };
        return s(r, i), i.name += "_instance_" + e.uses[n]++, i
    }
    _invokeOne(e) {
        const n = Object.values(this.plugins);
        n.push(this);
        for (let r = 0; r < n.length; r++) {
            const i = e(n[r]);
            if (i) return i
        }
        return null
    }
    _invokeAll(e) {
        const n = Object.values(this.plugins);
        n.unshift(this);
        const r = [];
        for (let i = 0; i < n.length; i++) {
            const s = e(n[i]);
            s && r.push(s)
        }
        return r
    }
    getDependency(e, n) {
        const r = e + ":" + n;
        let i = this.cache.get(r);
        if (!i) {
            switch (e) {
                case "scene":
                    i = this.loadScene(n);
                    break;
                case "node":
                    i = this._invokeOne(function(s) {
                        return s.loadNode && s.loadNode(n)
                    });
                    break;
                case "mesh":
                    i = this._invokeOne(function(s) {
                        return s.loadMesh && s.loadMesh(n)
                    });
                    break;
                case "accessor":
                    i = this.loadAccessor(n);
                    break;
                case "bufferView":
                    i = this._invokeOne(function(s) {
                        return s.loadBufferView && s.loadBufferView(n)
                    });
                    break;
                case "buffer":
                    i = this.loadBuffer(n);
                    break;
                case "material":
                    i = this._invokeOne(function(s) {
                        return s.loadMaterial && s.loadMaterial(n)
                    });
                    break;
                case "texture":
                    i = this._invokeOne(function(s) {
                        return s.loadTexture && s.loadTexture(n)
                    });
                    break;
                case "skin":
                    i = this.loadSkin(n);
                    break;
                case "animation":
                    i = this._invokeOne(function(s) {
                        return s.loadAnimation && s.loadAnimation(n)
                    });
                    break;
                case "camera":
                    i = this.loadCamera(n);
                    break;
                default:
                    if (i = this._invokeOne(function(s) {
                            return s != this && s.getDependency && s.getDependency(e, n)
                        }), !i) throw new Error("Unknown type: " + e);
                    break
            }
            this.cache.add(r, i)
        }
        return i
    }
    getDependencies(e) {
        let n = this.cache.get(e);
        if (!n) {
            const r = this,
                i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            n = Promise.all(i.map(function(s, o) {
                return r.getDependency(e, o)
            })), this.cache.add(e, n)
        }
        return n
    }
    loadBuffer(e) {
        const n = this.json.buffers[e],
            r = this.fileLoader;
        if (n.type && n.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + n.type + " buffer type is not supported.");
        if (n.uri === void 0 && e === 0) return Promise.resolve(this.extensions[An.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            r.load(Tl.resolveURL(n.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + n.uri + '".'))
            })
        })
    }
    loadBufferView(e) {
        const n = this.json.bufferViews[e];
        return this.getDependency("buffer", n.buffer).then(function(r) {
            const i = n.byteLength || 0,
                s = n.byteOffset || 0;
            return r.slice(s, s + i)
        })
    }
    loadAccessor(e) {
        const n = this,
            r = this.json,
            i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = EP[i.type],
                a = _m[i.componentType],
                l = i.normalized === !0,
                u = new a(i.count * o);
            return Promise.resolve(new Ln(u, o, l))
        }
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(o) {
            const a = o[0],
                l = EP[i.type],
                u = _m[i.componentType],
                c = u.BYTES_PER_ELEMENT,
                f = c * l,
                d = i.byteOffset || 0,
                p = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0,
                m = i.normalized === !0;
            let y, v;
            if (p && p !== f) {
                const b = Math.floor(d / p),
                    _ = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + b + ":" + i.count;
                let x = n.cache.get(_);
                x || (y = new u(a, b * p, i.count * p / c), x = new p1(y, p / c), n.cache.add(_, x)), v = new Hs(x, l, d % p / c, m)
            } else a === null ? y = new u(i.count * l) : y = new u(a, d, i.count * l), v = new Ln(y, l, m);
            if (i.sparse !== void 0) {
                const b = EP.SCALAR,
                    _ = _m[i.sparse.indices.componentType],
                    x = i.sparse.indices.byteOffset || 0,
                    S = i.sparse.values.byteOffset || 0,
                    E = new _(o[1], x, i.sparse.count * b),
                    A = new u(o[2], S, i.sparse.count * l);
                a !== null && (v = new Ln(v.array.slice(), v.itemSize, v.normalized));
                for (let T = 0, M = E.length; T < M; T++) {
                    const I = E[T];
                    if (v.setX(I, A[T * l]), l >= 2 && v.setY(I, A[T * l + 1]), l >= 3 && v.setZ(I, A[T * l + 2]), l >= 4 && v.setW(I, A[T * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return v
        })
    }
    loadTexture(e) {
        const n = this.json,
            r = this.options,
            s = n.textures[e].source,
            o = n.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = r.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, n, r) {
        const i = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[n],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const u = this.loadImageSource(n, r).then(function(c) {
            c.flipY = !1, c.name = o.name || a.name || "", c.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (c.name = a.uri);
            const d = (s.samplers || {})[o.sampler] || {};
            return c.magFilter = GU[d.magFilter] || fr, c.minFilter = GU[d.minFilter] || Dl, c.wrapS = VU[d.wrapS] || cf, c.wrapT = VU[d.wrapT] || cf, i.associations.set(c, {
                textures: e
            }), c
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = u, u
    }
    loadImageSource(e, n) {
        const r = this,
            i = this.json,
            s = this.options;
        if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(f => f.clone());
        const o = i.images[e],
            a = self.URL || self.webkitURL;
        let l = o.uri || "",
            u = !1;
        if (o.bufferView !== void 0) l = r.getDependency("bufferView", o.bufferView).then(function(f) {
            u = !0;
            const d = new Blob([f], {
                type: o.mimeType
            });
            return l = a.createObjectURL(d), l
        });
        else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const c = Promise.resolve(l).then(function(f) {
            return new Promise(function(d, p) {
                let m = d;
                n.isImageBitmapLoader === !0 && (m = function(y) {
                    const v = new Sr(y);
                    v.needsUpdate = !0, d(v)
                }), n.load(Tl.resolveURL(f, s.path), m, void 0, p)
            })
        }).then(function(f) {
            return u === !0 && a.revokeObjectURL(l), f.userData.mimeType = o.mimeType || z8e(o.uri), f
        }).catch(function(f) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), f
        });
        return this.sourceCache[e] = c, c
    }
    assignTexture(e, n, r, i) {
        const s = this;
        return this.getDependency("texture", r.index).then(function(o) {
            if (!o) return null;
            if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(), o.channel = r.texCoord), s.extensions[An.KHR_TEXTURE_TRANSFORM]) {
                const a = r.extensions !== void 0 ? r.extensions[An.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[An.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l)
                }
            }
            return i !== void 0 && ("colorSpace" in o ? o.colorSpace = i === 3001 ? "srgb" : "srgb-linear" : o.encoding = i), e[n] = o, o
        })
    }
    assignFinalMaterial(e) {
        const n = e.geometry;
        let r = e.material;
        const i = n.attributes.tangent === void 0,
            s = n.attributes.color !== void 0,
            o = n.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new GE, li.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, l.sizeAttenuation = !1, this.cache.add(a, l)), r = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new us, li.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, this.cache.add(a, l)), r = l
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + r.uuid + ":";
            i && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = r.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(r))), r = l
        }
        e.material = r
    }
    getMaterialType() {
        return M1
    }
    loadMaterial(e) {
        const n = this,
            r = this.json,
            i = this.extensions,
            s = r.materials[e];
        let o;
        const a = {},
            l = s.extensions || {},
            u = [];
        if (l[An.KHR_MATERIALS_UNLIT]) {
            const f = i[An.KHR_MATERIALS_UNLIT];
            o = f.getMaterialType(), u.push(f.extendParams(a, s, n))
        } else {
            const f = s.pbrMetallicRoughness || {};
            if (a.color = new dt(1, 1, 1), a.opacity = 1, Array.isArray(f.baseColorFactor)) {
                const d = f.baseColorFactor;
                a.color.fromArray(d), a.opacity = d[3]
            }
            f.baseColorTexture !== void 0 && u.push(n.assignTexture(a, "map", f.baseColorTexture, 3001)), a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && (u.push(n.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)), u.push(n.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
                return d.getMaterialType && d.getMaterialType(e)
            }), u.push(Promise.all(this._invokeAll(function(d) {
                return d.extendMaterialParams && d.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = Ra);
        const c = s.alphaMode || AP.OPAQUE;
        if (c === AP.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, c === AP.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== oo && (u.push(n.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new ke(1, 1), s.normalTexture.scale !== void 0)) {
            const f = s.normalTexture.scale;
            a.normalScale.set(f, f)
        }
        return s.occlusionTexture !== void 0 && o !== oo && (u.push(n.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== oo && (a.emissive = new dt().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== oo && u.push(n.assignTexture(a, "emissiveMap", s.emissiveTexture, 3001)), Promise.all(u).then(function() {
            const f = new o(a);
            return s.name && (f.name = s.name), Ec(f, s), n.associations.set(f, {
                materials: e
            }), s.extensions && Jf(i, f, s), f
        })
    }
    createUniqueName(e) {
        const n = Mn.sanitizeNodeName(e || "");
        return n in this.nodeNamesUsed ? n + "_" + ++this.nodeNamesUsed[n] : (this.nodeNamesUsed[n] = 0, n)
    }
    loadGeometries(e) {
        const n = this,
            r = this.extensions,
            i = this.primitiveCache;

        function s(a) {
            return r[An.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, n).then(function(l) {
                return jU(l, a, n)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const u = e[a],
                c = N8e(u),
                f = i[c];
            if (f) o.push(f.promise);
            else {
                let d;
                u.extensions && u.extensions[An.KHR_DRACO_MESH_COMPRESSION] ? d = s(u) : d = jU(new on, u, n), i[c] = {
                    primitive: u,
                    promise: d
                }, o.push(d)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const n = this,
            r = this.json,
            i = this.extensions,
            s = r.meshes[e],
            o = s.primitives,
            a = [];
        for (let l = 0, u = o.length; l < u; l++) {
            const c = o[l].material === void 0 ? k8e(this.cache) : this.getDependency("material", o[l].material);
            a.push(c)
        }
        return a.push(n.loadGeometries(o)), Promise.all(a).then(function(l) {
            const u = l.slice(0, l.length - 1),
                c = l[l.length - 1],
                f = [];
            for (let p = 0, m = c.length; p < m; p++) {
                const y = c[p],
                    v = o[p];
                let b;
                const _ = u[p];
                if (v.mode === Ro.TRIANGLES || v.mode === Ro.TRIANGLE_STRIP || v.mode === Ro.TRIANGLE_FAN || v.mode === void 0) b = s.isSkinnedMesh === !0 ? new wL(y, _) : new mi(y, _), b.isSkinnedMesh === !0 && b.normalizeSkinWeights(), v.mode === Ro.TRIANGLE_STRIP ? b.geometry = zU(b.geometry, cL) : v.mode === Ro.TRIANGLE_FAN && (b.geometry = zU(b.geometry, Dw));
                else if (v.mode === Ro.LINES) b = new Ja(y, _);
                else if (v.mode === Ro.LINE_STRIP) b = new ku(y, _);
                else if (v.mode === Ro.LINE_LOOP) b = new AL(y, _);
                else if (v.mode === Ro.POINTS) b = new CL(y, _);
                else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
                Object.keys(b.geometry.morphAttributes).length > 0 && F8e(b, s), b.name = n.createUniqueName(s.name || "mesh_" + e), Ec(b, s), v.extensions && Jf(i, b, v), n.assignFinalMaterial(b), f.push(b)
            }
            for (let p = 0, m = f.length; p < m; p++) n.associations.set(f[p], {
                meshes: e,
                primitives: p
            });
            if (f.length === 1) return s.extensions && Jf(i, f[0], s), f[0];
            const d = new Su;
            s.extensions && Jf(i, d, s), n.associations.set(d, {
                meshes: e
            });
            for (let p = 0, m = f.length; p < m; p++) d.add(f[p]);
            return d
        })
    }
    loadCamera(e) {
        let n;
        const r = this.json.cameras[e],
            i = r[r.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return r.type === "perspective" ? n = new dr(bd.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : r.type === "orthographic" && (n = new Ko(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), r.name && (n.name = this.createUniqueName(r.name)), Ec(n, r), Promise.resolve(n)
    }
    loadSkin(e) {
        const n = this.json.skins[e],
            r = [];
        for (let i = 0, s = n.joints.length; i < s; i++) r.push(this._loadNodeShallow(n.joints[i]));
        return n.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", n.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(i) {
            const s = i.pop(),
                o = i,
                a = [],
                l = [];
            for (let u = 0, c = o.length; u < c; u++) {
                const f = o[u];
                if (f) {
                    a.push(f);
                    const d = new Gt;
                    s !== null && d.fromArray(s.array, u * 16), l.push(d)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', n.joints[u])
            }
            return new h1(a, l)
        })
    }
    loadAnimation(e) {
        const r = this.json.animations[e],
            i = r.name ? r.name : "animation_" + e,
            s = [],
            o = [],
            a = [],
            l = [],
            u = [];
        for (let c = 0, f = r.channels.length; c < f; c++) {
            const d = r.channels[c],
                p = r.samplers[d.sampler],
                m = d.target,
                y = m.node,
                v = r.parameters !== void 0 ? r.parameters[p.input] : p.input,
                b = r.parameters !== void 0 ? r.parameters[p.output] : p.output;
            m.node !== void 0 && (s.push(this.getDependency("node", y)), o.push(this.getDependency("accessor", v)), a.push(this.getDependency("accessor", b)), l.push(p), u.push(m))
        }
        return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(u)]).then(function(c) {
            const f = c[0],
                d = c[1],
                p = c[2],
                m = c[3],
                y = c[4],
                v = [];
            for (let b = 0, _ = f.length; b < _; b++) {
                const x = f[b],
                    S = d[b],
                    E = p[b],
                    A = m[b],
                    T = y[b];
                if (x === void 0) continue;
                x.updateMatrix();
                let M;
                switch (vc[T.path]) {
                    case vc.weights:
                        M = zm;
                        break;
                    case vc.rotation:
                        M = ff;
                        break;
                    case vc.position:
                    case vc.scale:
                    default:
                        M = Hm;
                        break
                }
                const I = x.name ? x.name : x.uuid,
                    O = A.interpolation !== void 0 ? L8e[A.interpolation] : ep,
                    k = [];
                vc[T.path] === vc.weights ? x.traverse(function(N) {
                    N.morphTargetInfluences && k.push(N.name ? N.name : N.uuid)
                }) : k.push(I);
                let H = E.array;
                if (E.normalized) {
                    const N = CO(H.constructor),
                        B = new Float32Array(H.length);
                    for (let U = 0, q = H.length; U < q; U++) B[U] = H[U] * N;
                    H = B
                }
                for (let N = 0, B = k.length; N < B; N++) {
                    const U = new M(k[N] + "." + vc[T.path], S.array, H, O);
                    A.interpolation === "CUBICSPLINE" && (U.createInterpolant = function(Q) {
                        const F = this instanceof ff ? D8e : GZ;
                        return new F(this.times, this.values, this.getValueSize() / 3, Q)
                    }, U.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), v.push(U)
                }
            }
            return new Um(i, void 0, v)
        })
    }
    createNodeMesh(e) {
        const n = this.json,
            r = this,
            i = n.nodes[e];
        return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function(s) {
            const o = r._getNodeRef(r.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, u = i.weights.length; l < u; l++) a.morphTargetInfluences[l] = i.weights[l]
            }), o
        })
    }
    loadNode(e) {
        const n = this.json,
            r = this,
            i = n.nodes[e],
            s = r._loadNodeShallow(e),
            o = [],
            a = i.children || [];
        for (let u = 0, c = a.length; u < c; u++) o.push(r.getDependency("node", a[u]));
        const l = i.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", i.skin);
        return Promise.all([s, Promise.all(o), l]).then(function(u) {
            const c = u[0],
                f = u[1],
                d = u[2];
            d !== null && c.traverse(function(p) {
                p.isSkinnedMesh && p.bind(d, H8e)
            });
            for (let p = 0, m = f.length; p < m; p++) c.add(f[p]);
            return c
        })
    }
    _loadNodeShallow(e) {
        const n = this.json,
            r = this.extensions,
            i = this;
        if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
        const s = n.nodes[e],
            o = s.name ? i.createUniqueName(s.name) : "",
            a = [],
            l = i._invokeOne(function(u) {
                return u.createNodeMesh && u.createNodeMesh(e)
            });
        return l && a.push(l), s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(u) {
            return i._getNodeRef(i.cameraCache, s.camera, u)
        })), i._invokeAll(function(u) {
            return u.createNodeAttachment && u.createNodeAttachment(e)
        }).forEach(function(u) {
            a.push(u)
        }), this.nodeCache[e] = Promise.all(a).then(function(u) {
            let c;
            if (s.isBone === !0 ? c = new $E : u.length > 1 ? c = new Su : u.length === 1 ? c = u[0] : c = new Tn, c !== u[0])
                for (let f = 0, d = u.length; f < d; f++) c.add(u[f]);
            if (s.name && (c.userData.name = s.name, c.name = o), Ec(c, s), s.extensions && Jf(r, c, s), s.matrix !== void 0) {
                const f = new Gt;
                f.fromArray(s.matrix), c.applyMatrix4(f)
            } else s.translation !== void 0 && c.position.fromArray(s.translation), s.rotation !== void 0 && c.quaternion.fromArray(s.rotation), s.scale !== void 0 && c.scale.fromArray(s.scale);
            return i.associations.has(c) || i.associations.set(c, {}), i.associations.get(c).nodes = e, c
        }), this.nodeCache[e]
    }
    loadScene(e) {
        const n = this.extensions,
            r = this.json.scenes[e],
            i = this,
            s = new Su;
        r.name && (s.name = i.createUniqueName(r.name)), Ec(s, r), r.extensions && Jf(n, s, r);
        const o = r.nodes || [],
            a = [];
        for (let l = 0, u = o.length; l < u; l++) a.push(i.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let c = 0, f = l.length; c < f; c++) s.add(l[c]);
            const u = c => {
                const f = new Map;
                for (const [d, p] of i.associations)(d instanceof li || d instanceof Sr) && f.set(d, p);
                return c.traverse(d => {
                    const p = i.associations.get(d);
                    p != null && f.set(d, p)
                }), f
            };
            return i.associations = u(s), s
        })
    }
}

function $8e(t, e, n) {
    const r = e.attributes,
        i = new Xa;
    if (r.POSITION !== void 0) {
        const a = n.json.accessors[r.POSITION],
            l = a.min,
            u = a.max;
        if (l !== void 0 && u !== void 0) {
            if (i.set(new J(l[0], l[1], l[2]), new J(u[0], u[1], u[2])), a.normalized) {
                const c = CO(_m[a.componentType]);
                i.min.multiplyScalar(c), i.max.multiplyScalar(c)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new J,
            l = new J;
        for (let u = 0, c = s.length; u < c; u++) {
            const f = s[u];
            if (f.POSITION !== void 0) {
                const d = n.json.accessors[f.POSITION],
                    p = d.min,
                    m = d.max;
                if (p !== void 0 && m !== void 0) {
                    if (l.setX(Math.max(Math.abs(p[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(m[2]))), d.normalized) {
                        const y = CO(_m[d.componentType]);
                        l.multiplyScalar(y)
                    }
                    a.max(l)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    t.boundingBox = i;
    const o = new Fl;
    i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, t.boundingSphere = o
}

function jU(t, e, n) {
    const r = e.attributes,
        i = [];

    function s(o, a) {
        return n.getDependency("accessor", o).then(function(l) {
            t.setAttribute(a, l)
        })
    }
    for (const o in r) {
        const a = AO[o] || o.toLowerCase();
        a in t.attributes || i.push(s(r[o], a))
    }
    if (e.indices !== void 0 && !t.index) {
        const o = n.getDependency("accessor", e.indices).then(function(a) {
            t.setIndex(a)
        });
        i.push(o)
    }
    return Ec(t, e), $8e(t, e, n), Promise.all(i).then(function() {
        return e.targets !== void 0 ? B8e(t, e.targets, n) : t
    })
}
const MP = new WeakMap;
class G8e extends As {
    constructor(e) {
        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e, this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e, this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e, this
    }
    load(e, n, r, i) {
        const s = new ho(this.manager);
        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => {
            const a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(n).catch(i)
        }, r, i)
    }
    decodeDracoFile(e, n, r, i) {
        const s = {
            attributeIDs: r || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!r
        };
        this.decodeGeometry(e, s).then(n)
    }
    decodeGeometry(e, n) {
        for (const l in n.attributeTypes) {
            const u = n.attributeTypes[l];
            u.BYTES_PER_ELEMENT !== void 0 && (n.attributeTypes[l] = u.name)
        }
        const r = JSON.stringify(n);
        if (MP.has(e)) {
            const l = MP.get(e);
            if (l.key === r) return l.promise;
            if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let i;
        const s = this.workerNextTaskID++,
            o = e.byteLength,
            a = this._getWorker(s, o).then(l => (i = l, new Promise((u, c) => {
                i._callbacks[s] = {
                    resolve: u,
                    reject: c
                }, i.postMessage({
                    type: "decode",
                    id: s,
                    taskConfig: n,
                    buffer: e
                }, [e])
            }))).then(l => this._createGeometry(l.geometry));
        return a.catch(() => !0).then(() => {
            i && s && this._releaseTask(i, s)
        }), MP.set(e, {
            key: r,
            promise: a
        }), a
    }
    _createGeometry(e) {
        const n = new on;
        e.index && n.setIndex(new Ln(e.index.array, 1));
        for (let r = 0; r < e.attributes.length; r++) {
            const i = e.attributes[r],
                s = i.name,
                o = i.array,
                a = i.itemSize;
            n.setAttribute(s, new Ln(o, a))
        }
        return n
    }
    _loadLibrary(e, n) {
        const r = new ho(this.manager);
        return r.setPath(this.decoderPath), r.setResponseType(n), r.setWithCredentials(this.withCredentials), new Promise((i, s) => {
            r.load(e, i, void 0, s)
        })
    }
    preload() {
        return this._initDecoder(), this
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
            n = [];
        return e ? n.push(this._loadLibrary("draco_decoder.js", "text")) : (n.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), n.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(n).then(r => {
            const i = r[0];
            e || (this.decoderConfig.wasmBinary = r[1]);
            const s = V8e.toString(),
                o = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }), this.decoderPending
    }
    _getWorker(e, n) {
        return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
                const i = new Worker(this.workerSourceURL);
                i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), i.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                        case "decode":
                            i._callbacks[o.id].resolve(o);
                            break;
                        case "error":
                            i._callbacks[o.id].reject(o);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }, this.workerPool.push(i)
            } else this.workerPool.sort(function(i, s) {
                return i._taskLoad > s._taskLoad ? -1 : 1
            });
            const r = this.workerPool[this.workerPool.length - 1];
            return r._taskCosts[e] = n, r._taskLoad += n, r
        })
    }
    _releaseTask(e, n) {
        e._taskLoad -= e._taskCosts[n], delete e._callbacks[n], delete e._taskCosts[n]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
        return this.workerPool.length = 0, this
    }
}

function V8e() {
    let t, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
            case "init":
                t = a.decoderConfig, e = new Promise(function(c) {
                    t.onModuleLoaded = function(f) {
                        c({
                            draco: f
                        })
                    }, DracoDecoderModule(t)
                });
                break;
            case "decode":
                const l = a.buffer,
                    u = a.taskConfig;
                e.then(c => {
                    const f = c.draco,
                        d = new f.Decoder,
                        p = new f.DecoderBuffer;
                    p.Init(new Int8Array(l), l.byteLength);
                    try {
                        const m = n(f, d, p, u),
                            y = m.attributes.map(v => v.array.buffer);
                        m.index && y.push(m.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: a.id,
                            geometry: m
                        }, y)
                    } catch (m) {
                        console.error(m), self.postMessage({
                            type: "error",
                            id: a.id,
                            error: m.message
                        })
                    } finally {
                        f.destroy(p), f.destroy(d)
                    }
                });
                break
        }
    };

    function n(o, a, l, u) {
        const c = u.attributeIDs,
            f = u.attributeTypes;
        let d, p;
        const m = a.GetEncodedGeometryType(l);
        if (m === o.TRIANGULAR_MESH) d = new o.Mesh, p = a.DecodeBufferToMesh(l, d);
        else if (m === o.POINT_CLOUD) d = new o.PointCloud, p = a.DecodeBufferToPointCloud(l, d);
        else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!p.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + p.error_msg());
        const y = {
            index: null,
            attributes: []
        };
        for (const v in c) {
            const b = self[f[v]];
            let _, x;
            if (u.useUniqueIDs) x = c[v], _ = a.GetAttributeByUniqueId(d, x);
            else {
                if (x = a.GetAttributeId(d, o[c[v]]), x === -1) continue;
                _ = a.GetAttribute(d, x)
            }
            y.attributes.push(i(o, a, d, v, b, _))
        }
        return m === o.TRIANGULAR_MESH && (y.index = r(o, a, d)), o.destroy(d), y
    }

    function r(o, a, l) {
        const c = l.num_faces() * 3,
            f = c * 4,
            d = o._malloc(f);
        a.GetTrianglesUInt32Array(l, f, d);
        const p = new Uint32Array(o.HEAPF32.buffer, d, c).slice();
        return o._free(d), {
            array: p,
            itemSize: 1
        }
    }

    function i(o, a, l, u, c, f) {
        const d = f.num_components(),
            m = l.num_points() * d,
            y = m * c.BYTES_PER_ELEMENT,
            v = s(o, c),
            b = o._malloc(y);
        a.GetAttributeDataArrayForAllPoints(l, f, v, y, b);
        const _ = new c(o.HEAPF32.buffer, b, m).slice();
        return o._free(b), {
            name: u,
            array: _,
            itemSize: d
        }
    }

    function s(o, a) {
        switch (a) {
            case Float32Array:
                return o.DT_FLOAT32;
            case Int8Array:
                return o.DT_INT8;
            case Int16Array:
                return o.DT_INT16;
            case Int32Array:
                return o.DT_INT32;
            case Uint8Array:
                return o.DT_UINT8;
            case Uint16Array:
                return o.DT_UINT16;
            case Uint32Array:
                return o.DT_UINT32
        }
    }
}
const WU = new Xa,
    q_ = new J;
class wB extends VL {
    constructor() {
        super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
        const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0],
            n = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
            r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
        this.setIndex(r), this.setAttribute("position", new Mt(e, 3)), this.setAttribute("uv", new Mt(n, 2))
    }
    applyMatrix4(e) {
        const n = this.attributes.instanceStart,
            r = this.attributes.instanceEnd;
        return n !== void 0 && (n.applyMatrix4(e), r.applyMatrix4(e), n.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    setPositions(e) {
        let n;
        e instanceof Float32Array ? n = e : Array.isArray(e) && (n = new Float32Array(e));
        const r = new Bw(n, 6, 1);
        return this.setAttribute("instanceStart", new Hs(r, 3, 0)), this.setAttribute("instanceEnd", new Hs(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
    }
    setColors(e, n = 3) {
        let r;
        e instanceof Float32Array ? r = e : Array.isArray(e) && (r = new Float32Array(e));
        const i = new Bw(r, n * 2, 1);
        return this.setAttribute("instanceColorStart", new Hs(i, n, 0)), this.setAttribute("instanceColorEnd", new Hs(i, n, n)), this
    }
    fromWireframeGeometry(e) {
        return this.setPositions(e.attributes.position.array), this
    }
    fromEdgesGeometry(e) {
        return this.setPositions(e.attributes.position.array), this
    }
    fromMesh(e) {
        return this.fromWireframeGeometry(new LL(e.geometry)), this
    }
    fromLineSegments(e) {
        const n = e.geometry;
        return this.setPositions(n.attributes.position.array), this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Xa);
        const e = this.attributes.instanceStart,
            n = this.attributes.instanceEnd;
        e !== void 0 && n !== void 0 && (this.boundingBox.setFromBufferAttribute(e), WU.setFromBufferAttribute(n), this.boundingBox.union(WU))
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Fl), this.boundingBox === null && this.computeBoundingBox();
        const e = this.attributes.instanceStart,
            n = this.attributes.instanceEnd;
        if (e !== void 0 && n !== void 0) {
            const r = this.boundingSphere.center;
            this.boundingBox.getCenter(r);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++) q_.fromBufferAttribute(e, s), i = Math.max(i, r.distanceToSquared(q_)), q_.fromBufferAttribute(n, s), i = Math.max(i, r.distanceToSquared(q_));
            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
        }
    }
    toJSON() {}
    applyMatrix(e) {
        return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e)
    }
}
class j8e extends wB {
    constructor() {
        super(), this.isLineGeometry = !0, this.type = "LineGeometry"
    }
    setPositions(e) {
        const n = e.length - 3,
            r = new Float32Array(2 * n);
        for (let i = 0; i < n; i += 3) r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5];
        return super.setPositions(r), this
    }
    setColors(e, n = 3) {
        const r = e.length - n,
            i = new Float32Array(2 * r);
        if (n === 3)
            for (let s = 0; s < r; s += n) i[2 * s] = e[s], i[2 * s + 1] = e[s + 1], i[2 * s + 2] = e[s + 2], i[2 * s + 3] = e[s + 3], i[2 * s + 4] = e[s + 4], i[2 * s + 5] = e[s + 5];
        else
            for (let s = 0; s < r; s += n) i[2 * s] = e[s], i[2 * s + 1] = e[s + 1], i[2 * s + 2] = e[s + 2], i[2 * s + 3] = e[s + 3], i[2 * s + 4] = e[s + 4], i[2 * s + 5] = e[s + 5], i[2 * s + 6] = e[s + 6], i[2 * s + 7] = e[s + 7];
        return super.setColors(i, n), this
    }
    fromLine(e) {
        const n = e.geometry;
        return this.setPositions(n.attributes.position.array), this
    }
}
class EB extends ra {
    constructor(e) {
        super({
            type: "LineMaterial",
            uniforms: kw.clone(kw.merge([ot.common, ot.fog, {
                worldUnits: {
                    value: 1
                },
                linewidth: {
                    value: 1
                },
                resolution: {
                    value: new ke(1, 1)
                },
                dashOffset: {
                    value: 0
                },
                dashScale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                gapSize: {
                    value: 1
                }
            }])),
            vertexShader: `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,
            fragmentShader: `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${parseInt(vp.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,
            clipping: !0
        }), this.isLineMaterial = !0, this.onBeforeCompile = function() {
            this.transparent ? this.defines.USE_LINE_COLOR_ALPHA = "1" : delete this.defines.USE_LINE_COLOR_ALPHA
        }, Object.defineProperties(this, {
            color: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.diffuse.value
                },
                set: function(n) {
                    this.uniforms.diffuse.value = n
                }
            },
            worldUnits: {
                enumerable: !0,
                get: function() {
                    return "WORLD_UNITS" in this.defines
                },
                set: function(n) {
                    n === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
                }
            },
            linewidth: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.linewidth.value
                },
                set: function(n) {
                    this.uniforms.linewidth.value = n
                }
            },
            dashed: {
                enumerable: !0,
                get: function() {
                    return "USE_DASH" in this.defines
                },
                set(n) {
                    !!n != "USE_DASH" in this.defines && (this.needsUpdate = !0), n === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
                }
            },
            dashScale: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashScale.value
                },
                set: function(n) {
                    this.uniforms.dashScale.value = n
                }
            },
            dashSize: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashSize.value
                },
                set: function(n) {
                    this.uniforms.dashSize.value = n
                }
            },
            dashOffset: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.dashOffset.value
                },
                set: function(n) {
                    this.uniforms.dashOffset.value = n
                }
            },
            gapSize: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.gapSize.value
                },
                set: function(n) {
                    this.uniforms.gapSize.value = n
                }
            },
            opacity: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.opacity.value
                },
                set: function(n) {
                    this.uniforms.opacity.value = n
                }
            },
            resolution: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.resolution.value
                },
                set: function(n) {
                    this.uniforms.resolution.value.copy(n)
                }
            },
            alphaToCoverage: {
                enumerable: !0,
                get: function() {
                    return "USE_ALPHA_TO_COVERAGE" in this.defines
                },
                set: function(n) {
                    !!n != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), n === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1)
                }
            }
        }), this.setValues(e)
    }
}
const KU = new J,
    qU = new J,
    Li = new In,
    ki = new In,
    ol = new In,
    TP = new J,
    PP = new Gt,
    is = new tK,
    XU = new J,
    X_ = new Xa,
    J_ = new Fl,
    al = new In;
let bl, MO, VZ, Gd;

function JU(t, e, n) {
    return al.set(0, 0, -e, 1).applyMatrix4(t.projectionMatrix), al.multiplyScalar(1 / al.w), al.x = Gd / n.width, al.y = Gd / n.height, al.applyMatrix4(t.projectionMatrixInverse), al.multiplyScalar(1 / al.w), Math.abs(Math.max(al.x, al.y))
}

function W8e(t, e) {
    for (let n = 0, r = MO.count; n < r; n++) {
        is.start.fromBufferAttribute(MO, n), is.end.fromBufferAttribute(VZ, n);
        const i = new J,
            s = new J;
        bl.distanceSqToSegment(is.start, is.end, s, i), s.distanceTo(i) < Gd * .5 && e.push({
            point: s,
            pointOnLine: i,
            distance: bl.origin.distanceTo(s),
            object: t,
            face: null,
            faceIndex: n,
            uv: null,
            uv2: null
        })
    }
}

function K8e(t, e, n) {
    const r = e.projectionMatrix,
        s = t.material.resolution,
        o = t.matrixWorld,
        a = t.geometry,
        l = a.attributes.instanceStart,
        u = a.attributes.instanceEnd,
        c = -e.near;
    bl.at(1, ol), ol.w = 1, ol.applyMatrix4(e.matrixWorldInverse), ol.applyMatrix4(r), ol.multiplyScalar(1 / ol.w), ol.x *= s.x / 2, ol.y *= s.y / 2, ol.z = 0, TP.copy(ol), PP.multiplyMatrices(e.matrixWorldInverse, o);
    for (let f = 0, d = l.count; f < d; f++) {
        if (Li.fromBufferAttribute(l, f), ki.fromBufferAttribute(u, f), Li.w = 1, ki.w = 1, Li.applyMatrix4(PP), ki.applyMatrix4(PP), Li.z > c && ki.z > c) continue;
        if (Li.z > c) {
            const _ = Li.z - ki.z,
                x = (Li.z - c) / _;
            Li.lerp(ki, x)
        } else if (ki.z > c) {
            const _ = ki.z - Li.z,
                x = (ki.z - c) / _;
            ki.lerp(Li, x)
        }
        Li.applyMatrix4(r), ki.applyMatrix4(r), Li.multiplyScalar(1 / Li.w), ki.multiplyScalar(1 / ki.w), Li.x *= s.x / 2, Li.y *= s.y / 2, ki.x *= s.x / 2, ki.y *= s.y / 2, is.start.copy(Li), is.start.z = 0, is.end.copy(ki), is.end.z = 0;
        const m = is.closestPointToPointParameter(TP, !0);
        is.at(m, XU);
        const y = bd.lerp(Li.z, ki.z, m),
            v = y >= -1 && y <= 1,
            b = TP.distanceTo(XU) < Gd * .5;
        if (v && b) {
            is.start.fromBufferAttribute(l, f), is.end.fromBufferAttribute(u, f), is.start.applyMatrix4(o), is.end.applyMatrix4(o);
            const _ = new J,
                x = new J;
            bl.distanceSqToSegment(is.start, is.end, x, _), n.push({
                point: x,
                pointOnLine: _,
                distance: bl.origin.distanceTo(x),
                object: t,
                face: null,
                faceIndex: f,
                uv: null,
                uv2: null
            })
        }
    }
}
class q8e extends mi {
    constructor(e = new wB, n = new EB({
        color: Math.random() * 16777215
    })) {
        super(e, n), this.isLineSegments2 = !0, this.type = "LineSegments2"
    }
    computeLineDistances() {
        const e = this.geometry,
            n = e.attributes.instanceStart,
            r = e.attributes.instanceEnd,
            i = new Float32Array(2 * n.count);
        for (let o = 0, a = 0, l = n.count; o < l; o++, a += 2) KU.fromBufferAttribute(n, o), qU.fromBufferAttribute(r, o), i[a] = a === 0 ? 0 : i[a - 1], i[a + 1] = i[a] + KU.distanceTo(qU);
        const s = new Bw(i, 2, 1);
        return e.setAttribute("instanceDistanceStart", new Hs(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new Hs(s, 1, 1)), this
    }
    raycast(e, n) {
        const r = this.material.worldUnits,
            i = e.camera;
        i === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
        bl = e.ray;
        const o = this.matrixWorld,
            a = this.geometry,
            l = this.material;
        Gd = l.linewidth + s, MO = a.attributes.instanceStart, VZ = a.attributes.instanceEnd, a.boundingSphere === null && a.computeBoundingSphere(), J_.copy(a.boundingSphere).applyMatrix4(o);
        let u;
        if (r) u = Gd * .5;
        else {
            const f = Math.max(i.near, J_.distanceToPoint(bl.origin));
            u = JU(i, f, l.resolution)
        }
        if (J_.radius += u, bl.intersectsSphere(J_) === !1) return;
        a.boundingBox === null && a.computeBoundingBox(), X_.copy(a.boundingBox).applyMatrix4(o);
        let c;
        if (r) c = Gd * .5;
        else {
            const f = Math.max(i.near, X_.distanceToPoint(bl.origin));
            c = JU(i, f, l.resolution)
        }
        X_.expandByScalar(c), bl.intersectsBox(X_) !== !1 && (r ? W8e(this, n) : K8e(this, i, n))
    }
}
class X8e extends q8e {
    constructor(e = new j8e, n = new EB({
        color: Math.random() * 16777215
    })) {
        super(e, n), this.isLine2 = !0, this.type = "Line2"
    }
}
let Y_;
const IP = () => {
        if (Y_) return Y_;
        const t = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
            e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
            n = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
            r = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
        if (typeof WebAssembly != "object") return {
            supported: !1
        };
        let i = t;
        WebAssembly.validate(n) && (i = e);
        let s;
        const o = WebAssembly.instantiate(a(i), {}).then(f => {
            s = f.instance, s.exports.__wasm_call_ctors()
        });

        function a(f) {
            const d = new Uint8Array(f.length);
            for (let m = 0; m < f.length; ++m) {
                const y = f.charCodeAt(m);
                d[m] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62
            }
            let p = 0;
            for (let m = 0; m < f.length; ++m) d[p++] = d[m] < 60 ? r[d[m]] : (d[m] - 60) * 64 + d[++m];
            return d.buffer.slice(0, p)
        }

        function l(f, d, p, m, y, v) {
            const b = s.exports.sbrk,
                _ = p + 3 & -4,
                x = b(_ * m),
                S = b(y.length),
                E = new Uint8Array(s.exports.memory.buffer);
            E.set(y, S);
            const A = f(x, p, m, S, y.length);
            if (A === 0 && v && v(x, _, m), d.set(E.subarray(x, x + p * m)), b(x - b(0)), A !== 0) throw new Error(`Malformed buffer data: ${A}`)
        }
        const u = {
                0: "",
                1: "meshopt_decodeFilterOct",
                2: "meshopt_decodeFilterQuat",
                3: "meshopt_decodeFilterExp",
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            },
            c = {
                0: "meshopt_decodeVertexBuffer",
                1: "meshopt_decodeIndexBuffer",
                2: "meshopt_decodeIndexSequence",
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            };
        return Y_ = {
            ready: o,
            supported: !0,
            decodeVertexBuffer(f, d, p, m, y) {
                l(s.exports.meshopt_decodeVertexBuffer, f, d, p, m, s.exports[u[y]])
            },
            decodeIndexBuffer(f, d, p, m) {
                l(s.exports.meshopt_decodeIndexBuffer, f, d, p, m)
            },
            decodeIndexSequence(f, d, p, m) {
                l(s.exports.meshopt_decodeIndexSequence, f, d, p, m)
            },
            decodeGltfBuffer(f, d, p, m, y, v) {
                l(s.exports[c[y]], f, d, p, m, s.exports[u[v]])
            }
        }, Y_
    },
    J8e = () => parseInt(vp.replace(/\D+/g, "")),
    Y8e = J8e();
let Q_ = null,
    jZ = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";

function WZ(t, e, n) {
    return r => {
        n && n(r), t && (Q_ || (Q_ = new G8e), Q_.setDecoderPath(typeof t == "string" ? t : jZ), r.setDRACOLoader(Q_)), e && r.setMeshoptDecoder(typeof IP == "function" ? IP() : IP)
    }
}

function AB(t, e = !0, n = !0, r) {
    return rb(SB, t, WZ(e, n, r))
}
AB.preload = (t, e = !0, n = !0, r) => rb.preload(SB, t, WZ(e, n, r));
AB.clear = t => rb.clear(SB, t);
AB.setDecoderPath = t => {
    jZ = t
};

function Q8e(t, e, n) {
    const r = ri(d => d.size),
        i = ri(d => d.viewport),
        s = typeof t == "number" ? t : r.width * i.dpr,
        o = typeof e == "number" ? e : r.height * i.dpr,
        a = (typeof t == "number" ? n : t) || {},
        {
            samples: l = 0,
            depth: u,
            ...c
        } = a,
        f = P.useMemo(() => {
            const d = new na(s, o, {
                minFilter: fr,
                magFilter: fr,
                type: Qd,
                ...c
            });
            return u && (d.depthTexture = new xL(s, o, xl)), d.samples = l, d
        }, []);
    return P.useLayoutEffect(() => {
        f.setSize(s, o), l && (f.samples = l)
    }, [l, f, s, o]), P.useEffect(() => () => f.dispose(), []), f
}
const Z8e = t => typeof t == "function",
    WUe = P.forwardRef(({
        envMap: t,
        resolution: e = 256,
        frames: n = 1 / 0,
        makeDefault: r,
        children: i,
        ...s
    }, o) => {
        const a = ri(({
                set: v
            }) => v),
            l = ri(({
                camera: v
            }) => v),
            u = ri(({
                size: v
            }) => v),
            c = P.useRef(null);
        P.useImperativeHandle(o, () => c.current, []);
        const f = P.useRef(null),
            d = Q8e(e);
        P.useLayoutEffect(() => {
            s.manual || (c.current.aspect = u.width / u.height)
        }, [u, s]), P.useLayoutEffect(() => {
            c.current.updateProjectionMatrix()
        });
        let p = 0,
            m = null;
        const y = Z8e(i);
        return nb(v => {
            y && (n === 1 / 0 || p < n) && (f.current.visible = !1, v.gl.setRenderTarget(d), m = v.scene.background, t && (v.scene.background = t), v.gl.render(v.scene, c.current), v.scene.background = m, v.gl.setRenderTarget(null), f.current.visible = !0, p++)
        }), P.useLayoutEffect(() => {
            if (r) {
                const v = l;
                return a(() => ({
                    camera: c.current
                })), () => a(() => ({
                    camera: v
                }))
            }
        }, [c, r, a]), P.createElement(P.Fragment, null, P.createElement("perspectiveCamera", Y({
            ref: c
        }, s), !y && i), P.createElement("group", {
            ref: f
        }, y && i(d.texture)))
    }),
    KUe = P.forwardRef(({
        makeDefault: t,
        camera: e,
        regress: n,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: s = !1,
        onChange: o,
        onStart: a,
        onEnd: l,
        ...u
    }, c) => {
        const f = ri(A => A.invalidate),
            d = ri(A => A.camera),
            p = ri(A => A.gl),
            m = ri(A => A.events),
            y = ri(A => A.setEvents),
            v = ri(A => A.set),
            b = ri(A => A.get),
            _ = ri(A => A.performance),
            x = e || d,
            S = r || m.connected || p.domElement,
            E = P.useMemo(() => new c8e(x), [x]);
        return nb(() => {
            E.enabled && E.update()
        }, -1), P.useEffect(() => (s && E.connect(s === !0 ? S : s), E.connect(S), () => void E.dispose()), [s, S, n, E, f]), P.useEffect(() => {
            const A = I => {
                    f(), n && _.regress(), o && o(I)
                },
                T = I => {
                    a && a(I)
                },
                M = I => {
                    l && l(I)
                };
            return E.addEventListener("change", A), E.addEventListener("start", T), E.addEventListener("end", M), () => {
                E.removeEventListener("start", T), E.removeEventListener("end", M), E.removeEventListener("change", A)
            }
        }, [o, a, l, E, f, y]), P.useEffect(() => {
            if (t) {
                const A = b().controls;
                return v({
                    controls: E
                }), () => v({
                    controls: A
                })
            }
        }, [t, E]), P.createElement("primitive", Y({
            ref: c,
            object: E,
            enableDamping: i
        }, u))
    });
class e9e extends ra {
    constructor() {
        super({
            uniforms: {
                depth: {
                    value: null
                },
                opacity: {
                    value: 1
                },
                attenuation: {
                    value: 2.5
                },
                anglePower: {
                    value: 12
                },
                spotPosition: {
                    value: new J(0, 0, 0)
                },
                lightColor: {
                    value: new dt("white")
                },
                cameraNear: {
                    value: 0
                },
                cameraFar: {
                    value: 1
                },
                resolution: {
                    value: new ke(0, 0)
                }
            },
            transparent: !0,
            depthWrite: !1,
            vertexShader: `
        varying vec3 vNormal;
        varying float vViewZ;
        varying float vIntensity;
        uniform vec3 spotPosition;
        uniform float attenuation;

        #include <common>
        #include <logdepthbuf_pars_vertex>

        void main() {
          // compute intensity
          vNormal = normalize(normalMatrix * normal);
          vec4 worldPosition = modelMatrix * vec4(position, 1);
          vec4 viewPosition = viewMatrix * worldPosition;
          vViewZ = viewPosition.z;

          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);

          gl_Position = projectionMatrix * viewPosition;

          #include <logdepthbuf_vertex>
        }
      `,
            fragmentShader: `
        varying vec3 vNormal;
        varying float vViewZ;
        varying float vIntensity;

        uniform vec3 lightColor;
        uniform float anglePower;
        uniform sampler2D depth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float opacity;

        #include <packing>
        #include <logdepthbuf_pars_fragment>

        float readDepth(sampler2D depthSampler, vec2 uv) {
          float fragCoordZ = texture(depthSampler, uv).r;

          // https://github.com/mrdoob/three.js/issues/23072
          #ifdef USE_LOGDEPTHBUF
            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));
          #else
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          #endif

          return viewZ;
        }

        void main() {
          #include <logdepthbuf_fragment>

          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));
          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);
          float intensity = vIntensity * angleIntensity;

          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry
          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;
          if (isSoft) {
            vec2 uv = gl_FragCoord.xy / resolution;
            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));
          }

          gl_FragColor = vec4(lightColor, intensity * opacity);

          #include <tonemapping_fragment>
          #include <${Y8e>=154?"colorspace_fragment":"encodings_fragment"}>
        }
      `
        })
    }
}

function t9e({
    opacity: t = 1,
    radiusTop: e,
    radiusBottom: n,
    depthBuffer: r,
    color: i = "white",
    distance: s = 5,
    angle: o = .15,
    attenuation: a = 5,
    anglePower: l = 5
}) {
    const u = P.useRef(null),
        c = ri(v => v.size),
        f = ri(v => v.camera),
        d = ri(v => v.viewport.dpr),
        [p] = P.useState(() => new e9e),
        [m] = P.useState(() => new J);
    e = e === void 0 ? .1 : e, n = n === void 0 ? o * 7 : n, nb(() => {
        p.uniforms.spotPosition.value.copy(u.current.getWorldPosition(m)), u.current.lookAt(u.current.parent.target.getWorldPosition(m))
    });
    const y = P.useMemo(() => {
        const v = new wf(e, n, s, 128, 64, !0);
        return v.applyMatrix4(new Gt().makeTranslation(0, -s / 2, 0)), v.applyMatrix4(new Gt().makeRotationX(-Math.PI / 2)), v
    }, [s, e, n]);
    return P.createElement(P.Fragment, null, P.createElement("mesh", {
        ref: u,
        geometry: y,
        raycast: () => null
    }, P.createElement("primitive", {
        object: p,
        attach: "material",
        "uniforms-opacity-value": t,
        "uniforms-lightColor-value": i,
        "uniforms-attenuation-value": a,
        "uniforms-anglePower-value": l,
        "uniforms-depth-value": r,
        "uniforms-cameraNear-value": f.near,
        "uniforms-cameraFar-value": f.far,
        "uniforms-resolution-value": r ? [c.width * d, c.height * d] : [0, 0]
    })))
}
const qUe = P.forwardRef(({
        opacity: t = 1,
        radiusTop: e,
        radiusBottom: n,
        depthBuffer: r,
        color: i = "white",
        distance: s = 5,
        angle: o = .15,
        attenuation: a = 5,
        anglePower: l = 5,
        volumetric: u = !0,
        debug: c = !1,
        children: f,
        ...d
    }, p) => {
        const m = P.useRef(null);
        return P.useImperativeHandle(p, () => m.current, []), P.createElement("group", null, c && m.current && P.createElement("spotLightHelper", {
            args: [m.current]
        }), P.createElement("spotLight", Y({
            ref: m,
            angle: o,
            color: i,
            distance: s,
            castShadow: !0
        }, d), u && P.createElement(t9e, {
            debug: c,
            opacity: t,
            radiusTop: e,
            radiusBottom: n,
            depthBuffer: r,
            color: i,
            distance: s,
            angle: o,
            attenuation: a,
            anglePower: l
        })), f && P.cloneElement(f, {
            spotlightRef: m,
            debug: c
        }))
    }),
    KZ = P.createContext(null),
    XUe = P.forwardRef((t, e) => {
        P.useMemo(() => WQ({
            SegmentObject: n9e
        }), []);
        const {
            limit: n = 1e3,
            lineWidth: r = 1,
            children: i,
            ...s
        } = t, [o, a] = P.useState([]), [l] = P.useState(() => new X8e), [u] = P.useState(() => new EB), [c] = P.useState(() => new wB), [f] = P.useState(() => new ke(512, 512)), [d] = P.useState(() => Array(n * 6).fill(0)), [p] = P.useState(() => Array(n * 6).fill(0)), m = P.useMemo(() => ({
            subscribe: y => (a(v => [...v, y]), () => a(v => v.filter(b => b.current !== y.current)))
        }), []);
        return nb(() => {
            for (let v = 0; v < n; v++) {
                var y;
                const b = (y = o[v]) == null ? void 0 : y.current;
                b && (d[v * 6 + 0] = b.start.x, d[v * 6 + 1] = b.start.y, d[v * 6 + 2] = b.start.z, d[v * 6 + 3] = b.end.x, d[v * 6 + 4] = b.end.y, d[v * 6 + 5] = b.end.z, p[v * 6 + 0] = b.color.r, p[v * 6 + 1] = b.color.g, p[v * 6 + 2] = b.color.b, p[v * 6 + 3] = b.color.r, p[v * 6 + 4] = b.color.g, p[v * 6 + 5] = b.color.b)
            }
            c.setColors(p), c.setPositions(d), l.computeLineDistances()
        }), P.createElement("primitive", {
            object: l,
            ref: e
        }, P.createElement("primitive", {
            object: c,
            attach: "geometry"
        }), P.createElement("primitive", Y({
            object: u,
            attach: "material",
            vertexColors: !0,
            resolution: f,
            linewidth: r
        }, s)), P.createElement(KZ.Provider, {
            value: m
        }, i))
    });
class n9e {
    constructor() {
        this.color = new dt("white"), this.start = new J(0, 0, 0), this.end = new J(0, 0, 0)
    }
}
const YU = t => t instanceof J ? t : new J(...typeof t == "number" ? [t, t, t] : t),
    JUe = P.forwardRef(({
        color: t,
        start: e,
        end: n
    }, r) => {
        const i = P.useContext(KZ);
        if (!i) throw "Segment must used inside Segments component.";
        const s = P.useRef(null);
        return P.useImperativeHandle(r, () => s.current, []), P.useLayoutEffect(() => i.subscribe(s), []), P.createElement("segmentObject", {
            ref: s,
            color: t,
            start: YU(e),
            end: YU(n)
        })
    });
var Vd = [],
    r9e = function() {
        return Vd.some(function(t) {
            return t.activeTargets.length > 0
        })
    },
    i9e = function() {
        return Vd.some(function(t) {
            return t.skippedTargets.length > 0
        })
    },
    QU = "ResizeObserver loop completed with undelivered notifications.",
    s9e = function() {
        var t;
        typeof ErrorEvent == "function" ? t = new ErrorEvent("error", {
            message: QU
        }) : (t = document.createEvent("Event"), t.initEvent("error", !1, !1), t.message = QU), window.dispatchEvent(t)
    },
    j0;
(function(t) {
    t.BORDER_BOX = "border-box", t.CONTENT_BOX = "content-box", t.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box"
})(j0 || (j0 = {}));
var jd = function(t) {
        return Object.freeze(t)
    },
    o9e = function() {
        function t(e, n) {
            this.inlineSize = e, this.blockSize = n, jd(this)
        }
        return t
    }(),
    qZ = function() {
        function t(e, n, r, i) {
            return this.x = e, this.y = n, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, jd(this)
        }
        return t.prototype.toJSON = function() {
            var e = this,
                n = e.x,
                r = e.y,
                i = e.top,
                s = e.right,
                o = e.bottom,
                a = e.left,
                l = e.width,
                u = e.height;
            return {
                x: n,
                y: r,
                top: i,
                right: s,
                bottom: o,
                left: a,
                width: l,
                height: u
            }
        }, t.fromRect = function(e) {
            return new t(e.x, e.y, e.width, e.height)
        }, t
    }(),
    CB = function(t) {
        return t instanceof SVGElement && "getBBox" in t
    },
    XZ = function(t) {
        if (CB(t)) {
            var e = t.getBBox(),
                n = e.width,
                r = e.height;
            return !n && !r
        }
        var i = t,
            s = i.offsetWidth,
            o = i.offsetHeight;
        return !(s || o || t.getClientRects().length)
    },
    ZU = function(t) {
        var e;
        if (t instanceof Element) return !0;
        var n = (e = t == null ? void 0 : t.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView;
        return !!(n && t instanceof n.Element)
    },
    a9e = function(t) {
        switch (t.tagName) {
            case "INPUT":
                if (t.type !== "image") break;
            case "VIDEO":
            case "AUDIO":
            case "EMBED":
            case "OBJECT":
            case "CANVAS":
            case "IFRAME":
            case "IMG":
                return !0
        }
        return !1
    },
    kv = typeof window < "u" ? window : {},
    Z_ = new WeakMap,
    e$ = /auto|scroll/,
    l9e = /^tb|vertical/,
    u9e = /msie|trident/i.test(kv.navigator && kv.navigator.userAgent),
    ll = function(t) {
        return parseFloat(t || "0")
    },
    Sm = function(t, e, n) {
        return t === void 0 && (t = 0), e === void 0 && (e = 0), n === void 0 && (n = !1), new o9e((n ? e : t) || 0, (n ? t : e) || 0)
    },
    t$ = jd({
        devicePixelContentBoxSize: Sm(),
        borderBoxSize: Sm(),
        contentBoxSize: Sm(),
        contentRect: new qZ(0, 0, 0, 0)
    }),
    JZ = function(t, e) {
        if (e === void 0 && (e = !1), Z_.has(t) && !e) return Z_.get(t);
        if (XZ(t)) return Z_.set(t, t$), t$;
        var n = getComputedStyle(t),
            r = CB(t) && t.ownerSVGElement && t.getBBox(),
            i = !u9e && n.boxSizing === "border-box",
            s = l9e.test(n.writingMode || ""),
            o = !r && e$.test(n.overflowY || ""),
            a = !r && e$.test(n.overflowX || ""),
            l = r ? 0 : ll(n.paddingTop),
            u = r ? 0 : ll(n.paddingRight),
            c = r ? 0 : ll(n.paddingBottom),
            f = r ? 0 : ll(n.paddingLeft),
            d = r ? 0 : ll(n.borderTopWidth),
            p = r ? 0 : ll(n.borderRightWidth),
            m = r ? 0 : ll(n.borderBottomWidth),
            y = r ? 0 : ll(n.borderLeftWidth),
            v = f + u,
            b = l + c,
            _ = y + p,
            x = d + m,
            S = a ? t.offsetHeight - x - t.clientHeight : 0,
            E = o ? t.offsetWidth - _ - t.clientWidth : 0,
            A = i ? v + _ : 0,
            T = i ? b + x : 0,
            M = r ? r.width : ll(n.width) - A - E,
            I = r ? r.height : ll(n.height) - T - S,
            O = M + v + E + _,
            k = I + b + S + x,
            H = jd({
                devicePixelContentBoxSize: Sm(Math.round(M * devicePixelRatio), Math.round(I * devicePixelRatio), s),
                borderBoxSize: Sm(O, k, s),
                contentBoxSize: Sm(M, I, s),
                contentRect: new qZ(f, l, M, I)
            });
        return Z_.set(t, H), H
    },
    YZ = function(t, e, n) {
        var r = JZ(t, n),
            i = r.borderBoxSize,
            s = r.contentBoxSize,
            o = r.devicePixelContentBoxSize;
        switch (e) {
            case j0.DEVICE_PIXEL_CONTENT_BOX:
                return o;
            case j0.BORDER_BOX:
                return i;
            default:
                return s
        }
    },
    c9e = function() {
        function t(e) {
            var n = JZ(e);
            this.target = e, this.contentRect = n.contentRect, this.borderBoxSize = jd([n.borderBoxSize]), this.contentBoxSize = jd([n.contentBoxSize]), this.devicePixelContentBoxSize = jd([n.devicePixelContentBoxSize])
        }
        return t
    }(),
    QZ = function(t) {
        if (XZ(t)) return 1 / 0;
        for (var e = 0, n = t.parentNode; n;) e += 1, n = n.parentNode;
        return e
    },
    f9e = function() {
        var t = 1 / 0,
            e = [];
        Vd.forEach(function(o) {
            if (o.activeTargets.length !== 0) {
                var a = [];
                o.activeTargets.forEach(function(u) {
                    var c = new c9e(u.target),
                        f = QZ(u.target);
                    a.push(c), u.lastReportedSize = YZ(u.target, u.observedBox), f < t && (t = f)
                }), e.push(function() {
                    o.callback.call(o.observer, a, o.observer)
                }), o.activeTargets.splice(0, o.activeTargets.length)
            }
        });
        for (var n = 0, r = e; n < r.length; n++) {
            var i = r[n];
            i()
        }
        return t
    },
    n$ = function(t) {
        Vd.forEach(function(n) {
            n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(i) {
                i.isActive() && (QZ(i.target) > t ? n.activeTargets.push(i) : n.skippedTargets.push(i))
            })
        })
    },
    d9e = function() {
        var t = 0;
        for (n$(t); r9e();) t = f9e(), n$(t);
        return i9e() && s9e(), t > 0
    },
    RP, ZZ = [],
    p9e = function() {
        return ZZ.splice(0).forEach(function(t) {
            return t()
        })
    },
    h9e = function(t) {
        if (!RP) {
            var e = 0,
                n = document.createTextNode(""),
                r = {
                    characterData: !0
                };
            new MutationObserver(function() {
                return p9e()
            }).observe(n, r), RP = function() {
                n.textContent = "".concat(e ? e-- : e++)
            }
        }
        ZZ.push(t), RP()
    },
    m9e = function(t) {
        h9e(function() {
            requestAnimationFrame(t)
        })
    },
    WS = 0,
    g9e = function() {
        return !!WS
    },
    y9e = 250,
    v9e = {
        attributes: !0,
        characterData: !0,
        childList: !0,
        subtree: !0
    },
    r$ = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"],
    i$ = function(t) {
        return t === void 0 && (t = 0), Date.now() + t
    },
    OP = !1,
    b9e = function() {
        function t() {
            var e = this;
            this.stopped = !0, this.listener = function() {
                return e.schedule()
            }
        }
        return t.prototype.run = function(e) {
            var n = this;
            if (e === void 0 && (e = y9e), !OP) {
                OP = !0;
                var r = i$(e);
                m9e(function() {
                    var i = !1;
                    try {
                        i = d9e()
                    } finally {
                        if (OP = !1, e = r - i$(), !g9e()) return;
                        i ? n.run(1e3) : e > 0 ? n.run(e) : n.start()
                    }
                })
            }
        }, t.prototype.schedule = function() {
            this.stop(), this.run()
        }, t.prototype.observe = function() {
            var e = this,
                n = function() {
                    return e.observer && e.observer.observe(document.body, v9e)
                };
            document.body ? n() : kv.addEventListener("DOMContentLoaded", n)
        }, t.prototype.start = function() {
            var e = this;
            this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), r$.forEach(function(n) {
                return kv.addEventListener(n, e.listener, !0)
            }))
        }, t.prototype.stop = function() {
            var e = this;
            this.stopped || (this.observer && this.observer.disconnect(), r$.forEach(function(n) {
                return kv.removeEventListener(n, e.listener, !0)
            }), this.stopped = !0)
        }, t
    }(),
    TO = new b9e,
    s$ = function(t) {
        !WS && t > 0 && TO.start(), WS += t, !WS && TO.stop()
    },
    x9e = function(t) {
        return !CB(t) && !a9e(t) && getComputedStyle(t).display === "inline"
    },
    _9e = function() {
        function t(e, n) {
            this.target = e, this.observedBox = n || j0.CONTENT_BOX, this.lastReportedSize = {
                inlineSize: 0,
                blockSize: 0
            }
        }
        return t.prototype.isActive = function() {
            var e = YZ(this.target, this.observedBox, !0);
            return x9e(this.target) && (this.lastReportedSize = e), this.lastReportedSize.inlineSize !== e.inlineSize || this.lastReportedSize.blockSize !== e.blockSize
        }, t
    }(),
    S9e = function() {
        function t(e, n) {
            this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = e, this.callback = n
        }
        return t
    }(),
    eS = new WeakMap,
    o$ = function(t, e) {
        for (var n = 0; n < t.length; n += 1)
            if (t[n].target === e) return n;
        return -1
    },
    tS = function() {
        function t() {}
        return t.connect = function(e, n) {
            var r = new S9e(e, n);
            eS.set(e, r)
        }, t.observe = function(e, n, r) {
            var i = eS.get(e),
                s = i.observationTargets.length === 0;
            o$(i.observationTargets, n) < 0 && (s && Vd.push(i), i.observationTargets.push(new _9e(n, r && r.box)), s$(1), TO.schedule())
        }, t.unobserve = function(e, n) {
            var r = eS.get(e),
                i = o$(r.observationTargets, n),
                s = r.observationTargets.length === 1;
            i >= 0 && (s && Vd.splice(Vd.indexOf(r), 1), r.observationTargets.splice(i, 1), s$(-1))
        }, t.disconnect = function(e) {
            var n = this,
                r = eS.get(e);
            r.observationTargets.slice().forEach(function(i) {
                return n.unobserve(e, i.target)
            }), r.activeTargets.splice(0, r.activeTargets.length)
        }, t
    }(),
    w9e = function() {
        function t(e) {
            if (arguments.length === 0) throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
            if (typeof e != "function") throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
            tS.connect(this, e)
        }
        return t.prototype.observe = function(e, n) {
            if (arguments.length === 0) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
            if (!ZU(e)) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
            tS.observe(this, e, n)
        }, t.prototype.unobserve = function(e) {
            if (arguments.length === 0) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
            if (!ZU(e)) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
            tS.unobserve(this, e)
        }, t.prototype.disconnect = function() {
            tS.disconnect(this)
        }, t.toString = function() {
            return "function ResizeObserver () { [polyfill code] }"
        }, t
    }();
const E9e = Bt[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"],
    A9e = E9e,
    C9e = t => {
        const e = P.useRef(t);
        return P.useEffect(() => {
            e.current = t
        }), e
    },
    M9e = C9e,
    T9e = typeof window < "u" && "ResizeObserver" in window ? window.ResizeObserver : w9e;

function P9e() {}

function YUe(t, e) {
    const n = R9e(),
        r = M9e(e);
    return A9e(() => {
        let i = !1;
        const s = t && "current" in t ? t.current : t;
        if (!s) return P9e;

        function o(a, l) {
            i || r.current(a, l)
        }
        return n.subscribe(s, o), () => {
            i = !0, n.unsubscribe(s, o)
        }
    }, [t, n, r]), n.observer
}

function I9e() {
    let t = !1,
        e = [];
    const n = new Map,
        r = new T9e((i, s) => {
            e = e.concat(i);

            function o() {
                const a = new Set;
                for (let l = 0; l < e.length; l++) {
                    if (a.has(e[l].target)) continue;
                    a.add(e[l].target);
                    const u = n.get(e[l].target);
                    u == null || u.forEach(c => c(e[l], s))
                }
                e = [], t = !1
            }
            t || window.requestAnimationFrame(o), t = !0
        });
    return {
        observer: r,
        subscribe(i, s) {
            var o;
            r.observe(i);
            const a = (o = n.get(i)) !== null && o !== void 0 ? o : [];
            a.push(s), n.set(i, a)
        },
        unsubscribe(i, s) {
            var o;
            const a = (o = n.get(i)) !== null && o !== void 0 ? o : [];
            if (a.length === 1) {
                r.unobserve(i), n.delete(i);
                return
            }
            const l = a.indexOf(s);
            l !== -1 && a.splice(l, 1), n.set(i, a)
        }
    }
}
let DP;
const R9e = () => DP || (DP = I9e());
var MB = fb(),
    Zt = t => cb(t, MB),
    TB = fb();
Zt.write = t => cb(t, TB);
var QA = fb();
Zt.onStart = t => cb(t, QA);
var PB = fb();
Zt.onFrame = t => cb(t, PB);
var IB = fb();
Zt.onFinish = t => cb(t, IB);
var wm = [];
Zt.setTimeout = (t, e) => {
    let n = Zt.now() + e,
        r = () => {
            let s = wm.findIndex(o => o.cancel == r);
            ~s && wm.splice(s, 1), Uc -= ~s ? 1 : 0
        },
        i = {
            time: n,
            handler: t,
            cancel: r
        };
    return wm.splice(eee(n), 0, i), Uc += 1, tee(), i
};
var eee = t => ~(~wm.findIndex(e => e.time > t) || ~wm.length);
Zt.cancel = t => {
    QA.delete(t), PB.delete(t), IB.delete(t), MB.delete(t), TB.delete(t)
};
Zt.sync = t => {
    PO = !0, Zt.batchedUpdates(t), PO = !1
};
Zt.throttle = t => {
    let e;

    function n() {
        try {
            t(...e)
        } finally {
            e = null
        }
    }

    function r(...i) {
        e = i, Zt.onStart(n)
    }
    return r.handler = t, r.cancel = () => {
        QA.delete(n), e = null
    }, r
};
var RB = typeof window < "u" ? window.requestAnimationFrame : () => {};
Zt.use = t => RB = t;
Zt.now = typeof performance < "u" ? () => performance.now() : Date.now;
Zt.batchedUpdates = t => t();
Zt.catch = console.error;
Zt.frameLoop = "always";
Zt.advance = () => {
    Zt.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : ree()
};
var Hc = -1,
    Uc = 0,
    PO = !1;

function cb(t, e) {
    PO ? (e.delete(t), t(0)) : (e.add(t), tee())
}

function tee() {
    Hc < 0 && (Hc = 0, Zt.frameLoop !== "demand" && RB(nee))
}

function O9e() {
    Hc = -1
}

function nee() {
    ~Hc && (RB(nee), Zt.batchedUpdates(ree))
}

function ree() {
    let t = Hc;
    Hc = Zt.now();
    let e = eee(Hc);
    if (e && (iee(wm.splice(0, e), n => n.handler()), Uc -= e), !Uc) {
        O9e();
        return
    }
    QA.flush(), MB.flush(t ? Math.min(64, Hc - t) : 16.667), PB.flush(), TB.flush(), IB.flush()
}

function fb() {
    let t = new Set,
        e = t;
    return {
        add(n) {
            Uc += e == t && !t.has(n) ? 1 : 0, t.add(n)
        },
        delete(n) {
            return Uc -= e == t && t.has(n) ? 1 : 0, t.delete(n)
        },
        flush(n) {
            e.size && (t = new Set, Uc -= e.size, iee(e, r => r(n) && t.add(r)), Uc += t.size, e = t)
        }
    }
}

function iee(t, e) {
    t.forEach(n => {
        try {
            e(n)
        } catch (r) {
            Zt.catch(r)
        }
    })
}
var D9e = Object.defineProperty,
    L9e = (t, e) => {
        for (var n in e) D9e(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Ka = {};
L9e(Ka, {
    assign: () => B9e,
    colors: () => nf,
    createStringInterpolator: () => DB,
    skipAnimation: () => oee,
    to: () => see,
    willAdvance: () => LB
});

function IO() {}
var k9e = (t, e, n) => Object.defineProperty(t, e, {
        value: n,
        writable: !0,
        configurable: !0
    }),
    it = {
        arr: Array.isArray,
        obj: t => !!t && t.constructor.name === "Object",
        fun: t => typeof t == "function",
        str: t => typeof t == "string",
        num: t => typeof t == "number",
        und: t => t === void 0
    };

function pu(t, e) {
    if (it.arr(t)) {
        if (!it.arr(e) || t.length !== e.length) return !1;
        for (let n = 0; n < t.length; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }
    return t === e
}
var $n = (t, e) => t.forEach(e);

function $u(t, e, n) {
    if (it.arr(t)) {
        for (let r = 0; r < t.length; r++) e.call(n, t[r], `${r}`);
        return
    }
    for (let r in t) t.hasOwnProperty(r) && e.call(n, t[r], r)
}
var Xo = t => it.und(t) ? [] : it.arr(t) ? t : [t];

function Bv(t, e) {
    if (t.size) {
        let n = Array.from(t);
        t.clear(), $n(n, e)
    }
}
var nv = (t, ...e) => Bv(t, n => n(...e)),
    OB = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    DB, see, nf = null,
    oee = !1,
    LB = IO,
    B9e = t => {
        t.to && (see = t.to), t.now && (Zt.now = t.now), t.colors !== void 0 && (nf = t.colors), t.skipAnimation != null && (oee = t.skipAnimation), t.createStringInterpolator && (DB = t.createStringInterpolator), t.requestAnimationFrame && Zt.use(t.requestAnimationFrame), t.batchedUpdates && (Zt.batchedUpdates = t.batchedUpdates), t.willAdvance && (LB = t.willAdvance), t.frameLoop && (Zt.frameLoop = t.frameLoop)
    },
    Fv = new Set,
    jo = [],
    LP = [],
    A2 = 0,
    ZA = {
        get idle() {
            return !Fv.size && !jo.length
        },
        start(t) {
            A2 > t.priority ? (Fv.add(t), Zt.onStart(F9e)) : (aee(t), Zt(RO))
        },
        advance: RO,
        sort(t) {
            if (A2) Zt.onFrame(() => ZA.sort(t));
            else {
                let e = jo.indexOf(t);
                ~e && (jo.splice(e, 1), lee(t))
            }
        },
        clear() {
            jo = [], Fv.clear()
        }
    };

function F9e() {
    Fv.forEach(aee), Fv.clear(), Zt(RO)
}

function aee(t) {
    jo.includes(t) || lee(t)
}

function lee(t) {
    jo.splice(N9e(jo, e => e.priority > t.priority), 0, t)
}

function RO(t) {
    let e = LP;
    for (let n = 0; n < jo.length; n++) {
        let r = jo[n];
        A2 = r.priority, r.idle || (LB(r), r.advance(t), r.idle || e.push(r))
    }
    return A2 = 0, LP = jo, LP.length = 0, jo = e, jo.length > 0
}

function N9e(t, e) {
    let n = t.findIndex(e);
    return n < 0 ? t.length : n
}
var z9e = (t, e, n) => Math.min(Math.max(n, t), e),
    H9e = {
        transparent: 0,
        aliceblue: 4042850303,
        antiquewhite: 4209760255,
        aqua: 16777215,
        aquamarine: 2147472639,
        azure: 4043309055,
        beige: 4126530815,
        bisque: 4293182719,
        black: 255,
        blanchedalmond: 4293643775,
        blue: 65535,
        blueviolet: 2318131967,
        brown: 2771004159,
        burlywood: 3736635391,
        burntsienna: 3934150143,
        cadetblue: 1604231423,
        chartreuse: 2147418367,
        chocolate: 3530104575,
        coral: 4286533887,
        cornflowerblue: 1687547391,
        cornsilk: 4294499583,
        crimson: 3692313855,
        cyan: 16777215,
        darkblue: 35839,
        darkcyan: 9145343,
        darkgoldenrod: 3095792639,
        darkgray: 2846468607,
        darkgreen: 6553855,
        darkgrey: 2846468607,
        darkkhaki: 3182914559,
        darkmagenta: 2332068863,
        darkolivegreen: 1433087999,
        darkorange: 4287365375,
        darkorchid: 2570243327,
        darkred: 2332033279,
        darksalmon: 3918953215,
        darkseagreen: 2411499519,
        darkslateblue: 1211993087,
        darkslategray: 793726975,
        darkslategrey: 793726975,
        darkturquoise: 13554175,
        darkviolet: 2483082239,
        deeppink: 4279538687,
        deepskyblue: 12582911,
        dimgray: 1768516095,
        dimgrey: 1768516095,
        dodgerblue: 512819199,
        firebrick: 2988581631,
        floralwhite: 4294635775,
        forestgreen: 579543807,
        fuchsia: 4278255615,
        gainsboro: 3705462015,
        ghostwhite: 4177068031,
        gold: 4292280575,
        goldenrod: 3668254975,
        gray: 2155905279,
        green: 8388863,
        greenyellow: 2919182335,
        grey: 2155905279,
        honeydew: 4043305215,
        hotpink: 4285117695,
        indianred: 3445382399,
        indigo: 1258324735,
        ivory: 4294963455,
        khaki: 4041641215,
        lavender: 3873897215,
        lavenderblush: 4293981695,
        lawngreen: 2096890111,
        lemonchiffon: 4294626815,
        lightblue: 2916673279,
        lightcoral: 4034953471,
        lightcyan: 3774873599,
        lightgoldenrodyellow: 4210742015,
        lightgray: 3553874943,
        lightgreen: 2431553791,
        lightgrey: 3553874943,
        lightpink: 4290167295,
        lightsalmon: 4288707327,
        lightseagreen: 548580095,
        lightskyblue: 2278488831,
        lightslategray: 2005441023,
        lightslategrey: 2005441023,
        lightsteelblue: 2965692159,
        lightyellow: 4294959359,
        lime: 16711935,
        limegreen: 852308735,
        linen: 4210091775,
        magenta: 4278255615,
        maroon: 2147483903,
        mediumaquamarine: 1724754687,
        mediumblue: 52735,
        mediumorchid: 3126187007,
        mediumpurple: 2473647103,
        mediumseagreen: 1018393087,
        mediumslateblue: 2070474495,
        mediumspringgreen: 16423679,
        mediumturquoise: 1221709055,
        mediumvioletred: 3340076543,
        midnightblue: 421097727,
        mintcream: 4127193855,
        mistyrose: 4293190143,
        moccasin: 4293178879,
        navajowhite: 4292783615,
        navy: 33023,
        oldlace: 4260751103,
        olive: 2155872511,
        olivedrab: 1804477439,
        orange: 4289003775,
        orangered: 4282712319,
        orchid: 3664828159,
        palegoldenrod: 4008225535,
        palegreen: 2566625535,
        paleturquoise: 2951671551,
        palevioletred: 3681588223,
        papayawhip: 4293907967,
        peachpuff: 4292524543,
        peru: 3448061951,
        pink: 4290825215,
        plum: 3718307327,
        powderblue: 2967529215,
        purple: 2147516671,
        rebeccapurple: 1714657791,
        red: 4278190335,
        rosybrown: 3163525119,
        royalblue: 1097458175,
        saddlebrown: 2336560127,
        salmon: 4202722047,
        sandybrown: 4104413439,
        seagreen: 780883967,
        seashell: 4294307583,
        sienna: 2689740287,
        silver: 3233857791,
        skyblue: 2278484991,
        slateblue: 1784335871,
        slategray: 1887473919,
        slategrey: 1887473919,
        snow: 4294638335,
        springgreen: 16744447,
        steelblue: 1182971135,
        tan: 3535047935,
        teal: 8421631,
        thistle: 3636451583,
        tomato: 4284696575,
        turquoise: 1088475391,
        violet: 4001558271,
        wheat: 4125012991,
        white: 4294967295,
        whitesmoke: 4126537215,
        yellow: 4294902015,
        yellowgreen: 2597139199
    },
    ka = "[-+]?\\d*\\.?\\d+",
    C2 = ka + "%";

function eC(...t) {
    return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)"
}
var U9e = new RegExp("rgb" + eC(ka, ka, ka)),
    $9e = new RegExp("rgba" + eC(ka, ka, ka, ka)),
    G9e = new RegExp("hsl" + eC(ka, C2, C2)),
    V9e = new RegExp("hsla" + eC(ka, C2, C2, ka)),
    j9e = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    W9e = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    K9e = /^#([0-9a-fA-F]{6})$/,
    q9e = /^#([0-9a-fA-F]{8})$/;

function X9e(t) {
    let e;
    return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = K9e.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : nf && nf[t] !== void 0 ? nf[t] : (e = U9e.exec(t)) ? (mh(e[1]) << 24 | mh(e[2]) << 16 | mh(e[3]) << 8 | 255) >>> 0 : (e = $9e.exec(t)) ? (mh(e[1]) << 24 | mh(e[2]) << 16 | mh(e[3]) << 8 | u$(e[4])) >>> 0 : (e = j9e.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = q9e.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = W9e.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = G9e.exec(t)) ? (a$(l$(e[1]), nS(e[2]), nS(e[3])) | 255) >>> 0 : (e = V9e.exec(t)) ? (a$(l$(e[1]), nS(e[2]), nS(e[3])) | u$(e[4])) >>> 0 : null
}

function kP(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}

function a$(t, e, n) {
    let r = n < .5 ? n * (1 + e) : n + e - n * e,
        i = 2 * n - r,
        s = kP(i, r, t + 1 / 3),
        o = kP(i, r, t),
        a = kP(i, r, t - 1 / 3);
    return Math.round(s * 255) << 24 | Math.round(o * 255) << 16 | Math.round(a * 255) << 8
}

function mh(t) {
    let e = parseInt(t, 10);
    return e < 0 ? 0 : e > 255 ? 255 : e
}

function l$(t) {
    return (parseFloat(t) % 360 + 360) % 360 / 360
}

function u$(t) {
    let e = parseFloat(t);
    return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255)
}

function nS(t) {
    let e = parseFloat(t);
    return e < 0 ? 0 : e > 100 ? 1 : e / 100
}

function c$(t) {
    let e = X9e(t);
    if (e === null) return t;
    e = e || 0;
    let n = (e & 4278190080) >>> 24,
        r = (e & 16711680) >>> 16,
        i = (e & 65280) >>> 8,
        s = (e & 255) / 255;
    return `rgba(${n}, ${r}, ${i}, ${s})`
}
var W0 = (t, e, n) => {
    if (it.fun(t)) return t;
    if (it.arr(t)) return W0({
        range: t,
        output: e,
        extrapolate: n
    });
    if (it.str(t.output[0])) return DB(t);
    let r = t,
        i = r.output,
        s = r.range || [0, 1],
        o = r.extrapolateLeft || r.extrapolate || "extend",
        a = r.extrapolateRight || r.extrapolate || "extend",
        l = r.easing || (u => u);
    return u => {
        let c = Y9e(u, s);
        return J9e(u, s[c], s[c + 1], i[c], i[c + 1], l, o, a, r.map)
    }
};

function J9e(t, e, n, r, i, s, o, a, l) {
    let u = l ? l(t) : t;
    if (u < e) {
        if (o === "identity") return u;
        o === "clamp" && (u = e)
    }
    if (u > n) {
        if (a === "identity") return u;
        a === "clamp" && (u = n)
    }
    return r === i ? r : e === n ? t <= e ? r : i : (e === -1 / 0 ? u = -u : n === 1 / 0 ? u = u - e : u = (u - e) / (n - e), u = s(u), r === -1 / 0 ? u = -u : i === 1 / 0 ? u = u + r : u = u * (i - r) + r, u)
}

function Y9e(t, e) {
    for (var n = 1; n < e.length - 1 && !(e[n] >= t); ++n);
    return n - 1
}
var Q9e = (t, e = "end") => n => {
        n = e === "end" ? Math.min(n, .999) : Math.max(n, .001);
        let r = n * t,
            i = e === "end" ? Math.floor(r) : Math.ceil(r);
        return z9e(0, 1, i / t)
    },
    M2 = 1.70158,
    rS = M2 * 1.525,
    f$ = M2 + 1,
    d$ = 2 * Math.PI / 3,
    p$ = 2 * Math.PI / 4.5,
    iS = t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
    Z9e = {
        linear: t => t,
        easeInQuad: t => t * t,
        easeOutQuad: t => 1 - (1 - t) * (1 - t),
        easeInOutQuad: t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
        easeInCubic: t => t * t * t,
        easeOutCubic: t => 1 - Math.pow(1 - t, 3),
        easeInOutCubic: t => t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
        easeInQuart: t => t * t * t * t,
        easeOutQuart: t => 1 - Math.pow(1 - t, 4),
        easeInOutQuart: t => t < .5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
        easeInQuint: t => t * t * t * t * t,
        easeOutQuint: t => 1 - Math.pow(1 - t, 5),
        easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
        easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
        easeOutSine: t => Math.sin(t * Math.PI / 2),
        easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
        easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
        easeOutExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
        easeInOutExpo: t => t === 0 ? 0 : t === 1 ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
        easeInCirc: t => 1 - Math.sqrt(1 - Math.pow(t, 2)),
        easeOutCirc: t => Math.sqrt(1 - Math.pow(t - 1, 2)),
        easeInOutCirc: t => t < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
        easeInBack: t => f$ * t * t * t - M2 * t * t,
        easeOutBack: t => 1 + f$ * Math.pow(t - 1, 3) + M2 * Math.pow(t - 1, 2),
        easeInOutBack: t => t < .5 ? Math.pow(2 * t, 2) * ((rS + 1) * 2 * t - rS) / 2 : (Math.pow(2 * t - 2, 2) * ((rS + 1) * (t * 2 - 2) + rS) + 2) / 2,
        easeInElastic: t => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * d$),
        easeOutElastic: t => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - .75) * d$) + 1,
        easeInOutElastic: t => t === 0 ? 0 : t === 1 ? 1 : t < .5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * p$)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * p$) / 2 + 1,
        easeInBounce: t => 1 - iS(1 - t),
        easeOutBounce: iS,
        easeInOutBounce: t => t < .5 ? (1 - iS(1 - 2 * t)) / 2 : (1 + iS(2 * t - 1)) / 2,
        steps: Q9e
    },
    cg = Symbol.for("FluidValue.get"),
    hp = Symbol.for("FluidValue.observers"),
    yl = t => !!(t && t[cg]),
    Fo = t => t && t[cg] ? t[cg]() : t,
    h$ = t => t[hp] || null;

function eze(t, e) {
    t.eventObserved ? t.eventObserved(e) : t(e)
}

function T2(t, e) {
    let n = t[hp];
    n && n.forEach(r => {
        eze(r, e)
    })
}
var Wze, Kze, I$, tze = (I$ = class {
        constructor(t) {
            Ct(this, Wze);
            Ct(this, Kze);
            if (!t && !(t = this.get)) throw Error("Unknown getter");
            nze(this, t)
        }
    }, Wze = cg, Kze = hp, I$),
    nze = (t, e) => uee(t, cg, e);

function db(t, e) {
    if (t[cg]) {
        let n = t[hp];
        n || uee(t, hp, n = new Set), n.has(e) || (n.add(e), t.observerAdded && t.observerAdded(n.size, e))
    }
    return e
}

function P2(t, e) {
    let n = t[hp];
    if (n && n.has(e)) {
        let r = n.size - 1;
        r ? n.delete(e) : t[hp] = null, t.observerRemoved && t.observerRemoved(r, e)
    }
}
var uee = (t, e, n) => Object.defineProperty(t, e, {
        value: n,
        writable: !0,
        configurable: !0
    }),
    KS = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
    rze = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,
    m$ = new RegExp(`(${KS.source})(%|[a-z]+)`, "i"),
    ize = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,
    tC = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
    cee = t => {
        let [e, n] = sze(t);
        if (!e || OB()) return t;
        let r = window.getComputedStyle(document.documentElement).getPropertyValue(e);
        return r ? r.trim() : n && n.startsWith("--") ? window.getComputedStyle(document.documentElement).getPropertyValue(n) || t : n && tC.test(n) ? cee(n) : n || t
    },
    sze = t => {
        let e = tC.exec(t);
        if (!e) return [, ];
        let [, n, r] = e;
        return [n, r]
    },
    BP, oze = (t, e, n, r, i) => `rgba(${Math.round(e)}, ${Math.round(n)}, ${Math.round(r)}, ${i})`,
    fee = t => {
        BP || (BP = nf ? new RegExp(`(${Object.keys(nf).join("|")})(?!\\w)`, "g") : /^\b$/);
        let e = t.output.map(i => Fo(i).replace(tC, cee).replace(rze, c$).replace(BP, c$)),
            n = e.map(i => i.match(KS).map(Number)),
            r = n[0].map((i, s) => n.map(o => {
                if (!(s in o)) throw Error('The arity of each "output" value must be equal');
                return o[s]
            })).map(i => W0({ ...t,
                output: i
            }));
        return i => {
            var a;
            let s = !m$.test(e[0]) && ((a = e.find(l => m$.test(l))) == null ? void 0 : a.replace(KS, "")),
                o = 0;
            return e[0].replace(KS, () => `${r[o++](i)}${s||""}`).replace(ize, oze)
        }
    },
    kB = "react-spring: ",
    dee = t => {
        let e = t,
            n = !1;
        if (typeof e != "function") throw new TypeError(`${kB}once requires a function parameter`);
        return (...r) => {
            n || (e(...r), n = !0)
        }
    },
    aze = dee(console.warn);

function lze() {
    aze(`${kB}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
var uze = dee(console.warn);

function cze() {
    uze(`${kB}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
}

function nC(t) {
    return it.str(t) && (t[0] == "#" || /\d/.test(t) || !OB() && tC.test(t) || t in (nf || {}))
}
var BB = OB() ? P.useEffect : P.useLayoutEffect,
    fze = () => {
        let t = P.useRef(!1);
        return BB(() => (t.current = !0, () => {
            t.current = !1
        }), []), t
    };

function pee() {
    let t = P.useState()[1],
        e = fze();
    return () => {
        e.current && t(Math.random())
    }
}

function dze(t, e) {
    let [n] = P.useState(() => ({
        inputs: e,
        result: t()
    })), r = P.useRef(), i = r.current, s = i;
    return s ? e && s.inputs && pze(e, s.inputs) || (s = {
        inputs: e,
        result: t()
    }) : s = n, P.useEffect(() => {
        r.current = s, i == n && (n.inputs = n.result = void 0)
    }, [s]), s.result
}

function pze(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}
var hee = t => P.useEffect(t, hze),
    hze = [];

function g$(t) {
    let e = P.useRef();
    return P.useEffect(() => {
        e.current = t
    }), e.current
}
var K0 = Symbol.for("Animated:node"),
    mze = t => !!t && t[K0] === t,
    dl = t => t && t[K0],
    FB = (t, e) => k9e(t, K0, e),
    rC = t => t && t[K0] && t[K0].getPayload(),
    mee = class {
        constructor() {
            Ct(this, "payload");
            FB(this, this)
        }
        getPayload() {
            return this.payload || []
        }
    },
    pb = class extends mee {
        constructor(e) {
            super();
            Ct(this, "done", !0);
            Ct(this, "elapsedTime");
            Ct(this, "lastPosition");
            Ct(this, "lastVelocity");
            Ct(this, "v0");
            Ct(this, "durationProgress", 0);
            this._value = e, it.num(this._value) && (this.lastPosition = this._value)
        }
        static create(e) {
            return new pb(e)
        }
        getPayload() {
            return [this]
        }
        getValue() {
            return this._value
        }
        setValue(e, n) {
            return it.num(e) && (this.lastPosition = e, n && (e = Math.round(e / n) * n, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0)
        }
        reset() {
            let {
                done: e
            } = this;
            this.done = !1, it.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null)
        }
    },
    q0 = class extends pb {
        constructor(e) {
            super(0);
            Ct(this, "_string", null);
            Ct(this, "_toString");
            this._toString = W0({
                output: [e, e]
            })
        }
        static create(e) {
            return new q0(e)
        }
        getValue() {
            return this._string ? ? (this._string = this._toString(this._value))
        }
        setValue(e) {
            if (it.str(e)) {
                if (e == this._string) return !1;
                this._string = e, this._value = 1
            } else if (super.setValue(e)) this._string = null;
            else return !1;
            return !0
        }
        reset(e) {
            e && (this._toString = W0({
                output: [this.getValue(), e]
            })), this._value = 0, super.reset()
        }
    },
    I2 = {
        dependencies: null
    },
    NB = class extends mee {
        constructor(t) {
            super(), this.source = t, this.setValue(t)
        }
        getValue(t) {
            let e = {};
            return $u(this.source, (n, r) => {
                mze(n) ? e[r] = n.getValue(t) : yl(n) ? e[r] = Fo(n) : t || (e[r] = n)
            }), e
        }
        setValue(t) {
            this.source = t, this.payload = this._makePayload(t)
        }
        reset() {
            this.payload && $n(this.payload, t => t.reset())
        }
        _makePayload(t) {
            if (t) {
                let e = new Set;
                return $u(t, this._addToPayload, e), Array.from(e)
            }
        }
        _addToPayload(t) {
            I2.dependencies && yl(t) && I2.dependencies.add(t);
            let e = rC(t);
            e && $n(e, n => this.add(n))
        }
    },
    gee = class extends NB {
        constructor(t) {
            super(t)
        }
        static create(t) {
            return new gee(t)
        }
        getValue() {
            return this.source.map(t => t.getValue())
        }
        setValue(t) {
            let e = this.getPayload();
            return t.length == e.length ? e.map((n, r) => n.setValue(t[r])).some(Boolean) : (super.setValue(t.map(gze)), !0)
        }
    };

function gze(t) {
    return (nC(t) ? q0 : pb).create(t)
}

function OO(t) {
    let e = dl(t);
    return e ? e.constructor : it.arr(t) ? gee : nC(t) ? q0 : pb
}
var y$ = (t, e) => {
        let n = !it.fun(t) || t.prototype && t.prototype.isReactComponent;
        return P.forwardRef((r, i) => {
            let s = P.useRef(null),
                o = n && P.useCallback(m => {
                    s.current = bze(i, m)
                }, [i]),
                [a, l] = vze(r, e),
                u = pee(),
                c = () => {
                    let m = s.current;
                    n && !m || (m ? e.applyAnimatedValues(m, a.getValue(!0)) : !1) === !1 && u()
                },
                f = new yze(c, l),
                d = P.useRef();
            BB(() => (d.current = f, $n(l, m => db(m, f)), () => {
                d.current && ($n(d.current.deps, m => P2(m, d.current)), Zt.cancel(d.current.update))
            })), P.useEffect(c, []), hee(() => () => {
                let m = d.current;
                $n(m.deps, y => P2(y, m))
            });
            let p = e.getComponentProps(a.getValue());
            return P.createElement(t, { ...p,
                ref: o
            })
        })
    },
    yze = class {
        constructor(t, e) {
            this.update = t, this.deps = e
        }
        eventObserved(t) {
            t.type == "change" && Zt.write(this.update)
        }
    };

function vze(t, e) {
    let n = new Set;
    return I2.dependencies = n, t.style && (t = { ...t,
        style: e.createAnimatedStyle(t.style)
    }), t = new NB(t), I2.dependencies = null, [t, n]
}

function bze(t, e) {
    return t && (it.fun(t) ? t(e) : t.current = e), e
}
var v$ = Symbol.for("AnimatedComponent"),
    xze = (t, {
        applyAnimatedValues: e = () => !1,
        createAnimatedStyle: n = i => new NB(i),
        getComponentProps: r = i => i
    } = {}) => {
        let i = {
                applyAnimatedValues: e,
                createAnimatedStyle: n,
                getComponentProps: r
            },
            s = o => {
                let a = b$(o) || "Anonymous";
                return it.str(o) ? o = s[o] || (s[o] = y$(o, i)) : o = o[v$] || (o[v$] = y$(o, i)), o.displayName = `Animated(${a})`, o
            };
        return $u(t, (o, a) => {
            it.arr(t) && (a = b$(o)), s[a] = s(o)
        }), {
            animated: s
        }
    },
    b$ = t => it.str(t) ? t : t && it.str(t.displayName) ? t.displayName : it.fun(t) && t.name || null;

function dd(t, ...e) {
    return it.fun(t) ? t(...e) : t
}
var Nv = (t, e) => t === !0 || !!(e && t && (it.fun(t) ? t(e) : Xo(t).includes(e))),
    yee = (t, e) => it.obj(t) ? e && t[e] : t,
    vee = (t, e) => t.default === !0 ? t[e] : t.default ? t.default[e] : void 0,
    _ze = t => t,
    zB = (t, e = _ze) => {
        let n = Sze;
        t.default && t.default !== !0 && (t = t.default, n = Object.keys(t));
        let r = {};
        for (let i of n) {
            let s = e(t[i], i);
            it.und(s) || (r[i] = s)
        }
        return r
    },
    Sze = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"],
    wze = {
        config: 1,
        from: 1,
        to: 1,
        ref: 1,
        loop: 1,
        reset: 1,
        pause: 1,
        cancel: 1,
        reverse: 1,
        immediate: 1,
        default: 1,
        delay: 1,
        onProps: 1,
        onStart: 1,
        onChange: 1,
        onPause: 1,
        onResume: 1,
        onRest: 1,
        onResolve: 1,
        items: 1,
        trail: 1,
        sort: 1,
        expires: 1,
        initial: 1,
        enter: 1,
        update: 1,
        leave: 1,
        children: 1,
        onDestroyed: 1,
        keys: 1,
        callId: 1,
        parentId: 1
    };

function Eze(t) {
    let e = {},
        n = 0;
    if ($u(t, (r, i) => {
            wze[i] || (e[i] = r, n++)
        }), n) return e
}

function bee(t) {
    let e = Eze(t);
    if (e) {
        let n = {
            to: e
        };
        return $u(t, (r, i) => i in e || (n[i] = r)), n
    }
    return { ...t
    }
}

function X0(t) {
    return t = Fo(t), it.arr(t) ? t.map(X0) : nC(t) ? Ka.createStringInterpolator({
        range: [0, 1],
        output: [t, t]
    })(1) : t
}

function Aze(t) {
    for (let e in t) return !0;
    return !1
}

function DO(t) {
    return it.fun(t) || it.arr(t) && it.obj(t[0])
}

function Cze(t, e) {
    var n;
    (n = t.ref) == null || n.delete(t), e == null || e.delete(t)
}

function Mze(t, e) {
    var n;
    e && t.ref !== e && ((n = t.ref) == null || n.delete(t), e.add(t), t.ref = e)
}
var Tze = {
        default: {
            tension: 170,
            friction: 26
        },
        gentle: {
            tension: 120,
            friction: 14
        },
        wobbly: {
            tension: 180,
            friction: 12
        },
        stiff: {
            tension: 210,
            friction: 20
        },
        slow: {
            tension: 280,
            friction: 60
        },
        molasses: {
            tension: 280,
            friction: 120
        }
    },
    LO = { ...Tze.default,
        mass: 1,
        damping: 1,
        easing: Z9e.linear,
        clamp: !1
    },
    Pze = class {
        constructor() {
            Ct(this, "tension");
            Ct(this, "friction");
            Ct(this, "frequency");
            Ct(this, "damping");
            Ct(this, "mass");
            Ct(this, "velocity", 0);
            Ct(this, "restVelocity");
            Ct(this, "precision");
            Ct(this, "progress");
            Ct(this, "duration");
            Ct(this, "easing");
            Ct(this, "clamp");
            Ct(this, "bounce");
            Ct(this, "decay");
            Ct(this, "round");
            Object.assign(this, LO)
        }
    };

function Ize(t, e, n) {
    n && (n = { ...n
    }, x$(n, e), e = { ...n,
        ...e
    }), x$(t, e), Object.assign(t, e);
    for (let o in LO) t[o] == null && (t[o] = LO[o]);
    let {
        mass: r,
        frequency: i,
        damping: s
    } = t;
    return it.und(i) || (i < .01 && (i = .01), s < 0 && (s = 0), t.tension = Math.pow(2 * Math.PI / i, 2) * r, t.friction = 4 * Math.PI * s * r / i), t
}

function x$(t, e) {
    if (!it.und(e.decay)) t.duration = void 0;
    else {
        let n = !it.und(e.tension) || !it.und(e.friction);
        (n || !it.und(e.frequency) || !it.und(e.damping) || !it.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0)
    }
}
var _$ = [],
    Rze = class {
        constructor() {
            Ct(this, "changed", !1);
            Ct(this, "values", _$);
            Ct(this, "toValues", null);
            Ct(this, "fromValues", _$);
            Ct(this, "to");
            Ct(this, "from");
            Ct(this, "config", new Pze);
            Ct(this, "immediate", !1)
        }
    };

function xee(t, {
    key: e,
    props: n,
    defaultProps: r,
    state: i,
    actions: s
}) {
    return new Promise((o, a) => {
        let l, u, c = Nv(n.cancel ? ? (r == null ? void 0 : r.cancel), e);
        if (c) p();
        else {
            it.und(n.pause) || (i.paused = Nv(n.pause, e));
            let m = r == null ? void 0 : r.pause;
            m !== !0 && (m = i.paused || Nv(m, e)), l = dd(n.delay || 0, e), m ? (i.resumeQueue.add(d), s.pause()) : (s.resume(), d())
        }

        function f() {
            i.resumeQueue.add(d), i.timeouts.delete(u), u.cancel(), l = u.time - Zt.now()
        }

        function d() {
            l > 0 && !Ka.skipAnimation ? (i.delayed = !0, u = Zt.setTimeout(p, l), i.pauseQueue.add(f), i.timeouts.add(u)) : p()
        }

        function p() {
            i.delayed && (i.delayed = !1), i.pauseQueue.delete(f), i.timeouts.delete(u), t <= (i.cancelId || 0) && (c = !0);
            try {
                s.start({ ...n,
                    callId: t,
                    cancel: c
                }, o)
            } catch (m) {
                a(m)
            }
        }
    })
}
var HB = (t, e) => e.length == 1 ? e[0] : e.some(n => n.cancelled) ? Em(t.get()) : e.every(n => n.noop) ? _ee(t.get()) : Pa(t.get(), e.every(n => n.finished)),
    _ee = t => ({
        value: t,
        noop: !0,
        finished: !0,
        cancelled: !1
    }),
    Pa = (t, e, n = !1) => ({
        value: t,
        finished: e,
        cancelled: n
    }),
    Em = t => ({
        value: t,
        cancelled: !0,
        finished: !1
    });

function See(t, e, n, r) {
    let {
        callId: i,
        parentId: s,
        onRest: o
    } = e, {
        asyncTo: a,
        promise: l
    } = n;
    return !s && t === a && !e.reset ? l : n.promise = (async () => {
        n.asyncId = i, n.asyncTo = t;
        let u = zB(e, (v, b) => b === "onRest" ? void 0 : v),
            c, f, d = new Promise((v, b) => (c = v, f = b)),
            p = v => {
                let b = i <= (n.cancelId || 0) && Em(r) || i !== n.asyncId && Pa(r, !1);
                if (b) throw v.result = b, f(v), v
            },
            m = (v, b) => {
                let _ = new S$,
                    x = new w$;
                return (async () => {
                    if (Ka.skipAnimation) throw J0(n), x.result = Pa(r, !1), f(x), x;
                    p(_);
                    let S = it.obj(v) ? { ...v
                    } : { ...b,
                        to: v
                    };
                    S.parentId = i, $u(u, (A, T) => {
                        it.und(S[T]) && (S[T] = A)
                    });
                    let E = await r.start(S);
                    return p(_), n.paused && await new Promise(A => {
                        n.resumeQueue.add(A)
                    }), E
                })()
            },
            y;
        if (Ka.skipAnimation) return J0(n), Pa(r, !1);
        try {
            let v;
            it.arr(t) ? v = (async b => {
                for (let _ of b) await m(_)
            })(t) : v = Promise.resolve(t(m, r.stop.bind(r))), await Promise.all([v.then(c), d]), y = Pa(r.get(), !0, !1)
        } catch (v) {
            if (v instanceof S$) y = v.result;
            else if (v instanceof w$) y = v.result;
            else throw v
        } finally {
            i == n.asyncId && (n.asyncId = s, n.asyncTo = s ? a : void 0, n.promise = s ? l : void 0)
        }
        return it.fun(o) && Zt.batchedUpdates(() => {
            o(y, r, r.item)
        }), y
    })()
}

function J0(t, e) {
    Bv(t.timeouts, n => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e)
}
var S$ = class extends Error {
        constructor() {
            super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
            Ct(this, "result")
        }
    },
    w$ = class extends Error {
        constructor() {
            super("SkipAnimationSignal");
            Ct(this, "result")
        }
    },
    kO = t => t instanceof UB,
    Oze = 1,
    UB = class extends tze {
        constructor() {
            super(...arguments);
            Ct(this, "id", Oze++);
            Ct(this, "_priority", 0)
        }
        get priority() {
            return this._priority
        }
        set priority(e) {
            this._priority != e && (this._priority = e, this._onPriorityChange(e))
        }
        get() {
            let e = dl(this);
            return e && e.getValue()
        }
        to(...e) {
            return Ka.to(this, e)
        }
        interpolate(...e) {
            return lze(), Ka.to(this, e)
        }
        toJSON() {
            return this.get()
        }
        observerAdded(e) {
            e == 1 && this._attach()
        }
        observerRemoved(e) {
            e == 0 && this._detach()
        }
        _attach() {}
        _detach() {}
        _onChange(e, n = !1) {
            T2(this, {
                type: "change",
                parent: this,
                value: e,
                idle: n
            })
        }
        _onPriorityChange(e) {
            this.idle || ZA.sort(this), T2(this, {
                type: "priority",
                parent: this,
                priority: e
            })
        }
    },
    mp = Symbol.for("SpringPhase"),
    wee = 1,
    BO = 2,
    FO = 4,
    FP = t => (t[mp] & wee) > 0,
    bc = t => (t[mp] & BO) > 0,
    Uy = t => (t[mp] & FO) > 0,
    E$ = (t, e) => e ? t[mp] |= BO | wee : t[mp] &= ~BO,
    A$ = (t, e) => e ? t[mp] |= FO : t[mp] &= ~FO,
    Dze = class extends UB {
        constructor(e, n) {
            super();
            Ct(this, "key");
            Ct(this, "animation", new Rze);
            Ct(this, "queue");
            Ct(this, "defaultProps", {});
            Ct(this, "_state", {
                paused: !1,
                delayed: !1,
                pauseQueue: new Set,
                resumeQueue: new Set,
                timeouts: new Set
            });
            Ct(this, "_pendingCalls", new Set);
            Ct(this, "_lastCallId", 0);
            Ct(this, "_lastToId", 0);
            Ct(this, "_memoizedDuration", 0);
            if (!it.und(e) || !it.und(n)) {
                let r = it.obj(e) ? { ...e
                } : { ...n,
                    from: e
                };
                it.und(r.default) && (r.default = !0), this.start(r)
            }
        }
        get idle() {
            return !(bc(this) || this._state.asyncTo) || Uy(this)
        }
        get goal() {
            return Fo(this.animation.to)
        }
        get velocity() {
            let e = dl(this);
            return e instanceof pb ? e.lastVelocity || 0 : e.getPayload().map(n => n.lastVelocity || 0)
        }
        get hasAnimated() {
            return FP(this)
        }
        get isAnimating() {
            return bc(this)
        }
        get isPaused() {
            return Uy(this)
        }
        get isDelayed() {
            return this._state.delayed
        }
        advance(e) {
            let n = !0,
                r = !1,
                i = this.animation,
                {
                    config: s,
                    toValues: o
                } = i,
                a = rC(i.to);
            !a && yl(i.to) && (o = Xo(Fo(i.to))), i.values.forEach((c, f) => {
                if (c.done) return;
                let d = c.constructor == q0 ? 1 : a ? a[f].lastPosition : o[f],
                    p = i.immediate,
                    m = d;
                if (!p) {
                    if (m = c.lastPosition, s.tension <= 0) {
                        c.done = !0;
                        return
                    }
                    let y = c.elapsedTime += e,
                        v = i.fromValues[f],
                        b = c.v0 != null ? c.v0 : c.v0 = it.arr(s.velocity) ? s.velocity[f] : s.velocity,
                        _, x = s.precision || (v == d ? .005 : Math.min(1, Math.abs(d - v) * .001));
                    if (it.und(s.duration))
                        if (s.decay) {
                            let S = s.decay === !0 ? .998 : s.decay,
                                E = Math.exp(-(1 - S) * y);
                            m = v + b / (1 - S) * (1 - E), p = Math.abs(c.lastPosition - m) <= x, _ = b * E
                        } else {
                            _ = c.lastVelocity == null ? b : c.lastVelocity;
                            let S = s.restVelocity || x / 10,
                                E = s.clamp ? 0 : s.bounce,
                                A = !it.und(E),
                                T = v == d ? c.v0 > 0 : v < d,
                                M, I = !1,
                                O = 1,
                                k = Math.ceil(e / O);
                            for (let H = 0; H < k && (M = Math.abs(_) > S, !(!M && (p = Math.abs(d - m) <= x, p))); ++H) {
                                A && (I = m == d || m > d == T, I && (_ = -_ * E, m = d));
                                let N = -s.tension * 1e-6 * (m - d),
                                    B = -s.friction * .001 * _,
                                    U = (N + B) / s.mass;
                                _ = _ + U * O, m = m + _ * O
                            }
                        }
                    else {
                        let S = 1;
                        s.duration > 0 && (this._memoizedDuration !== s.duration && (this._memoizedDuration = s.duration, c.durationProgress > 0 && (c.elapsedTime = s.duration * c.durationProgress, y = c.elapsedTime += e)), S = (s.progress || 0) + y / this._memoizedDuration, S = S > 1 ? 1 : S < 0 ? 0 : S, c.durationProgress = S), m = v + s.easing(S) * (d - v), _ = (m - c.lastPosition) / e, p = S == 1
                    }
                    c.lastVelocity = _, Number.isNaN(m) && (console.warn("Got NaN while animating:", this), p = !0)
                }
                a && !a[f].done && (p = !1), p ? c.done = !0 : n = !1, c.setValue(m, s.round) && (r = !0)
            });
            let l = dl(this),
                u = l.getValue();
            if (n) {
                let c = Fo(i.to);
                (u !== c || r) && !s.decay ? (l.setValue(c), this._onChange(c)) : r && s.decay && this._onChange(u), this._stop()
            } else r && this._onChange(u)
        }
        set(e) {
            return Zt.batchedUpdates(() => {
                this._stop(), this._focus(e), this._set(e)
            }), this
        }
        pause() {
            this._update({
                pause: !0
            })
        }
        resume() {
            this._update({
                pause: !1
            })
        }
        finish() {
            if (bc(this)) {
                let {
                    to: e,
                    config: n
                } = this.animation;
                Zt.batchedUpdates(() => {
                    this._onStart(), n.decay || this._set(e, !1), this._stop()
                })
            }
            return this
        }
        update(e) {
            return (this.queue || (this.queue = [])).push(e), this
        }
        start(e, n) {
            let r;
            return it.und(e) ? (r = this.queue || [], this.queue = []) : r = [it.obj(e) ? e : { ...n,
                to: e
            }], Promise.all(r.map(i => this._update(i))).then(i => HB(this, i))
        }
        stop(e) {
            let {
                to: n
            } = this.animation;
            return this._focus(this.get()), J0(this._state, e && this._lastCallId), Zt.batchedUpdates(() => this._stop(n, e)), this
        }
        reset() {
            this._update({
                reset: !0
            })
        }
        eventObserved(e) {
            e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1)
        }
        _prepareNode(e) {
            let n = this.key || "",
                {
                    to: r,
                    from: i
                } = e;
            r = it.obj(r) ? r[n] : r, (r == null || DO(r)) && (r = void 0), i = it.obj(i) ? i[n] : i, i == null && (i = void 0);
            let s = {
                to: r,
                from: i
            };
            return FP(this) || (e.reverse && ([r, i] = [i, r]), i = Fo(i), it.und(i) ? dl(this) || this._set(r) : this._set(i)), s
        }
        _update({ ...e
        }, n) {
            let {
                key: r,
                defaultProps: i
            } = this;
            e.default && Object.assign(i, zB(e, (a, l) => /^on/.test(l) ? yee(a, r) : a)), M$(this, e, "onProps"), Gy(this, "onProps", e, this);
            let s = this._prepareNode(e);
            if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
            let o = this._state;
            return xee(++this._lastCallId, {
                key: r,
                props: e,
                defaultProps: i,
                state: o,
                actions: {
                    pause: () => {
                        Uy(this) || (A$(this, !0), nv(o.pauseQueue), Gy(this, "onPause", Pa(this, $y(this, this.animation.to)), this))
                    },
                    resume: () => {
                        Uy(this) && (A$(this, !1), bc(this) && this._resume(), nv(o.resumeQueue), Gy(this, "onResume", Pa(this, $y(this, this.animation.to)), this))
                    },
                    start: this._merge.bind(this, s)
                }
            }).then(a => {
                if (e.loop && a.finished && !(n && a.noop)) {
                    let l = Eee(e);
                    if (l) return this._update(l, !0)
                }
                return a
            })
        }
        _merge(e, n, r) {
            if (n.cancel) return this.stop(!0), r(Em(this));
            let i = !it.und(e.to),
                s = !it.und(e.from);
            if (i || s)
                if (n.callId > this._lastToId) this._lastToId = n.callId;
                else return r(Em(this));
            let {
                key: o,
                defaultProps: a,
                animation: l
            } = this, {
                to: u,
                from: c
            } = l, {
                to: f = u,
                from: d = c
            } = e;
            s && !i && (!n.default || it.und(f)) && (f = d), n.reverse && ([f, d] = [d, f]);
            let p = !pu(d, c);
            p && (l.from = d), d = Fo(d);
            let m = !pu(f, u);
            m && this._focus(f);
            let y = DO(n.to),
                {
                    config: v
                } = l,
                {
                    decay: b,
                    velocity: _
                } = v;
            (i || s) && (v.velocity = 0), n.config && !y && Ize(v, dd(n.config, o), n.config !== a.config ? dd(a.config, o) : void 0);
            let x = dl(this);
            if (!x || it.und(f)) return r(Pa(this, !0));
            let S = it.und(n.reset) ? s && !n.default : !it.und(d) && Nv(n.reset, o),
                E = S ? d : this.get(),
                A = X0(f),
                T = it.num(A) || it.arr(A) || nC(A),
                M = !y && (!T || Nv(a.immediate || n.immediate, o));
            if (m) {
                let H = OO(f);
                if (H !== x.constructor)
                    if (M) x = this._set(A);
                    else throw Error(`Cannot animate between ${x.constructor.name} and ${H.name}, as the "to" prop suggests`)
            }
            let I = x.constructor,
                O = yl(f),
                k = !1;
            if (!O) {
                let H = S || !FP(this) && p;
                (m || H) && (k = pu(X0(E), A), O = !k), (!pu(l.immediate, M) && !M || !pu(v.decay, b) || !pu(v.velocity, _)) && (O = !0)
            }
            if (k && bc(this) && (l.changed && !S ? O = !0 : O || this._stop(u)), !y && ((O || yl(u)) && (l.values = x.getPayload(), l.toValues = yl(f) ? null : I == q0 ? [1] : Xo(A)), l.immediate != M && (l.immediate = M, !M && !S && this._set(u)), O)) {
                let {
                    onRest: H
                } = l;
                $n(kze, B => M$(this, n, B));
                let N = Pa(this, $y(this, u));
                nv(this._pendingCalls, N), this._pendingCalls.add(r), l.changed && Zt.batchedUpdates(() => {
                    var B;
                    l.changed = !S, H == null || H(N, this), S ? dd(a.onRest, N) : (B = l.onStart) == null || B.call(l, N, this)
                })
            }
            S && this._set(E), y ? r(See(n.to, n, this._state, this)) : O ? this._start() : bc(this) && !m ? this._pendingCalls.add(r) : r(_ee(E))
        }
        _focus(e) {
            let n = this.animation;
            e !== n.to && (h$(this) && this._detach(), n.to = e, h$(this) && this._attach())
        }
        _attach() {
            let e = 0,
                {
                    to: n
                } = this.animation;
            yl(n) && (db(n, this), kO(n) && (e = n.priority + 1)), this.priority = e
        }
        _detach() {
            let {
                to: e
            } = this.animation;
            yl(e) && P2(e, this)
        }
        _set(e, n = !0) {
            let r = Fo(e);
            if (!it.und(r)) {
                let i = dl(this);
                if (!i || !pu(r, i.getValue())) {
                    let s = OO(r);
                    !i || i.constructor != s ? FB(this, s.create(r)) : i.setValue(r), i && Zt.batchedUpdates(() => {
                        this._onChange(r, n)
                    })
                }
            }
            return dl(this)
        }
        _onStart() {
            let e = this.animation;
            e.changed || (e.changed = !0, Gy(this, "onStart", Pa(this, $y(this, e.to)), this))
        }
        _onChange(e, n) {
            n || (this._onStart(), dd(this.animation.onChange, e, this)), dd(this.defaultProps.onChange, e, this), super._onChange(e, n)
        }
        _start() {
            let e = this.animation;
            dl(this).reset(Fo(e.to)), e.immediate || (e.fromValues = e.values.map(n => n.lastPosition)), bc(this) || (E$(this, !0), Uy(this) || this._resume())
        }
        _resume() {
            Ka.skipAnimation ? this.finish() : ZA.start(this)
        }
        _stop(e, n) {
            if (bc(this)) {
                E$(this, !1);
                let r = this.animation;
                $n(r.values, s => {
                    s.done = !0
                }), r.toValues && (r.onChange = r.onPause = r.onResume = void 0), T2(this, {
                    type: "idle",
                    parent: this
                });
                let i = n ? Em(this.get()) : Pa(this.get(), $y(this, e ? ? r.to));
                nv(this._pendingCalls, i), r.changed && (r.changed = !1, Gy(this, "onRest", i, this))
            }
        }
    };

function $y(t, e) {
    let n = X0(e),
        r = X0(t.get());
    return pu(r, n)
}

function Eee(t, e = t.loop, n = t.to) {
    let r = dd(e);
    if (r) {
        let i = r !== !0 && bee(r),
            s = (i || t).reverse,
            o = !i || i.reset;
        return Y0({ ...t,
            loop: e,
            default: !1,
            pause: void 0,
            to: !s || DO(n) ? n : void 0,
            from: o ? t.from : void 0,
            reset: o,
            ...i
        })
    }
}

function Y0(t) {
    let {
        to: e,
        from: n
    } = t = bee(t), r = new Set;
    return it.obj(e) && C$(e, r), it.obj(n) && C$(n, r), t.keys = r.size ? Array.from(r) : null, t
}

function Lze(t) {
    let e = Y0(t);
    return it.und(e.default) && (e.default = zB(e)), e
}

function C$(t, e) {
    $u(t, (n, r) => n != null && e.add(r))
}
var kze = ["onStart", "onRest", "onChange", "onPause", "onResume"];

function M$(t, e, n) {
    t.animation[n] = e[n] !== vee(e, n) ? yee(e[n], t.key) : void 0
}

function Gy(t, e, ...n) {
    var r, i, s, o;
    (i = (r = t.animation)[e]) == null || i.call(r, ...n), (o = (s = t.defaultProps)[e]) == null || o.call(s, ...n)
}
var Bze = ["onStart", "onChange", "onRest"],
    Fze = 1,
    Nze = class {
        constructor(t, e) {
            Ct(this, "id", Fze++);
            Ct(this, "springs", {});
            Ct(this, "queue", []);
            Ct(this, "ref");
            Ct(this, "_flush");
            Ct(this, "_initialProps");
            Ct(this, "_lastAsyncId", 0);
            Ct(this, "_active", new Set);
            Ct(this, "_changed", new Set);
            Ct(this, "_started", !1);
            Ct(this, "_item");
            Ct(this, "_state", {
                paused: !1,
                pauseQueue: new Set,
                resumeQueue: new Set,
                timeouts: new Set
            });
            Ct(this, "_events", {
                onStart: new Map,
                onChange: new Map,
                onRest: new Map
            });
            this._onFrame = this._onFrame.bind(this), e && (this._flush = e), t && this.start({
                default: !0,
                ...t
            })
        }
        get idle() {
            return !this._state.asyncTo && Object.values(this.springs).every(t => t.idle && !t.isDelayed && !t.isPaused)
        }
        get item() {
            return this._item
        }
        set item(t) {
            this._item = t
        }
        get() {
            let t = {};
            return this.each((e, n) => t[n] = e.get()), t
        }
        set(t) {
            for (let e in t) {
                let n = t[e];
                it.und(n) || this.springs[e].set(n)
            }
        }
        update(t) {
            return t && this.queue.push(Y0(t)), this
        }
        start(t) {
            let {
                queue: e
            } = this;
            return t ? e = Xo(t).map(Y0) : this.queue = [], this._flush ? this._flush(this, e) : (Pee(this, e), NO(this, e))
        }
        stop(t, e) {
            if (t !== !!t && (e = t), e) {
                let n = this.springs;
                $n(Xo(e), r => n[r].stop(!!t))
            } else J0(this._state, this._lastAsyncId), this.each(n => n.stop(!!t));
            return this
        }
        pause(t) {
            if (it.und(t)) this.start({
                pause: !0
            });
            else {
                let e = this.springs;
                $n(Xo(t), n => e[n].pause())
            }
            return this
        }
        resume(t) {
            if (it.und(t)) this.start({
                pause: !1
            });
            else {
                let e = this.springs;
                $n(Xo(t), n => e[n].resume())
            }
            return this
        }
        each(t) {
            $u(this.springs, t)
        }
        _onFrame() {
            let {
                onStart: t,
                onChange: e,
                onRest: n
            } = this._events, r = this._active.size > 0, i = this._changed.size > 0;
            (r && !this._started || i && !this._started) && (this._started = !0, Bv(t, ([a, l]) => {
                l.value = this.get(), a(l, this, this._item)
            }));
            let s = !r && this._started,
                o = i || s && n.size ? this.get() : null;
            i && e.size && Bv(e, ([a, l]) => {
                l.value = o, a(l, this, this._item)
            }), s && (this._started = !1, Bv(n, ([a, l]) => {
                l.value = o, a(l, this, this._item)
            }))
        }
        eventObserved(t) {
            if (t.type == "change") this._changed.add(t.parent), t.idle || this._active.add(t.parent);
            else if (t.type == "idle") this._active.delete(t.parent);
            else return;
            Zt.onFrame(this._onFrame)
        }
    };

function NO(t, e) {
    return Promise.all(e.map(n => Aee(t, n))).then(n => HB(t, n))
}
async function Aee(t, e, n) {
    let {
        keys: r,
        to: i,
        from: s,
        loop: o,
        onRest: a,
        onResolve: l
    } = e, u = it.obj(e.default) && e.default;
    o && (e.loop = !1), i === !1 && (e.to = null), s === !1 && (e.from = null);
    let c = it.arr(i) || it.fun(i) ? i : void 0;
    c ? (e.to = void 0, e.onRest = void 0, u && (u.onRest = void 0)) : $n(Bze, y => {
        let v = e[y];
        if (it.fun(v)) {
            let b = t._events[y];
            e[y] = ({
                finished: _,
                cancelled: x
            }) => {
                let S = b.get(v);
                S ? (_ || (S.finished = !1), x && (S.cancelled = !0)) : b.set(v, {
                    value: null,
                    finished: _ || !1,
                    cancelled: x || !1
                })
            }, u && (u[y] = e[y])
        }
    });
    let f = t._state;
    e.pause === !f.paused ? (f.paused = e.pause, nv(e.pause ? f.pauseQueue : f.resumeQueue)) : f.paused && (e.pause = !0);
    let d = (r || Object.keys(t.springs)).map(y => t.springs[y].start(e)),
        p = e.cancel === !0 || vee(e, "cancel") === !0;
    (c || p && f.asyncId) && d.push(xee(++t._lastAsyncId, {
        props: e,
        state: f,
        actions: {
            pause: IO,
            resume: IO,
            start(y, v) {
                p ? (J0(f, t._lastAsyncId), v(Em(t))) : (y.onRest = a, v(See(c, y, f, t)))
            }
        }
    })), f.paused && await new Promise(y => {
        f.resumeQueue.add(y)
    });
    let m = HB(t, await Promise.all(d));
    if (o && m.finished && !(n && m.noop)) {
        let y = Eee(e, o, i);
        if (y) return Pee(t, [y]), Aee(t, y, !0)
    }
    return l && Zt.batchedUpdates(() => l(m, t, t.item)), m
}

function T$(t, e) {
    let n = { ...t.springs
    };
    return e && $n(Xo(e), r => {
        it.und(r.keys) && (r = Y0(r)), it.obj(r.to) || (r = { ...r,
            to: void 0
        }), Tee(n, r, i => Mee(i))
    }), Cee(t, n), n
}

function Cee(t, e) {
    $u(e, (n, r) => {
        t.springs[r] || (t.springs[r] = n, db(n, t))
    })
}

function Mee(t, e) {
    let n = new Dze;
    return n.key = t, e && db(n, e), n
}

function Tee(t, e, n) {
    e.keys && $n(e.keys, r => {
        (t[r] || (t[r] = n(r)))._prepareNode(e)
    })
}

function Pee(t, e) {
    $n(e, n => {
        Tee(t.springs, n, r => Mee(r, t))
    })
}
var iC = ({
        children: t,
        ...e
    }) => {
        let n = P.useContext(R2),
            r = e.pause || !!n.pause,
            i = e.immediate || !!n.immediate;
        e = dze(() => ({
            pause: r,
            immediate: i
        }), [r, i]);
        let {
            Provider: s
        } = R2;
        return P.createElement(s, {
            value: e
        }, t)
    },
    R2 = zze(iC, {});
iC.Provider = R2.Provider;
iC.Consumer = R2.Consumer;

function zze(t, e) {
    return Object.assign(t, P.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t
}
var Hze = () => {
    let t = [],
        e = function(r) {
            cze();
            let i = [];
            return $n(t, (s, o) => {
                if (it.und(r)) i.push(s.start());
                else {
                    let a = n(r, s, o);
                    a && i.push(s.start(a))
                }
            }), i
        };
    e.current = t, e.add = function(r) {
        t.includes(r) || t.push(r)
    }, e.delete = function(r) {
        let i = t.indexOf(r);
        ~i && t.splice(i, 1)
    }, e.pause = function() {
        return $n(t, r => r.pause(...arguments)), this
    }, e.resume = function() {
        return $n(t, r => r.resume(...arguments)), this
    }, e.set = function(r) {
        $n(t, (i, s) => {
            let o = it.fun(r) ? r(s, i) : r;
            o && i.set(o)
        })
    }, e.start = function(r) {
        let i = [];
        return $n(t, (s, o) => {
            if (it.und(r)) i.push(s.start());
            else {
                let a = this._getProps(r, s, o);
                a && i.push(s.start(a))
            }
        }), i
    }, e.stop = function() {
        return $n(t, r => r.stop(...arguments)), this
    }, e.update = function(r) {
        return $n(t, (i, s) => i.update(this._getProps(r, i, s))), this
    };
    let n = function(r, i, s) {
        return it.fun(r) ? r(s, i) : r
    };
    return e._getProps = n, e
};

function Uze(t, e, n) {
    let r = it.fun(e) && e;
    r && !n && (n = []);
    let i = P.useMemo(() => r || arguments.length == 3 ? Hze() : void 0, []),
        s = P.useRef(0),
        o = pee(),
        a = P.useMemo(() => ({
            ctrls: [],
            queue: [],
            flush(b, _) {
                let x = T$(b, _);
                return s.current > 0 && !a.queue.length && !Object.keys(x).some(S => !b.springs[S]) ? NO(b, _) : new Promise(S => {
                    Cee(b, x), a.queue.push(() => {
                        S(NO(b, _))
                    }), o()
                })
            }
        }), []),
        l = P.useRef([...a.ctrls]),
        u = [],
        c = g$(t) || 0;
    P.useMemo(() => {
        $n(l.current.slice(t, c), b => {
            Cze(b, i), b.stop(!0)
        }), l.current.length = t, f(c, t)
    }, [t]), P.useMemo(() => {
        f(0, Math.min(c, t))
    }, n);

    function f(b, _) {
        for (let x = b; x < _; x++) {
            let S = l.current[x] || (l.current[x] = new Nze(null, a.flush)),
                E = r ? r(x, S) : e[x];
            E && (u[x] = Lze(E))
        }
    }
    let d = l.current.map((b, _) => T$(b, u[_])),
        p = P.useContext(iC),
        m = g$(p),
        y = p !== m && Aze(p);
    BB(() => {
        s.current++, a.ctrls = l.current;
        let {
            queue: b
        } = a;
        b.length && (a.queue = [], $n(b, _ => _())), $n(l.current, (_, x) => {
            i == null || i.add(_), y && _.start({
                default: p
            });
            let S = u[x];
            S && (Mze(_, S.ref), _.ref ? _.queue.push(S) : _.start(S))
        })
    }), hee(() => () => {
        $n(a.ctrls, b => b.stop(!0))
    });
    let v = d.map(b => ({ ...b
    }));
    return i ? [v, i] : v
}

function QUe(t, e) {
    let n = it.fun(t),
        [
            [r], i
        ] = Uze(1, n ? t : [t], n ? e || [] : e);
    return n || arguments.length == 2 ? [r, i] : r
}
var $ze = class extends UB {
    constructor(e, n) {
        super();
        Ct(this, "key");
        Ct(this, "idle", !0);
        Ct(this, "calc");
        Ct(this, "_active", new Set);
        this.source = e, this.calc = W0(...n);
        let r = this._get(),
            i = OO(r);
        FB(this, i.create(r))
    }
    advance(e) {
        let n = this._get(),
            r = this.get();
        pu(n, r) || (dl(this).setValue(n), this._onChange(n, this.idle)), !this.idle && P$(this._active) && NP(this)
    }
    _get() {
        let e = it.arr(this.source) ? this.source.map(Fo) : Xo(Fo(this.source));
        return this.calc(...e)
    }
    _start() {
        this.idle && !P$(this._active) && (this.idle = !1, $n(rC(this), e => {
            e.done = !1
        }), Ka.skipAnimation ? (Zt.batchedUpdates(() => this.advance()), NP(this)) : ZA.start(this))
    }
    _attach() {
        let e = 1;
        $n(Xo(this.source), n => {
            yl(n) && db(n, this), kO(n) && (n.idle || this._active.add(n), e = Math.max(e, n.priority + 1))
        }), this.priority = e, this._start()
    }
    _detach() {
        $n(Xo(this.source), e => {
            yl(e) && P2(e, this)
        }), this._active.clear(), NP(this)
    }
    eventObserved(e) {
        e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = Xo(this.source).reduce((n, r) => Math.max(n, (kO(r) ? r.priority : 0) + 1), 0))
    }
};

function Gze(t) {
    return t.idle !== !1
}

function P$(t) {
    return !t.size || Array.from(t).every(Gze)
}

function NP(t) {
    t.idle || (t.idle = !0, $n(rC(t), e => {
        e.done = !0
    }), T2(t, {
        type: "idle",
        parent: t
    }))
}
Ka.assign({
    createStringInterpolator: fee,
    to: (t, e) => new $ze(t, e)
});
var Vze = ["primitive"].concat(Object.keys(y0).filter(t => /^[A-Z]/.test(t)).map(t => t[0].toLowerCase() + t.slice(1)));
Ka.assign({
    createStringInterpolator: fee,
    colors: H9e,
    frameLoop: "demand"
});
JQ(() => {
    Zt.advance()
});
var jze = xze(Vze, {
        applyAnimatedValues: Qh
    }),
    ZUe = jze.animated;
export {
    K2e as $, oUe as A, eHe as B, dt as C, Mie as D, BHe as E, Ite as F, yHe as G, MHe as H, PHe as I, LHe as J, RHe as K, OHe as L, gHe as M, GHe as N, xHe as O, vHe as P, YHe as Q, Bt as R, nUe as S, V2e as T, en as U, cUe as V, kc as W, UHe as X, THe as Y, qHe as Z, ZHe as _, Qze as a, WUe as a$, fUe as a0, CHe as a1, bHe as a2, hHe as a3, mUe as a4, dUe as a5, AHe as a6, LUe as a7, PBe as a8, DUe as a9, hUe as aA, ih as aB, RUe as aC, OUe as aD, NUe as aE, zHe as aF, $He as aG, NHe as aH, XHe as aI, jHe as aJ, HHe as aK, $Ue as aL, IHe as aM, JHe as aN, aUe as aO, uUe as aP, VHe as aQ, _He as aR, FHe as aS, pHe as aT, QHe as aU, kHe as aV, wHe as aW, YUe as aX, ri as aY, QUe as aZ, nb as a_, yUe as aa, FUe as ab, wUe as ac, BUe as ad, kUe as ae, DBe as af, FBe as ag, UBe as ah, jBe as ai, AUe as aj, vUe as ak, qh as al, EUe as am, CUe as an, TUe as ao, pUe as ap, uOe as aq, MUe as ar, IUe as as, SUe as at, xUe as au, _Ue as av, bUe as aw, gUe as ax, pOe as ay, PUe as az, Cse as b, Jze as b0, Fd as b1, ZUe as b2, UUe as b3, AB as b4, XUe as b5, JUe as b6, VUe as b7, Ln as b8, Tn as b9, qUe as ba, Tze as bb, HUe as bc, KUe as bd, EHe as be, KHe as bf, tUe as bg, lUe as bh, sUe as bi, eUe as bj, Yze as bk, Cs as bl, rUe as bm, VG as bn, tHe as c, rHe as d, Zze as e, fHe as f, cHe as g, dHe as h, N0e as i, gt as j, Zo as k, O1e as l, iUe as m, q_e as n, eA as o, iHe as p, mHe as q, P as r, uHe as s, DHe as t, Xze as u, WHe as v, SHe as w, nHe as x, KX as y, Au as z
};